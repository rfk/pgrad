#LyX 1.4.2 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble

\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}

\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{ijcai07}

\usepackage{times}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\end_preamble
\options letterpaper
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize 11
\spacing single
\papersize letterpaper
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Property Persistence in the Situation Calculus
\end_layout

\begin_layout Author
Ryan F.
 Kelly and Adrian R.
 Pearce
\newline
NICTA Victoria Laboratory
\newline
 Department of Computer Science and Software
 Engineering
\newline
 The University of Melbourne
\newline
 Victoria, 3010, Australia
\newline
 {rfk,adrian}@
csse.unimelb.edu.au
\end_layout

\begin_layout Abstract
We develop an algorithm for reducing universally quantified situation calculus
 queries to a form more amenable to automated reasoning.
 Universal quantification in the situation calculus requires a second-order
 induction axiom, making automated reasoning difficult for such queries.
 We show how to reduce queries about property persistence, a common family
 of universally-quantified query, to an equivalent form that does not quantify
 over situations.
 The algorithm for doing so utilizes only first-order reasoning.
 We give several examples of important reasoning tasks that are facilitated
 by our approach, including checking for goal impossibility and reasoning
 about knowledge with partial observability of actions.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 has long been one of the most popular formalisms for reasoning about dynamic
 worlds.
 It has more recently become a popular choice for 
\emph on
implementing 
\emph default
systems situated in a dynamic world, as it offers, among other advantages:
 a formalism based in first-order logic; an elegant monotonic solution to
 the frame problem; and an effective reasoning procedure for the projection
 problem 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

.
 Coupled with logic programming languages such as Prolog, it has facilitated
 the implementation of a wide range of systems.
\end_layout

\begin_layout Standard
The foundational axioms of the situation calculus include a second-order
 induction axiom defining the set of all situations 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
 Sentences that contain only existential quantification over situation terms
 can be proven without the induction axiom and so are more amenable to automated
 reasoning 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 It is therefore important for systems built on a situation calculus theory
 of action to limit queries to existential form.
 Much of the work on implementing systems with the situation calculus has
 been on reducing the number of axioms required to answer a given query,
 to allow more efficient reasoning.
\end_layout

\begin_layout Standard
Unfortunately there are many reasoning tasks that require universal quantificati
on over situations.
 For example, it is often desirable to show that no situation can satisfy
 a particular goal.
 In this paper we are interested in a subset of such queries which we refer
 to as 
\emph on
persistence queries
\emph default
: under a particular situation calculus theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, and given some property 
\begin_inset Formula $\phi$
\end_inset

 and situation 
\begin_inset Formula $s$
\end_inset

, determine whether 
\begin_inset Formula $\phi$
\end_inset

 will hold in all situations in the future of 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\forall s'\,.\, s\sqsubseteq s'\,\rightarrow\,\phi[s']\]

\end_inset

The need for second-order logic has traditionally limited automated reasoning
 about such queries.
 We introduce a new approach that is similar in spirit to the regression
 operator of 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

: define an operator that transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 into a formula 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi]$
\end_inset

, such that 
\begin_inset Formula $\phi$
\end_inset

 persists in 
\begin_inset Formula $s$
\end_inset

 if and only if 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi]$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

.
 We term this the 
\emph on
persistence condition
\emph default
 of 
\begin_inset Formula $\phi$
\end_inset

, and show how to calculate it in a form suitable for effective automated
 reasoning.
\end_layout

\begin_layout Standard
To determine 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi]$
\end_inset

, we first define an operator 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}[\phi]$
\end_inset

 that holds in 
\begin_inset Formula $s$
\end_inset

 whenever 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate successors.
 The persistence condition is shown to be a fixed-point of this operator,
 which can be sought using a straightforward iterative algorithm.
 Since this requires only first-order reasoning with a limited number of
 axioms, the result is an effective procedure with which to answer a family
 of queries that universally quantify over situations.
\end_layout

\begin_layout Standard
The paper is organized as follows: Section 
\begin_inset LatexCommand \ref{sec:Background}

\end_inset

 gives a brief introduction to the situation calculus, formally defines
 the persistence problem, discusses related work and gives several examples
 of important persistence queries; Section 
\begin_inset LatexCommand \ref{sec:Persistence-Condition}

\end_inset

 formally defines the persistence condition, presents an algorithm that
 calculates it, shows that the algorithm is correct and discusses the conditions
 necessary for completeness; and Section 
\begin_inset LatexCommand \ref{sec:Conclusions}

\end_inset

 concludes with a summary of our results.
\end_layout

\begin_layout Section
Background
\begin_inset LatexCommand \label{sec:Background}

\end_inset


\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 It has the following sorts: 
\emph on
Action
\emph default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change; 
\emph on
Situation
\emph default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built up using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\emph on
Object
\emph default
 terms represent any other object in the domain.
 It further distinguishes 
\emph on
Fluents
\emph default
 as predicates or functions representing properties of the world that may
 change from one situation to another, and so take a situation term as their
 final argument.
 For a detailed description consult 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 
\end_layout

\begin_layout Standard
A 
\emph on
basic action theory
\emph default
 is a set 
\begin_inset Formula $\mathcal{D}$
\end_inset

 of situation calculus sentences (with a specific syntactic form as specified
 in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

) that describes a particular dynamic world.
 Queries about the behavior or evolution of the world are posed as logical
 entailment queries relative to this theory.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); successor state axioms describing how fluents change between situations
 (
\begin_inset Formula $\mathcal{D}_{ss}$
\end_inset

); precondition axioms indicating when actions can be performed (
\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

); unique names axioms ensuring that action terms are distinct (
\begin_inset Formula $\mathcal{D}_{una}$
\end_inset

); and axioms describing the value of fluents in the initial situation (
\begin_inset Formula $\mathcal{D}_{S_{0}}$
\end_inset

):
\begin_inset Formula \[
\mathcal{D}=\Sigma\cup\mathcal{D}_{ss}\cup\mathcal{D}_{ap}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
The foundational axiom of most import for this paper is the induction axiom,
 which defines the set of all situations as the least set containing 
\begin_inset Formula $S_{0}$
\end_inset

 and closed under application of the 
\begin_inset Formula $do$
\end_inset

 function, as follows:
\begin_inset Formula \[
\forall P\,.\,\left[P(S_{0})\wedge\forall s,a\,.\,\left(P(s)\rightarrow P(do(a,s))\right)\rightarrow\forall s\,.\, P(s)\right]\]

\end_inset

The fundamental importance of this axiom is described in 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
 Much research has focused on identifying sentences of the situation calculus
 that can be proven without this axiom, and thus require only first-order
 logic.
 Our work continues this tradition.
\end_layout

\begin_layout Standard
There is a distinguished predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 The set of action precondition axioms 
\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

 contains one axiom for each type of action 
\begin_inset Formula $A$
\end_inset

, of the general form:
\begin_inset Formula \[
\forall s,\overrightarrow{x}\,.\,\left[Poss(A(\overrightarrow{x}),s)\equiv\Pi_{A}(\overrightarrow{x},s)\right]\]

\end_inset

Here 
\begin_inset Formula $\Pi_{A}$
\end_inset

 represents a uniform formula (see below) defining action possibility on
 a per-action basis.
\end_layout

\begin_layout Standard
It is often useful to introduce analogous predicates to describe different
 aspects of action performance.
 For example, a predicate 
\begin_inset Formula $CantObs(agt,a,s)$
\end_inset

 could indicate when an agent will be unable to observe the occurrence of
 an action.
 Such predicates are easily incorporated into a basic action theory by axiomatiz
ing them in 
\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

 in the same manner as 
\begin_inset Formula $Poss$
\end_inset

.
 We refer to these predicates in general as 
\emph on
action description predicate
\emph default
s, and use the meta-variable 
\begin_inset Formula $\alpha$
\end_inset

 to represent an arbitrary such predicate.
\end_layout

\begin_layout Standard
The 
\emph on
uniform formulae
\emph default
 as defined in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 can be thought of as formulae that describe a 
\emph on
property 
\emph default
of the state of the world.
 They are basically logical combinations of fluents referring to a common
 situation term, which cannot mention action description predicates nor
 compare situation terms.
 We will use the meta-variable 
\begin_inset Formula $\phi$
\end_inset

 to refer to an arbitrary uniform formula.
\end_layout

\begin_layout Standard
It is often useful to determine the truth of a property at a given situation.
 The formula 
\begin_inset Formula $\phi[s]$
\end_inset

 represents the uniform formula 
\begin_inset Formula $\phi$
\end_inset

 with all occurrences of its unique situation term replaced by the situation
 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsection
Ordering over Situations
\end_layout

\begin_layout Standard
Situations form a tree with 
\begin_inset Formula $S_{0}$
\end_inset

 at the root and 
\begin_inset Formula $do$
\end_inset

 constructing child situations from parents.
 There is a basic ordering relation 
\begin_inset Formula $\sqsubset$
\end_inset

 defined by the following foundational axioms:
\begin_inset Formula \[
\forall s\,.\,\neg\left(s\sqsubset S_{0}\right)\]

\end_inset


\begin_inset Formula \[
\forall s,s',a\,.\, s\sqsubset do(a,s')\equiv s\sqsubseteq s'\]

\end_inset

Where 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation of 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 It is frequently useful to restrict the situations under consideration
 to those possible in the real world, by defining an ordering relation 
\begin_inset Formula $<$
\end_inset

 over only these 
\begin_inset Quotes eld
\end_inset

executable
\begin_inset Quotes erd
\end_inset

 situations:
\begin_inset Formula \[
\forall s\,.\,\neg\left(s<S_{0}\right)\]

\end_inset


\begin_inset Formula \[
\forall s,s',a\,.\, s<do(a,s')\equiv s\leq s'\wedge Poss(a,s')\]

\end_inset

Many results of the situation calculus are derived relative to the executable
 situations - for example, 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

 develops an induction principle for all situations where 
\begin_inset Formula $S_{0}\leq s$
\end_inset

.
 This notation is so useful that we propose a parametrization of it: let
 
\begin_inset Formula $\alpha$
\end_inset

 be an action description predicate specifying the actions of interest,
 then define the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\alpha$
\end_inset

-ordering
\begin_inset Quotes erd
\end_inset

 over situations as follows:
\begin_inset Formula \[
\forall s\,.\,\neg\left(s<_{\alpha}S_{0}\right)\]

\end_inset


\begin_inset Formula \[
\forall s,s',a\,.\, s<_{\alpha}do(a,s')\equiv s\leq_{\alpha}s'\wedge\alpha(a,s')\]

\end_inset

The standard ordering over executable situations is clearly 
\begin_inset Formula $<_{Poss}$
\end_inset

.
 If 
\begin_inset Formula $s$
\end_inset

 is thought of as the 
\begin_inset Quotes eld
\end_inset

current situation
\begin_inset Quotes erd
\end_inset

, then 
\begin_inset Formula $s<_{\alpha}s'$
\end_inset

 means that 
\begin_inset Formula $s'$
\end_inset

 is one potential future, and all actions that will occur in that future
 satisfy 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Subsection
Effective Reasoning
\begin_inset LatexCommand \label{sub:Effective-Reasoning}

\end_inset


\end_layout

\begin_layout Standard
Answering an arbitrary situation calculus query 
\begin_inset Formula $\psi$
\end_inset

 involves, in general, an entailment problem in second-order logic (SOL):
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\psi\]

\end_inset

This can be problematic for efficient automated reasoning.
 Fortunately, there exist particular syntactic forms for which some of the
 axioms in 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required.
 In 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\exists$
\end_inset

s sentences
\begin_inset Quotes erd
\end_inset

 are defined as those in which every situation variable is in the scope
 of a positive existential quantifier.
 They show that such sentences can always be proven without the induction
 axiom (
\begin_inset Formula $I$
\end_inset

) and hence are answerable by first-order logical entailment (FOL):
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\exists s\,\psi\,\,\,\mathit{iff}\,\,\,\mathcal{D}-\{ I\}\models_{FOL}\exists s\,\psi\]

\end_inset

Such queries can be approached with standard first-order reasoning systems.
 To increase the efficiency of reasoning it is desirable to eliminate further
 axioms from 
\begin_inset Formula $\mathcal{D}$
\end_inset

, which 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 show possible for several syntactic forms.
\end_layout

\begin_layout Standard
Axiom reduction is also the key idea behind the regression operator, the
 principal tool for effective reasoning in the situation calculus 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

.
 The regression operator 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 is a syntactic manipulation whose behavior can be summarized
\begin_inset Foot
status collapsed

\begin_layout Standard
The full behavior of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 is beyond the scope of this paper.
 Experienced readers please note that we use the single-step version of
 the regression operator, as in 
\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset

.
 Since any formula uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

 is by definition single-step regressable, the development below omits the
 traditional qualification that formulae must be regressable.
\end_layout

\end_inset

 for our purposes as follows: given a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

, regression transforms it into a formula 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}[\phi]$
\end_inset

 that is uniform in 
\begin_inset Formula $s$
\end_inset

 and is equivalent to 
\begin_inset Formula $\phi$
\end_inset

 under the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\,\models\,\phi\equiv\mathcal{R}_{\mathcal{D}}[\phi]\]

\end_inset

Regression also replaces instances of the 
\begin_inset Formula $Poss$
\end_inset

 predicate with appropriate instantiations of the corresponding uniform
 formula from the axioms in 
\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

, and other action description predicates can easily be treated in the same
 way.
 In order to regress such a predicate over an action variable one must assume
 that there are only a finite number of action types, so that it can be
 replaced with the disjunctive closure of its definitional axioms.
 We assume this restriction throughout.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\phi$
\end_inset

 refers to a situation that is rooted at 
\begin_inset Formula $S_{0}$
\end_inset

, repeated applications of the regression operator (denoted by 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}$
\end_inset

) can transform it into an equivalent formula uniform in the initial situation.
 The successor state and action precondition axioms are 
\begin_inset Quotes eld
\end_inset

compiled into
\begin_inset Quotes erd
\end_inset

 the regressed formula, and so are not required for the reasoning task:
\begin_inset Formula \[
\mathcal{D}\models\phi\,\,\,\mathit{iff}\,\,\,\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\models\mathcal{R}_{\mathcal{D}}^{*}[\phi][S_{0}]\]

\end_inset

The trade-off is that the length of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}[\phi]$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 In practice this is typically more than compensated for by the reduction
 in the number of axioms required, and regression has proven a very effective
 technique.
\end_layout

\begin_layout Subsection
Property Persistence
\begin_inset LatexCommand \label{sub:Property-Persistence}

\end_inset


\end_layout

\begin_layout Standard
One important form of situation calculus query is to ask whether a given
 property 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\emph on
all future situations
\emph default
 of a given situation 
\begin_inset Formula $s$
\end_inset

, as well as at 
\begin_inset Formula $s$
\end_inset

 itself:
\begin_inset Formula \[
\mathcal{D}\models\forall s'\,.\, s\sqsubseteq s'\rightarrow\phi(s')\]

\end_inset

More generally, one may wish to limit the futures considered to those brought
 about by a certain class of actions 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\forall s'\,.\, s\le_{\alpha}s'\rightarrow\phi[s']\]

\end_inset

In words this states 
\begin_inset Quotes eld
\end_inset

given that all subsequent actions satisfy 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 will remain true
\begin_inset Quotes erd
\end_inset

 or, more succinctly, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 We term queries of this form 
\emph on
property persistence
\emph default
 
\emph on
queries
\emph default
, and they are involved in many useful reasoning tasks.
 The following are a small selection:
\end_layout

\begin_layout Standard

\series bold
Goal Impossibility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no possible situation in which that goal is satisfied:
\begin_inset Formula \[
\mathcal{D}\models\forall s\,.\, S_{0}\leq s\rightarrow\neg G(s)\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Goal Futility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $s$
\end_inset

, establish that the goal cannot be satisfied in any possible situation
 in the future of 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\forall s'\,.\, s\leq s'\rightarrow\neg G(s')\]

\end_inset

Note how this is different from goal impossibility: while the agent may
 have initially been able to achieve its goal, the actions that have subsequentl
y been performed have rendered the goal unachievable.
 Agents would be well advised to avoid such situations.
\end_layout

\begin_layout Standard

\series bold
Checking State Constraints:
\series default
 This is a variant of goal impossibility - show that the constraint can
 never be violated.
\end_layout

\begin_layout Standard

\series bold
Need for Cooperation:
\series default
 To establish that it is absolutely necessary to cooperate with another
 agent, an agent must determine persistence with respect to actions performed
 by itself:
\begin_inset Formula \[
\mathcal{D}\models\forall s'\,.\, s\leq_{OwnAction}s'\rightarrow\neg G[s']\]

\end_inset

Assuming that the action description predicate 
\begin_inset Formula $OwnAction$
\end_inset

 has been defined to identify actions performed by the agent in question,
 this states that no situation in the future of 
\begin_inset Formula $s$
\end_inset

 in which all actions were performed by that agent can satisfy 
\begin_inset Formula $G$
\end_inset

.
 If this is the case, it will need to cooperate with another agent in order
 to achieve its goal.
\end_layout

\begin_layout Standard

\series bold
Knowledge under Partial Observability:
\series default
 In recent unpublished work we develop a new account of knowledge in the
 situation calculus when not all actions are observable by all agents.
 To facilitate reasoning in this formalism, agents must be able to reason
 about what cannot be changed by actions that they cannot observe, a form
 of persistence query.
\end_layout

\begin_layout Standard
Due to the universal quantification over situations, the techniques for
 effective automated reasoning in Section 
\begin_inset LatexCommand \ref{sub:Effective-Reasoning}

\end_inset

 cannot be applied to persistence queries.
 This paper is devoted to developing of a complementary technique for handling
 such queries.
\end_layout

\begin_layout Subsection
Related Work
\end_layout

\begin_layout Standard
While there is a rich and diverse literature base for the situation calculus,
 there appears to have been little work dealing with universally quantified
 queries.
 The work of 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

 shows how to handle such queries by hand using an appropriate instantiation
 of the induction axiom, but makes no mention of automating this reasoning.
\end_layout

\begin_layout Standard
Other work considering persistence focuses exclusively on verifying state
 constraints.
 These are uniform formulae that must hold in every possible situation,
 a highly specialized form of persistence query.
 The work of 
\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset

 
\begin_inset Quotes eld
\end_inset

compiles away
\begin_inset Quotes erd
\end_inset

 the induction axiom when verifying a state constraint, by means of the
 following equivalence:
\begin_inset Formula \begin{gather*}
\Sigma\cup\mathcal{D}_{una}\cup\mathcal{D}_{ss}\models\phi[S_{0}]\rightarrow\left(\forall s\,.\, S_{0}\leq s\rightarrow\phi[s]\right)\\
\mathit{iff}\\
\mathcal{D}_{una}\models\forall s,a\,.\,\phi[s]\wedge\mathcal{R}_{\mathcal{D}}[Poss(a,s)]\,\rightarrow\,\mathcal{R}_{\mathcal{D}}[\phi[do(a,s)]]\end{gather*}

\end_inset

Verification of a state constraint can thus be reduced to reasoning about
 a universally quantified uniform formula using only the unique names axioms,
 a comparatively straightforward reasoning task.
 This problem is also approached by 
\begin_inset LatexCommand \cite{bertossi96automating}

\end_inset

, who develop a system for automatically verifying state constraints based
 on an induction theorem prover.
\end_layout

\begin_layout Standard
However, there are many issues related to persistence that are not addressed
 by such work, including: persistence at situations other than 
\begin_inset Formula $S_{0}$
\end_inset

; action description predicates other than 
\begin_inset Formula $Poss$
\end_inset

; how to combine notions of persistence and regression; and determining
 what additional conditions may be necessary to guarantee the persistence
 of 
\begin_inset Formula $\phi$
\end_inset

.
 As our treatment of persistence can provide a concrete basis for these
 considerations, it is significantly more general than existing work.
\end_layout

\begin_layout Section
The Persistence Condition
\begin_inset LatexCommand \label{sec:Persistence-Condition}

\end_inset


\end_layout

\begin_layout Standard
For implementing persistence queries in practical systems, we clearly need
 to transform the query into a form suitable for effective reasoning.
 Specifically, we will transform a persistence query based at 
\begin_inset Formula $s$
\end_inset

 into the evaluation of a uniform formula at 
\begin_inset Formula $s$
\end_inset

, which can be done effectively using the regression operator.
 We need some transformation of a property 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

 into a uniform formula 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$
\end_inset

 that is true at precisely the situations in which 
\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

, given a particular action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

.
 We call 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 the 
\emph on
persistence condition
\emph default
 of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{definition}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The persistence condition 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$
\end_inset

 is a uniform formula that is the weakest precondition for the persistence
 of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

, given a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

 without the initial situation axioms.
 That is:
\begin_inset LatexCommand \label{def:persistence-condition}

\end_inset


\begin_inset Formula \[
\mathcal{D}-\mathcal{D}_{S_{0}}\models\forall s\,.\,\left(\mathcal{P_{D}}[\phi,\alpha][s]\,\equiv\,\forall s'\,.\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\]

\end_inset


\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{definition}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Defining 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 to be independent of the initial world state allows an agent to calculate
 it regardless of what (if anything) is known about the actual state of
 the world.
 To see how 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 may be calculated, consider the weaker notion of a formula 
\emph on
persisting to depth 
\begin_inset Formula $n$
\end_inset


\emph default
 in a situation:
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{definition}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A uniform formula 
\begin_inset Formula $\phi$
\end_inset

 persists to depth 1 under 
\begin_inset Formula $\alpha$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

 when the formula 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha]$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

, as defined by:
\begin_inset LatexCommand \label{def:persists-depth-n}

\end_inset


\begin_inset Formula \[
\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha][s]\,\isdef\,\phi[s]\,\wedge\,\forall a\,.\,\mathcal{R_{D}}[\alpha(a,s)\rightarrow\phi[do(a,s)]]\]

\end_inset

More generally, for any 
\begin_inset Formula $n\geq0$
\end_inset

, a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 persists to depth 
\begin_inset Formula $n$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

 when the formula 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

, as defined by:
\begin_inset Formula \[
\mathcal{P}_{\mathcal{D}}^{0}[\phi,\alpha]\,\isdef\,\phi\]

\end_inset


\begin_inset Formula \[
\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]\,\isdef\,\mathcal{P}_{\mathcal{D}}^{1}[\mathcal{P}_{D}^{n-1}[\phi,\alpha],\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{definition}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}$
\end_inset

 is a literal encoding of the requirement 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and in all its direct successors
\begin_inset Quotes erd
\end_inset

.
 Since 
\begin_inset Formula $\alpha$
\end_inset

 is an action description predicate and 
\begin_inset Formula $\phi$
\end_inset

 is a uniform formula, the expression 
\begin_inset Formula $\alpha(a,s)\rightarrow\phi[do(a,s)]$
\end_inset

 can always be regressed and the result will always be uniform in 
\begin_inset Formula $s$
\end_inset

.
 Successive applications of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}$
\end_inset

 assert persistence to greater depths.
\end_layout

\begin_layout Standard
Intuitively, one would expect 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$
\end_inset

 to be a fixed-point of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha]$
\end_inset

, since 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$
\end_inset

 implies persistence up to any depth.
 Such a fixed-point can then be calculated using standard iterative approximatio
n techniques.
 To show that this is in fact the case we require a number of theoretical
 results, presented below.
\end_layout

\begin_layout Subsection
Formal Development
\end_layout

\begin_layout Standard
We begin by adapting two existing results involving induction to operate
 with our generalized 
\begin_inset Formula $\leq_{\alpha}$
\end_inset

 notation, and be based at situations other than 
\begin_inset Formula $S_{0}$
\end_inset

:
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{proposition}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For any action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, the foundational axioms of the situation calculus entail the following
 induction principle:
\begin_inset LatexCommand \label{prop:a-order-induction}

\end_inset


\begin_inset Formula \begin{multline*}
\forall W,s\,.\,\, W(s)\wedge\left[\forall a,s'\,.\,\alpha(a,s')\wedge s\leq_{\alpha}s'\right.\\
\left.\wedge W(s')\rightarrow W(do(a,s'))\right]\rightarrow\forall s'\,.\, s\leq_{\alpha}s'\rightarrow W(s')\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{proposition}
\backslash
begin{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A trivial adaptation of theorem 1 in 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{proposition}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For any basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset LatexCommand \label{prop:a-order-reduction}

\end_inset


\begin_inset Formula \begin{gather*}
\mathcal{D}-\mathcal{D}_{S_{0}}\models\forall s\,.\,\phi[s]\rightarrow\left(\forall s'\,.\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\\
\mathit{iff}\\
\mathcal{D}_{una}\models\forall s,a\,.\,\phi[s]\wedge\mathcal{R}_{\mathcal{D}}[\alpha(a,s)]\rightarrow\mathcal{R}_{\mathcal{D}}[\phi[do(a,s)]]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{proposition}
\backslash
begin{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A straightforward generalization of Lemma 5 in 
\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset

, utilizing Proposition 
\begin_inset LatexCommand \ref{prop:a-order-induction}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset

Proposition 
\begin_inset LatexCommand \ref{prop:a-order-reduction}

\end_inset

 will be key in our algorithm for calculating the persistence condition.
 It allows one to establish the result 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

, then 
\begin_inset Formula $\phi$
\end_inset

 persists in 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

 by checking entailment of a uniform formula by the unique names axioms,
 a straightforward first-order reasoning task.
\end_layout

\begin_layout Standard
Next we must formalize some basic relationships between 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 and 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}$
\end_inset

, as follows:
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{lemma}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset LatexCommand \label{lem:p-equiv-p(pn)}

\end_inset


\begin_inset Formula \begin{multline*}
\mathcal{D}-\mathcal{D}_{S_{0}}\models\forall s\,.\,\left[\,\,\forall s'\,.\,\left(s\leq_{\alpha}s'\rightarrow\phi[s']\right)\right.\\
\left.\equiv\forall s'\,.\,\left(s\leq_{\alpha}s'\rightarrow\mathcal{P}_{D}^{n}[\phi,\alpha][s']\right)\,\,\right]\end{multline*}

\end_inset

That is, 
\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

 iff 
\begin_inset Formula $\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{lemma}
\backslash
begin{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By the definition of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}$
\end_inset

, any 
\begin_inset Formula $s'$
\end_inset

 that falsifies the right-hand side of this equivalence will also falsify
 the left-hand side, and vice-versa.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{lemma}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset LatexCommand \label{lem:p-implies-pn}

\end_inset


\begin_inset Formula \[
\mathcal{D}-\mathcal{D}_{S_{0}}\models\forall s\,.\,\left(\mathcal{P_{D}}[\phi,\alpha][s]\rightarrow\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\right)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{lemma}
\backslash
begin{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

 implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

 by definition, which implies 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 by Lemma 
\begin_inset LatexCommand \ref{lem:p-equiv-p(pn)}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset

We are now equipped to prove the major theorem of this paper: that if 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 implies 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha]$
\end_inset

, then 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 is equivalent to the persistence condition for 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset LatexCommand \label{thm:p(pn)-equiv-p}

\end_inset


\begin_inset Formula \begin{gather}
\mathcal{D}_{una}\models\forall s\,.\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\rightarrow\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha][s]\label{eqn:pn_persists}\\
\mathit{iff}\nonumber \\
\mathcal{D}-\mathcal{D}_{s_{0}}\models\forall s\,.\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\equiv\mathcal{P_{D}}[\phi,\alpha][s]\label{eqn:pn_equiv_persists}\end{gather}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{theorem}
\backslash
begin{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the 
\emph on
if 
\emph default
direction, we first see by the definition of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}$
\end_inset

 that equation (
\begin_inset LatexCommand \ref{eqn:pn_persists}

\end_inset

) is equivalent to:
\begin_inset Formula \begin{multline*}
\mathcal{D}_{una}\models\forall s,a\,.\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\wedge\mathcal{R}_{\mathcal{D}}[\alpha(a,s)]\\
\rightarrow\mathcal{R}_{\mathcal{D}}[\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][do(a,s)]]\end{multline*}

\end_inset

which by Proposition 
\begin_inset LatexCommand \ref{prop:a-order-reduction}

\end_inset

 implies the persistence of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
 By Lemma 
\begin_inset LatexCommand \ref{lem:p-equiv-p(pn)}

\end_inset

 this implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

, which in turn implies 
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

, giving:
\begin_inset Formula \[
\mathcal{D}-\mathcal{D}_{s_{0}}\models\forall s\,.\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\rightarrow\mathcal{P_{D}}[\phi,\alpha][s]\]

\end_inset

By Lemma 
\begin_inset LatexCommand \ref{lem:p-implies-pn}

\end_inset

 this implication is in fact an equivalence, yielding equation (
\begin_inset LatexCommand \ref{eqn:pn_equiv_persists}

\end_inset

) as required.
\end_layout

\begin_layout Standard
The 
\emph on
only if
\emph default
 direction is a straightforward reversal of this reasoning: 
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

 implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

, which implies the persistence of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

, which implies (
\begin_inset LatexCommand \ref{eqn:pn_persists}

\end_inset

) by Proposition 
\begin_inset LatexCommand \ref{prop:a-order-reduction}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset

Since 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha]\rightarrow\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 by definition, equation (
\begin_inset LatexCommand \ref{eqn:pn_persists}

\end_inset

) identifies 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 as a fixed-point of the 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}$
\end_inset

 operator, as our initial intuition suggested.
\end_layout

\begin_layout Subsection
Algorithm for the Persistence Condition
\end_layout

\begin_layout Standard
Since we can easily calculate 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 for any 
\begin_inset Formula $n$
\end_inset

, we have a straightforward algorithm for determining 
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

: search for an 
\begin_inset Formula $n$
\end_inset

 such that
\begin_inset Formula \[
\mathcal{D}_{una}\models\forall s\,.\,\left(\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\rightarrow\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha][s]\right)\]

\end_inset

Since we expect 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 to be simpler than 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha]$
\end_inset

, we should look for the smallest such 
\begin_inset Formula $n$
\end_inset

.
 Algorithm 
\begin_inset LatexCommand \ref{alg:calc_p}

\end_inset

 presents an iterative procedure for doing just that.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{algorithm}
\end_layout

\begin_layout Standard


\backslash
caption{Calculate $
\backslash
mathcal{P}_
\backslash
mathcal{D}[
\backslash
phi,
\backslash
alpha]$}
\end_layout

\begin_layout Standard


\backslash
label{alg:calc_p}
\end_layout

\begin_layout Standard


\backslash
begin{algorithmic}
\end_layout

\begin_layout Standard


\backslash
STATE $
\backslash
mathtt{pn} 
\backslash
Leftarrow 
\backslash
phi$
\end_layout

\begin_layout Standard


\backslash
STATE $
\backslash
mathtt{pn1} 
\backslash
Leftarrow 
\backslash
mathcal{P}^1_
\backslash
mathcal{D}[
\backslash
mathtt{pn},
\backslash
alpha]$
\end_layout

\begin_layout Standard


\backslash
WHILE{$
\backslash
mathcal{D}_{una} 
\backslash
not
\backslash
models 
\backslash
forall s
\backslash
,.
\backslash
,
\backslash
mathtt{pn}[s] 
\backslash
rightarrow 
\backslash
mathtt{pn1}[s]$}
\end_layout

\begin_layout Standard

  
\backslash
STATE $
\backslash
mathtt{pn} 
\backslash
Leftarrow 
\backslash
mathtt{pn1}$
\end_layout

\begin_layout Standard

  
\backslash
STATE $
\backslash
mathtt{pn1} 
\backslash
Leftarrow 
\backslash
mathcal{P}^1_{
\backslash
mathcal{D}}[
\backslash
mathtt{pn},
\backslash
alpha]$
\end_layout

\begin_layout Standard


\backslash
ENDWHILE
\end_layout

\begin_layout Standard


\backslash
STATE return $
\backslash
mathtt{pn}$
\end_layout

\begin_layout Standard


\backslash
end{algorithmic}
\end_layout

\begin_layout Standard


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the calculation of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha]$
\end_inset

 is a straightforward syntactic transformation and so requires no further
 treatment.
\end_layout

\begin_layout Subsubsection
Correctness
\end_layout

\begin_layout Standard
If algorithm 
\begin_inset LatexCommand \ref{alg:calc_p}

\end_inset

 terminates, it terminates returning a value of 
\begin_inset Formula $pn$
\end_inset

 for which equation (
\begin_inset LatexCommand \ref{eqn:pn_persists}

\end_inset

) holds.
 By Theorem 
\begin_inset LatexCommand \ref{thm:p(pn)-equiv-p}

\end_inset

 this value of 
\begin_inset Formula $pn$
\end_inset

 is equivalent to the persistence condition for 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
 The algorithm therefore correctly calculates the persistence condition.
\end_layout

\begin_layout Standard
Note that equation (
\begin_inset LatexCommand \ref{eqn:pn_persists}

\end_inset

) holds when 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
\end_inset

 is unsatisfiable for any situation, as it appears in the antecedent of
 the implication.
 The algorithm thus correctly returns an unsatisfiable condition (equivalent
 to 
\begin_inset Formula $false$
\end_inset

) when 
\begin_inset Formula $\phi$
\end_inset

 can never persist under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Completeness
\end_layout

\begin_layout Standard
As Theorem 
\begin_inset LatexCommand \ref{thm:p(pn)-equiv-p}

\end_inset

 is an equivalence, the only source of incompleteness will be failure to
 terminate.
 Algorithm 
\begin_inset LatexCommand \ref{alg:calc_p}

\end_inset

 may fail to terminate for two reasons: the loop condition may never be
 satisfied, or the first-order logical inference in the loop condition may
 be undecidable and fail to terminate.
\end_layout

\begin_layout Standard
The later indicates that the basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

 is undecidable.
 While this is a concern, it affects more than just our algorithm - any
 system implemented around such an action theory will be incomplete.
 Thus, with respect to this source of incompleteness, our algorithm is no
 more incomplete than any larger system it would form a part of.
\end_layout

\begin_layout Standard
The former is of more direct consequence to our work, and raises two questions:
 is the persistence condition guaranteed to exist, and is it guaranteed
 to be reachable in a finite number of iterations? Since 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}$
\end_inset

 is clearly monotone, the constructive proof of Tarski's fixed-point theorem
 
\begin_inset LatexCommand \cite{cousot79constructive_tarski}

\end_inset

 guarantees the existence of a fixed-point that can be calculated via transfinit
e iteration, as performed by our algorithm.
 Moreover, this will be the least fixed-point greater than 
\begin_inset Formula $\phi$
\end_inset

, a satisfying confirmation of correctness since the persistence condition
 must be the weakest precondition for the persistence of 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
Unfortunately, there is no guarantee that this fixed-point can be reached
 via 
\emph on
finite
\emph default
 iteration, which is required for termination.
 Indeed, it is straightforward to construct a fluent for which the algorithm
 never terminates: consider a fluent 
\begin_inset Formula $Fp(x,s)$
\end_inset

 taking integers 
\begin_inset Formula $x$
\end_inset

, that is affected by a single action that makes it false whenever 
\begin_inset Formula $Fp(x+1,s)$
\end_inset

 is false.
 Letting 
\begin_inset Formula $\alpha$
\end_inset

 be vacuously true, the sequence of iterations produced by our algorithm
 would be:
\begin_inset Formula \begin{gather*}
\mathcal{P}_{\mathcal{D}}^{1}[Fp(x,s)]\equiv Fp(x,s)\wedge Fp(x+1,s)\\
\mathcal{P}_{\mathcal{D}}^{2}[Fp(x,s)]\equiv Fp(x,s)\wedge Fp(x+1,s)\wedge Fp(x+2,s)\\
\vdots\\
\mathcal{P}_{\mathcal{D}}^{n}[Fp(x,s)]\equiv\bigwedge_{i=0}^{i=n}Fp(x+i,s)\end{gather*}

\end_inset

The persistence condition in this case is 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[Fp(x,s)]\equiv\forall y\,.\, x\leq y\rightarrow Fp(y,s)$
\end_inset

, and while this is the limit of the iteration it is clearly unachievable
 in any finite number of steps.
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}$
\end_inset

 operates over the set of equivalence classes of formulae uniform in 
\begin_inset Formula $s$
\end_inset

, and the theory of fixed-points requires that this set be a 
\emph on
well-founded partial order
\emph default
 to guarantee termination of an iterative approximation algorithm.
 There are certain classes of basic action theory for which this well-foundednes
s can be guaranteed.
 The most obvious is theories with finite action and object domains, in
 which the set of equivalence classes is finite.
 Another is the case where successor-state axioms refer only to the direct
 arguments of their fluents, in which case repeated applications of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}$
\end_inset

 will pick out a subset of the equivalence classes that refers to a finite
 number of objects, giving the same guarantee.
\end_layout

\begin_layout Standard
In general, termination requires that repeated applications of the successor-sta
te axioms (via the regression operator) do not construct infinite chains.
 We are currently investigating syntactic restrictions on successor state
 axioms that can enforce this requirement, and have found it to be easily
 met in practice.
 We are also investigating more advanced fixed-point algorithms that may
 give better efficiency and termination guarantees.
\end_layout

\begin_layout Subsubsection
Effectiveness
\end_layout

\begin_layout Standard
Our algorithm replaces a single reasoning task based on the full action
 theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

 with a series of reasoning tasks based on the unique names axioms 
\begin_inset Formula $\mathcal{D}_{una}$
\end_inset

.
 Is this a worthwhile trade-off in practice? The following points weigh
 strongly in favor of our approach:
\end_layout

\begin_layout Standard
First and foremost, we avoid the need for the second-order induction axiom.
 All the reasoning tasks can be performed using standard first-order reasoning,
 for which there are many high-quality automated provers.
 Second, the calculation of 
\begin_inset Formula $\mathcal{P_{D}}$
\end_inset

 only reasons based on the unique names axioms, which as discussed is a
 comparatively straightforward task.
 Third, 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi,\alpha][s]$
\end_inset

 is in a form amenable to regression, a standard tool for effective reasoning
 in the situation calculus.
 Fourth, the persistence condition for a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

 can be cached and re-used for a series of related queries about different
 situations, a significant gain in amortized efficiency.
 Finally, in realistic domains we expect many properties to fail to persist
 beyond a few situations into the future, meaning that our algorithm will
 require few iterations in a large number of cases.
\end_layout

\begin_layout Standard
Of course, we also inherit the potential disadvantage of the regression
 operator: the length of 
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 As with regression, our experience thus far has been that this is rarely
 a problem, and is more than compensated for by the reduced number of axioms
 required for reasoning.
\end_layout

\begin_layout Subsection
Applications
\end_layout

\begin_layout Standard
The persistence condition is readily applicable to the persistence query
 problems given in Section 
\begin_inset LatexCommand \ref{sub:Property-Persistence}

\end_inset

.
 Since 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 yields a uniform formula, the techniques outlined in Section 
\begin_inset LatexCommand \ref{sub:Effective-Reasoning}

\end_inset

 can be directly applied to the following transformed queries.
\end_layout

\begin_layout Standard

\series bold
Goal Impossibility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no possible situation in which that goal is satisfied:
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P_{D}}[\neg G,Poss][S_{0}]\]

\end_inset

The persistence condition of 
\begin_inset Formula $\neg G$
\end_inset

 with respect to action possibility allows goal impossibility to be checked
 easily.
\end_layout

\begin_layout Standard

\series bold
Goal Futility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $s$
\end_inset

, establish that the goal cannot be satisfied in any possible situation
 in the future of 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P_{D}}[\neg G,Poss][s]\]

\end_inset

Precisely the same formula is required for checking goal impossibility and
 goal futility.
 This highlights the advantage of re-using the persistence condition at
 multiple situations.
 Our approach makes it feasible for an agent to check for goal futility
 each time it considers performing an action, and avoid situations that
 would make its goals unachievable.
 
\end_layout

\begin_layout Standard

\series bold
Checking State Constraints:
\series default
 This can be handled as per goal impossibility above.
 A state constraint 
\begin_inset Formula $\phi$
\end_inset

 should always satisfy:
\begin_inset Formula \[
\mathcal{D}_{una}\models\phi\equiv\mathcal{P}_{\mathcal{D}}[\phi,Poss]\]

\end_inset


\end_layout

\begin_layout Standard
If this is not the case then 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi,Poss]$
\end_inset

 indicates the additional conditions that are necessary to ensure that 
\begin_inset Formula $\phi$
\end_inset

 persists, which may be useful in adjusting the action theory to accommodate
 the constraint.
\end_layout

\begin_layout Standard

\series bold
Need for Cooperation:
\series default
 To establish that it is absolutely necessary to cooperate with another
 agent, an agent must determine persistence with respect to actions performed
 by itself:
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P_{D}}[\neg G,OwnAction][s]\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Knowledge under Partial Observability:
\series default
 In recent unpublished work, we have used the persistence condition to formulate
 a regression procedure for knowledge formulae when actions may be unobservable.
 To know 
\begin_inset Formula $\phi$
\end_inset

, the agent must know that 
\begin_inset Formula $\phi$
\end_inset

 will persist under any actions that it would be unable to observe, resulting
 in a regression rule like the following:
\begin_inset Formula \begin{multline*}
\mathcal{R}_{\mathcal{D}}[\mathbf{Knows}(\phi,do(a,s))]=\\
\mathbf{Knows}(\mathcal{R}_{\mathcal{D}}[\mathcal{P}_{\mathcal{D}}[\phi,CantObs][do(a,s)]],s)\end{multline*}

\end_inset


\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand \label{sec:Conclusions}

\end_inset


\end_layout

\begin_layout Standard
We have developed an algorithm that transforms persistence queries, a very
 general and useful class of situation calculus query, to a form that is
 amenable to standard techniques for effective reasoning in the situation
 calculus.
 The algorithm is based on iterative application of the standard regression
 operator, and uses only first-order reasoning with a small number of axioms.
 Our algorithm is shown to be correct, and complete given some basic restriction
s on the theory of action.
\end_layout

\begin_layout Standard
Our approach generalizes previous work on persistence in several important
 ways.
 It can consider sequences of actions satisfying a range of conditions,
 not just the standard ordering over possibility, enabling us to treat problems
 such as need for cooperation and knowledge under partial observability.
 It can establish that properties persist in the future of an arbitrary
 situation, not necessarily the initial situation, enabling us to answer
 the question of goal futility.
 The results of calculating the persistence condition can be cached, allowing
 for example the goal futility question to be efficiently posed on a large
 number of situations once the persistence condition has been calculated.
 Finally, the fact that 
\begin_inset Formula $\mathcal{P_{D}}$
\end_inset

 operates similarly to the standard regression operator 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 allows them to interact in non-trivial ways, such as in the regression
 of knowledge formulae under partial observability of actions.
\end_layout

\begin_layout Standard
As a result, we have significantly increased the scope of queries that can
 be effectively posed in practical systems built on the situation calculus.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[named]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
