#LyX 1.4.2 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble




\newtheorem{theorem}{Theorem}
\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}
\end_preamble
\options letterpaper
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Knowledge and Observations in the Situation Calculus 
\end_layout

\begin_layout Author
Ryan F.
 Kelly
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
titlenote{Currently a PhD student at the University of Melbourne.}
\end_layout

\end_inset

and Adrian R.
 Pearce
\newline
NICTA Victoria Laboratory
\newline
 Department of Computer Science and Software
 Engineering
\newline
 The University of Melbourne
\newline
 Victoria, 3010, Australia
\newline
 {rfk,adrian}@
csse.unimelb.edu.au 
\end_layout

\begin_layout Abstract
We develop a new semantics for multi-agent knowledge in the situation calculus
 by reifying the observations that each agent makes as the world evolves.
 Our approach is strictly more general than previous formalisms, and is
 flexible enough to handle the case where an agent can observe the effects
 of an action but not the occurence of the action itself.
 We develop a technique for effective reasoning in this formalism using
 a combination of the regression and persistence condition operators.
 This technique also allows agents to reason from their internal history
 of observations, rather than requiring a full history of the world.
 The result is a robust account of knowledge for partially-observable multi-agen
t domains.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 is one of the most popular formalisms for reasoning about dynamic worlds.
 Many extensions have been proposed to incorporate concepts such as knowledge
 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

 and concurrent actions 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

, which can be combined to provide a rich formalism for modeling complex
 domains such as multi-agent systems.
\end_layout

\begin_layout Standard
A common assumption when working with knowledge in the situation calculus
 is that agents are fully aware of the actions that have been performed
 in the world.
 Indeed, the notion of 'situation' is formalized as a history of all actions
 that have occurred.
 In the rare cases that this is not assumed, the opposing extreme is posited
 - that agents are completely ignorant of actions performed by others 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset

.
 However, neither approach accounts for the general case of knowledge with
 
\emph on
partial
\emph default
 awareness of actions.
 For example, consider agents occupying a building who are aware of only
 those actions performed in the room they currently occupy.
\end_layout

\begin_layout Standard
To overcome this limitation, we reify (that is, treat as concrete objects
 in the logic) the notion of 
\emph on
observations
\emph default
 and define the function 
\begin_inset Formula $Observations(agt,c,s)$
\end_inset

 to axiomatize the conditions under which an agent will observe the occurrence
 of an action.
 By ensuring that agents consider possible any situation compatible with
 what they have observed, we develop an improved account of knowledge that
 spans the two extremes.
 Appropriate axiomatisation of this function can model both total awareness
 of actions and total ignorance, as well as previously unaccounted-for circumsta
nces such as those described above.
 The formalism can also be extended to model agents who observe the effects
 of actions, rather than the actions themselves.
 It is thus a true generalization of previous situation calculus approaches
 to knowledge.
\end_layout

\begin_layout Standard
The full axiomatisation of the situation calculus includes a second-order
 induction axiom.
 For effective automated reasoning, queries must be restricted to syntactic
 forms that can be proven without employing induction 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 Our new semantics does not satisfy this restriction as it employs universal
 quantification over situations.
 Using the persistence condition meta-operator developed in 
\begin_inset LatexCommand \cite{kelly07sc_persistence}

\end_inset

 to augment the traditional regression meta-operator 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

, we show how to transform queries about knowledge into a form amenable
 to purely first-order reasoning.
 The result is a powerful new account of multi-agent knowledge that still
 permits an effective reasoning procedure.
\end_layout

\begin_layout Standard
Reasoning in the situation calculus traditionally requires an omniscient
 viewpoint, with queries posed relative to the current situation.
 While this works well for modeling and simulation where a full world history
 is available, it makes it difficult for agents to reason about their own
 world based on their limited observations of what has occurred.
 Our regression technique can be applied to the sequence of observations
 made by a single agent, rather than to a full situation term, facilitating
 reasoning from an internal viewpoint more appropriate for implementation
 in real systems.
 Our work thus has strong parallels with the classic view-based account
 of knowledge 
\begin_inset LatexCommand \cite{halpern90knowledge_distrib}

\end_inset

, but grounded in the situation calculus and with an emphasis on automated
 reasoning.
\end_layout

\begin_layout Standard
The paper is organized as follows: Section 
\begin_inset LatexCommand \ref{sec:ma-sitcalc}

\end_inset

 gives a brief introduction to the situation calculus with knowledge and
 concurrent actions, and highlights some of the limitations of current approache
s; Section 
\begin_inset LatexCommand \ref{sec:New-Semantics}

\end_inset

 introduces our new semantics, defines regression of knowledge formulae,
 and offers a short example; and Section 
\begin_inset LatexCommand \ref{sec:Conclusions}

\end_inset

 concludes with a summary of our results.
\end_layout

\begin_layout Section
The Multi-Agent Situation Calculus
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{sec:ma-sitcalc}

\end_inset

Our work utilizes the situation calculus as described in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

, enriched with concurrent actions 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 to better represent the dynamics of a multi-agent system.
 We use the standard approach found in 
\begin_inset LatexCommand \cite{shapiro01casl_feat_inter}

\end_inset

 for representing multiple agents, and begin from the standard account of
 knowledge due to 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

.
 A brief overview is presented below.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\emph on
Agent
\emph default
 terms represent the agents operating in the world; 
\emph on
Action
\emph default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change, with the initiating agent indicated by
 their first argument; 
\emph on
Concurrent
\emph default
 terms are sets of actions that occur simultaneously; 
\emph on
Situation
\emph default
 terms are histories of the concurrent actions that have occurred in the
 world, with the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Concurrent\times Situation\rightarrow Situation$
\end_inset

; 
\emph on
Result
\emph default
 terms represent sensing results returned by actions; 
\emph on
Object
\emph default
 terms represent any other object in the domain.
 It also distinguishes 
\emph on
Fluents
\emph default
 as predicates or functions representing properties of the world that may
 change between situations, and so take a situation term as their final
 argument.
\end_layout

\begin_layout Standard
A 
\emph on
basic action theory
\emph default
 is a set 
\begin_inset Formula $\mathcal{D}$
\end_inset

 of situation calculus sentences (with a specific syntactic form as specified
 in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

) that describes a particular dynamic world.
 Queries about the behavior of the world are posed as logical entailment
 queries relative to this theory.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); successor state axioms describing how fluents change between situations
 (
\begin_inset Formula $\mathcal{D}_{ss}$
\end_inset

); precondition axioms indicating when actions can be performed (
\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

); unique names axioms ensuring that action terms are distinct (
\begin_inset Formula $\mathcal{D}_{una}$
\end_inset

); and axioms describing the value of fluents in the initial situation (
\begin_inset Formula $\mathcal{D}_{S_{0}}$
\end_inset

):
\begin_inset Formula \[
\mathcal{D}=\Sigma\cup\mathcal{D}_{ss}\cup\mathcal{D}_{ap}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
There is a distinguished fluent predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 For example, it is only possible for an agent to drop an object if they
 are actually holding it
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow the convention that lower-case roman names indicate variables,
 with free variables being implicitly universally quantified.
\end_layout

\end_inset

: 
\begin_inset Formula \[
Poss(drop(agt,obj),s)\equiv Holding(agt,obj,s)\]

\end_inset


\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

 contains one axiom of the above form for each type of action.
 We also appeal to the more general notion of 
\emph on
action description predicates
\emph default
 as used in 
\begin_inset LatexCommand \cite{kelly07sc_persistence}

\end_inset

.
 These are predicates defined in the same manner as 
\begin_inset Formula $Poss$
\end_inset

 that describe some other aspect of the performance of an action.
 For example, we will define below an action description predicate 
\begin_inset Formula $CanObs$
\end_inset

 that specifies when an agent will observe the occurance of an action.
\end_layout

\begin_layout Standard
Situations form a tree structure with 
\begin_inset Formula $S_{0}$
\end_inset

 at the root and 
\begin_inset Formula $do$
\end_inset

 constructing child situations from parents.
 There is a basic ordering relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 which should be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

 and is defined as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\neg\left(s\sqsubset S_{0}\right)\]

\end_inset


\begin_inset Formula \[
s\sqsubset do(a,s')\equiv s\sqsubseteq s'\]

\end_inset

Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 More generally, one may consider only those futures in which all actions
 satisfy a particular action description predicate 
\begin_inset Formula $\alpha$
\end_inset

 by using the 
\begin_inset Formula $<_{\alpha}$
\end_inset

 relation of 
\begin_inset LatexCommand \cite{kelly07sc_persistence}

\end_inset

:
\begin_inset Formula \[
\neg\left(s<_{\alpha}S_{0}\right)\]

\end_inset


\begin_inset Formula \[
s<_{\alpha}do(a,s')\equiv s\leq_{\alpha}s'\wedge\alpha(a,s')\]

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
uniform formulae
\emph default
 as defined in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 can be thought as 
\emph on
properties 
\emph default
of the state of the world.
 They are basically logical combinations of fluents referring to a common
 situation term, which cannot mention action description predicates nor
 compare situation terms.
 The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout to refer to an arbitrary uniform formula.
 It is often useful to determine the truth of a uniform formula at an alternate
 situation term, and 
\begin_inset Formula $\phi[s]$
\end_inset

 represents the uniform formula 
\begin_inset Formula $\phi$
\end_inset

 with all occurrences of its unique situation term replaced by the situation
 
\begin_inset Formula $s$
\end_inset

.
 Where no confusion can arise, we suppress the situation terms in uniform
 formulae to simplify the presentation.
\end_layout

\begin_layout Standard
The truth of a fluent is completely specified by defining its truth in the
 initial situation, and collecting the effects of various actions into 
\emph on
successor state axioms
\emph default
.
 Such axioms provide a monotonic solution to the infamous frame problem.
 They have the following general form, asserting the truth of a fluent 
\begin_inset Formula $F$
\end_inset

 in the successor situation 
\begin_inset Formula $do(c,s)$
\end_inset

 based on the current situation 
\begin_inset Formula $s$
\end_inset

 and the actions 
\begin_inset Formula $c$
\end_inset

 that were performed: 
\begin_inset Formula \[
F(\overrightarrow{x},do(c,s))\equiv\Phi(\overrightarrow{x},c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi$
\end_inset

 is a formula uniform in 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsection
Knowledge and Sensing
\end_layout

\begin_layout Standard
The standard semantics of knowledge 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

 are based on the popular 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 model.
 A knowledge fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 The macro 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 is then introduced as a shorthand for the standard possible-worlds definition
 of knowledge, stating that an agent knows something when it is true in
 all situations considered possible: 
\begin_inset Formula \begin{equation}
\mathbf{Knows}(agt,\phi,s)\,\isdef\,\forall s'\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}

\end_inset

 To allow actions to return sensing information the sensing result function
 
\begin_inset Formula $SR(a,s)$
\end_inset

 is introduced, giving the result returned by the action 
\begin_inset Formula $a$
\end_inset

 when executed in a situation 
\begin_inset Formula $s$
\end_inset

.
 For actions that don't return sensing information, the value of 
\begin_inset Formula $SR$
\end_inset

 is set to some arbitrary constant such as 
\begin_inset Formula $"OK"$
\end_inset

.
\end_layout

\begin_layout Standard
Combining the multi-agent semantics of 
\begin_inset LatexCommand \cite{shapiro01casl_feat_inter}

\end_inset

 with the handling of concurrent actions in 
\begin_inset LatexCommand \cite{scherl03conc_knowledge}

\end_inset

, the common form of successor state axiom for the knowledge fluent is
\begin_inset Foot
status collapsed

\begin_layout Standard
Using the standard abbreviation 
\begin_inset Formula $\forall a\in c\,.\,\psi\,\isdef\,\forall a\,.a\in c\rightarrow\psi$
\end_inset


\end_layout

\end_inset

: 
\begin_inset Formula \begin{multline}
K(agt,s'',do(c,s))\equiv\\
\exists s'\,\, s''=do(c,s')\,\wedge K(agt,s',s)\wedge Poss(c,s')\\
\wedge\,\forall a\in c\left[agent(a)=agt\rightarrow SR(a,s)=SR(a,s')\right]\label{eqn:k_ssa_standard}\end{multline}

\end_inset

 The function 
\begin_inset Formula $agent(a)$
\end_inset

 gives the agent performing the action, which always corresponds to the
 first argument of the action.
\end_layout

\begin_layout Standard
This successor state axiom ensures that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(c,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing those same actions 
\begin_inset Formula $c$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is a possible alternative to 
\begin_inset Formula $s$
\end_inset

.
 It must furthermore have been possible to perform those actions in 
\begin_inset Formula $s'$
\end_inset

, and the sensing results must be consistent for all actions in 
\begin_inset Formula $c$
\end_inset

 that were carried out by the agent.
\end_layout

\begin_layout Standard
It is also necessary to permit alternate possible worlds to the initial
 situation 
\begin_inset Formula $S_{0}$
\end_inset

 to represent incomplete initial knowledge.
 The predicate 
\begin_inset Formula $Init$
\end_inset

 identifies initial situations, and only other initial situations may be
 
\begin_inset Formula $K$
\end_inset

-related to an initial situation.
 We also talk of situations being 
\emph on
rooted at
\emph default
 some initial situation: 
\begin_inset Formula \[
\begin{split} & Init(s)\rightarrow Root(s)=s\\
 & Root(do(c,s))=Root(s)\\
 & Init(s)\rightarrow\left(K(s',s)\rightarrow Init(s')\right)\end{split}
\]

\end_inset

 While powerful, this formulation has an important limitation: each agent
 is assumed to be aware of 
\emph on
all
\emph default
 actions that have occurred.
 Note that this awareness is passive - the agents perform no explicit sensing
 actions to determine what has occurred.
 Responsibility for generating such 
\begin_inset Quotes eld
\end_inset

awareness
\begin_inset Quotes erd
\end_inset

 in real systems must thus be abdicated to a lower-level software component,
 such as a continuous sensing system that identifies change in the environment
 and notifies the agent when an action occurs.
\end_layout

\begin_layout Standard
While suitable for some domains, there are clearly many realistic multi-agent
 domains that do not meet this limitation.
 An alternate formulation from 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset

 assumes the opposite extreme, that agents are only aware of the actions
 that they themselves perform:
\begin_inset Formula \begin{multline}
K(agt,s'',do(c,s))\equiv\\
\exists s',s^{*},c'\,\, s''=do(c',s^{*})\,\wedge K(s',s)\wedge Poss(c',s^{*})\\
\wedge\,\mathbf{ExoOnly}(agt,s',s^{*})\\
\wedge\,\forall a\left[agent(a)=agt\rightarrow a\in c'\equiv a\in c\right]\\
\wedge\,\forall a\in c\left[agent(a)=agt\rightarrow SR(a,s)=SR(a,s')\right]\label{eqn:k_ssa_exo}\end{multline}

\end_inset

 Where the macro 
\begin_inset Formula $\mathbf{ExoOnly}$
\end_inset

 indicates that two situations are connected only by actions performed by
 other agents:
\begin_inset Formula \begin{multline*}
\mathbf{ExoOnly}(agt,s,s'')\,\,\isdef\,\, s\leq s''\wedge\\
\forall s',c,a\left[s<do(c,s')\leq s''\wedge a\in c\rightarrow agent(a)\neq agt\right]\end{multline*}

\end_inset

 Here agents consider possible any situation compatible with the actions
 that they themselves have performed.
 There may have been an arbitrary sequence of situations between 
\begin_inset Formula $s'$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

 of which the agent was unaware, because they consisted entirely of exogenous
 actions.
\end_layout

\begin_layout Standard
This approach is also limiting, in that agents can 
\emph on
never
\emph default
 be aware of the actions performed by others.
 Consider agents occupying a house who are aware of actions performed by
 others in the same room, or even the simple case of an agent being aware
 that another agent has collided with it - full generality requires that
 agents can be aware of 
\emph on
some
\emph default
 of the actions performed by others.
\end_layout

\begin_layout Standard
Furthermore, suppose that 
\begin_inset Formula $agt$
\end_inset

 has just performed action 
\begin_inset Formula $a_{1}$
\end_inset

, so the world is in some situation 
\begin_inset Formula $do(a_{1},s)$
\end_inset

.
 Another agent then performs the action 
\begin_inset Formula $a_{2}$
\end_inset

, leaving the world in situation 
\begin_inset Formula $do(a_{2},do(a_{1},s))$
\end_inset

.
 Since it is not aware of the occurrence of 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $agt$
\end_inset

 cannot be aware that the state of the world has changed.
 Its state of knowledge should also remain unchanged.
 Unfortunately this is not the case: 
\begin_inset Formula $K(agt,s',do(a_{2},do(a_{1},s)))\not\equiv K(agt,s',do(a_{1},s))$
\end_inset

 under this formulation.
 To faithfully represent this aspect of the knowledge of real-world agents,
 the successor state axiom for 
\begin_inset Formula $K$
\end_inset

 must permit any 
\emph on
future
\emph default
 of 
\begin_inset Formula $do(a_{1},s)$
\end_inset

 that can be brought about by exogenous actions, rather than any 
\emph on
past
\emph default
 as done above.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 The principle tool is the regression meta-operator 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

, a syntactic manipulation whose behavior can be summarized
\begin_inset Foot
status collapsed

\begin_layout Standard
The full behavior of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 is beyond the scope of this paper.
 See 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

 for a detailed development of regression for handling knowledge.
 Since any formula uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

 is by definition single-step regressable, the development below omits the
 traditional qualification that formulae must be regressable.
\end_layout

\end_inset

 for our purposes as follows: it transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

 into a formula 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}(\phi)$
\end_inset

 that is uniform in 
\begin_inset Formula $s$
\end_inset

 and is equivalent to 
\begin_inset Formula $\phi$
\end_inset

 under the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\,\models\,\phi\equiv\mathcal{R}_{\mathcal{D}}(\phi)\]

\end_inset


\end_layout

\begin_layout Standard
It also replaces action description predicates such as 
\begin_inset Formula $Poss$
\end_inset

 with their appropriate definitions.
 If 
\begin_inset Formula $\phi$
\end_inset

 refers to a situation that is rooted at 
\begin_inset Formula $S_{0}$
\end_inset

, repeated applications of the regression operator (denoted by 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}$
\end_inset

) can transform it into an equivalent formula uniform in the initial situation.
 The successor state and action precondition axioms are 
\begin_inset Quotes eld
\end_inset

compiled into
\begin_inset Quotes erd
\end_inset

 the regressed formula, and so are not required for answering the regressed
 query: 
\begin_inset Formula \[
\mathcal{D}\models\phi[do(c_{n},do(c_{n-1},\dots,do(c_{1},S_{0}))]\equiv\mathcal{R}_{\mathcal{D}}^{*}(\phi)[S_{0}]\]

\end_inset

The trade-off is that the length of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}(\phi)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

, the regression operator is extended to handle the standard account of
 knowledge in equation (
\begin_inset LatexCommand \ref{eqn:k_ssa_standard}

\end_inset

) by reducing reasoning about formulae containing the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro to modal reasoning over the 
\begin_inset Formula $K$
\end_inset

 relation in the initial situation.
 Regressing such formulae relies on the fact that agents are aware of all
 actions.
 Formulae containing quantification over situations, such as the modified
 dynamics of knowledge in equation (
\begin_inset LatexCommand \ref{eqn:k_ssa_exo}

\end_inset

), cannot be regressed.
 Indeed, 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset

 offer no procedure for reasoning in their formalism other than using second-ord
er induction.
 We believe this to be the main reason for the near-ubiquity of the assumption
 of total awareness of actions.
\end_layout

\begin_layout Section
New Semantics of Knowledge
\begin_inset LatexCommand \label{sec:New-Semantics}

\end_inset


\end_layout

\begin_layout Subsection
Observations
\end_layout

\begin_layout Standard
Existing situation calculus accounts of knowledge all employ an assumption
 about when an agent is aware of an action occurring - either 
\begin_inset Quotes eld
\end_inset

agents are always aware of actions
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

agents are only aware of actions that they perform
\begin_inset Quotes erd
\end_inset

.
 A more general formalism requires a robust account of this notion of 
\begin_inset Quotes eld
\end_inset

awareness
\begin_inset Quotes erd
\end_inset

.
 To achieve this we introduce a distinction between 
\emph on
actions
\emph default
, which cause changes to the state of the world, and 
\emph on
observations
\emph default
, which cause an agent to become 
\emph on
aware
\emph default
 of some change in the state of the world.
\end_layout

\begin_layout Standard
Definition: An 
\emph on
observation
\emph default
 is a notification received by an agent that makes it aware of some change
 in the state of the world.
 When an agent receives such a notification 
\begin_inset Formula $o$
\end_inset

, we say the agent 
\begin_inset Quotes eld
\end_inset

observed 
\begin_inset Formula $o$
\end_inset


\begin_inset Quotes erd
\end_inset

 or that 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $o$
\end_inset

 was observed/perceived by
\begin_inset Quotes erd
\end_inset

 the agent.
\end_layout

\begin_layout Standard
How are these notifications generated? How are they delivered to the agent?
 As with the work of 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

, we abdicate responsibility for generating this 
\begin_inset Quotes eld
\end_inset

awareness
\begin_inset Quotes erd
\end_inset

 to some lower-level component of the agent's control software.
\end_layout

\begin_layout Standard
There are, quite intentionally, strong parallels between actions and observation
s.
 An action causes the state of the world to change, and an agent may observe
 that change, which changes the mental state of the agent.
 For simplicity, we assume that observations are received by an agent at
 the same instant as the action causing them is performed.
\end_layout

\begin_layout Standard
For the moment, let us introduce an additional sort 
\emph on
Observations
\emph default
 to the language of the situation calculus without any particular commitment
 towards what that sort may contain.
 We then introduce the function 
\begin_inset Formula $Observations(agt,c,s)=o$
\end_inset

, returning a set of individual observations, to mean 
\begin_inset Quotes eld
\end_inset

when the actions 
\begin_inset Formula $c$
\end_inset

 are performed in situation 
\begin_inset Formula $s$
\end_inset

, agent 
\begin_inset Formula $agt$
\end_inset

 will make the observations 
\begin_inset Formula $o$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
With a concrete notion of observations in place, the concept of an 
\emph on
Observation History
\emph default
 follows naturally - it is a sequence of all the observations made by an
 agent as the world has evolved.
 We introduce another sort consisting of sequences of observations, with
 
\begin_inset Formula $\epsilon$
\end_inset

 being the empty sequence, and the fluent 
\begin_inset Formula $ObsHist$
\end_inset

 giving the observation history associated with a particular situation:
 
\begin_inset Formula \begin{multline}
Init(s)\rightarrow ObsHist(agt,s)=\epsilon\\
\shoveleft{ObsHist(agt,do(c,s))=h\equiv}\\
\,\,\,\,\exists o\,.\, Observations(agt,c,s)=o\,\wedge\\
\shoveleft{\,\,\,\,\left(o=\{\}\rightarrow h=ObsHist(agt,s)\right)\,\wedge}\\
\left(o\neq\{\}\rightarrow h=o\cdot ObsHist(agt,s)\right)\label{eqn:obshist_defn}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
An observation history is the agent-internal analogue of a situation - while
 a situation is a global history of all the actions that have occured, an
 observation history is a local history of all the observations an agent
 has perceived.
 Let us then see how these notions can be used to generalize the standard
 account of knowledge.
\end_layout

\begin_layout Subsection
Axiomatising Observations
\end_layout

\begin_layout Standard
Let us begin by re-casting the standard account of knowledge in terms of
 observations.
 Its basic assumption that 
\begin_inset Quotes eld
\end_inset

all agents are aware of all actions
\begin_inset Quotes erd
\end_inset

 may be rephrased as 
\begin_inset Quotes eld
\end_inset

when an action occurs, all agents will observe that action
\begin_inset Quotes erd
\end_inset

.
 Allowing the 
\emph on
Observations
\emph default
 sort to contain 
\emph on
Action
\emph default
 terms, this assumption is akin to the following assertion about the 
\begin_inset Formula $Observations()$
\end_inset

 function:
\begin_inset Formula \[
a\in Observations(agt,c,s)\equiv a\in c\]

\end_inset


\end_layout

\begin_layout Standard
What about sensing information? We can extend the 
\emph on
Observations
\emph default
 sort to contain terms of the form 
\emph on

\begin_inset Formula $(Action=Result)$
\end_inset

 
\emph default
and axiomatize like so:
\begin_inset Formula \begin{multline*}
(a=r)\in Observations(agt,c,s)\equiv\\
a\in c\wedge SR(a,s)=r\wedge agent(a)=agt\end{multline*}

\end_inset

To generalize this to handle partial observaility of actions we introduce
 a new action description predicate, akin to 
\begin_inset Formula $Poss$
\end_inset

 but describing when actions will be observed by agents: 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 indicates that agent 
\begin_inset Formula $agt$
\end_inset

 would observe action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 We can then formulate the 
\begin_inset Formula $Observations()$
\end_inset

 function according to:
\begin_inset Formula \[
a\in Observations(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
There is another related assumption in the standard handling of sensing
 actions: only the agent performing a sensing action is aware of its result.
 Such a restriction is common but certainly not universal: if an agent waiting
 for a train activates a speaker to determine when it will arrive, the result
 of this sensing action would be available to any other agent within earshot.
 We add an analogous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 to indicate when sensing information is available to an agent.
 We then include bare action terms in an agent's observations when it observes
 the action but not its result, and 
\emph on
(Action=Result)
\emph default
 terms when it also senses the result:
\begin_inset Formula \begin{multline*}
a\in Observations(agt,c,s)\equiv a\in c\\
CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\end{multline*}

\end_inset


\begin_inset Formula \begin{multline*}
(a=r)\in Observations(agt,c,s)\equiv a\in c\\
SR(a,s)=r\wedge CanObs(agt,a,s)\wedge CanSense(agt,a,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Like their counterpart 
\begin_inset Formula $Poss$
\end_inset

, 
\begin_inset Formula $CanObs$
\end_inset

 and 
\begin_inset Formula $CanSense$
\end_inset

 may suffer from interaction problems when concurrent actions are considered
 - for example, one action may alter the observability of another if performed
 concurrently.
 This is an instance of the precondition interaction problem 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

, which can be addressed by several techniques that are outside the scope
 of this paper.
\end_layout

\begin_layout Subsection
Knowledge and Observation
\end_layout

\begin_layout Standard
In general, an agent's knowledge at any particular time must depend solely
 on its local history: the knowledge that it started out with combined with
 the observations it as made since then 
\begin_inset LatexCommand \cite{halpern90knowledge_distrib}

\end_inset

.
 Given an explicit account of the observations made by each agent, the required
 semantics of the 
\begin_inset Formula $K$
\end_inset

 relation are clear - 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 must hold whenever situations 
\begin_inset Formula $s'$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 would result in the same observation history for the agent:
\begin_inset Formula \begin{multline*}
\mathcal{D}\models K(agt,s',s)\equiv K(Root(s'),Root(s))\\
\wedge ObsHist(agt,s')=ObsHist(agt,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
While a wonderfully succinct definition of how knowledge should behave,
 this formulation cannot be directly inserted into a basic action theory.
 Instead, we must formulate a sucessor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent which enforces the above relationship.
\end_layout

\begin_layout Standard
For notational convenience, let us first introduce an action description
 predicate 
\begin_inset Formula $PossUnobs(agt,c,s)$
\end_inset

 indicating that the actions 
\begin_inset Formula $c$
\end_inset

 are possible in 
\begin_inset Formula $s$
\end_inset

, but no observations will be made by the agent 
\begin_inset Formula $agt$
\end_inset

 if they are performed:
\begin_inset Formula \begin{multline*}
PossUnobs(agt,c,s)\equiv Poss(c,s)\\
\wedge Observations(agt,c,s)=\{\}\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Using the generalised situation ordering of 
\begin_inset LatexCommand \cite{kelly07sc_persistence}

\end_inset

, we can then easily express the fact that an agent would make no observations
 were the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

:
\begin_inset Formula \[
s\leq_{PossUnobs(agt)}s'\]

\end_inset


\end_layout

\begin_layout Standard
If the agent considers possible a situation 
\begin_inset Formula $s$
\end_inset

 then it must also consider possible any legal situation 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $s\leq_{PossUnobs(agt)}s'$
\end_inset

.
 The following successor state axiom then captures the desired semantics
 of knowledge: 
\begin_inset Formula \begin{multline}
K(agt,s'',do(c,s))\equiv\\
Observations(agt,c,s)=\{\}\wedge K(agt,s'',s)\\
\shoveleft{\vee\,\,\exists c',s'\,\, Observations(agt,c,s)\neq\{\}\,\wedge}\\
Observations(agt,c',s')=Observations(agt,c,s)\,\wedge\\
K(agt,s',s)\wedge do(c',s')\leq_{PossUnobs(agt)}s'')\label{eqn:new_k_ssa}\end{multline}

\end_inset

 If 
\begin_inset Formula $c$
\end_inset

 was totally unobservable, the agent's state of knowledge does not change.
 Otherwise, it considers possible any legal successor to a possible situation
 that can be brought about by actions 
\begin_inset Formula $c'$
\end_inset

 resulting in identical observations.
 It also considers possible any unobservable future of such a situation.
\end_layout

\begin_layout Standard
It remains to specify 
\begin_inset Formula $K$
\end_inset

 in the initial situation.
 Since situations where 
\begin_inset Formula $S_{0}\leq_{UnObs(agt)}s$
\end_inset

 holds must be 
\begin_inset Formula $K$
\end_inset

-related to 
\begin_inset Formula $S_{0}$
\end_inset

, we introduce another relation 
\begin_inset Formula $K_{0}$
\end_inset

 to specify each agent's initial knowledge: 
\begin_inset Formula \begin{multline}
K_{0}(s',s)\rightarrow Init(s')\wedge Init(s)\\
\shoveleft{Init(s)\rightarrow K(agt,s'',s)\equiv}\\
\exists s'\,.\,\left[K_{0}(agt,s',s)\wedge s'\leq_{PossUnobs(agt)}s'')\right]\label{eqn:new_k_s0}\end{multline}

\end_inset

 These definitions are enough to ensure that knowledge behaves as we require:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset

 
\begin_inset LatexCommand \label{thm:k_obs_equiv}

\end_inset

 For any basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

 that includes our new semantics of knowledge, any agent 
\begin_inset Formula $agt$
\end_inset

 and legal situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

: 
\begin_inset Formula \begin{multline*}
\mathcal{D}\models K(agt,s',s)\equiv K_{0}(Root(s'),Root(s))\\
\wedge ObsHist(agt,s')=ObsHist(agt,s)\end{multline*}

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{theorem}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{proof}
\end_layout

\end_inset

Straightforward.
 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using this new formulation, an agent's knowledge is completly decoupled
 from the global notion of actions, instead depending only on the local
 information that it has observed.
 It remains to specify precisely what the 
\emph on
Observations 
\emph default
sort contains, and how the 
\begin_inset Formula $Observations()$
\end_inset

 function behaves.
\end_layout

\begin_layout Subsection
Observing Action Effects
\end_layout

\begin_layout Standard
In many domains it would be infeasible for an agent to observe a particular
 action occurring, but it may be able to observe some of the effects of
 that action.
 For example, suppose that an agent monitors the state of a light in its
 environment, such that it notices it changing from dark to light.
 While it knows that 
\emph on
some
\emph default
 action must have occurred to produce that effect, it may not be sure precisely
 what action took place (e.g.
 precisely 
\emph on
who
\emph default
 turned off the light).
\end_layout

\begin_layout Standard
This can be modeled by further extending the 
\emph on
Observations
\emph default
 sort to contain reified fluents in the style of [TODO].
\begin_inset Formula \begin{multline*}
f\in Observations(agt,c,s)\equiv Monitoring(agt,f,s)\\
\wedge\neg holds(f,s)\wedge holds(f,do(c,s))\end{multline*}

\end_inset


\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Poss(pickup(agt,box),s)\equiv\neg\exists x\,.\, Holding(x,box,s)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
Poss(drop(agt,box),s)\equiv Holding(agt,box,s)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
Poss(goToRoom(agt,room),s)\equiv true\]

\end_inset


\begin_inset Formula \begin{multline*}
Holding(agt,box,do(c,s))\equiv pickup(agt,box)\in c\,\vee\\
Holding(agt,box,s)\wedge drop(agt,box)\not\in c\end{multline*}

\end_inset


\begin_inset Formula \begin{multline*}
InRoom(obj,room,do(c,s))\equiv\exists agt\,.\, goToRoom(agt,room)\in c\wedge\\
\left[obj=agt\vee Holding(agt,obj,s)\right]\,\,\vee\\
InRoom(obj,room,s)\wedge\neg\left(\exists agt,r2\,.\, goToRoom(agt,r2)\in c\wedge\right.\\
\left.r2\neq room\wedge\left[obj=agt\vee Holding(agt,obj,s)\right]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
CanObs(agt,a,s)\equiv\exists room\,.\, InRoom(agt,room)\wedge InRoom(agent(a),room)\]

\end_inset


\begin_inset Formula \[
CanSense(agt,a,s)\equiv false\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\neg Holding(agt,box,S_{0})\]

\end_inset


\begin_inset Formula \[
InRoom(Richard,Room1,S_{0})\]

\end_inset


\begin_inset Formula \[
InRoom(Box1,Room1,S_{0})\]

\end_inset


\begin_inset Formula \[
InRoom(Harriet,Room2,S_{0})\]

\end_inset


\begin_inset Formula \[
InRoom(Box2,Room2,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
The following are consequences:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathbf{Knows}(Richard,\neg Holding(Harriet,Box1),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathbf{\neg Knows}(Richard,\neg Holding(Harriet,Box2),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(Richard,Holding(Harriet,Box1),\\
do(\{ pickup(Harriet,Box1)\},do(\{ goToRoom(Harriet,Room1)\},S_{0})))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\mathbf{\neg Knows}(Richard,Holding(Harriet,Box1),\\
do(\{ goToRoom(Harriet,Room2)\},do(\{ pickup(Harriet,Box1)\},\\
do(\{ goToRoom(Harriet,Room1)\},S_{0}))))\end{multline*}

\end_inset


\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The appearance of the 
\begin_inset Formula $\leq_{PossUnobs(agt)}$
\end_inset

 ordering over situations in equation (
\begin_inset LatexCommand \ref{eqn:new_k_ssa}

\end_inset

) means that our new successor state axiom universally quantifies over situation
s.
 As for the total-ignorance semantics of 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset

, this means that standard regression techniques cannot be applied.
 To permit an effective reasoning procedure, we appeal to the 
\emph on
persistence condition
\emph default
 meta-operator 
\begin_inset LatexCommand \cite{kelly07sc_persistence}

\end_inset

.
 The persistence condition transforms a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

 into a uniform formula 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}(\phi,\alpha)$
\end_inset

 such that 
\begin_inset Formula $\phi$
\end_inset

 will persist if all future actions satisfy 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P}_{\mathcal{D}}(\phi,\alpha)[s]\equiv\forall s'\,.\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
The procedure for determining 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 replaces second-order induction with iterated first-order reasoning.
 It also requires that there be only finitely many types of action, an assumptio
n met by most realistic domains.
\end_layout

\begin_layout Standard
By applying it to the action description predicate 
\begin_inset Formula $PossUnobs(agt)$
\end_inset

, the persistence condition can be used to augment the existing techniques
 for regressing knowledge queries developed in 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

.
\end_layout

\begin_layout Standard
Assuming that the knowledge fluent 
\begin_inset Formula $K$
\end_inset

 appears only in the context of a 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, we propose the following to replace the existing regression clause
 for 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

:
\begin_inset Formula \begin{multline}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,do(c,s)))=\\
\left[Observations(agt,c,s)=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
\wedge\,\left[Observations(agt,c,s)\neq\{\}\rightarrow\right.\\
\mathbf{Knows}(agt,\forall c'\, Observations(agt,c',now)=o\rightarrow\\
\left.\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,PossUnobs(agt))[do(c',now)]),s)\right]\label{eqn:R_do_c_s}\end{multline}

\end_inset

 As required, this reduces reasoning about knowledge in 
\begin_inset Formula $do(c,s)$
\end_inset

 to reasoning about knowledge in 
\begin_inset Formula $s$
\end_inset

.
 It is also intuitively appealing: to know that 
\begin_inset Formula $\phi$
\end_inset

 holds, the agent must know that in all situations that agree with its observati
ons, 
\begin_inset Formula $\phi$
\end_inset

 cannot become false without it noticing that an action has occurred.
 We must also specify the regression of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 in the initial situation, as equation (
\begin_inset LatexCommand \ref{eqn:new_k_s0}

\end_inset

) also quantifies over situations.
 This clause results in standard first-order modal reasoning over the 
\begin_inset Formula $K_{0}$
\end_inset

 relation, as required: 
\begin_inset Formula \begin{multline}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,S_{0}))=\\
\forall s\, K_{0}(agt,s)\rightarrow\mathcal{P}_{\mathcal{D}}(\phi,PossUnobs(agt))[s]\label{eqn:R_s0}\end{multline}

\end_inset

 Regression of the additional predicates we have introduced (
\begin_inset Formula $CanObs$
\end_inset

, 
\begin_inset Formula $Observations$
\end_inset

, etc) is identical to that of 
\begin_inset Formula $Poss$
\end_inset

 and requires no special treatment here, except to mention that the restriction
 to a finite number of actions allows regression of such formulae even when
 their arguments are variables.
\end_layout

\begin_layout Standard
We briefly sketch the highlights of a proof that our modified regression
 operator in equations (
\begin_inset LatexCommand \ref{eqn:R_do_c_s}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:R_s0}

\end_inset

) preserves equivalence.
 It proceeds by expanding the definition for 
\begin_inset Formula $\mathbf{Knows}(agt,\phi,do(c,s))$
\end_inset

 using our new successor state axiom for 
\begin_inset Formula $K$
\end_inset

, collecting sub-formulae that match the form of the 
\begin_inset Formula $\mathbf{Knows}(agt,\psi,s)$
\end_inset

 macro, and using regression and persistence to render the resulting knowledge
 expression 
\begin_inset Formula $\psi$
\end_inset

 uniform in 
\begin_inset Formula $s$
\end_inset

.
 A straightforward expansion of 
\begin_inset Formula $\mathbf{Knows}(agt,\phi,S_{0})$
\end_inset

 using the persistence operator completes the proof.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset

 Given a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and a ground situation term 
\begin_inset Formula $s$
\end_inset

, it is always the case that: 
\begin_inset Formula \[
\mathcal{D}\models\phi[s]\equiv\mathcal{R}_{\mathcal{D}}(\phi)[S_{0}]\]

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{theorem}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We need only consider applications of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 has the form 
\begin_inset Formula $\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as other regression clauses have not been modified.
 For clarity we define the abbreviation 
\begin_inset Formula $\mathbf{PK}(agt,\phi,o,s)$
\end_inset

 as the following, which states that 
\begin_inset Formula $\phi$
\end_inset

 holds in all futures of 
\begin_inset Formula $s$
\end_inset

 compatible with the observations 
\begin_inset Formula $o$
\end_inset

:
\begin_inset Formula \begin{multline*}
\mathbf{PK}(agt,\phi,o,s)\,\isdef\,\forall c\,.Observations(agt,c,s)=o\rightarrow\\
\left[\forall s'\,.\, do(c,s)\leq_{PossUnobs(agt)}s'\rightarrow\,\phi[s']\right]\end{multline*}

\end_inset

 Combining and rearranging equations (
\begin_inset LatexCommand \ref{eqn:knows_def}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:new_k_ssa}

\end_inset

), the definition of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 can be written in the form: 
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\\
\left[Observations(agt,c,s)=\{\}\rightarrow\forall s'K(agt,s',s)\rightarrow\phi[s']\right]\\
\shoveleft{\wedge\left[Observations(agt,c,s)\neq\{\}\rightarrow\right.}\\
\left.\forall s'\, K(agt,s',s)\rightarrow\mathbf{PK}(agt,\phi,Observations(agt,c,s),s')\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Noting that both conjuncts contain sub-formulae matching the form of the
 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, it can be substituted back in to give:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\\
\left[Observations(agt,c,s)=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
\shoveleft{\wedge\left[Observations(agt,c,s)\neq\{\}\rightarrow\right.}\\
\left.\mathbf{Knows}(agt,\mathbf{PK}(agt,\phi,Observations(agt,c,s),s')),s)\right]\end{multline*}

\end_inset

 For 
\begin_inset Formula $\mathbf{PK}(agt,\phi,o,s')$
\end_inset

 to legitimately appear inside the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro it must be uniform in the situation variable 
\begin_inset Formula $s'$
\end_inset

.
 Applying the persistence condition by noting that equation (
\begin_inset LatexCommand \ref{eqn:unobs_defn}

\end_inset

) matches the form of equation (
\begin_inset LatexCommand \ref{eqn:P_defn}

\end_inset

), and regressing to make the expression uniform, we develop the following
 equivalence as required:
\begin_inset Formula \begin{multline*}
\mathbf{PK}(agt,\phi,o,s)\equiv\forall c\, Observations(agt,c,s)=o\rightarrow\\
\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,PossUnobs(agt))[do(c',s')])\end{multline*}

\end_inset

 For 
\begin_inset Formula $S_{0}$
\end_inset

, a straightforward transformation of equations (
\begin_inset LatexCommand \ref{eqn:knows_def}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:new_k_s0}

\end_inset

) gives:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(\phi,S_{0})\equiv\forall s\, K_{0}(agt,s)\rightarrow\\
\{\forall s'\,.\, s\leq_{PossUnobs(agt)}s'\rightarrow\phi[s']\}\end{multline*}

\end_inset

 Applying the persistence condition operator, this can easily be re-written
 in the required form:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(\phi,S_{0})\equiv\forall s\, K_{0}(agt,s)\rightarrow\\
\mathcal{P}_{\mathcal{D}}(\phi,PossUnobs(agt))[s]\end{multline*}

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our extension of the regression operator thus provides an effective procedure
 for automated reasoning with our improved account of knowledge.
\end_layout

\begin_layout Subsection
Reasoning from Observations
\end_layout

\begin_layout Standard
While this reasoning method is suitable for modeling and simulation purposes,
 it would be unreasonable for a situated agent to ask 
\begin_inset Quotes eld
\end_inset

do I know 
\begin_inset Formula $\phi$
\end_inset

 in the current situation?
\begin_inset Quotes erd
\end_inset

 using the situation calculus query 
\begin_inset Formula $\mathcal{D}\models\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as it cannot be expected to have the full current situation 
\begin_inset Formula $s$
\end_inset

.
 However, it will have its current observation history 
\begin_inset Formula $h$
\end_inset

.
 We therefore define knowledge with respect to an observation history as
 follows:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,h)\,\isdef\\
\forall s\, ObsHist(agt,h,s)\wedge Root(s)=S_{0}\rightarrow\mathbf{Knows}(agt,\phi,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset

 Given a theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

 including our semantics for knowledge, a situation term 
\begin_inset Formula $s$
\end_inset

 rooted at 
\begin_inset Formula $S_{0}$
\end_inset

, and an observation history 
\begin_inset Formula $h$
\end_inset

 such that 
\begin_inset Formula $ObsHist(agt,h,s)$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\mathbf{Knows}(agt,\phi,s)\equiv\mathbf{Knows}(agt,\phi,h)\]

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{theorem}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Straightforward consequence of theorem 
\begin_inset LatexCommand \ref{thm:k_obs_equiv}

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Extending the regression clauses in equations (
\begin_inset LatexCommand \ref{eqn:R_do_c_s}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:R_s0}

\end_inset

) to handle formulae of this form is actually simpler than for regression
 over situations, as there are no empty observations in a history: 
\begin_inset Formula \begin{multline*}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,o\cdot h))=\\
\mathbf{Knows}(agt,\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,\mathbf{UA}(agt))[do(c',s')]),h)\end{multline*}

\end_inset

 
\begin_inset Formula \begin{multline*}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,\epsilon))=\\
\forall s\, K_{0}(agt,s)\rightarrow\mathcal{P}_{\mathcal{D}}(\phi,\mathbf{UA}(agt))[s]\end{multline*}

\end_inset

 Using this, agents can reason about their own knowledge using only their
 local information.
 Our work thus makes it possible to include a situation calculus model in
 the implementation of a real-world multi-agent system, even when agents
 have only partial awareness of the actions being performed.
\end_layout

\begin_layout Subsection
Knowledge or Belief?
\end_layout

\begin_layout Standard
We note at this point that we are interested in a logic of 
\emph on
knowledge
\emph default
 - everything known by an agent must actually be true in the world.
 There has also been significant work on 
\emph on
belief
\emph default
 in the situation calculus 
\begin_inset LatexCommand \cite{shapiro00sc_belief}

\end_inset

, where agents may be mistaken about the state of the world.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{shapiro04sc_belief_exog}

\end_inset

 show how agents may hypothesize the occurrence of exogenous actions when
 they discover that their beliefs are wrong, neatly avoiding the issue of
 being aware of actions performed by others.
 This approach cannot be applied when dealing with knowledge.
 However, we believe that the concrete notion of observations we develop
 below will also be useful for belief-based systems.
\end_layout

\begin_layout Standard
TODO: expand this section
\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand \label{sec:Conclusions}

\end_inset


\end_layout

\begin_layout Standard
In this paper we have significantly increased the scope of the situation
 calculus for modeling knowledge in complex domains, where there may be
 multiple agents and partial observability of actions.
 By explicitly reifying the observations made by each agent as the world
 evolves, we have generalized the dynamics of knowledge update.
 We have shown that this can accommodate the important case where agents
 are aware that a property of their environment has changed, but do not
 know the precise actions responsible.
 Despite requiring universal quantification over future situations, we have
 shown that the regression operator can be adapted to allow effective reasoning
 within our new formalism.
 It can also be used to reason from the internal perspective of a single
 agent.
\end_layout

\begin_layout Standard
With our new semantics of knowledge, the situation calculus is well positioned
 for representing, reasoning about, and implementing more complex, realistic
 agent systems.
\end_layout

\begin_layout Standard
TODO: refrence 
\begin_inset LatexCommand \cite{demolombe00tractable_sc_belief}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[abbrv]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
