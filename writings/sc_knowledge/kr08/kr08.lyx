#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass tech-article
\begin_preamble
\usepackage{aaai}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage{tikz}
\usepackage{amsthm}
\nocopyright
\end_preamble
\options letterpaper
\language british
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Complex Epistemic Modalities in the Situation Calculus
\end_layout

\begin_layout Author
Ryan F.
 Kelly and Adrian R.
 Pearce
\newline
NICTA Victoria Laboratory
\newline
 Department of Computer Science and Software
 Engineering
\newline
 The University of Melbourne
\newline
 Victoria, 3010, Australia
\newline
 {rfk,adrian}@
csse.unimelb.edu.au
\end_layout

\begin_layout Abstract
We develop a formal account of complex group-level epistemic modalities
 in the situation calculus, with a particular focus on reasoning about common
 knowledge.
 Expressions involving common knowledge cannot be handled by standard regression
 techniques and are thus difficult to reason about effectively.
 Taking our cue from recent promising work in dynamic epistemic logic, we
 overcome this limitation by increasing the expressive power of the epistemic
 language.
 The syntax of first-order dynamic logic is used to form complex epistemic
 modalities from the individual-level knowledge operators.
 Common knowledge is a special case of this syntax, using the unbounded
 iteration operator.
 We develop a regression rule for these complex modalities and demonstrate
 its use to reason about common knowledge in an example domain.
 The result is a rich multi-agent theory of knowledge and action in which
 complex group-level epistemic modalities are amenable to effective automated
 reasoning.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isdef}{\stackrel{\mbox{\tiny def}}{=}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Dt}{\mathcal{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Reg}{\mathcal{R}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Trn}{\mathcal{T}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Kln}{\mathcal{K}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\TrnA}{\Trn_{a}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EKnows}{\mathbf{EKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Knows}{\mathbf{Knows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\CKnows}{\mathbf{CKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PKnows}{\mathbf{PKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KTrans}{\mathbf{KDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KDo}{\mathbf{KDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EDo}{\mathbf{EDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\vars}[1]{\bar{#1}}
\end_inset

In their landmark paper 
\emph on
Knowledge, Action, and the Frame Problem,
\emph default
 Scherl and Levesque (2003) adapt Reiter's solution to the frame problem
 in the situation calculus to allow reasoning about the knowledge of an
 agent using regression 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

.
 Extensions to concurrent actions 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

, multiple agents 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

, and partial observability of actions 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

 have produced an expressive logic of knowledge and action that is amenable
 to standard effective reasoning techniques of the situation calculus.
\end_layout

\begin_layout Standard
While powerful, the existing account has a shortcoming that limits its utility
 in multi-agent domains: it lacks a formal treatment of group-level epistemic
 modalities.
 Simple group-level modalities such as 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 can be expressed as finite combinations of individual-level knowledge operators
, but more complex modalities such as 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 cannot be handled in this way.
\end_layout

\begin_layout Standard
Common knowledge is typically introduced to the situation calculus as a
 separate axiom 
\begin_inset LatexCommand cite
key "davis05fo_ma_theory,ghaderi07sc_joint_ability"

\end_inset

.
 While logically sound, this approach means regression can no longer be
 used for effective automated reasoning.
 Our work offers a new approach that combines a rich group-level epistemic
 language with a regression rule for effective reasoning.
\end_layout

\begin_layout Standard
To achieve this we must overcome a fundamental expressivity limitation,
 as the regression of common knowledge cannot be expressed in terms of common
 knowledge alone 
\begin_inset LatexCommand citep
key "baltag98pa_ck"

\end_inset

.
 We take our cue from recent promising work in the related field of dynamic
 epistemic logic, with the main idea due to van Bentham, van Eijck and Kooi
 (2006): increase the expressive power of the epistemic language so it is
 strong enough to formulate a proper regression rule.
 They have developed the Logic of Communication and Change (henceforth 
\begin_inset Quotes eld
\end_inset

LCC
\begin_inset Quotes erd
\end_inset

) using propositional dynamic logic to express epistemic modalities, and
 have shown that it allows reasoning about common knowledge using techniques
 akin to regression.
 We follow a similar approach in this paper and introduce complex epistemic
 modalities to the situation calculus.
 
\end_layout

\begin_layout Standard
While our development naturally parallels that of LCC, the richer ontology
 of the situation calculus also means there are substantial differences.
 Our formalism captures first-order effects, quantifying-in and de-dicto/de-re,
 and arbitrary sets of concurrent actions, while providing a regression
 rule for automated reasoning and integrating smoothly with existing techniques
 based on the situation calculus.
\end_layout

\begin_layout Standard
Following the tradition of 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

 we develop our formalism as a series of macro-expansions, with no changes
 to the underlying situation calculus theory.
 We adopt the language of first-order dynamic logic to construct complex
 epistemic paths.
 The macro 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 expresses knowledge using a path.
 Common knowledge between 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 can be expressed in this syntax using the iteration operator: 
\begin_inset Formula $\PKnows((A\cup B)^{*},\phi,s)$
\end_inset

.
 Regression is modified to treat 
\begin_inset Formula $\PKnows(\pi,\phi,do(c,s))$
\end_inset

 as a primitive fluent, producing an equivalent formula 
\begin_inset Formula $\PKnows(\Trn(\pi),\Reg(\phi),s)$
\end_inset

.
 This paper thus contributes a rich multi-agent theory of knowledge and
 action in which complex group-level epistemic modalities are amenable to
 effective automated reasoning.
\end_layout

\begin_layout Standard
The paper proceeds as follows: Sections 2-3 review the necessary background
 material; Section 4 adopts dynamic logic as an epistemic path language
 and defines the macro 
\begin_inset Formula $\PKnows$
\end_inset

; Section 5 shows how to regress 
\begin_inset Formula $\PKnows$
\end_inset

 expressions; Section 6 demonstrates the formalism in action by reasoning
 about common knowledge in an example domain; and Sections 7-8 complete
 the paper with related work, future work and conclusions.
\end_layout

\begin_layout Section
Background: The Situation Calculus
\end_layout

\begin_layout Standard
Our work utilises the situation calculus 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 with multiple agents 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "reiter96sc_nat_conc"

\end_inset

, and we build on the standard account of knowledge due to 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

.
 A brief overview is presented below
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 It has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change, with the initiating agent indicated by
 their first argument; 
\noun on
Concurrent
\noun default
 terms are sets of actions that occur simultaneously; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world; 
\noun on
Result
\noun default
 terms represent sensing results returned by actions; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\emph on
Fluents
\emph default
 are predicates or functions that represent properties of the world that
 may change between situations; they take a situation term as their final
 argument.
 An agent's 
\emph on
knowledge
\emph default
 is represented using the macro 
\begin_inset Formula $\Knows$
\end_inset

.
 We call the fluents that are directly affected by actions 
\emph on
primitive 
\emph default
fluents.
 Although defined as a macro, 
\begin_inset Formula $\Knows$
\end_inset

 is treated syntactically as a primitive fluent.
\end_layout

\begin_layout Standard
A 
\emph on
basic action theory
\emph default
 is a set 
\begin_inset Formula $\mathcal{D}$
\end_inset

 of situation calculus sentences (with a specific syntactic form as specified
 in 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

) that describes a particular dynamic world.
 Queries about the behaviour of the world are posed as logical entailment
 queries relative to this theory.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); successor state axioms describing how fluents change between situations
 (
\begin_inset Formula $\mathcal{D}_{ss}$
\end_inset

); precondition axioms indicating when actions can be performed (
\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

); unique names axioms ensuring that action terms are distinct (
\begin_inset Formula $\mathcal{D}_{una}$
\end_inset

); and axioms describing the value of fluents in the initial situation (
\begin_inset Formula $\mathcal{D}_{S_{0}}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{una}\cup\Dt_{ap}\cup\Dt_{ss}\cup\Dt_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
We assume a fixed 
\begin_inset Formula $\Dt$
\end_inset

 throughout the paper.
 There is a distinguished fluent predicate 
\begin_inset Formula $Poss(c,s)$
\end_inset

 indicating when it is possible to perform actions in a given situation.
 In simple domains it suffices to specify 
\begin_inset Formula $Poss(a,s)$
\end_inset

 for each individual action type, and define 
\begin_inset Formula $Poss(c,s)$
\end_inset

 by:
\begin_inset Formula \[
Poss(c,s)\equiv c\neq\{\}\,\wedge\,\forall a:\, a\in c\rightarrow Poss(a,s)\]

\end_inset


\end_layout

\begin_layout Standard
In more complex domains 
\emph on
precondition interaction
\emph default
 may be an issue, but techniques for handling this are well outside the
 scope of this paper; see 
\begin_inset LatexCommand citep
key "reiter96sc_nat_conc"

\end_inset

.
\end_layout

\begin_layout Standard
Situations give a branching-time account of the world, with initial situations
 identified by 
\begin_inset Formula $Init(s)$
\end_inset

 and the function 
\begin_inset Formula $do(c,s)$
\end_inset

 constructing successor situations by performing sets of concurrent actions.
 The special initial situation 
\begin_inset Formula $S_{0}$
\end_inset

 represents the 
\emph on
actual
\emph default
 initial state of the world, while other initial situations model incomplete
 knowledge of the initial state.
\end_layout

\begin_layout Standard
The 
\emph on
uniform formulae
\emph default
 as defined in 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

 can be thought of as 
\emph on
properties
\emph default
 of the state of the world.
 They are basically logical combinations of primitive fluents referring
 to a common situation term.
 The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout to refer to an arbitrary uniform formula.
 It is often useful to determine the truth of a uniform formula at an alternate
 situation term, and 
\begin_inset Formula $\phi[s]$
\end_inset

 represents 
\begin_inset Formula $\phi$
\end_inset

 with all occurrences of its unique situation term replaced by 
\begin_inset Formula $s$
\end_inset

.
 Where no confusion can arise, we suppress the situation terms in uniform
 formulae to simplify the presentation.
\end_layout

\begin_layout Standard
The truth of a fluent is completely specified by defining its truth in the
 initial situation, and collecting the effects of the various actions into
 
\emph on
successor state axioms
\emph default
.
 Such axioms provide a monotonic solution to the frame problem.
 They have the following general form, asserting the truth of a fluent 
\begin_inset Formula $F$
\end_inset

 in the successor situation 
\begin_inset Formula $do(c,s)$
\end_inset

 based on the current situation 
\begin_inset Formula $s$
\end_inset

 and the actions 
\begin_inset Formula $c$
\end_inset

 that were performed: 
\begin_inset Formula \[
F(\vars{x},do(c,s))\equiv\Phi(\overrightarrow{x},c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Effective reasoning in the situation calculus depends on the regression
 meta-operator 
\begin_inset Formula $\Reg_{\Dt}$
\end_inset

 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

, a syntactic manipulation whose behaviour can be summarised for our purposes
 as follows: it transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into a formula 
\begin_inset Formula $\Reg_{\Dt}(\phi)$
\end_inset

 that is uniform in 
\begin_inset Formula $s$
\end_inset

 and is equivalent to 
\begin_inset Formula $\phi$
\end_inset

 under the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\phi\equiv\Reg_{\Dt}(\phi)\]

\end_inset


\end_layout

\begin_layout Standard
Regression operates by replacing primitive fluents 
\begin_inset Formula $F(\vars{x},do(c,s))$
\end_inset

 with the body of the matching successor state axiom.
 It also replaces non-primitive fluents such as 
\begin_inset Formula $Poss$
\end_inset

 with their corresponding definitions.
 Since we assume a fixed action theory, we drop the 
\begin_inset Formula $\Dt$
\end_inset

 subscript throughout this paper.
 We also write 
\begin_inset Formula $\Reg(\phi,c)$
\end_inset

 for 
\begin_inset Formula $\Reg(\phi[do(c,s)])$
\end_inset

 where it simplifies the presentation.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\phi$
\end_inset

 refers to a situation that is rooted at 
\begin_inset Formula $S_{0}$
\end_inset

, repeated applications of the regression operator (denoted by 
\begin_inset Formula $\Reg^{*}$
\end_inset

) can transform it into an equivalent formula uniform in the initial situation.
 The successor state and action precondition axioms are 
\begin_inset Quotes eld
\end_inset

compiled in
\begin_inset Quotes erd
\end_inset

 to the formula and so are not required for answering the regressed query:
\begin_inset Formula \begin{gather*}
\Dt\models\phi[do(c_{n},do(c_{n-1},\dots,do(c_{1},S_{0}))]\\
\mathrm{iff}\\
\Dt_{una}\cup\Dt_{S_{0}}\models\Reg^{*}(\phi)[S_{0}]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The axioms 
\begin_inset Formula $\Dt_{una}\cup\Dt_{S_{0}}$
\end_inset

 are often in very simple forms or can be compiled to make reasoning more
 efficient.
 The trade-off is that the length of 
\begin_inset Formula $\Reg^{*}(\phi)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven very
 effective in practice.
\end_layout

\begin_layout Section
Background: Epistemic Reasoning
\end_layout

\begin_layout Standard
This section presents epistemic reasoning specifically in the context of
 the situation calculus; for a comprehensive treatment of the wider field
 see 
\begin_inset LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

.
 
\end_layout

\begin_layout Standard
Epistemic reasoning was first introduced to the situation calculus by 
\begin_inset LatexCommand citet
key "moore80know_act"

\end_inset

, and formalised extensively by 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

 whose paper is now the canonical reference for these techniques.
 It has been further extended to include concurrent actions 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

, multiple agents 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

 and partial observability of actions 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

.
 It is this family of techniques that we build upon in this paper.
\end_layout

\begin_layout Standard
The semantics of knowledge are based on a reification of the 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 semantics of modal logic, using situation terms rather than abstract worlds.
 A knowledge fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 The macro 
\begin_inset Formula $\Knows$
\end_inset

 is then defined as a shorthand for the standard possible-worlds definition
 of knowledge, stating that an agent knows something when it is true in
 all situations considered possible:
\begin_inset Formula \[
\Knows(agt,\phi,s)\isdef\forall s':\, K(agt,s',s)\rightarrow\phi[s']\]

\end_inset

 
\end_layout

\begin_layout Standard
The sensing result function 
\begin_inset Formula $SR(a,s)$
\end_inset

 gives the result returned by the action 
\begin_inset Formula $a$
\end_inset

 when executed in situation 
\begin_inset Formula $s$
\end_inset

, allowing additional information to be obtained at run-time.
 Partial observability of actions is accounted for by the function 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

, which specifies what information an agent perceives when actions are performed.
 A simple axiomatisation might have agents observe all actions performed,
 and all sensing results from their own actions:
\begin_inset Formula \begin{align*}
a\in Obs(agt,c,s)\,\equiv\,\, & a\in c\\
a\#r\,\in Obs(agt,c,s)\,\equiv\,\, & a\in c\,\wedge\, r=SR(a,s)\\
 & \wedge\, actor(a)=agt\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We assume that the domain is synchronised, so agents always know when
\emph on
 
\emph default
an action has occurred even if they are uncertain as to its precise details.
 The dynamics of knowledge are specified by a successor state axiom for
 
\begin_inset Formula $K$
\end_inset

:
\begin_inset Formula \begin{multline*}
K(agt,s'',do(c,s))\equiv\exists c',s':\, s''=do(c',s')\\
\shoveright{\wedge\, K(agt,s',s)\,\wedge\, Poss(c',s')}\\
\wedge\, Obs(agt,c',s')=Obs(agt,c,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
This axiom ensures that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(c,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing actions 
\begin_inset Formula $c'$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is considered a possible alternative to 
\begin_inset Formula $s$
\end_inset

, where 
\begin_inset Formula $c'$
\end_inset

 was possible and produced the same observations as 
\begin_inset Formula $c$
\end_inset

.
 Thus an agent's knowledge after the occurrence of an action is completely
 determined by the combination of its knowledge before the action, and the
 sensing results returned by the action.
 
\end_layout

\begin_layout Standard
An important result of 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 allows the regression operator to treat the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro syntactically, as if it were a primitive fluent.
 This makes epistemic queries amenable to the standard reasoning techniques
 of the situation calculus, by reducing them to epistemic queries about
 the initial situation only.
 The regression rule is:
\begin_inset Formula \begin{multline*}
\Reg(\Knows(agt,\phi,do(c,s)))\isdef\\
\exists y:\, y=Obs(agt,c,s)\,\wedge\,\Knows(agt,\\
\forall c':\Reg(Poss(c')\wedge Obs(agt,c')=y)\rightarrow\Reg(\phi,c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Note that regression must be able to replace 
\begin_inset Formula $Poss(c')$
\end_inset

 and 
\begin_inset Formula $Obs(agt,c')$
\end_inset

 with a finite combination of primitive fluents even when 
\begin_inset Formula $c'$
\end_inset

 is a variable.
 The simplest way to ensure this is by having finitely many action types.
\end_layout

\begin_layout Standard
Group-level epistemic modalities can now be defined in terms of individual-level
 knowledge.
 Let 
\begin_inset Formula $G$
\end_inset

 be a finite group of agents.
 The basic group-level modality is 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

, which is defined as:
\begin_inset Formula \[
\mathbf{EKnows}(G,\phi)\,\isdef\,\bigwedge_{agt\in G}\,\mathbf{Knows}(agt,\phi)\]

\end_inset


\end_layout

\begin_layout Standard
Since the definition is finite, 
\begin_inset Formula $\EKnows$
\end_inset

 can be handled in the situation calculus using simple macro-expansion.
 To assert more complete knowledge by members of the group, one can say
 
\begin_inset Quotes eld
\end_inset

everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 by nesting 
\begin_inset Formula $\mathbf{EKnows}$
\end_inset

 operators.
 In general:
\begin_inset Formula \begin{gather*}
\mathbf{EKnows}^{1}(G,\phi)\,\isdef\,\mathbf{EKnows}(G,\phi)\\
\mathbf{EKnows}^{n}(G,\phi)\,\isdef\,\mathbf{EKnows}(G,\mathbf{EKnows}^{n-1}(G,\phi))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The higher the value of 
\begin_inset Formula $n$
\end_inset

, the stronger an assertion is made about the knowledge of the group.
 The strongest group-level modality is 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

, meaning that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, and so on ad infinitum.
 Common knowledge is extremely powerful and has deep implications for coordinate
d group behaviour.
 For example, the impossibility of the famous 
\begin_inset Quotes eld
\end_inset

Coordinated Attack
\begin_inset Quotes erd
\end_inset

 problem rests on an inability to obtain common knowledge 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
 It can be defined variously via an infinite conjunction, a fixpoint or
 a transitive closure on 
\begin_inset Formula $\EKnows$
\end_inset

, e.g.:
\begin_inset Formula \[
\mathbf{CKnows}(G,\phi,s)\,\isdef\,\bigwedge_{n\in\mathbb{N}}\mathbf{EKnows}^{n}(G,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Since its definition is second-order or infinitary, common knowledge cannot
 be reduced to individual knowledge during reasoning.
 The only formal treatments of common knowledge in the situation calculus
 and related literature introduce it via a separate, explicit axiom 
\begin_inset LatexCommand cite
key "davis05fo_ma_theory,ghaderi07sc_joint_ability"

\end_inset

.
 This makes reasoning difficult as regression cannot be applied.
\end_layout

\begin_layout Standard
The problem boils down to a fundamental expressivity limitation, first discovere
d in the related field of dynamic epistemic logic:
\end_layout

\begin_layout Quote
Epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone 
\begin_inset LatexCommand cite
key "baltag98pa_ck"

\end_inset


\end_layout

\begin_layout Standard
In our terminology: 
\begin_inset Formula $\Reg(\CKnows(G,\phi,do(c,s)))$
\end_inset

 cannot be expressed in terms of 
\begin_inset Formula $\CKnows(G,\varphi,s)$
\end_inset

.
 Given the deep similarities between the situation calculus and modal logic
 
\begin_inset LatexCommand citep
key "vanbentham07ml_sitcalc"

\end_inset

, we can be confident that this limitation also holds in the situation calculus.
 Rather than trying to confirm it, we proceed directly with a technique
 for circumventing it.
 We follow the recent promising work of 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

, who use two important new ideas to produce a regression rule for common
 knowledge in their logic LCC:
\end_layout

\begin_layout Itemize
form more expressive epistemic modalities using the syntax of dynamic logic,
 interpreted epistemically
\end_layout

\begin_layout Itemize
apply regression within the modality as well as to the enclosed formula
\end_layout

\begin_layout Standard
We apply these ideas to perform epistemic reasoning in the situation calculus,
 allowing common knowledge to be handled using regression.
 While the development naturally parallels that of LCC, the much richer
 ontology of the situation calculus means there are also substantial differences.
 A full description of LCC would take us too far afield in this paper.
\end_layout

\begin_layout Section
Complex Epistemic Modalities
\begin_inset LatexCommand label
name "sec:Complex-Epistemic-Modalities"

\end_inset


\end_layout

\begin_layout Standard
In this section, we adopt the language of dynamic logic to express complex
 epistemic modalities.
 To deal gracefully with the many first-order aspects of the situation calculus
 we use a variant of 
\emph on
first-order dynamic logic,
\emph default
 adapted from 
\begin_inset LatexCommand citet
key "kooi07dyn_termmodal_logic"

\end_inset

 but with some simplifications.
\end_layout

\begin_layout Standard
First, let us specify the syntax of our new epistemic language.
 We use 
\begin_inset Formula $\pi$
\end_inset

 to denote an arbitrary 
\emph on
epistemic path
\emph default
: 
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $agt$
\end_inset

 be an 
\noun on
Agent 
\noun default
term, 
\begin_inset Formula $\phi$
\end_inset

 a uniform formula and 
\begin_inset Formula $x$
\end_inset

 a variable name, then the epistemic paths 
\begin_inset Formula $\pi$
\end_inset

 are the smallest set matching the following structural rules:
\begin_inset Formula \[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end_inset


\end_layout

\begin_layout Standard
The test (
\begin_inset Formula $?$
\end_inset

), sequence (
\begin_inset Formula $;$
\end_inset

), choice (
\begin_inset Formula $\cup$
\end_inset

) and unbounded iteration (
\begin_inset Formula $^{*}$
\end_inset

) operators are standard in dynamic logic, although test formulae may now
 contain variables that must be interpreted.
 The operator 
\begin_inset Formula $\exists x$
\end_inset

 allows the value of a variable to change by non-deterministically re-binding
 
\begin_inset Formula $x$
\end_inset

 to some value.
\end_layout

\begin_layout Standard
Let us reiterate the purpose of this path language.
 Despite using the syntax of dynamic logic, it is 
\emph on
not
\emph default
 related to actions in any way.
 Rather it expresses paths through the epistemic frame generated by the
 agents' individual 
\begin_inset Formula $K$
\end_inset

 relations.
 We will shortly introduce a new macro 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 (read this as 
\begin_inset Quotes eld
\end_inset

path-knows
\begin_inset Quotes erd
\end_inset

) to express knowledge using these epistemic paths.
 To make this clear, here is how some different kinds of knowledge would
 be expressed using the standard account of knowledge, and how we intend
 to express them using epistemic paths:
\begin_inset Formula \begin{gather}
\Knows(A,\phi)\equiv\PKnows(A,\phi)\nonumber \\
\Knows(A,\Knows(B,\phi))\equiv\PKnows(A;B,\phi)\nonumber \\
\Knows(A,\phi)\wedge\Knows(B,\phi)\equiv\PKnows(A\cup B,\phi)\nonumber \\
\EKnows(G,\phi)\equiv\PKnows(\bigcup_{a\in G}a,\phi)\nonumber \\
\CKnows(G,\phi)\equiv\PKnows((\bigcup_{a\in G}a)^{*},\phi)\label{eq:pknows_identities}\end{gather}

\end_inset


\end_layout

\begin_layout Standard
The semantics of epistemic paths are given by the macro 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

, which should be read 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $s'$
\end_inset

 can be reached from 
\begin_inset Formula $s$
\end_inset

 by following the epistemic path 
\begin_inset Formula $\pi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 It expands to a rather complicated second-order formula in the base language
 of the situation calculus.
 What follows is a simplified presentation of the semantics of each operator;
 a complete definition of 
\begin_inset Formula $\KDo$
\end_inset

 can be found in the appendix.
\end_layout

\begin_layout Standard
Formulae of first-order dynamic logic are interpreted relative to both a
 
\begin_inset Quotes eld
\end_inset

current world
\begin_inset Quotes erd
\end_inset

 and a 
\begin_inset Quotes eld
\end_inset

current variable binding
\begin_inset Quotes erd
\end_inset

, which is represented by a first-order substitution 
\begin_inset Formula $\mu$
\end_inset

.
 The semantics below operate over such pairs 
\begin_inset Formula $(\mu,s)$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset LatexCommand label
name "def:KDo"

\end_inset

A situation 
\begin_inset Formula $s'$
\end_inset

 is reachable from situation 
\begin_inset Formula $s$
\end_inset

 via epistemic path 
\begin_inset Formula $\pi$
\end_inset

, denoted 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

, according to the following semantics.
 All introduced variables are fresh.
 RTC represents the standard second-order definition of reflexive transitive
 closure.
\begin_inset Formula \[
\KDo(\pi,s,s')\,\,\equiv\,\,\exists\mu,\mu':\KTrans(\pi,\mu,s,\mu',s')\]

\end_inset


\begin_inset Formula \begin{align*}
\KTrans(agt,\mu,s,\mu',s')\,\equiv\,\, & \mu'=\mu\wedge K(agt,s',s)\\
\KTrans(?\phi,\mu,s,\mu',s')\,\equiv\,\, & s'=s\wedge\mu'=\mu\wedge\mu(\phi)[s]\\
\KTrans(\pi_{1};\pi_{2},\mu,s,\mu',s')\,\equiv\,\, & \exists\mu'',s'':\\
 & \,\,\,\,\,\KTrans(\pi_{1},\mu,s,\mu'',s'')\\
 & \,\wedge\,\KTrans(\pi_{2},\mu'',s'',\mu',s')\\
\KTrans(\pi_{1}\cup\pi_{2},\mu,s,\mu',s')\,\equiv\,\, & \KTrans(\pi_{1},\mu,s,\mu',s')\,\\
 & \vee\,\KTrans(\pi_{2},\mu,s,\mu',s')\\
\KTrans(\exists x,\mu,s,\mu',s')\,\equiv\,\, & s'=s\wedge\exists z:\,\mu'=\mu[x/z]\\
\KTrans(\pi^{*},\mu,s,\mu',s')\,\equiv\,\, & \mathrm{RTC[\KTrans(\pi,\mu,s,\mu',s')]}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset

Like its single-agent counterpart 
\begin_inset Formula $\Knows$
\end_inset

, the macro 
\begin_inset Formula $\PKnows$
\end_inset

 is a straightforward encoding of the semantics of the modal box operator:
\begin_inset Formula \[
\PKnows(\pi,\phi,s)\isdef\forall s':\,\KDo(\pi,s,s')\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
An advantage of this macro-expansion approach is that 
\begin_inset Formula $\PKnows$
\end_inset

 expressions can be nested and quantified-into without any ontological difficult
ies; it all simply expands to a formula of the base language.
 The de-dicto/de-re distinction is explicated by placing quantifiers inside/outs
ide the scope of the macro.
 The situation calculus also settles other semantic issues that might arise
 in a modal formalism (e.g.
 rigid vs non-rigid designators).
\end_layout

\begin_layout Standard
These definitions provide the required expressiveness boost for our epistemic
 language.
 Of course, they should not be used directly for reasoning purposes as they
 expand to complicated second-order expressions.
 We close this section with a formal statement of the validity of our new
 formalism in relation to the standard account.
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:PKnows-works"

\end_inset

The identities in equation 
\begin_inset LatexCommand eqref
reference "eq:pknows_identities"

\end_inset

 are entailed by 
\begin_inset Formula $\Dt$
\end_inset

, where CKnows is the transitive closure of EKnows.
\end_layout

\begin_layout ProofSketch
Each is a straightforward matter of expanding the 
\begin_inset Formula $\PKnows$
\end_inset

 definition, using the relevant identities from Definition 
\begin_inset LatexCommand ref
reference "def:KDo"

\end_inset

, and collecting back together components matching the form of the 
\begin_inset Formula $\Knows$
\end_inset

 macro.
\end_layout

\begin_layout Section
Epistemic Path Regression
\end_layout

\begin_layout Standard
As with the case of the standard 
\begin_inset Formula $\Knows$
\end_inset

 macro, we do not want to expand 
\begin_inset Formula $\PKnows$
\end_inset

 macros during reasoning.
 Instead, we need regression to treat 
\begin_inset Formula $\PKnows$
\end_inset

 syntactically as a primitive fluent.
 This can be achieved by regressing both the epistemic path 
\begin_inset Formula $\pi$
\end_inset

 and the enclosed formulae 
\begin_inset Formula $\phi$
\end_inset

.
 Mirroring the notation of LCC, we introduce the meta-operator 
\begin_inset Formula $\Trn$
\end_inset

 for this purpose and define the following regression rule:
\begin_inset Formula \begin{multline}
\Reg(\PKnows(\pi,\phi,do(c,s)))\isdef\\
\forall c':\,\PKnows(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\label{eq:reg_pknows}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
Let us consider the operation of the path-regressor 
\begin_inset Formula $\Trn$
\end_inset

 by analogy with 
\begin_inset Formula $\Reg$
\end_inset

.
 One can think of regression as a 
\begin_inset Quotes eld
\end_inset

pre-encoding
\begin_inset Quotes erd
\end_inset

 of the effects of an action: 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\begin_inset Formula $do(c,s)$
\end_inset

 iff 
\begin_inset Formula $\Reg(\phi,c)$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

.
 The path regressor 
\begin_inset Formula $\Trn$
\end_inset

 needs to lift this idea to epistemic paths: there is a 
\begin_inset Formula $\pi$
\end_inset

-path from 
\begin_inset Formula $do(c,s)$
\end_inset

 to 
\begin_inset Formula $do(c',s')$
\end_inset

 iff there is a 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

-path from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
\end_layout

\begin_layout Standard
To achieve this, every 
\begin_inset Formula $agt$
\end_inset

-step from 
\begin_inset Formula $s_{1}$
\end_inset

 to 
\begin_inset Formula $s_{2}$
\end_inset

 along the regressed path 
\begin_inset Formula $\Trn(\pi)$
\end_inset

 must correspond to an 
\begin_inset Formula $agt$
\end_inset

-step from 
\begin_inset Formula $do(c_{1},s_{1})$
\end_inset

 to 
\begin_inset Formula $do(c_{2},s_{2})$
\end_inset

 along the original path 
\begin_inset Formula $\pi$
\end_inset

.
 The path regressor uses a fresh variable 
\begin_inset Formula $x$
\end_inset

 to track the action corresponding to the current situation.
 It adds several tests to encode the successor state axiom for 
\begin_inset Formula $K$
\end_inset

 in the regressed path:
\end_layout

\begin_layout Itemize
action 
\begin_inset Formula $x$
\end_inset

 must always be possible in the current situation
\end_layout

\begin_layout Itemize
when making an 
\begin_inset Formula $agt$
\end_inset

-step, 
\begin_inset Formula $Obs(agt,x)$
\end_inset

 before making the step must match 
\begin_inset Formula $Obs(agt,x)$
\end_inset

 after making the step
\end_layout

\begin_layout Standard
Contrast with the regression rule for 
\begin_inset Formula $\Knows$
\end_inset

, which encodes this information within the enclosed formula.
 Note that 
\begin_inset Formula $\Reg$
\end_inset

 is used to ensure tests are proper uniform formulae.
 Note also that 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $c'$
\end_inset

 must be situation calculus variables rather than path variables, as they
 are used outside the path expression.
 
\begin_inset Formula $\Trn$
\end_inset

 simply asserts that 
\begin_inset Formula $x$
\end_inset

 is equal to 
\begin_inset Formula $c$
\end_inset

 at the beginning of the path, and equal to 
\begin_inset Formula $c'$
\end_inset

 at the end.
\end_layout

\begin_layout Definition
\begin_inset LatexCommand label
name "def:EpistemicPathRegression"

\end_inset

 The epistemic path regressor 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

 operates according to the definitions below, where 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are fresh variables not appearing in 
\begin_inset Formula $\pi$
\end_inset

 :
\begin_inset Formula \begin{align*}
\Trn(\pi,c,c')\,\isdef\,\, & \exists x\,;\,?x=c\,;\,\TrnA(\pi,x)\,;\,?x=c'\\
\TrnA(agt,x)\,\isdef\,\, & \exists z\,;\,?\Reg(Obs(agt,x)=z)\,;\, agt\,;\\
 & \,\,\exists x\,;?\Reg(Poss(x)\,\wedge\, Obs(agt,x)=z)\\
\TrnA(?\phi,x)\isdef\,\, & ?\Reg(\phi,x)\\
\TrnA(\exists y,x)\isdef\,\, & \exists y\\
\begin{array}{c}
\TrnA(\pi_{1};\pi_{2},x)\end{array}\isdef\,\, & \TrnA(\pi_{1},x)\,;\,\TrnA(\pi_{2},x)\\
\TrnA(\pi_{1}\cup\pi_{2},x)\isdef\,\, & \TrnA(\pi_{1},x)\cup\TrnA(\pi_{2},x)\\
\TrnA(\pi^{*},x)\isdef\,\, & \TrnA(\pi,x)^{*}\end{align*}

\end_inset

 
\end_layout

\begin_layout Standard
The following theorem states that these definitions behave as desired, respectin
g the semantics of epistemic paths:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Trn-respects-epi-paths"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\models\,\KDo(\pi,do(c,s),s'')\,\equiv\\
\exists c',s':\,\, s''=do(c',s')\wedge\KDo(\Trn(\pi,c,c'),s,s')\end{multline*}

\end_inset


\end_layout

\begin_layout ProofSketch
The proof proceeds by cases, covering each path operator in turn.
 The base cases 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $?\phi$
\end_inset

 and 
\begin_inset Formula $\exists y$
\end_inset

 follow from Definition 
\begin_inset LatexCommand ref
reference "def:KDo"

\end_inset

 and the successor state axiom for 
\begin_inset Formula $K$
\end_inset

.
 The inductive cases are straightforward as 
\begin_inset Formula $\Trn_{a}$
\end_inset

 is simply pushed inside each operator.
 
\end_layout

\begin_layout Standard
With this result in hand, we can justify the use of equation 
\begin_inset LatexCommand eqref
reference "eq:reg_pknows"

\end_inset

 for regressing 
\begin_inset Formula $\PKnows$
\end_inset

 expressions:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Reg_PKnowsZ"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and actions 
\begin_inset Formula $c$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\,\models\,\PKnows(\pi,\phi,do(c,s))\,\equiv\\
\forall c':\,\PKnows(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout ProofSketch
The mechanics of this proof mirror the corresponding proof from 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

: we expand the 
\begin_inset Formula $\PKnows$
\end_inset

 macro, apply Theorem 
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 as a successor state axiom for 
\begin_inset Formula $\KDo$
\end_inset

, re-arrange to eliminate existential quantifiers, then collect terms back
 into forms that match 
\begin_inset Formula $\PKnows$
\end_inset

.
\end_layout

\begin_layout Standard
We are now in a position to reduce an epistemic query 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 at some future situation to an epistemic query 
\begin_inset Formula $\PKnows(\Trn^{*}(\pi),\Reg^{*}(\phi),S_{0})$
\end_inset

 at the initial situation.
 While this is a significant gain for effective automated reasoning, it
 still remains to answer the regressed query.
 As with the work of 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, we assume this will be handled by a special-purpose epistemic reasoning
 engine rather than by expanding the knowledge macros and reasoning directly
 in the situation calculus.
\end_layout

\begin_layout Standard
However, we should note that validity in first-order dynamic logic is undecidabl
e; in fact it is 
\begin_inset Formula $\Pi_{1}^{1}$
\end_inset

-hard 
\begin_inset LatexCommand cite
key "kooi07dyn_termmodal_logic"

\end_inset

.
 As with previous work in the situation calculus, we must assume that axioms
 about the initial situation are in a restricted form amenable to effective
 reasoning.
 There are several special cases that can simplify answering the regressed
 query.
\end_layout

\begin_layout Standard
A common simplifying assumption is that the potential values of each variable
 can be finitely enumerated.
 In this case it is possible to translate our epistemic paths into propositional
 dynamic logic, which is decidable.
 The only difficulty is the elimination of variable bindings inside an iteration
 operator, which can be handled using a Kleene-style technique similar to
 the 
\begin_inset Formula $\mathcal{K}$
\end_inset

 translator of 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

.
 
\end_layout

\begin_layout Standard
Alternately, it may be that the initial situation is completely known and
 uncertainty is introduced only due to partial observability of actions.
 In this case the initial epistemic frame contains the lone situation 
\begin_inset Formula $S_{0}$
\end_inset

, and the regressed path can be reduced to a series of tests and variable
 re-bindings.
\end_layout

\begin_layout Standard
As we shall see in the next section, the epistemic paths resulting from
 regression can often be substantially simplified.
 In particular, if all actions are public then the variable 
\begin_inset Formula $x$
\end_inset

 introduced by 
\begin_inset Formula $\Trn$
\end_inset

 can be simplified away as it will always contain the actions that actually
 occurred.
\end_layout

\begin_layout Standard
We are currently investigating further techniques for answering the regressed
 query in a more effective manner.
\end_layout

\begin_layout Section
Example
\begin_inset LatexCommand label
name "sec:Example"

\end_inset


\end_layout

\begin_layout Standard
In this section we give a small example to demonstrate our technique in
 action.
 Two agents, 
\begin_inset Formula $A$
\end_inset

lice and 
\begin_inset Formula $B$
\end_inset

ob, are attending a party.
 They know that its location, the fluent 
\begin_inset Formula $loc$
\end_inset

, is either 
\begin_inset Formula $C$
\end_inset

athy's house or 
\begin_inset Formula $D$
\end_inset

ave's house, and they have just received an invitation telling them it is
 in fact at 
\begin_inset Formula $C$
\end_inset

athy's house.
 The sensing action 
\begin_inset Formula $read(agt)$
\end_inset

 is publicly observable and returns the location of the party.
 All of this is common knowledge.
 This domain can be summarised as follows:
\begin_inset Formula \begin{gather*}
loc(S_{0})=C\\
Poss(read(agt),s)\equiv true\\
SR(read(agt),s)=r\equiv r=loc(s)\\
\PKnows((A\cup B)^{*},loc=C\vee loc=D,S_{0})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Using the techniques developed in this paper, we can prove several interesting
 facts about this domain.
\newline

\end_layout

\begin_layout Example
After Bob reads the invitation, he knows that the party is at Cathy's house:
\begin_inset Formula \[
\Dt\,\models\,\PKnows(B,loc=C,do(read(B),S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
This example could be done equivalently using 
\begin_inset Formula $\Knows$
\end_inset

, but it is a good introduction to the mechanics of the regression procedure.
 To begin, note that 
\begin_inset Formula $loc$
\end_inset

 cannot change and so is invariant under regression.
 Applying our new regression rule from equation 
\begin_inset LatexCommand eqref
reference "eq:reg_pknows"

\end_inset

, we get:
\begin_inset Formula \[
\forall c':\,\PKnows(\Trn(B,read(B),c'),loc=C,S_{0})\]

\end_inset

Expanding the definition of 
\begin_inset Formula $\Trn$
\end_inset

, the new epistemic path is:
\begin_inset Formula \begin{multline*}
\Trn(B,read(B),c')\,\Rightarrow\\
\exists x\,;\,?x=read(B)\,;\,\exists z\,;\,?\Reg(Obs(B,x)=z)\,;\, B\,;\\
\exists x\,;\,?\Reg(Poss(x)\,\wedge\, Obs(B,x)=z)\,;\,?x=c'\end{multline*}

\end_inset

Inserting the definitions of 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Obs$
\end_inset

 and applying some straightforward simplifications, we get:
\begin_inset Formula \begin{multline*}
\Trn(B,read(B),c')\,\Rightarrow\exists z\,;\,?z=read(B)\#loc\,;\, B\,;\\
\,?z=read(B)\#loc\,;\,?c'=read(B)\end{multline*}

\end_inset

Examining the test conditions in this path, we see that the value of 
\begin_inset Formula $loc$
\end_inset

 after the 
\begin_inset Formula $B$
\end_inset

 step must equal the value of 
\begin_inset Formula $loc$
\end_inset

 before it.
 We can in fact simplify this to:
\begin_inset Formula \begin{multline*}
\Trn(B,read(B),c')\Rightarrow\\
\exists z\,;\,?z=loc\,;\, B\,;\,?z=loc\,;\,?c'=read(B)\end{multline*}

\end_inset

We can thus use the following when evaluating 
\begin_inset Formula $\PKnows$
\end_inset

 in the regressed query:
\begin_inset Formula \[
\KDo(\Trn(B,read(B),c'),S_{0},s')\rightarrow loc(s')=loc(S_{0})\]

\end_inset

 Since 
\begin_inset Formula $loc(S_{0})=C$
\end_inset

, the query is entailed.
\newline

\end_layout

\begin_layout Example
After Bob reads the invitation, it is not common knowledge that the party
 is at Cathy's house:
\begin_inset Formula \[
\Dt\,\not\models\,\PKnows((A\cup B)^{*},loc=C,do(read(B),S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
This query regresses to:
\begin_inset Formula \[
\forall c':\,\PKnows(\Trn((A\cup B)^{*},read(B),c'),loc=C,S_{0})\]

\end_inset

To calculate 
\begin_inset Formula $\Trn((A\cup B)^{*})$
\end_inset

 we need the following result:
\begin_inset Formula \begin{multline*}
\Trn_{a}(A,read(B))\,\Rightarrow\\
\exists z\,;\,?z=read(B)\,;\, A\,;\,?read(B)=z\end{multline*}

\end_inset

Since Alice does not observe any sensing results from 
\begin_inset Formula $read(B)$
\end_inset

, and since 
\begin_inset Formula $Poss(read(B))$
\end_inset

 is always true, the tests in this regressed path provide no new information
 and Alice's knowledge is not changed.
 Using this, the regression of the entire epistemic path can be simplified
 to:
\begin_inset Formula \begin{multline*}
\Trn((A\cup B)^{*},read(B),c')\,\Rightarrow\\
\left[A\cup\,\exists z\,;\,?z=loc\,;\, B\,;\,?z=loc\right]^{*};?c'=read(B)\end{multline*}

\end_inset

Since this path permits 
\begin_inset Formula $A$
\end_inset

 steps, and Alice considers 
\begin_inset Formula $loc=D$
\end_inset

 a possibility, the query is not entailed.
\newline

\end_layout

\begin_layout Example
After Bob reads the invitation, it is common knowledge that Bob knows where
 the party is:
\begin_inset Formula \begin{multline*}
\Dt\,\models\,\PKnows((A\cup B)^{*},\exists x:\PKnows(B,loc=x),\\
do(read(B),S_{0}))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Regressing the inner expression over the variable 
\begin_inset Formula $c'$
\end_inset

 gives:
\begin_inset Formula \begin{multline*}
\Reg(\exists x:\PKnows(B,loc=x),c')\Rightarrow\\
\exists x:\PKnows(B,loc=x)\vee c'=read(B)\end{multline*}

\end_inset

So when regressing the outer expression, we get:
\begin_inset Formula \begin{multline*}
\forall c':\,\PKnows(\Trn((A\cup B)^{*},read(B),c'),\\
\exists x:\PKnows(B,loc=x)\vee c'=read(B),S_{0})\end{multline*}

\end_inset

From the previous example, 
\begin_inset Formula $\Trn((A\cup B)^{*},read(B),c')$
\end_inset

 asserts that 
\begin_inset Formula $c'=read(B)$
\end_inset

.
 This is due to the public observability of 
\begin_inset Formula $read$
\end_inset

.
 The enclosing 
\begin_inset Formula $\forall c'$
\end_inset

 can thus be simplified away and the result is a simple tautology.
 If the 
\begin_inset Formula $read$
\end_inset

 action were not publicly observable, common knowledge would not be obtained;
 a proof of this would mirror example 2.
 
\newline

\end_layout

\begin_layout Example
If Alice also reads the invitation, it becomes common knowledge that the
 party is at Cathy's house:
\begin_inset Formula \begin{multline*}
\Dt\,\models\,\PKnows((A\cup B)^{*},loc=C,\\
do(read(A),do(read(B),S_{0})))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Applying regression over the first action, and simplifying with 
\begin_inset Formula $c'=read(B)$
\end_inset

 as before, we reduce this query to:
\begin_inset Formula \begin{multline*}
\PKnows(\left[\exists z\,;\,?z=loc\,;\, A\,;\,?z=loc\,\cup\, B\right]^{*},\\
loc=C,do(read(B),S_{0}))\end{multline*}

\end_inset

When we apply regression a second time, the 
\begin_inset Formula $\exists z$
\end_inset

 and test components in this path are not modified.
 The resulting query is:
\begin_inset Formula \begin{multline*}
\PKnows(\left[\exists z\,;\,?z=loc\,;\, A\,;\,?z=loc\,\cup\right.\\
\left.\exists z\,;\,?z=loc\,;\, B\,;\,?z=loc\right]^{*},\\
loc=C,do(read(B),S_{0}))\end{multline*}

\end_inset

Or equivalently, the simpler form:
\begin_inset Formula \begin{multline*}
\PKnows(\left[\exists z\,;\,?z=loc\,;\,(A\cup B)\,;\,?z=loc\right]^{*},\\
loc=C,S_{0})\end{multline*}

\end_inset

By a similar argument to the first example, this query is entailed by the
 domain.
 Again, the public observability of 
\begin_inset Formula $read$
\end_inset

 is the key to obtaining common knowledge in this case.
\end_layout

\begin_layout Section
Related and Future Work
\begin_inset LatexCommand label
name "sec:Related-and-Future"

\end_inset


\end_layout

\begin_layout Standard
Existing work using group-level epistemics in the situation calculus has,
 when common knowledge is included at all, used an explicit axiom to define
 it and has thus forgone the use of regression for effective reasoning 
\begin_inset LatexCommand cite
key "davis05fo_ma_theory,ghaderi07sc_joint_ability"

\end_inset

.
 By combining complex epistemic modalities with an effective reasoning procedure
, our work allows reasoning about common knowledge in a wide range of applicatio
n areas.
 Work that could immediately benefit from our approach includes: specification
 of multi-agent systems 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

; theories of coordination and ability 
\begin_inset LatexCommand cite
key "ghaderi07sc_joint_ability"

\end_inset

; reasoning about the epistemic feasibility of plans 
\begin_inset LatexCommand citep
key "Lesperance01epi_feas_casl"

\end_inset

; analysing multi-player games 
\begin_inset LatexCommand citep
key "delgrande01sitcalc_cleudo"

\end_inset

; and our own work on the cooperative execution of Golog programs 
\begin_inset LatexCommand citep
key "kelly06hlp_dps"

\end_inset

.
\end_layout

\begin_layout Standard
This paper clearly owes much to the heritage of dynamic epistemic logics
 in general 
\begin_inset LatexCommand cite
key "halpern90knowledge_distrib,baltag98pa_ck"

\end_inset

 and the development of LCC in particular 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

.
 We choose the situation calculus for its much richer ontology, e.g.
 preconditions and effects are first order, while actions take arguments
 and may be performed concurrently.
 On one hand, this forces us to use a more powerful dynamic logic for our
 epistemic language and run the risk of undecidability.
 On the other, it actually simplifies some aspects of our presentation.
 We do not need explicit update frames, and the definition of our path regressor
 does not require an auxiliary Kleene-style operator to handle iteration.
 We echo the sentiment of 
\begin_inset LatexCommand cite
key "vanbentham07ml_sitcalc"

\end_inset

 and look forward to continued cross-pollination between these two disciplines.
\end_layout

\begin_layout Standard
Our ongoing work extends this approach to asynchronous domains, where some
 action occurrences may be completely hidden from an agent.
 Accounting for arbitrarily-long sequences of hidden actions requires a
 more complex reasoning procedure that builds on the techniques of 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs,kelly07sc_persistence"

\end_inset

.
 We are also incorporating additional extensions to the situation calculus,
 such as continuous time 
\begin_inset LatexCommand cite
key "reiter96sc_nat_conc"

\end_inset

.
 A journal paper presenting the extended version of our formalism is currently
 in preparation.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
In this paper we have enriched the situation calculus with a comprehensive
 account of complex group-level epistemic modalities.
 Using first-order dynamic logic to construct complex modalities from the
 base knowledge operators of each agent, our formalism can capture a wide
 variety of group-level knowledge expressions, including the important case
 of common knowledge.
 It is formulated as a series of macro-expansions and additions to the meta-theo
retical reasoning machinery, so it can be used directly to enrich existing
 action theories and should be compatible with other extensions to the situation
 calculus.
 By leveraging the situation calculus, we gain a very rich domain ontology
 without significant complications.
 In particular, concurrent actions can be handled in a straightforward manner.
\end_layout

\begin_layout Standard
Utilising the increased expressive power of our formalism, we have extended
 the regression meta-operator to do effective reasoning for epistemic queries.
 The most immediate benefit of this work, and indeed the impetus for its
 development, is that reasoning about common knowledge no longer requires
 a separate axiomatisation.
 As we have shown with a small example, it can now be handled using regression.
\end_layout

\begin_layout Standard
The end result is a rich multi-agent theory of knowledge and action in which
 complex group-level epistemic modalities are amenable to effective automated
 reasoning.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "aaai"
bibfiles "../../../library/references"

\end_inset


\end_layout

\begin_layout Standard
\start_of_appendix

\newpage

\end_layout

\begin_layout Section
Appendix: Dynamic Logic using Macros
\end_layout

\begin_layout Standard
This appendix develops an encoding of first-order dynamic logic (henceforth
 
\begin_inset Quotes eld
\end_inset

FODL
\begin_inset Quotes erd
\end_inset

) into the situation calculus via macro expansion.
 Our encoding is based on embedding FODL into Golog, a programming language
 based on the situation calculus that has many similarities to dynamic logic.
\end_layout

\begin_layout Standard
This may seem like an unnecessary complication - why not expand FODL directly
 into sentences of the situation calculus? We find the embedding into Golog
 simpler and clearer, and expect many readers familiar with the situation
 calculus will feel likewise.
 As Golog is well-understood, it relieves some our burden of proof that
 the embedding works as required.
 Since the semantics of Golog itself it based on macro-expansion, the end
 result is the the same: sentences of FODL macro-expand into sentences of
 the situation calculus.
 Finally, our modification to Golog so that it is interpreted over epistemic
 frames may further elucidate the intended operation of FODL in this paper.
\end_layout

\begin_layout Standard
We make one modification to the semantics of Golog, so that it is interpreted
 over epistemic frames.
 The base program component is no longer an action but an agent's epistemic
 relation.
 
\begin_inset Formula $\delta$
\end_inset

 represents an arbitrary Golog program.
 Since we intend to interpret Golog over epistemic frames, we will use the
 macro 
\begin_inset Formula $\EDo(\delta,s,s')$
\end_inset

 to distinguish it from standard action-based Golog.
\end_layout

\begin_layout Definition
The semantics of Golog over epistemic frames is given by the macro 
\begin_inset Formula $\EDo$
\end_inset

 defined as follows, where 
\begin_inset Formula $P$
\end_inset

 names a predicate symbol:
\begin_inset Formula \begin{multline*}
\delta::=agt\,|\,?\phi\,|\,\delta_{1};\delta_{2}\,|\,\delta_{1}\cup\delta_{2}\,|\,\pi(x)\delta(x)\,\\
|\,\delta^{*}\,|\,\mathbf{proc}\, P(\vars{x})\,\delta(\vars{x})\,\mathbf{end}\,;\,\delta\,|\, P(\vars{x})\end{multline*}

\end_inset


\begin_inset Formula \begin{align*}
\EDo(agt,s,s')\,\isdef\,\, & K(agt,s',s)\\
\EDo(?\phi,s,s')\,\isdef\,\, & s=s'\wedge\phi[s]\\
\EDo(\delta_{1}\,;\,\delta_{2},s,s')\,\isdef\,\, & \exists s'':\,\EDo(\delta_{1},s,s'')\\
 & \,\wedge\,\EDo(\delta_{2},s'',s')\\
\EDo(\delta_{1}\,\cup\,\delta_{2},s,s')\,\isdef\,\, & \EDo(\delta_{1},s,s')\\
 & \vee\EDo(\delta_{2},s,s')\\
\EDo(\pi(x)\delta(x),s,s')\,\isdef\,\, & \exists x:\,\EDo(\delta(x),s,s')\\
\EDo(\delta^{*},s,s')\,\isdef\,\, & \mathrm{RTC}[\EDo(\delta,s,s')]\\
\EDo(P(\vars{x}),s,s')\,\isdef\,\, & P(\vars{x},s,s')\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The final clause identifies a procedure call with arguments 
\begin_inset Formula $\vars{x}$
\end_inset

.
 Defining procedure calls via macro expansion involves a second-order definition
 corresponding to the standard least-fixed-point semantics for recursive
 procedures.
 We will not repeat the definition here, but note that the invocation of
 a Golog program using procedure definitions appears as:
\begin_inset Formula \[
\{\mathbf{proc}\, P_{1}(\vars{x})\,\delta_{1}(\vars{x})\,\mathbf{end}\,;\dots;\,\mathbf{proc}\, P_{n}(\vars{x})\,\delta_{n}(\vars{x})\,\mathbf{end}\,;\,\delta\}\]

\end_inset


\end_layout

\begin_layout Standard
Clearly Golog is a very powerful language, so the question must be asked:
 could we use Golog as our epistemic path language, rather than FODL? Unfortunat
ely not, as Golog has no notion of 
\emph on
state
\emph default
 - while the Golog operator 
\begin_inset Formula $\pi(x)\delta(x)$
\end_inset

 is similar to the FODL operator 
\begin_inset Formula $\exists x$
\end_inset

, its effect is localised to the contained program 
\begin_inset Formula $\delta(x)$
\end_inset

.
 FODL allows variable assignments to affect the entire remaining program.
 In order to simulate this via macro expansion, we use what is essentially
 a continuation-passing transformation to pass state among the operators.
\end_layout

\begin_layout Standard
First, note that any epistemic path 
\begin_inset Formula $\pi$
\end_inset

 will be contain only a finite number of FODL variables.
 Without loss of generality, suppose that 
\begin_inset Formula $\pi$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 such variables named 
\begin_inset Formula $x_{1}$
\end_inset

 to 
\begin_inset Formula $x_{n}$
\end_inset

.
 The idea is to translate each component of the path into a Golog procedure
 with 
\begin_inset Formula $n$
\end_inset

 arguments, where the 
\begin_inset Formula $i$
\end_inset

th argument is used to pass in the current value of 
\begin_inset Formula $x_{i}$
\end_inset

.
 After performing the necessary operations to encode the semantics of that
 path component, it calls a continuation procedure representing the next
 path component.
 This translation is based on the macro 
\begin_inset Formula $\KDo_{c}(\pi,N,C)$
\end_inset

 which is passed the name to use for the procedure encoding the given path
 component (
\begin_inset Formula $N$
\end_inset

) and the name of the continuation procedure (
\begin_inset Formula $C$
\end_inset

).
\end_layout

\begin_layout Definition
The embedding of FODL into Golog is given by the macros 
\begin_inset Formula $\KDo$
\end_inset

 and 
\begin_inset Formula $\KDo_{c}$
\end_inset

 defined as follows, where 
\begin_inset Formula $P_{i}$
\end_inset

 are fresh procedure names and 
\begin_inset Formula $\vars{v}$
\end_inset

 are argument vectors of length 
\begin_inset Formula $n$
\end_inset

:
\begin_inset Formula \begin{multline*}
\KDo(\pi,s,s')\,\isdef\,\,\EDo(\{\KDo_{c}(\pi,P,End)\,\\
;\,\mathbf{proc}\, End(\vars{v})\,?\top\,\mathbf{end}\,;\,\pi(\vars{v})P(\vars{v})\},s,s')\end{multline*}

\end_inset


\begin_inset Formula \begin{align*}
\KDo_{c}(agt,N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\, agt\,;\, C(\vars{v})\,\mathbf{end}\\
\KDo_{c}(?\phi(\vars{x}),N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,?\phi(\vars{v})\,;\, C(\vars{v})\,\ \mathbf{end}\\
\KDo_{c}(\exists x_{i},N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,\pi(x)C(\vars{v}[v_{i}/x])\,\mathbf{end}\\
\KDo_{c}(\pi_{1};\pi_{2},N,C)\,\isdef\,\, & \KDo_{c}(\pi_{1},N,P)\,;\\
 & \,\,\,\KDo_{c}(\pi_{2},P,C)\\
\KDo_{c}(\pi_{1}\cup\pi_{2},N,C)\,\isdef\,\, & \KDo_{c}(\pi_{1},P_{1},C)\,;\\
 & \,\,\,\KDo_{c}(\pi_{2},P_{2},C)\,;\\
 & \,\,\,\mathbf{proc}\, N(\vars{v})\, P_{1}(\vars{v})\cup P_{2}(\vars{v})\,\mathbf{end}\\
\KDo_{c}(\pi^{*},N,C)\,\isdef\,\, & \KDo_{c}(\pi,P,N)\,;\\
 & \,\,\,\mathbf{proc}\, N(\vars{v})\, C(\vars{v})\cup P(\vars{v})\,\mathbf{end}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This translation generates one procedure for each operator in the path,
 plus the procedure 
\begin_inset Formula $End$
\end_inset

 used to successfully terminate execution.
 Most of these definitions are straightforward translations of equivalent
 operators in FODL to Golog.
 One interesting case is 
\begin_inset Formula $\exists x_{i}$
\end_inset

, which calls the continuation procedure with a fresh variable in position
 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
The most complex case is 
\begin_inset Formula $\pi^{*}$
\end_inset

, which simulates iteration using a pair of mutually recursive procedures
 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 Procedure 
\begin_inset Formula $N$
\end_inset

 can either terminate immediately (calling the continuation 
\begin_inset Formula $C$
\end_inset

) or call 
\begin_inset Formula $P$
\end_inset

.
 A call to 
\begin_inset Formula $P$
\end_inset

 executes one iteration of 
\begin_inset Formula $\pi$
\end_inset

 before continuing with another invocation of 
\begin_inset Formula $N$
\end_inset

.
 The possible executions for 
\begin_inset Formula $\pi^{*}$
\end_inset

 are thus 
\begin_inset Formula $nil$
\end_inset

, 
\begin_inset Formula $\pi$
\end_inset

, 
\begin_inset Formula $\pi;\pi$
\end_inset

, etc as required by the semantics of FODL.
\end_layout

\begin_layout Standard
It should be clear that the expansion of each operator satisfies the relevant
 identity from Definition 
\begin_inset LatexCommand eqref
reference "def:KDo"

\end_inset

.
\newpage

\end_layout

\begin_layout Section
Appendix: Extended Proofs
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:PKnows-works"

\end_inset

 The identities in equation 
\begin_inset LatexCommand eqref
reference "eq:pknows_identities"

\end_inset

 are entailed by 
\begin_inset Formula $\Dt$
\end_inset

, where CKnows is the transitive closure of EKnows.
\end_layout

\begin_layout Proof
Each is a straightforward matter of expanding the 
\begin_inset Formula $\PKnows$
\end_inset

 definition, using the relevant identities from Definition 
\begin_inset LatexCommand ref
reference "def:KDo"

\end_inset

, and collecting back together components matching the form of the 
\begin_inset Formula $\Knows$
\end_inset

 macro.
 We take the 
\begin_inset Formula $A\cup B$
\end_inset

 case as an example:
\begin_inset Formula \begin{multline*}
\PKnows(A\cup B,\phi,s)\Rightarrow\\
\forall s':\,\KDo(A\cup B,s,s')\rightarrow\phi[s']\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Using the semantics of the 
\begin_inset Formula $\cup$
\end_inset

 operator:
\begin_inset Formula \begin{multline*}
\PKnows(A\cup B,\phi,s)\Rightarrow\\
\forall s':\,\left[\KDo(A,s,s')\vee\KDo(B,s,s')\right]\rightarrow\phi[s']\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Using the semantics of the 
\begin_inset Formula $agt$
\end_inset

 operator, this expands to:
\begin_inset Formula \begin{multline*}
\PKnows(A\cup B,\phi,s)\Rightarrow\\
\forall s':\, K(A,s,s')\rightarrow\phi[s']\,\wedge\, K(B,s,s')\rightarrow\phi[s']\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Which matches the form of 
\begin_inset Formula $\Knows$
\end_inset

, giving the required:
\begin_inset Formula \begin{multline*}
\PKnows(A\cup B,\phi,s)\Rightarrow\\
\Knows(A,\phi,s)\,\wedge\,\Knows(B,\phi,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\models\,\KDo(\pi,do(c,s),s'')\,\equiv\\
\exists c',s':\,\, s''=do(c',s')\wedge\KDo(\Trn(\pi,c,c'),s,s')\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Proceed by cases, covering each path operator in turn.
 We will omit the use of 
\begin_inset Formula $\Reg()$
\end_inset

 in the definition of 
\begin_inset Formula $\Trn$
\end_inset

 to simplify the presentation.
 For the base case of an individual agent, we have:
\begin_inset Formula \begin{align*}
\KDo(\pi,do(c,s),s'')\,\equiv\, & K(agt,s'',do(c,s))\end{align*}

\end_inset


\begin_inset Formula \begin{multline*}
\Trn(agt,c,c')\Rightarrow\\
\exists x\,;\,?x=c\,;\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\\
\exists x\,;\,?Poss(x)\,\wedge\, Obs(agt,x)=z\,;\,?x=c'\end{multline*}

\end_inset

Then expanding 
\begin_inset Formula $\KDo(\Trn(agt,c,c'),s,s')$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 we get:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula \begin{multline*}
\KDo(\Trn(agt,c,c'),s,s')\equiv\\
\exists x:\, x=c\wedge\exists z:\, Obs(agt,x,s)=z\,\wedge\,\exists s'':\, K(agt,s'',s)\\
\wedge\exists x:\, Poss(x,s'')\,\wedge\, Obs(agt,x,s'')=z\,\wedge\, x=c'\wedge s''=s'\end{multline*}

\end_inset

Which can be simplified dramatically to:
\begin_inset Formula \begin{multline*}
\KDo(\Trn(agt,c,c'),s,s')\equiv K(agt,s,s')\,\wedge\, Poss(c',s')\\
\wedge\, Obs(agt,c,s)=Obs(agt,c',s')\end{multline*}

\end_inset

Substituting these back into the hypothesis, we get:
\begin_inset Formula \begin{multline*}
\Dt\models K(agt,s'',do(c,s))\equiv\exists c',s':\,\, s''=do(c',s')\\
\shoveright{\wedge K(agt,s,s')\,\wedge\, Poss(c',s')}\\
\wedge\, Obs(agt,c,s)=Obs(agt,c',s')\end{multline*}

\end_inset

This is simply the successor state axiom for 
\begin_inset Formula $K$
\end_inset

.
\newline

\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $?\phi$
\end_inset

 case, we have:
\begin_inset Formula \begin{eqnarray*}
\KDo(?\phi,do(c,s),s'') & \equiv & \phi[do(c,s)]\wedge s''=do(c,s)\end{eqnarray*}

\end_inset


\begin_inset Formula \begin{align*}
\Trn(?\phi,c,c')\Rightarrow & \exists x\,;\,?x=c\,;\,?\Reg(\phi,x)\,;\,?x=c'\\
\Rightarrow & ?\Reg(\phi,c)\wedge c=c'\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Giving:
\begin_inset Formula \[
\KDo(\Trn(?\phi,c,c'),s,s')\equiv\Reg(\phi,c)\wedge c=c'\wedge s=s'\]

\end_inset


\end_layout

\begin_layout Proof
Coupled with 
\begin_inset Formula $s''=do(c',s')$
\end_inset

 from the hypothesis, and 
\begin_inset Formula $\Reg(\phi,c)\equiv\phi[do(c,s)]$
\end_inset

 by definition, the hypothesis is clearly entailed.
\end_layout

\begin_layout Proof
The case for 
\begin_inset Formula $\exists y$
\end_inset

 is trivial as 
\begin_inset Formula $\KDo(\exists y,s,s')\equiv s=s'$
\end_inset

.
\end_layout

\begin_layout Proof
The inductive cases are straightforward as 
\begin_inset Formula $\Trn_{a}$
\end_inset

 is simply pushed inside each operator.
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Reg_PKnowsZ"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and actions 
\begin_inset Formula $c$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\,\models\,\PKnows(\pi,\phi,do(c,s))\,\equiv\\
\forall c':\,\PKnows(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
The mechanics of this proof mirror the corresponding proof from 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

.
 First we expand the 
\begin_inset Formula $\PKnows$
\end_inset

 macro to produce:
\begin_inset Formula \begin{multline*}
\PKnows(\pi,\phi,do(c,s))\,\equiv\\
\forall s'':\,\KDo(\pi,do(c,s),s'')\rightarrow\phi[s'']\end{multline*}

\end_inset

Using Theorem 
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 as a kind of pseudo-successor-state-axiom for 
\begin_inset Formula $\KDo$
\end_inset

, we may write:
\begin_inset Formula \begin{multline*}
\PKnows(\pi,\phi,do(c,s))\,\equiv\forall s'':\\
(\exists c',s':s''=do(c',s')\wedge\KDo(\Trn(\pi,c,c'),s,s'))\rightarrow\phi[s'']\end{multline*}

\end_inset

Bringing the existential variables outside of the implication produces:
\begin_inset Formula \begin{multline*}
\PKnows(\pi,\phi,do(c,s))\,\equiv\forall s'',c',s':\\
s''=do(c',s')\wedge\KDo(\Trn(\pi,c,c'),s,s')\rightarrow\phi[s'']\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
The variable 
\begin_inset Formula $s''$
\end_inset

 is now doing no work in this formula, so it can be removed:
\begin_inset Formula \begin{multline*}
\PKnows(\pi,\phi,do(c,s))\,\equiv\forall c',s':\\
\KDo(\Trn(\pi,c,c'),s,s')\rightarrow\phi[do(c',s')]\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
The use of variable 
\begin_inset Formula $s'$
\end_inset

 now matches the form of the 
\begin_inset Formula $\PKnows$
\end_inset

 macro.
 Capturing it, and using regression on the 
\begin_inset Formula $\phi$
\end_inset

 term , we have the hypothesis as required:
\begin_inset Formula \begin{multline*}
\PKnows(\pi,\phi,do(c,s))\,\equiv\\
\forall c':\,\PKnows(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
