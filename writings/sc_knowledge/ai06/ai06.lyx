#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass llncs
\begin_preamble

\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}

\usepackage{algorithm}
\usepackage{algorithmic}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 2
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Property Persistence in the Situation Calculus
\end_layout

\begin_layout Author
Ryan Kelly 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
and
\end_layout

\end_inset

 Adrian Pearce
\end_layout

\begin_layout Institute
NICTA Victoria Laboratory
\newline
Department of Computer Science and Software Engineering
\newline

 The University of Melbourne
\newline
 Victoria, 3010, Australia
\newline
 {rfk,adrian}@csse.unimelb.e
du.au
\end_layout

\begin_layout Abstract
We develop an algorithm for reducing universally quantified situation calculus
 queries to a form more amenable to automated reasoning.
 Universal quantification in the situation calculus requires a second-order
 induction axiom, making automated reasoning difficult for such queries.
 We show how to reduce queries about property persistence, a common family
 of universally-qantified query, to an equivalent form that does not quantify
 over situations.
 The algorithm for doing so utilises only first-order reasoning.
 We give several examples of useful reasoning tasks that are facilitated
 by our approach.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 is one of the most popular formalisms for reasoning about dynamics worlds.
 Based on first-order logic, its attractive features include an elegant
 monotonic solution to the frame problem and an effective reasoning procedure
 for the projection problem based on the regression meta-operator 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

.
 These have facilitated the implementation of a wide range of agent systems.
 
\end_layout

\begin_layout Standard
However, a complete axiomatisation of the situation calculus requires a
 second-order induction axiom that defines the set of all situations 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
 For effective automated reasoning it is important to limit queries to syntactic
 forms which can be proven without induction, and so require only first-order
 reasoning.
 This includes sentences containing existential quantification over situation
 terms 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

, which encompasses a wide range of queries utilised in practice.
\end_layout

\begin_layout Standard
Unfortunately, there are many other useful reasoning tasks that require
 universal quantification over situations.
 For example, it is often useful to determine whether 
\emph on
any
\emph default
 situation exists that satisfies a given goal.
 In this paper we are interested in a subset of such queries which we refer
 to as 
\emph on
persistence queries
\emph default
: given some formula 
\begin_inset Formula $\phi$
\end_inset

 and a situation 
\begin_inset Formula $s$
\end_inset

, determine whether 
\begin_inset Formula $\phi$
\end_inset

 will hold in all situations in the future of 
\begin_inset Formula $s$
\end_inset

.
 The need for second-order logic has traditionally limited automated reasoning
 about such queries.
\end_layout

\begin_layout Standard
In the spirit of regression, we introduce a new meta-operator 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 that takes a formula 
\begin_inset Formula $\phi$
\end_inset

 and produces a formula 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi]$
\end_inset

 that is equivalent to the persistence of 
\begin_inset Formula $\phi$
\end_inset

.
 We term this the 
\emph on
persistence condition
\emph default
 of 
\begin_inset Formula $\phi$
\end_inset

, and it is guaranteed to be of a form that is amenable to first-order reasoning.
 As the algorithm for determining the persistence condition employs purely
 first-order reasoning.
 the result is an effective procedure with which to answer some queries
 that universally quantify over situations.
\end_layout

\begin_layout Standard
The paper is organised as follows: section 
\begin_inset LatexCommand \ref{sec:Background}

\end_inset

 gives a brief introduction to the situation calculus, formally defines
 the persistence problem and gives several examples of useful persistence
 queries; section 
\begin_inset LatexCommand \ref{sec:Persistence-Condition}

\end_inset

 defines the persistence condition and presents an algorithm that calculates
 it; section 
\begin_inset LatexCommand \ref{sec:Related-Work}

\end_inset

 places this work in the context of related work on the topic; and section
 
\begin_inset LatexCommand \ref{sec:Conclusions}

\end_inset

 concludes with a summary of our results.
\end_layout

\begin_layout Section
Background
\begin_inset LatexCommand \label{sec:Background}

\end_inset


\end_layout

\begin_layout Standard
Our work is based on the situation calculus as described in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 A brief overview is presented below.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Action
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built up using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 We also distinguish 
\noun on
Fluents
\noun default
 as predicates or functions representing properties of the world that may
 change from one situation to another, and so take a situation term as their
 final argument.
\end_layout

\begin_layout Standard
A collection of situation calculus statements 
\begin_inset Formula $\mathcal{D}$
\end_inset

 that describe the behavior of a dynamic world is referred to as a 
\emph on
basic action theory
\emph default
.
 It consists of disjoint sets of statements captuing the foundational axioms
 of the situation calculus, successor state axioms for fluents, precondition
 axioms for actions, unique names axioms for actions, and axioms describing
 the initial situation:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}=\Sigma\cup\mathcal{D}_{ss}\cup\mathcal{D}_{ap}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
An action theory must also satisfy some basic consistency constraints.
 Queries about the behavior or evolution of the world are posed as logical
 entailment queries relative to the theory of action.
\end_layout

\begin_layout Subsection
Action Description Axioms
\end_layout

\begin_layout Standard
There is a distinguished predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 The set of action precondition axioms 
\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

 contains one axiom for each action function 
\begin_inset Formula $A$
\end_inset

, of the general form:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Poss(A(\overrightarrow{x}),s)\equiv\Pi_{A}(\overrightarrow{x},s)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\Pi_{A}$
\end_inset

 is required to be 
\emph on
uniform
\emph default
 in 
\begin_inset Formula $s$
\end_inset

, a special syntatcic structure defined below that has advantages for automated
 reasoning.
 Action possibility is thus defined on a per-action basis.
 It is often useful to introduce other predicates with a similar form that
 describe different aspects of action performance - for example, in recent
 unpublished work [citation ommitted] we utilise a predicate 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 to indicate when an agent will be aware of the occurance of an action.
 We shall refer to such predicates as 
\emph on
action description predicates.
 
\emph default
The meta-variable 
\begin_inset Formula $\alpha$
\end_inset

 will be used throughout to stand for an arbitrary action description predicate
 (or any logical combination thereof, as this could trivially be defined
 as an independent predicate if desired).
\end_layout

\begin_layout Subsection
Foundational Axioms
\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 are a set of axioms that describe the domain-independent behavior of the
 situation calculus.
 Of most import here is the induction axiom that defines the set of all
 situations:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\forall P\,\left[P(S_{0})\wedge\forall s,a\,\left(P(s)\rightarrow P(do(a,s))\right)\rightarrow\forall s\, P(s)\right]\]

\end_inset


\end_layout

\begin_layout Standard
The fundamental importance of this axiom is described in 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
 Since it is second-order and thus traditionally problematic for automated
 reasoning systems, much research has focussed on identifying sentences
 of the situation calculus that can be proved without this axiom.
\end_layout

\begin_layout Standard
Situations form a tree structure, with 
\begin_inset Formula $S_{0}$
\end_inset

 being the root of the tree and 
\begin_inset Formula $do$
\end_inset

 constructing child situations from parents.
 There is a basic ordering relation 
\begin_inset Formula $\sqsubset$
\end_inset

 defined by the following foundational axioms
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow the convention that lower-case roman names indicate variables,
 with free variables being implicitly universally quantified.
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\neg s\sqsubset S_{0}\]

\end_inset


\begin_inset Formula \[
s\sqsubset do(a,s')\equiv s\sqsubseteq s'\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is an abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 It is frequently useful to restrict the situations under consideration
 to those that are 
\begin_inset Quotes eld
\end_inset

executable
\begin_inset Quotes erd
\end_inset

 - that is, possible to reach in the real world.
 It is thus customary to define an ordering over only these situations:
\begin_inset Formula \[
\neg s<S_{0}\]

\end_inset


\begin_inset Formula \[
s<do(a,s')\equiv s\leq s'\wedge Poss(a,s')\]

\end_inset


\end_layout

\begin_layout Standard
Many results of the situation calculus are derived relative to the executable
 situations - for example, 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

 develops an induction principle over situations where 
\begin_inset Formula $S_{0}\leq s$
\end_inset

.
 This notation is so useful that we propose a parameterization of it: let
 
\begin_inset Formula $\alpha$
\end_inset

 be an action description predicate specifying the actions of interest,
 then define the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\alpha$
\end_inset

-ordering
\begin_inset Quotes erd
\end_inset

 over situations as follows:
\begin_inset Formula \[
\neg s<_{\alpha}S_{0}\]

\end_inset


\begin_inset Formula \[
s<_{\alpha}do(a,s')\equiv s\leq_{\alpha}s'\wedge\alpha(a,s)\]

\end_inset


\end_layout

\begin_layout Standard
The standard ordering over executable situations is clearly 
\begin_inset Formula $<_{Poss}$
\end_inset

.
 If 
\begin_inset Formula $s$
\end_inset

 is thought of as the 
\begin_inset Quotes eld
\end_inset

current situation
\begin_inset Quotes erd
\end_inset

, then 
\begin_inset Formula $s<_{\alpha}s'$
\end_inset

 means that 
\begin_inset Formula $s'$
\end_inset

 is in the future, and all actions that will occur in that future satsfy
 
\begin_inset Formula $\alpha$
\end_inset

.
 Note that this does 
\emph on
not
\emph default
 restrict the actions contained in 
\begin_inset Formula $s$
\end_inset

, which are considered to be in the past.
\end_layout

\begin_layout Subsection
Uniform Formulae
\end_layout

\begin_layout Standard
An important class of formulae in the situation calculus are the 
\emph on
uniform formulae
\emph default
 - those that refer to a single situation term, and do not mention any action
 description predicates or ordering over situations.
 Such formulae can be thought of as describing a 
\emph on
property 
\emph default
of the state of the world, as they are basically logical combinations of
 fluents refering to a common situation.
 Throughout this paper, we will use the meta-variable 
\begin_inset Formula $\phi$
\end_inset

 to refer to an arbitrary uniform formula.
\end_layout

\begin_layout Standard
It is often useful to determine the truth of a property at a given situation.
 The formula 
\begin_inset Formula $\phi[s]$
\end_inset

 represents the uniform formula 
\begin_inset Formula $\phi$
\end_inset

 with all occurrences of its unique situation term replaced by the situation
 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsection
Property Persistence
\end_layout

\begin_layout Standard
One interesting form of query in the situation calculus is to ask whether
 a given property 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\emph on
all future situations
\emph default
 of a given situation 
\begin_inset Formula $s$
\end_inset

, as well as at 
\begin_inset Formula $s$
\end_inset

 itself:
\begin_inset Formula \[
\mathcal{D}\models\forall s'\, s\sqsubseteq s'\rightarrow\phi(s')\]

\end_inset


\end_layout

\begin_layout Standard
More generally, we way wish to limit the futures considered to those brought
 about by a certain class of actions.
 Suppose that 
\begin_inset Formula $\alpha$
\end_inset

 specifies the actions to be considered, then we are intereted in whether:
\begin_inset Formula \begin{multline}
\mathcal{D}\models\forall s'\, s\le_{\alpha}s'\rightarrow\phi[s']\end{multline}

\end_inset


\end_layout

\begin_layout Standard
In words this states 
\begin_inset Quotes eld
\end_inset

given that all subsequent actions satisfy 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 will remain true
\begin_inset Quotes erd
\end_inset

 or, more succinctly, 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 We term queries of this form 
\emph on
property persistence 
\emph default
queries.
 Such queries appear in many useful reasoning tasks; the following are a
 small selection:
\end_layout

\begin_layout Paragraph
Goal Impossibility:
\end_layout

\begin_layout Standard
Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no possible situation in which that goal is satisfied:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models\forall s\, S_{0}\leq s\rightarrow\neg G(s)\]

\end_inset


\end_layout

\begin_layout Paragraph
Goal Futility:
\end_layout

\begin_layout Standard
Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $s$
\end_inset

, establish that the goal cannot be satisfied in any possible situation
 in the future of 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models\forall s'\, s\leq s'\rightarrow\neg G(s')\]

\end_inset


\end_layout

\begin_layout Standard
Note how this is different from goal impossibility: while the agent may
 have initially been able to achieve the goal, the actions that have subsequentl
y been performed have rendered the goal unachievable.
 Agents would be well advised to avoid such situations.
\end_layout

\begin_layout Paragraph
Checking State Constraints:
\end_layout

\begin_layout Standard
This is a variant of goal impossibility - show that the state constraint
 can never be violated.
\end_layout

\begin_layout Paragraph
Need for Cooperation:
\end_layout

\begin_layout Standard
To establish that it needs to cooperate with another agent, an agent must
 determine persistence with respect to actions performed by itself:
\begin_inset Formula \begin{multline}
\mathcal{D}\models\forall s'\, s\leq_{agent()=agt}s'\rightarrow\neg G[s']\end{multline}

\end_inset


\end_layout

\begin_layout Standard
In words this states that no situation in the future of 
\begin_inset Formula $s$
\end_inset

 can satisfy 
\begin_inset Formula $G$
\end_inset

, if all the actions that brought about that situation were performed by
 
\begin_inset Formula $agt$
\end_inset

.
 If this is the case, then 
\begin_inset Formula $agt$
\end_inset

 will need to cooperate with another agent in order to achieve its goal.
\end_layout

\begin_layout Paragraph
Knowledge under Partial Observability:
\end_layout

\begin_layout Standard
In recent unpublished work, we develop a new account of knowledge in the
 situation calculus when not all actions are observable by all agents.
 To facilitate reasoning in this formalism, agents must be able to reason
 about what cannot be changed by actions that they cannot observe, a form
 of persistence query.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
One of the main attractions of the situation calculus is the existence of
 efficient reasoning procedures for certain types of query.
 The principle tool is the regression meta-operator 
\begin_inset LatexCommand \cite{reiter91frameprob,pirri99contributions_sitcalc}

\end_inset

 which transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into a formula 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}[\phi]$
\end_inset

 uniform in 
\begin_inset Formula $s$
\end_inset

, such that the two are equivalent relative to the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

.
 By repeatedly applying
\begin_inset Foot
status collapsed

\begin_layout Standard
It is also possible to define a single-pass regression operator that directly
 transforms 
\begin_inset Formula $\phi$
\end_inset

 into a formula uniform in 
\begin_inset Formula $S_{0}$
\end_inset

.
 The single-step version described here is more useful for our work.
\end_layout

\end_inset

 the regression operator, 
\begin_inset Formula $\phi$
\end_inset

 can be transformed into an equivalent formula uniform in the initial situation:
\begin_inset Formula \[
\mathcal{D}\models\phi[do(c_{1},do(c_{2},\dots,do(c_{n},S_{0}))]\equiv\mathcal{R}_{\mathcal{D}}^{*}[\phi][S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Many of the axioms from 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required for reasoning about the initial situation, and so can
 be discarded when reasoning about 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}(\phi)[S_{0}]$
\end_inset

.
 Most importantly, the induction axiom is not needed so the reasoning is
 purely first-order.
 The successor state and action precondition axioms are also not required.
 The trade-off is that the length of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}(\phi)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice.
\end_layout

\begin_layout Standard
In order to apply regression to a formula containing an action description
 predicate that operates on a variable, one must assume that there are only
 a finite number of actions.
 This allows, for example, 
\begin_inset Formula $Poss(a,s)$
\end_inset

 to be replaced with the disjunction 
\begin_inset Formula $a=A_{1}\wedge\Pi_{A_{1}}(s)\,\vee\, a=A_{2}\wedge\Pi_{A_{2}}(s)\,\vee\,\dots$
\end_inset

.
 Since we shall be applying regression to such formulae below, we require
 there be a finite number of actions.
\end_layout

\begin_layout Standard
Regression can only be applied to queries with a special syntactic form.
 In particular, it cannot be used for queries that quantify over situations.
 This means that regression cannot be applied to peristence queries.
\end_layout

\begin_layout Subsection
Axiom Reduction
\end_layout

\begin_layout Standard
As noted previously, reasoning about an arbitrary sentence 
\begin_inset Formula $\psi$
\end_inset

 of the situation calculus is an entailment problem of second-order logic:
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\psi\]

\end_inset


\end_layout

\begin_layout Standard
Fortunately, there exist particular syntactic forms for which some of the
 axioms in 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required.
 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 define the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\exists$
\end_inset

s sentences
\begin_inset Quotes erd
\end_inset

 as those in which every situation variable is in the scope of a positive
 existential quantifier, and show that they can always be proven without
 the induction axiom (which we denote 
\begin_inset Formula $I$
\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\psi\,\,\, iff\,\,\,\mathcal{D}-\{ I\}\models_{FOL}\psi\]

\end_inset


\end_layout

\begin_layout Standard
Regression also operates in this way, allowing the successor state and action
 precondition axioms to be discarded:
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\psi\,\,\, iff\,\,\,\mathcal{D}_{S_{0}}\cup\mathcal{D}_{una}\models_{FOL}\mathcal{R_{D}}^{*}[\psi]\]

\end_inset


\end_layout

\begin_layout Standard
To assist their work on state constraints in the situation calculus, 
\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset

 show that that universally quantified uniform formulae can be proven using
 only the unique names axioms:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\,\forall s\,\phi[s]\,\,\, iff\,\,\,\mathcal{D}_{una}\models_{FOL}\,\forall s\,\phi[s]\]

\end_inset

 
\end_layout

\begin_layout Standard
This makes such formulae are among the most straightforward to prove of
 all situation calculus queries.
 Our work continues in this tradition, developing a transformation allowing
 persistence queries to be answered using a reduced set of axioms.
\end_layout

\begin_layout Section
Persistence Condition
\begin_inset LatexCommand \label{sec:Persistence-Condition}

\end_inset


\end_layout

\begin_layout Standard
For implementing practial agent systems, we need to replace quantification
 over situations with a more tractable form of reasoning - specifically,
 evaluation of a uniform formula at a specific situation.
 We seek some syntactic transformation of a property 
\begin_inset Formula $\phi$
\end_inset

 and action conditions 
\begin_inset Formula $\alpha$
\end_inset

 into a uniform formula 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$
\end_inset

 that is true at precisely the situations in which 
\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Definition
The persistence condition 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$
\end_inset

 is a uniform formula that is the weakest precondition for the persistence
 of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
 That is:
\begin_inset LatexCommand \label{def:persistence-condition}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P_{D}}[\phi,\alpha][s]\,\equiv\,\forall s'\, s\leq_{\alpha}s'\rightarrow\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
Intuitively, we will approximate 
\begin_inset Formula $\mathcal{P}[\phi,\alpha]$
\end_inset

 by asserting that 
\begin_inset Formula $\phi$
\end_inset

 persists for all situations up to 
\begin_inset Formula $n$
\end_inset

 deep in the future of 
\begin_inset Formula $s$
\end_inset

, and increasing 
\begin_inset Formula $n$
\end_inset

 until the proof that this persists if straightforward.
 We first develop the theoretical justification for our algorithm below.
\end_layout

\begin_layout Subsection
Formal Development
\end_layout

\begin_layout Standard
We begin by adapting two existing results involving induction to operate
 with the generalised 
\begin_inset Formula $<_{\alpha}$
\end_inset

 notation, and be based at situations other than 
\begin_inset Formula $S_{0}$
\end_inset

:
\end_layout

\begin_layout Proposition
For any action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, the foundational axioms of the situation calculus entail:
\begin_inset LatexCommand \label{prop:a-order-induction}

\end_inset


\begin_inset Formula \begin{multline*}
\forall W,s\,\, W(s)\wedge\left[\forall a,s'\,\,\alpha(a,s')\wedge s\leq_{\alpha}s'\wedge W(s')\rightarrow W(do(a,s'))\right]\\
\rightarrow\forall s'\,\, s\leq_{\alpha}s'\rightarrow W(s')\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
A straightforward adaptation of Theorem 1 in 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
\end_layout

\begin_layout Proposition
For any basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset LatexCommand \label{prop:a-order-reduction}

\end_inset


\begin_inset Formula \[
\mathcal{D}\models\forall s\,\,\phi[s]\rightarrow\left(\forall s'\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\]

\end_inset

iff
\begin_inset Formula \[
\mathcal{D}_{una}\models\forall s,a\,\,\phi[s]\wedge\alpha(a,s)\rightarrow\mathcal{R}_{\mathcal{D}}[\phi[do(a,s)]]\]

\end_inset


\end_layout

\begin_layout Proof
A straightforward adaptation of Lemma 5 in 
\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset

.
\end_layout

\begin_layout Proof
Proposition 
\begin_inset LatexCommand \ref{prop:a-order-reduction}

\end_inset

 will be key in the development of our algorithm.
 It allows one to establish the result 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

, then 
\begin_inset Formula $\phi$
\end_inset

 persists in 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

 by checking entailment of a uniform fomula by the unique names axioms,
 a straightforward first-order reasoning task.
\end_layout

\begin_layout Proof
Next, we must define the notion of a property 
\begin_inset Quotes eld
\end_inset

persisting to depth 
\begin_inset Formula $n$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Definition
A uniform formula 
\begin_inset Formula $\phi$
\end_inset

 persists to depth 1 under 
\begin_inset Formula $\alpha$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

 when the formula 
\begin_inset Formula $\mathcal{P}_{D}^{1}[\phi,\alpha]$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

, as defined by:
\begin_inset LatexCommand \label{def:persists-depth-n}

\end_inset


\begin_inset Formula \[
\mathcal{P}_{D}^{1}[\phi,\alpha][s]\isdef\phi[s]\,\wedge\,\forall a\,\alpha(a,s)\rightarrow\mathcal{R_{D}}[\phi[do(a,s)]]\]

\end_inset


\end_layout

\begin_layout Definition
For any 
\begin_inset Formula $n\geq0$
\end_inset

, a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 
\begin_inset Quotes eld
\end_inset

persists to depth 
\begin_inset Formula $n$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset


\begin_inset Quotes erd
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

 when the formula 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

, as defined by:
\begin_inset Formula \[
\mathcal{P_{D}}^{n}[\phi,\alpha]\isdef\mathcal{P_{D}}^{1}[\mathcal{P}_{D}^{n-1}[\phi,\alpha],\alpha]\]

\end_inset


\begin_inset Formula \[
\mathcal{P_{D}}^{0}[\phi,\alpha]\isdef\phi\]

\end_inset


\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $\mathcal{P_{D}}^{1}$
\end_inset

 is a literal encoding of the requirement 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and in all direct successors of 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

, using regression to keep the expression uniform in 
\begin_inset Formula $s$
\end_inset

.
 Successive applications of this operator will require persistence of 
\begin_inset Formula $\phi$
\end_inset

 to greater depths.
 Clearly persistence to depth 
\begin_inset Formula $n$
\end_inset

 is closely related to persistence in general, as the following two lemmas
 formalize.
\end_layout

\begin_layout Lemma
Given a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, action description predicate 
\begin_inset Formula $\alpha$
\end_inset

 and situation term 
\begin_inset Formula $s$
\end_inset

, for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset LatexCommand \label{lem:p-equiv-p(pn)}

\end_inset


\begin_inset Formula \[
\mathcal{D}\models\forall s'\, s\leq_{\alpha}s'\rightarrow\phi[s]\,\,\equiv\,\,\forall s'\, s\leq_{\alpha}s'\rightarrow\mathcal{P}_{D}^{n}[\phi,\alpha]\]

\end_inset

That is, 
\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

 precisely when 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Proof
Trivial, from the definition of 
\begin_inset Formula $\mathcal{P_{D}}^{n}$
\end_inset

.
 Note that any 
\begin_inset Formula $s'$
\end_inset

 that falsifies the right-hand side of the equivalence will also falsify
 the left-hand side, and vice-versa.
 
\end_layout

\begin_layout Lemma
Given a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset LatexCommand \label{lem:p-implies-pn}

\end_inset


\begin_inset Formula \[
\mathcal{D}\models\forall s\,\,\mathcal{P_{D}}[\phi,\alpha][s]\rightarrow\mathcal{P_{D}}^{n}[\phi,\alpha][s]\]

\end_inset


\end_layout

\begin_layout Proof
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

 implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

 by definition, which implies 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

 by lemma 
\begin_inset LatexCommand \ref{lem:p-equiv-p(pn)}

\end_inset

.
\end_layout

\begin_layout Proof
We are now equipped to prove the major theorem of this paper: that if 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

 will persist whenever it holds, then 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

 is equivalent to the persistence condition for 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Theorem
Given a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

 and action-indexed fluent 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset LatexCommand \label{thm:p(pn)-equiv-p}

\end_inset


\begin_inset Formula \begin{equation}
\mathcal{D}_{una}\models\forall s,a\,\mathcal{P_{D}}^{n}[\phi,\alpha][s]\wedge\alpha(a,s)\rightarrow\mathcal{R}[\mathcal{P_{D}}^{n}[\phi,\alpha][do(a,s)]]\label{eqn:pn_persists}\end{equation}

\end_inset

iff
\begin_inset Formula \begin{equation}
\mathcal{D}\models\forall s\,\,\mathcal{P_{D}}^{n}[\phi,\alpha][s]\equiv\mathcal{P_{D}}[\phi,\alpha][s]\label{eqn:pn_equiv_persists}\end{equation}

\end_inset


\end_layout

\begin_layout Proof
For the 
\emph on
if 
\emph default
direction, we see by proposition 
\begin_inset LatexCommand \ref{prop:a-order-reduction}

\end_inset

 that equation 
\begin_inset LatexCommand \ref{eqn:pn_persists}

\end_inset

 implies the persistence of 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
 By lemma 
\begin_inset LatexCommand \ref{lem:p-equiv-p(pn)}

\end_inset

 this implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

, which in turn implies 
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

, giving 
\begin_inset Formula $\mathcal{D}\models\forall s\,\,\mathcal{P_{D}}^{n}[\phi,\alpha][s]\rightarrow\mathcal{P_{D}}[\phi,\alpha][s]$
\end_inset

.
 By lemma 
\begin_inset LatexCommand \ref{lem:p-implies-pn}

\end_inset

 we have 
\begin_inset Formula $\mathcal{D}\models\forall s\,\,\mathcal{P_{D}}[\phi,\alpha][s]\rightarrow\mathcal{P_{D}}^{n}[\phi,\alpha][s]$
\end_inset

, yielding the required equivlance in equation 
\begin_inset LatexCommand \ref{eqn:pn_equiv_persists}

\end_inset

.
\end_layout

\begin_layout Proof
The 
\emph on
only if
\emph default
 direction is a straightforward reversal of this reasoning: 
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

 implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

, which implies the persistence of 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

, which implies 
\begin_inset LatexCommand \ref{eqn:pn_persists}

\end_inset

 by proposition 
\begin_inset LatexCommand \ref{prop:a-order-reduction}

\end_inset

.
\end_layout

\begin_layout Subsection
Algorithm Determining the Persistence Condition
\end_layout

\begin_layout Standard
Since we can calculuate 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

 for any 
\begin_inset Formula $n$
\end_inset

, we have a straightforward algorithm for determining 
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

: search for an 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula \[
\mathcal{D}_{una}\models\forall s,a\,\mathcal{P_{D}}^{n}[\phi,\alpha][s]\wedge\alpha(a,s)\rightarrow\mathcal{R_{D}}[\mathcal{P_{D}}^{n}[\phi,\alpha][do(a,s)]]\]

\end_inset


\end_layout

\begin_layout Standard
Since we expect 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

 to be simpler than 
\begin_inset Formula $\mathcal{P_{D}}^{n+1}[\phi,\alpha]$
\end_inset

, we should look for the smallest such 
\begin_inset Formula $n$
\end_inset

.
 Algorithm 
\begin_inset LatexCommand \ref{alg:calc_p}

\end_inset

 presents an iterative procedure for doing just that.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{algorithm}
\end_layout

\begin_layout Standard


\backslash
caption{Calculate $
\backslash
mathcal{P}[
\backslash
phi,
\backslash
alpha]$}
\end_layout

\begin_layout Standard


\backslash
label{alg:calc_p}
\end_layout

\begin_layout Standard


\backslash
begin{algorithmic}
\end_layout

\begin_layout Standard


\backslash
STATE $n 
\backslash
Leftarrow 0$
\end_layout

\begin_layout Standard


\backslash
LOOP
\end_layout

\begin_layout Standard

  
\backslash
IF{$
\backslash
mathcal{D}_{una} 
\backslash
models 
\backslash
forall s,a 
\backslash
mathcal{P}^n[
\backslash
phi
\backslash
alpha][s]
\backslash
wedge 
\backslash
alpha(a,s) 
\backslash
rightarrow 
\backslash
mathcal{R}[
\backslash
mathcal{P}^n[
\backslash
phi
\backslash
alpha][do(a,s)]]$}
\end_layout

\begin_layout Standard

     
\backslash
STATE return $
\backslash
mathcal{P}^n[
\backslash
phi
\backslash
alpha]$
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

  
\backslash
ENDIF
\end_layout

\begin_layout Standard

  
\backslash
STATE $n 
\backslash
Leftarrow n + 1$
\end_layout

\begin_layout Standard


\backslash
ENDLOOP
\end_layout

\begin_layout Standard


\backslash
end{algorithmic}
\end_layout

\begin_layout Standard


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Correctness
\end_layout

\begin_layout Standard
If algorithm 
\begin_inset LatexCommand \ref{alg:calc_p}

\end_inset

 terminates, it terminates returning the persistence condition of 
\begin_inset Formula $\phi$
\end_inset

 with respect to 
\begin_inset Formula $\alpha$
\end_inset

.
 This correctness is guaranteed by theorem 
\begin_inset LatexCommand \ref{thm:p(pn)-equiv-p}

\end_inset

 and the fact the the algorithm only terminates for an 
\begin_inset Formula $n$
\end_inset

 where equation 
\begin_inset LatexCommand \ref{eqn:pn_persists}

\end_inset

 is valid.
\end_layout

\begin_layout Standard
Note that equation 
\begin_inset LatexCommand \ref{eqn:pn_persists}

\end_inset

 is valid when 
\begin_inset Formula $\mathcal{P_{D}}^{n}[\phi,\alpha]$
\end_inset

 is unsatisfiable for any situation, as it appears in the antecedent of
 the implication.
 The algorithm thus correctly returns an unsatisfiable condition (equivalent
 to 
\begin_inset Formula $false$
\end_inset

) when the formula 
\begin_inset Formula $\phi$
\end_inset

 can never persist under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Completeness
\end_layout

\begin_layout Standard
As theorem 
\begin_inset LatexCommand \ref{thm:p(pn)-equiv-p}

\end_inset

 is an equivalence, the only source of incompleteness will be failure to
 terminate.
 Algorithm 
\begin_inset LatexCommand \ref{alg:calc_p}

\end_inset

 may fail to terminate for two reasons: the return condition may never be
 satisfied and so the algorithm may loop forever, or the first-order logical
 inference in the loop condition may be undecidable and fail to terminate.
\end_layout

\begin_layout Standard
The later indicates that the basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

 is undecidable.
 While this is a concern, it affects more than just our algorithm - any
 system implemented on top of such an action theory maybe incomplete.
 Thus, with respect to this feature, our algorithm is no more incomplete
 than the larger system it would form a part of.
\end_layout

\begin_layout Standard
The former is of more direct consequence to our work: for a decidable action
 theory, when can the loop condition be guaranteed to be met? Or, in other
 words, when can we guarantee that persistence can be verified at finite
 depth?
\end_layout

\begin_layout Standard
TODO: so, when can it? Come up with something convincing.
\end_layout

\begin_layout Subsubsection
Efficiency
\end_layout

\begin_layout Standard
Our algorithm has replaced a single reasoning task based on the full action
 theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

 with a (potentially large) number of reasoning tasks based on the unique
 names axioms 
\begin_inset Formula $\mathcal{D}_{una}$
\end_inset

.
 We believe the increased number of reasoning tasks is offset by several
 clear increases in efficiency.
\end_layout

\begin_layout Standard
First and foremost, we avoid the need for the second-order induction axiom.
 All the reasoning tasks can be performed using standard first-order reasoning,
 for which there are many high-quality automated proovers.
 In addition, we have greatly reduced the number of axioms required for
 the reasoning task.
 Similarly to the regression operator, we have removed the need for the
 foundational axioms, successor state axioms and possibility axioms by compiling
 their effects into the formula under consideration.
 
\end_layout

\begin_layout Standard
Of course, we also inherit the potential disadvantage of the regression
 operator: the formula 
\begin_inset Formula $\mathcal{P_{D}}[\phi,\alpha]$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 As with regression, our experience has been that this is rarely a problem,
 and is compensated for by the reduced number of axioms required for reasoning.
 Unlike regression, this tradeoff is improved even more by the transition
 from second-order to first-order logic.
\end_layout

\begin_layout Subsection
Applications
\end_layout

\begin_layout Paragraph
Goal Impossibility:
\end_layout

\begin_layout Standard
Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no possible situation in which that goal is satisfied:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P_{D}}[\neg G,Poss][S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
The persistence condition of 
\begin_inset Formula $\neg G$
\end_inset

 with respect to all possible situations allows goal impossibility to be
 checked easily.
\end_layout

\begin_layout Paragraph
Goal Futility:
\end_layout

\begin_layout Standard
Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $s$
\end_inset

, establish that the goal cannot be satisfied in any possible situation
 in the future of 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P_{D}}[\neg G,Poss][s]\]

\end_inset


\end_layout

\begin_layout Standard
Precisely the same formula is required for checking goal impossibility and
 goal futility.
 This highlights an important advantage of our approach - the persistence
 condition can be cached and re-used.
 This would make it feasible for an agent to check for goal futility each
 time it considers performing an action, and avoid situations that would
 make its goals unachievable.
 
\end_layout

\begin_layout Paragraph
Checking State Constraints:
\end_layout

\begin_layout Standard
This can be handled as per goal impossibility above.
\end_layout

\begin_layout Paragraph
Need for Cooperation:
\end_layout

\begin_layout Standard
To establish that it needs to cooperate with another agent, an agent must
 determine persistence with respect to actions performed by itself:
\begin_inset Formula \begin{multline}
\mathcal{D}\models\mathcal{P_{D}}[\neg G,agent()=agt][s]\end{multline}

\end_inset


\end_layout

\begin_layout Paragraph
Knowledge under Partial Observability:
\end_layout

\begin_layout Standard
TODO: put equation here.
\end_layout

\begin_layout Section
Related Work
\begin_inset LatexCommand \label{sec:Related-Work}

\end_inset


\end_layout

\begin_layout Standard
While there is a rich and diverse literature base on the situation calculus,
 there appears to have been little work on automating universally quantified
 queries.
 That which we are aware of focusses exclusively on verifying pre-existing
 integrity constraints - uniform formulae that must hold in every possible
 situation.
 
\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset

 show how the induction axiom can be 
\begin_inset Quotes eld
\end_inset

compiled away
\begin_inset Quotes erd
\end_inset

 when verifying that an integrity constraint holds, with the development
 of (a less general form of) proposition 
\begin_inset LatexCommand \ref{prop:a-order-reduction}

\end_inset

.
 
\begin_inset LatexCommand \cite{bertossi96automating}

\end_inset

 describe an automated system for checking integrity constraints based on
 an induction theorem prover.
\end_layout

\begin_layout Standard
Our approach generalises such work in several important ways.
 It can consider an arbitrary 
\begin_inset Formula $\alpha$
\end_inset

-ordering over situations, not just the standard ordering over possibility,
 enabling us to treat problems such as need for cooperation and knowledge
 under partial observability.
 It can prove that properties hold in the future of an arbitrary situation,
 not necessary the initial situation, enabling us to answer the question
 of goal futility.
 And the results of calculating the persistence condition can be cached
 for later re-use - this allows, for example, the goal futility question
 to be efficiently posed on a large number of situations once the persistence
 condition has been calculated.
\end_layout

\begin_layout Standard
Another advantage of the persistence condition approach is its similarity
 to the regression operator, an established technique for reasoning in the
 situation calculus.
 The two operators can interact very successfully.
 In [TODO:cite ourselves] we use the persistence condition operator to define
 regression over an account of knowledge that requires universal quantification
 over situations.
\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand \label{sec:Conclusions}

\end_inset


\end_layout

\begin_layout Standard
TODO: we've done good work, very useful, blah blah blah blah
\end_layout

\begin_layout Section
TODO
\end_layout

\begin_layout Standard
Formal assumption to make this workable: finite number of action types?
 fluents affected by finite number of actions?
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
bibliographystyle{plain}
\end_layout

\end_inset

 
\begin_inset LatexCommand \bibtex[plain]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
