#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass llncs
\begin_preamble

\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}

\usepackage{algorithm}
\usepackage{algorithmic}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 2
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Property Persistence in the Situation Calculus
\end_layout

\begin_layout Author
Ryan Kelly 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
and
\end_layout

\end_inset

 Adrian Pearce
\end_layout

\begin_layout Institute
NICTA Victoria Laboratory
\newline
Department of Computer Science and Software Engineering
\newline

 The University of Melbourne
\newline
 Victoria, 3010, Australia
\newline
 {rfk,adrian}@csse.unimelb.e
du.au
\end_layout

\begin_layout Abstract
Universal quantification in the situation calculus requires the use of a
 second-order induction axiom, which can be problematic for automated reasoning.
 We show how to replace this with iterated first-order reasoning for a special
 class of universally-quantified queries - the persistence of a property
 in all futures of a given situation.
 We give several examples of important reasoning tasks can be posed as persisten
ce queries, and demonstrate the effectiveness of our procedure for answering
 them.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 is one of the most popular formalisms for reasoning about dynamics worlds.
 Based on first-order logic, its attractive features include an elegant
 monotonic solution to the frame problem and an effective reasoning procedure
 for the projection problem based on the regression meta-operator 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

.
 These have facilitated the implementation of a wide range of agent systems.
 
\end_layout

\begin_layout Standard
However, a complete axiomatisation of the situation calculus requires a
 second-order induction axiom that defines the set of all situations 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
 For effective automated reasoning it is important to limit queries to syntactic
 forms which can be proven without using induction, and so require only
 first-order reasoning.
 This includes sentences containing positive 
\emph on
existential
\emph default
 quantification over situation terms 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 and thus encompasses a wide range of queries.
\end_layout

\begin_layout Standard
Unfortunately, there are many useful reasoning tasks that require 
\emph on
universal
\emph default
 quantification over situations.
 For example, it is often useful to determine whether 
\emph on
any
\emph default
 situation exists that satisfies a given goal.
 In this paper we are interested in a subset of such queries which we refer
 to as the 
\emph on
persistence problem
\emph default
: given some formula 
\begin_inset Formula $\phi$
\end_inset

 and situation 
\begin_inset Formula $s$
\end_inset

, determine whether 
\begin_inset Formula $\phi$
\end_inset

 will hold in all situations in the future of 
\begin_inset Formula $s$
\end_inset

.
 The need for second-order logic has traditionally limited automated reasoning
 about such queries.
\end_layout

\begin_layout Standard
In the spirit of regression, we introduce a new meta-operator 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 that takes a formula 
\begin_inset Formula $\phi$
\end_inset

 and produces a formula 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi]$
\end_inset

 that is equivalent to the persistence problem for 
\begin_inset Formula $\phi$
\end_inset

.
 We term this the 
\emph on
persistence condition
\emph default
 of 
\begin_inset Formula $\phi$
\end_inset

, and it is guaranteed to be of a form that is amenable to first-order reasoning.
 As the algorithm for determining the persistence condition also employs
 purely first-order reasoning, the result is an effective procedure with
 which to answer some queries that universally quantify over situations.
\end_layout

\begin_layout Standard
The paper is organised as follows: section 
\begin_inset LatexCommand \ref{sec:Background}

\end_inset

 gives a brief introduction to the situation calculus and formally defines
 the persistence problem; section 
\begin_inset LatexCommand \ref{sec:Persistence-Condition}

\end_inset

 develops the persistence condition operator and proves that it behaves
 as required; TODO: finish off this list.
\end_layout

\begin_layout Section
Background
\begin_inset LatexCommand \label{sec:Background}

\end_inset


\end_layout

\begin_layout Standard
Our work is based on the situation calculus as described in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 A brief overview is presented below.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic, augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Action
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built up using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 We also distinguish 
\noun on
Fluents
\noun default
 as predicates or functions representing properties of the world that may
 change from one situation to another, and so take a situation term as their
 final argument.
\end_layout

\begin_layout Standard
A collection of situation calculus statements 
\begin_inset Formula $\mathcal{D}$
\end_inset

 that describe the behavior of a dynamic world is referred to as a 
\emph on
basic action theory
\emph default
.
 It consists of disjoint sets of statements captuing the foundational axioms
 of the situation calculus, successor state axioms for fluents, precondition
 axioms for actions, unique names axioms for actions, and axioms describing
 the initial situation:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}=\Sigma\cup\mathcal{D}_{ss}\cup\mathcal{D}_{ap}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
An action theory must also satisfy some basic consistency constraints.
 Queries about the behavior or evolution of the world are posed as logical
 entailment queries relative to the theory of action.
\end_layout

\begin_layout Subsubsection
Uniform Formulae
\end_layout

\begin_layout Standard
An important class of formulae in the situation calculus are the 
\emph on
uniform formulae
\emph default
 - those that refer to a single situation term, and do not mention the action
 precondition predicate 
\begin_inset Formula $Poss$
\end_inset

 or ordering over situations.
 Such formulae can be thought of as describing a 
\emph on
property 
\emph default
of the state of the world, as they are basically logical combinations of
 fluents refering to a common situation.
 Throughout this paper, we will use the meta-variable 
\begin_inset Formula $\phi$
\end_inset

 to refer to an arbitrary uniform formula.
\end_layout

\begin_layout Standard
It is often useful to determine the truth of a property at a given situation.
 The formula 
\begin_inset Formula $\phi[s]$
\end_inset

 represents the uniform formula 
\begin_inset Formula $\phi$
\end_inset

 with all occurrences of its unique situation term replaced by the situation
 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Foundational Axioms
\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 are a set of four axioms that describe the basic behavior of a situation
 calculus domain, and are independent of any particular domain application.
 Of most import here is the induction axiom that defines the set of all
 situations:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\forall P\,\left[P(S_{0})\wedge\forall s,a\,\left(P(s)\rightarrow P(do(a,s))\right)\rightarrow\forall s\, P(s)\right]\]

\end_inset


\end_layout

\begin_layout Standard
The fundamental importance of this axiom is described in 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
 Since it is second-order and thus traditionally problematic for automated
 reasoning systems, much research has focussed on identifying sentences
 of the situation calculus that can be proved without induction.
\end_layout

\begin_layout Subsubsection
Action Precondition Axioms
\end_layout

\begin_layout Standard
There is a distinguished fluent predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 For example, it is only possible to drop an object if one is actually holding
 it: 
\begin_inset Formula \[
Poss(drop(obj),s)\equiv Holding(obj,s)\]

\end_inset


\end_layout

\begin_layout Standard
The set of action precondition axioms 
\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

 contains one such axiom for each action function 
\begin_inset Formula $A$
\end_inset

, of the general form:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Poss(A(\overrightarrow{x}),s)\equiv\Pi_{A}(\overrightarrow{x},s)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\Pi_{A}$
\end_inset

 is required to be uniform in 
\begin_inset Formula $s$
\end_inset

.
 It is often useful to introduce other predicates with a similar form and
 purpose, which we shall refer to as 
\emph on
action-indexed fluents
\emph default
 to distinguish them from regular fluents.
 As they are defined on a per-action basis, they require special treatment
 from the regression operator (and, as we shall see, from the persistence
 condition operator).
\end_layout

\begin_layout Subsubsection
Regression
\end_layout

\begin_layout Standard
One of the principle attractions of the situation calculus is the existence
 of efficient reasoning procedures for certain types of query.
 The principle tool is the regression meta-operator 
\begin_inset LatexCommand \cite{reiter91frameprob,pirri99contributions_sitcalc}

\end_inset

 which transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into a formula 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}[\phi]$
\end_inset

 uniform in 
\begin_inset Formula $s$
\end_inset

, such that the two are equivalent relative to the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

.
 By repeatedly applying
\begin_inset Foot
status collapsed

\begin_layout Standard
It is also possible to define a single-pass regression operator that directly
 transforms 
\begin_inset Formula $\phi$
\end_inset

 into a formula uniform in 
\begin_inset Formula $S_{0}$
\end_inset

.
 The single-step version described here is more useful for our work.
\end_layout

\end_inset

 the regression operator, 
\begin_inset Formula $\phi$
\end_inset

 can be transformed into an equivalent formula uniform in the initial situation:
\begin_inset Formula \[
\mathcal{D}\models\phi[do(c_{1},do(c_{2},\dots,do(c_{n},S_{0}))]\equiv\mathcal{R}_{\mathcal{D}}^{*}[\phi][S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Many of the axioms from 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required for reasoning about the initial situation, and so can
 be discarded when reasoning about 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}(\phi)[S_{0}]$
\end_inset

.
 Most importantly, the induction axiom is not needed so the reasoning is
 purely first-order.
 The successor state and action precondition axioms are also not required.
 The trade-off is that the length of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}(\phi)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice.
\end_layout

\begin_layout Standard
The regression operator is only defined for formulae that meet a number
 of requirements, the so-called 
\begin_inset Quotes eld
\end_inset

regressable formulas
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize
the formula is first-order
\end_layout

\begin_layout Itemize
all situation terms in the formula are of the form 
\begin_inset Formula $do(\alpha,s)$
\end_inset

 for some action term 
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\begin_layout Itemize
for every acton-indexed fluent mentioned by the formula, its argument has
 the form 
\begin_inset Formula $A(\overrightarrow{x})$
\end_inset

 for some action function symbol 
\begin_inset Formula $A$
\end_inset

.
\end_layout

\begin_layout Standard
TODO: explain why these are needed, briefly
\end_layout

\begin_layout Standard
TODO: somewhere define ordering on situations
\end_layout

\begin_layout Subsubsection
Axiom Reduction
\end_layout

\begin_layout Standard
As noted previously, reasoning about an arbitrary sentence 
\begin_inset Formula $\psi$
\end_inset

 of the situation calculus is an entailment problem of second-order logic:
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\psi\]

\end_inset


\end_layout

\begin_layout Standard
Fortunately, there exist particular syntactic forms for which some of the
 axioms in 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required.
 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 define the 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\exists$
\end_inset

s sentences
\begin_inset Quotes erd
\end_inset

 as those in which every situation variable is in the scope of positive
 existential quantifier, and show that they can always be proven without
 the induction axioms (which we denote 
\begin_inset Formula $I$
\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\psi\,\,\, iff\,\,\,\mathcal{D}-\{ I\}\models_{FOL}\psi\]

\end_inset


\end_layout

\begin_layout Standard
To assist their work on state constraints in the situation calculus, 
\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset

 appeal to the fact that universally quantified uniform formulae can be
 proven using only the unique names axioms: (TODO: double-check this)
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\forall s\,\phi[s]\,\,\, iff\,\,\,\mathcal{D}_{una}\models_{FOL}\forall s\,\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
This means such formulae are among the most straightforward to prove.
 We will use this result frequently to justify of our algorithm for the
 persistence condition operator.
\end_layout

\begin_layout Subsubsection
Property Persistence
\end_layout

\begin_layout Standard
One interesting form of query requiring universal quantification over situations
 is to ask whether a given property 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\emph on
all future situations
\emph default
 of a given situation 
\begin_inset Formula $s$
\end_inset

, as well as at 
\begin_inset Formula $s$
\end_inset

 itself:
\begin_inset Formula \[
\mathcal{D}\models\forall s'\, s\leq s'\rightarrow\phi(s')\]

\end_inset


\end_layout

\begin_layout Standard
More generally, we way wish to limit the futures considered to those brought
 about by a certain class of actions.
 Suppose that 
\begin_inset Formula $\alpha(a,s)$
\end_inset

 is a formula that is true for precisely those actions 
\begin_inset Formula $a$
\end_inset

 that are to be considered, then we are intereted in whether:
\begin_inset Formula \begin{multline}
\mathcal{D}\models\forall s''\,\left(s\leq s''\wedge\neg\exists a',s'\, s<do(a',s')\leq s''\wedge\neg\alpha(a',s')\right)\rightarrow\phi[s'']\end{multline}

\end_inset


\end_layout

\begin_layout Standard
In words this states 
\begin_inset Quotes eld
\end_inset

given that no actions occur that do not match 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 will remain true
\begin_inset Quotes erd
\end_inset

.
 We term queries of this form 
\emph on
property persistence 
\emph default
queries.
 Such queries appear in many useful reasoning tasks; the following are a
 small selection:
\end_layout

\begin_layout Paragraph
Goal Impossibility:
\end_layout

\begin_layout Standard
Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no possible situation in which that goal is satisfied:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models\forall s\,\left(S_{0}\leq s\wedge\neg\exists a',s'\, S_{0}<do(a',s')\leq s\wedge\neg Poss(a',s')\right)\rightarrow\neg G(s)\]

\end_inset


\end_layout

\begin_layout Paragraph
Goal Futility:
\end_layout

\begin_layout Standard
Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $s$
\end_inset

, establish that the goal cannot be satisfied in any possible situation
 in the future of 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models\forall s''\,\left(s\leq s''\wedge\neg\exists a',s'\, s<do(a',s')\leq s''\wedge\neg Poss(a',s')\right)\rightarrow\neg G(s)\]

\end_inset


\end_layout

\begin_layout Standard
Note that this is subtly different from goal impossibility - while the agent
 may have initially been able to achieve the goal, the actions that have
 subsequently been performed have rendered the goal unachievable.
 Agents would be well advised to avoid such situations.
\end_layout

\begin_layout Paragraph
Checking State Constraints:
\end_layout

\begin_layout Standard
This is a variant of goal impossibility - show that the state constraint
 can never be violated.
\end_layout

\begin_layout Paragraph
Need for Cooperation:
\end_layout

\begin_layout Standard
To establish that it needs to cooperate with another agent, an agent must
 determine persistence with respect to actions performed by itself:
\begin_inset Formula \begin{multline}
\mathcal{D}\models\forall s''\,\left(S_{0}\leq s\wedge\neg\exists a',s'\, S_{0}<do(a',s')\leq s\wedge\neg agent(a)=agt\right)\rightarrow\neg G[s'']\end{multline}

\end_inset


\end_layout

\begin_layout Standard
In words this states that no situation in the future of 
\begin_inset Formula $s$
\end_inset

 can satisfy 
\begin_inset Formula $G$
\end_inset

, if all the actions that brought about that situation were performed by
 
\begin_inset Formula $agt$
\end_inset

.
 If this is valid, then 
\begin_inset Formula $agt$
\end_inset

 will need to cooperate with another agent in order to achieve its goal.
\end_layout

\begin_layout Paragraph
Knowledge under Partial Observability:
\end_layout

\begin_layout Standard
In recent unpublished work, we develop a new account of knowledge in the
 situation calculus when not all actions are observable by all agents.
 To facilitate reasoning in this formalism, agents must be able to reason
 about what cannot be changed by actions that they cannot observe:
\end_layout

\begin_layout Standard
TODO: put equation here.
\end_layout

\begin_layout Section
Persistence Condition
\begin_inset LatexCommand \label{sec:Persistence-Condition}

\end_inset


\end_layout

\begin_layout Standard
For implementing practial agent systems, we need to replace quantification
 over situations with a more tractable form of reasoning - specifically,
 evaluation of a uniform formula at a specific situation.
 That is, we would like some syntactic transformation 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$
\end_inset

 of a property 
\begin_inset Formula $\phi$
\end_inset

 and action conditions 
\begin_inset Formula $\alpha$
\end_inset

 such that:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models\left[\forall s''\,\left(s\leq s''\wedge\neg\exists a',s'\, s<do(a',s')\leq s''\wedge\neg\alpha(a',s')\rightarrow\phi[s]\right)\right]\,\equiv\,\mathcal{P}_{\mathcal{D}}[\phi,\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
We call 
\begin_inset Formula $\mathcal{P}[\phi,\alpha]$
\end_inset

 the 
\emph on
persistence condition
\emph default
 of formula 
\begin_inset Formula $\phi$
\end_inset

 with respect to the class of actions 
\begin_inset Formula $\alpha$
\end_inset

.
 The main purpose of this paper is to develop an algorithm that constructs
 the persistence condition for a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Standard
The construction of the persistence condition is intuitively straightforward.
 Let 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha]$
\end_inset

 be a formula uniform in 
\begin_inset Formula $s$
\end_inset

 that is true precisely when 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate successors where the action satisfies 
\begin_inset Formula $\alpha$
\end_inset

.
 A candidate defnition for such a formula would be:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha]\isdef\phi\wedge\forall a\,\phi(do(a,s))\vee\neg\alpha(a,s)\]

\end_inset


\end_layout

\begin_layout Standard
Unfortunately, this cannot be used because the right-hand side is not uniform
 in 
\begin_inset Formula $s$
\end_inset

.
 By applying the regression operator, we can obtain an equivalent definition
 that is uniform in 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha]\isdef\phi\wedge\forall a\,\mathcal{R}_{\mathcal{D}}[\phi(do(a,s))]\vee\neg\alpha(a,s)\]

\end_inset


\end_layout

\begin_layout Standard
We construct the operator 
\begin_inset Formula $\mathcal{P}$
\end_inset

 from 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

 by induction.
 Intuitively, if 
\begin_inset Formula $\mathcal{P}^{1}[\phi]$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate sucecssors, then 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\begin_inset Formula $s$
\end_inset

 and all successors up to depth two:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{P}^{2}[\phi,\alpha]\isdef\mathcal{P}^{1}[\mathcal{P}^{1}[\phi,\alpha],\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
This generalises in a straightforward way to arbitrarily deep successors:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{P}^{n}[\phi,\alpha]\isdef\mathcal{P}^{1}[\mathcal{P}^{n-1}[\phi,\alpha],\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
By the definition of 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

 it is clear that, for any 
\begin_inset Formula $n$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P}^{n+1}[\phi,\alpha]\rightarrow\mathcal{P}^{n}[\phi,\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
If it is possible to show that there is an 
\begin_inset Formula $n$
\end_inset

 such that:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P}^{n}[\phi,\alpha]\rightarrow\mathcal{P}^{n+1}[\phi,\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
Then we have shown logical equivalence of all further applications of 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P}^{n}[\phi,\alpha]\equiv\mathcal{P}^{m}[\phi,\alpha]\,,for\, all\, m>n\]

\end_inset


\end_layout

\begin_layout Standard
This 
\begin_inset Formula $\mathcal{P}^{n}$
\end_inset

 can thus be considered a fixed-point of 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

, which we shall denote
\begin_inset Formula $\mathcal{P}[\phi,\alpha]$
\end_inset

.
 It is a simple inductive argument to show that, as required:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\left[\forall s''\, s\leq s''\rightarrow\phi(s'')\vee\exists a,s'\, s<do(a,s')\leq s''\wedge\neg\alpha(a,s)\right]\,\equiv\,\mathcal{P}[\phi,\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
Given the definitions of 
\begin_inset Formula $\mathcal{R}$
\end_inset

 and 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

, the following algorithm will determine the persistence condition for a
 formula 
\begin_inset Formula $\phi$
\end_inset

 and class of actions 
\begin_inset Formula $\alpha$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{algorithm}
\end_layout

\begin_layout Standard


\backslash
caption{Calculate $
\backslash
mathcal{P}_
\backslash
mathcal{D}[
\backslash
phi,
\backslash
alpha]$}
\end_layout

\begin_layout Standard


\backslash
begin{algorithmic}
\end_layout

\begin_layout Standard


\backslash
STATE $p_n 
\backslash
Leftarrow 
\backslash
phi$
\end_layout

\begin_layout Standard


\backslash
STATE $p_{n+1} 
\backslash
Leftarrow 
\backslash
mathcal{P}^1[
\backslash
phi,
\backslash
alpha]$
\end_layout

\begin_layout Standard


\backslash
LOOP
\end_layout

\begin_layout Standard

  
\backslash
IF{$
\backslash
mathcal{D}_{una} 
\backslash
models p_n 
\backslash
rightarrow p_{n+1}$}
\end_layout

\begin_layout Standard

    
\backslash
STATE return $p_n$
\end_layout

\begin_layout Standard

  
\backslash
ELSIF{$
\backslash
mathcal{D}_{una} 
\backslash
models p_n 
\backslash
rightarrow 
\backslash
neg p_{n+1}$}
\end_layout

\begin_layout Standard

    
\backslash
STATE return $false$
\end_layout

\begin_layout Standard

  
\backslash
ENDIF
\end_layout

\begin_layout Standard

  
\backslash
STATE $p_n 
\backslash
Leftarrow p_{n+1}$
\end_layout

\begin_layout Standard

  
\backslash
STATE $p_{n+1} 
\backslash
Leftarrow 
\backslash
mathcal{P}^1[
\backslash
phi,
\backslash
alpha]$
\end_layout

\begin_layout Standard


\backslash
ENDLOOP
\end_layout

\begin_layout Standard


\backslash
end{algorithmic}
\end_layout

\begin_layout Standard


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Section
TODO
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Formal assumption to make this workable: finite number of action types?
 fluents affected by finite number of actions?
\end_layout

\begin_layout Standard
Reference 
\begin_inset LatexCommand \cite{bertossi96automating}

\end_inset

 in related work
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
bibliographystyle{plain}
\end_layout

\end_inset

 
\begin_inset LatexCommand \bibtex[plain]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
