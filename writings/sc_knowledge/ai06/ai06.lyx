#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass llncs
\begin_preamble

\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 2
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Property Persistence in the Situation Calculus
\end_layout

\begin_layout Author
Ryan Kelly 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
and
\end_layout

\end_inset

 Adrian Pearce
\end_layout

\begin_layout Institute
Department of Computer Science and Software Engineering
\newline
 NICTA Victoria Laborator
y
\newline
 The University of Melbourne
\newline
 Victoria, 3010, Australia
\newline
 {rfk,adrian}@csse.unimelb.
edu.au
\end_layout

\begin_layout Abstract
Universally quantifying over states in the situation calculus typically
 requires the use of a second-order induction axiom, which can be problematic
 for automated reasoning.
 Fortunately, special cases exist where the need for induction can be eliminated.
 We show that given a uniform formula expressing some property of a situtation,
 the persistence of that property - that is, whether the property holds
 in a given situation and all future situations - can be determined without
 employing the induction axiom.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus is one of the most popular formalisms for reasoning
 about dynamics worlds.
 Among its attractive features are an elegant monotonic solution to the
 frame problem, and an effective reasoning procedure for the projection
 problem.
 However, a complete axiomatisation of a dynamic world in the situation
 calculus requires a second-order induction axiom to define the set of all
 situations.
\end_layout

\begin_layout Standard
It has been shown that existential reasoning about situations does not require
 the induction axioms, and is therefore amenable to automated theorem-proving
 techniques.
 Unofrtunately, many useful reasoning tasks require universal quantification
 over situations.
 For example, it is often useful to determine whether 
\emph on
any
\emph default
 situation exists that satisfies a given goal.
 The need for second-order logic has traditionally limited automated reasoning
 about such queries.
\end_layout

\begin_layout Standard
In this paper we introduce a reasoning procedure for a special class of
 universal query: 
\emph on
persistence
\emph default
 of a property in a situation.
 This is the problem of determining, given some formula 
\begin_inset Formula $\phi$
\end_inset

 and situation 
\begin_inset Formula $s$
\end_inset

, whether 
\begin_inset Formula $\phi$
\end_inset

 will hold in all situations in the future of 
\begin_inset Formula $s$
\end_inset

.
 We show that this query can be answered using iterated first-order reasoning.
 Importantly, we limit the axioms required at each reasoning step.
 TODO: explain why this is better, in the spirit of regression.
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
We work in a version of the the situation calculus as described in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 A brief overview is presented below.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic, augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Action
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built up using the function 
\begin_inset Formula $do\,:\, Concurrent\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 We also distinguish 
\noun on
Fluents
\noun default
 as predicates or functions representing properties of the world that may
 change from one situation to another.
 Fluents take a situation term as their final argument.
\end_layout

\begin_layout Standard
A collection of situation calculus statements that describe the behavior
 of a dynamic world is referred to as a 
\emph on
basic action theory
\emph default
 and is typically represented by 
\begin_inset Formula $\mathcal{D}$
\end_inset

.
 It consists of seperate sets of statements that capture some foundational
 axioms of the situation calculus, successor state axioms for fluents, action
 precondition axioms, unique names axioms for actions, and axioms describing
 the initial situation:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{D}=\Sigma\cup\mathcal{D}_{ss}\cup\mathcal{D}_{ap}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
An action theory must also satisfy some basic consistency constraints, described
 in detail in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 Queries about the behavior or evolution of the world are posed as logical
 entailment queries relative to the theory of action.
\end_layout

\begin_layout Subsubsection
Uniform Formulae
\end_layout

\begin_layout Standard
An important class of formulae in the situation calculus are the 
\emph on
uniform formulae
\emph default
 - those that refer to a single situation term, so representing a property
 of a situation.
 Throughout this paper, we will use the meta-variable 
\begin_inset Formula $\phi$
\end_inset

 to refer to an arbitrary uniform formula.
 Where no confusion can arise, we suppress the situation terms in uniform
 formulae to simplify the presentation.
 It is also standard practice to pass uniform formulae as arguments to other
 functions or predicates - this technically requires an encoding of formulae
 as terms, as discussed in 
\begin_inset LatexCommand \cite{shapiro01casl_feat_inter}

\end_inset

.
 We omit such details for notational simplicity.
\end_layout

\begin_layout Standard
It is often useful to determine the truth of a uniform formula at a given
 situation term.
 The formula 
\begin_inset Formula $\phi[s]$
\end_inset

 represents the uniform formula 
\begin_inset Formula $\phi$
\end_inset

 with all occurrences of its unique situation term replaced by the situation
 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Standard
Clearly uniform formulae describe a 
\emph on
property 
\emph default
of a particular situation, and we shall use this term in the following rather
 than the more cumbersome 
\begin_inset Quotes eld
\end_inset

uniform formula
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Foundational Axioms
\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 are a set of four axioms that describe the basic behavior of a situation
 calculus domain, and are independent of any particular domain application.
 Of most import here is the induction axiom that defines the set of all
 situations:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\forall P\,\left[P(S_{0})\wedge\forall s,a\,\left(P(s)\rightarrow P(do(a,s))\right)\rightarrow\forall s\, P(s)\right]\]

\end_inset


\end_layout

\begin_layout Standard
The fundamental importance of this axiom is described in 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
 Since it is second-order and thus traditionally hard to handle for automated
 reasoning systems, much research has focussed on identifying sentences
 of the situation calculus that can be proved without induction.
\end_layout

\begin_layout Subsubsection
Successor State Axioms
\end_layout

\begin_layout Standard
The truth of fluents from one situation to the next is specified by collecting
 the effects of various actions into a set of successor state axioms 
\begin_inset Formula $\mathcal{D}_{ss}$
\end_inset

, one per fluent.
 These axioms provide a monotonic solution to the infamous frame problem
 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

 and are a principle attraction of the situation calculus.
 They have the general form:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
F(\overrightarrow{x},do(c,s))\equiv\Phi_{F}(\overrightarrow{x},c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $\Phi_{F}$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

.
 TODO: talk about the common substructure of 
\begin_inset Formula $\Phi_{F}$
\end_inset

?
\end_layout

\begin_layout Subsubsection
Action Precondition Axioms
\end_layout

\begin_layout Standard
There is a distinguished fluent predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 For example, it is only possible to drop an object if one is actually holding
 it: 
\begin_inset Formula \[
Poss(drop(obj),s)\equiv Holding(obj,s)\]

\end_inset


\end_layout

\begin_layout Standard
The set of action precondition axioms 
\begin_inset Formula $\mathcal{D}_{ap}$
\end_inset

 contains one such axiom for each action function 
\begin_inset Formula $A$
\end_inset

, of the general form:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
Poss(A(\overrightarrow{x}),s)\equiv\Pi_{A}(\overrightarrow{x},s)\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $\Pi_{A}$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Unique Names Axioms for Actions
\end_layout

\begin_layout Standard
The unique names axioms 
\begin_inset Formula $D_{una}$
\end_inset

 consists of statements of the following form, for each pair of distinct
 action symbols 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Formula \[
A(\overrightarrow{x})\neq B(\overrightarrow{y})\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
A(\overrightarrow{x})=A(\overrightarrow{y})\rightarrow\overrightarrow{x}=\overrightarrow{y}\]

\end_inset


\end_layout

\begin_layout Standard
These ensure that each action function is in fact a unique way in which
 the state of the worl can be changed.
 For example, dropping an object is never the same thing as picking it up.
\end_layout

\begin_layout Subsubsection
Initial Situation Axioms
\end_layout

\begin_layout Standard
TODO: fill this in
\end_layout

\begin_layout Subsubsection
Regression
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of efficient
 reasoning procedures for certain types of query.
 The principle tool is the regression meta-operator 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

 which transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into a formula 
\begin_inset Formula $\mathcal{R}_{\Sigma}(\phi)$
\end_inset

 uniform in 
\begin_inset Formula $s$
\end_inset

, such that the two are equivalent relative to the theory of action 
\begin_inset Formula $\Sigma$
\end_inset

.
 By repeatedly applying the regression operator, 
\begin_inset Formula $\phi$
\end_inset

 can be transformed into an equivalent formula uniform in the initial situation:
\begin_inset Formula \[
\Sigma\models\phi[do(c_{1},do(c_{2},\dots,do(c_{n},S_{0}))]\equiv\mathcal{R}_{\Sigma}^{*}(\phi)[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Many of the axioms from 
\begin_inset Formula $\Sigma$
\end_inset

 are not required for reasoning about the initial situation, and so can
 be discarded when reasoning about 
\begin_inset Formula $\mathcal{R}_{\Sigma}^{*}(\phi)[S_{0}]$
\end_inset

.
 This is frequently more efficient than directly reasoning about 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
TODO: define regressible sentences.
 Talk about single-step operator vs multi-step operator
\end_layout

\begin_layout Subsubsection
Axiom Reduction
\end_layout

\begin_layout Subsubsection
Property Persistence
\end_layout

\begin_layout Standard
TODO: define it in words.
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\forall s'\, s\leq s'\rightarrow\phi(s')\]

\end_inset


\end_layout

\begin_layout Standard
For some applications it is desirable to limit the future situations to
 those containing a certain class of actions.
 Suppose the formula 
\begin_inset Formula $\alpha(a,s)$
\end_inset

 is true for precisely those actions 
\begin_inset Formula $a$
\end_inset

 that are to be considered, then the question of persistence becomes:
\begin_inset Formula \begin{multline}
\forall s''\, s\leq s''\wedge\neg\exists a',s'\, s<do(a',s')\leq s''\wedge\neg\alpha(a',s')\rightarrow\phi[s'']\end{multline}

\end_inset


\end_layout

\begin_layout Section
Persistence Condition
\end_layout

\begin_layout Standard
For practical programming purposes, we would like to replace quantification
 over situations with a more tractable form of reasoning - specifically,
 evaluation of a uniform formula at a specific situation.
 That is, we would like some syntactic transformation 
\begin_inset Formula $\mathcal{P}[\phi,\alpha]$
\end_inset

 of a property 
\begin_inset Formula $\phi$
\end_inset

 and action conditions 
\begin_inset Formula $\alpha$
\end_inset

 such that:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\left[\forall s''\, s\leq s''\rightarrow\phi(s'')\vee\exists a,s'\, s<do(a,s')\leq s''\wedge\neg\alpha(a,s)\right]\,\equiv\,\mathcal{P}[\phi,\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
We call 
\begin_inset Formula $\mathcal{P}[\phi,\alpha]$
\end_inset

 the 
\emph on
persistence condition
\emph default
 of formula 
\begin_inset Formula $\phi$
\end_inset

 with respect to the class of actions 
\begin_inset Formula $\alpha$
\end_inset

.
 The main purpose of this paper is demonstrating an algorithm that constructs
 the persistence condition for a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Standard
The construction of the persistence condition is intuitively quite straightforwa
rd.
 Recall the single-step regression operator 
\begin_inset Formula $\mathcal{R}$
\end_inset

 define by Reiter 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\phi(do(a,s))\equiv\mathcal{R}[\phi(do(a,s))](s)\]

\end_inset


\end_layout

\begin_layout Standard
Note that that 
\begin_inset Formula $\mathcal{R}[\phi(do(a,s))]$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

.
 Using this operator, Reiter gives a procedure for reducing reasoning about
 an arbitrary situation to reasoning about its preceeding situation.
 Via repeated applications of the regression operator, reasoning about any
 ground situation term can be reduced to reasoning about the initial situation.
 Regression thus forms an important part of tractable reasoning in the situation
 calculus.
\end_layout

\begin_layout Standard
The regresion operator can also be employed for our purposes.
 Let 
\begin_inset Formula $\mathcal{P}^{1}[\phi,\alpha]$
\end_inset

 be a formula uniform in 
\begin_inset Formula $s$
\end_inset

 that is true precisely when 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate successors where the action satisfies 
\begin_inset Formula $\alpha$
\end_inset

.
 A candidate defnition for such a formula would be:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{P}^{1}[\phi,\alpha]\isdef\phi\wedge\forall a\,\phi(do(a,s))\vee\neg\alpha(a,s)\]

\end_inset


\end_layout

\begin_layout Standard
Unfortunately, this cannot be used because the right-hand side is not uniform
 in 
\begin_inset Formula $s$
\end_inset

.
 By applying the regression operator, we can obtain an equivalent definition
 that is uniform in 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{P}^{1}[\phi]\isdef\phi\wedge\forall a\,\mathcal{R}[\phi(do(a,s))]\vee\neg\alpha(a,s)\]

\end_inset


\end_layout

\begin_layout Standard
We construct the operator 
\begin_inset Formula $\mathcal{P}$
\end_inset

 from 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

 by induction.
 Intuitively, if 
\begin_inset Formula $\mathcal{P}^{1}[\phi]$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate sucecssors, then 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\begin_inset Formula $s$
\end_inset

 and all successors up to depth two:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{P}^{2}[\phi]\isdef\mathcal{P}^{1}[\mathcal{P}^{1}[\phi],\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
This generalises in a straightforward way to arbitrarily deep successors:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{P}^{n}[\phi]\isdef\mathcal{P}^{1}[\mathcal{P}^{n-1}[\phi],\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
By the definition of 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

 it is clear that, for any 
\begin_inset Formula $n$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\models\mathcal{P}^{n+1}[\phi,\alpha]\rightarrow\mathcal{P}^{n}[\phi,\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
If it is possible to show that there is an 
\begin_inset Formula $n$
\end_inset

 such that:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\models\mathcal{P}^{n}[\phi,\alpha]\rightarrow\mathcal{P}^{n+1}[\phi,\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
Then we have shown logical equivalence of all further applications of 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

:
\begin_inset Formula \[
\models\mathcal{P}^{n}[\phi,\alpha]\equiv\mathcal{P}^{m}[\phi,\alpha]\,,for\, all\, m>n\]

\end_inset


\end_layout

\begin_layout Standard
This 
\begin_inset Formula $\mathcal{P}^{n}$
\end_inset

 can thus be considered a fixed-point of 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

, which we shall denote
\begin_inset Formula $\mathcal{P}[\phi,\alpha]$
\end_inset

.
 It is then a simple inductive argument to show that, as required:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\left[\forall s''\, s\leq s''\rightarrow\phi(s'')\vee\exists a,s'\, s<do(a,s')\leq s''\wedge\neg\alpha(a,s)\right]\,\equiv\,\mathcal{P}[\phi,\alpha]\]

\end_inset


\end_layout

\begin_layout Standard
Given the definitions of 
\begin_inset Formula $\mathcal{R}$
\end_inset

 and 
\begin_inset Formula $\mathcal{P}^{1}$
\end_inset

, the following algorithm will thus determine the persistence condition
 for a formula 
\begin_inset Formula $\phi$
\end_inset

 and class of actions 
\begin_inset Formula $\alpha$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $p_{n}=\phi$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $p_{n+1}=\mathcal{P}^{1}[\phi,\alpha]$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $while\, p_{n}\not\models p_{n+1}\, do$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\,\,\,\,\,\, p_{n}=p_{n+1}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\,\,\,\,\,\, p_{n+1}=\mathcal{P}^{1}[p_{n+1},\alpha]$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $return\, p_{n}$
\end_inset


\end_layout

\begin_layout Standard
The remainder of this paper is dedicated to formally proving that 
\begin_inset Formula $\mathcal{P}$
\end_inset

 operates as desired, and to answering the following questions:
\end_layout

\begin_layout Itemize
When can the algorithm for determining 
\begin_inset Formula $\mathcal{P}$
\end_inset

 be guaranteed to terminate? 
\end_layout

\begin_layout Itemize
Can 
\begin_inset Formula $\mathcal{P}$
\end_inset

 be determined more efficiently for theories of action with a specific form?
 
\end_layout

\begin_layout Subsubsection
Goal Impossibility
\end_layout

\begin_layout Standard
Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no possible situation in which that goal is satisfied:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Sigma\models\forall s\, S_{0}\leq s\rightarrow\neg G(s)\,\, iff\,\, D_{una}\models\mathcal{P}[\neg G,Poss]\]

\end_inset


\end_layout

\begin_layout Standard
That is to say, if the persistence condition of 
\begin_inset Formula $\neg G$
\end_inset

 is a tautology, then the goal 
\begin_inset Formula $G$
\end_inset

 can never be satisfied.
\end_layout

\begin_layout Subsubsection
Goal Futility
\end_layout

\begin_layout Standard
Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $s$
\end_inset

, establish that the goal cannot be satisfied in any situation in the future
 of 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Sigma\models\forall s'\, s\leq s'\rightarrow\neg G(s')\,\, iff\,\,\Sigma\models\mathcal{P}[\neg G,Poss](s)\]

\end_inset


\end_layout

\begin_layout Standard
That is to say, if the persistence condition of 
\begin_inset Formula $\neg G$
\end_inset

 is true in 
\begin_inset Formula $s$
\end_inset

, that goal can no longer be achieved.
 This example highlights the utility of calculation the persistence condition
 in advance - the agent could check for 
\begin_inset Formula $\mathcal{P}[\neg G,Poss](do(a,s))$
\end_inset

 for any action 
\begin_inset Formula $a$
\end_inset

 it is considering performing, and avoid situations which would make its
 goal futile.
\end_layout

\begin_layout Subsubsection
Checking State Constraints
\end_layout

\begin_layout Standard
The persistence condition of any state constraint should be a tautology
 given the unique names axioms - otherwise, there would be situations in
 which the constraints did not hold.
\end_layout

\begin_layout Subsubsection
Need for Cooperation
\end_layout

\begin_layout Standard
To establish that it needs to cooperate with another agent, an agent could
 examine persistence with respect to actions performed by itself:
\begin_inset Formula \begin{multline}
\Sigma\models\forall s''\, s\leq s''\wedge\neg\exists a',s'\, s<do(c',s')\leq s''\wedge\neg agent(a)=agt\rightarrow\neg G[s'']\end{multline}

\end_inset


\end_layout

\begin_layout Standard
In words this states that no situation in the future of 
\begin_inset Formula $s$
\end_inset

 can satisfy 
\begin_inset Formula $G$
\end_inset

, if all the actions that brought about that situation were performed by
 
\begin_inset Formula $agt$
\end_inset

.
 This is of course equivalent to the persistence condition:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Sigma\models\mathcal{P}[\neg G,Poss\wedge agent()=agt](s)\]

\end_inset


\end_layout

\begin_layout Standard
If this is valid, then 
\begin_inset Formula $agt$
\end_inset

 will need to cooperate with another agent in order to achieve its goal.
\end_layout

\begin_layout Subsubsection
Knowledge under Partial Observability
\end_layout

\begin_layout Standard
In recent unpublished work, we develop a new account of knowledge in the
 situation calculus when not all actions are observable by all agents.
 To facilitate reasoning in this formalism, agents must be able to reason
 about what cannot be changed by actions that they cannot observe:
\end_layout

\begin_layout Standard
TODO: put equation here.
\end_layout

\begin_layout Section
Formal Construction of 
\begin_inset Formula $\mathcal{P}[\phi,\alpha]$
\end_inset


\end_layout

\begin_layout Section
Construction from Effect Axioms
\end_layout

\begin_layout Standard
TODO: do we have room for this?
\end_layout

\begin_layout Subsection
Effect Axioms
\end_layout

\begin_layout Standard
We assume that the theory of action is specified in terms of 
\emph on
effect axioms
\emph default
.
 For each action function 
\begin_inset Formula $\alpha(\overrightarrow{x})$
\end_inset

 that could cause a fluent 
\begin_inset Formula $F(\overrightarrow{y})$
\end_inset

 to become true, there is a positive effect axiom of the form:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\forall\overrightarrow{x},\overrightarrow{y},s\,\pi_{\alpha}(\overrightarrow{x},s)\wedge\epsilon_{F,\alpha}^{+}(\overrightarrow{x},\overrightarrow{y},s)\rightarrow F(\overrightarrow{y},do(\alpha(\overrightarrow{x}),s))\]

\end_inset


\end_layout

\begin_layout Standard
The meta-formula 
\begin_inset Formula $\pi_{\alpha}$
\end_inset

 gives the prerequisites that must be satisfied in order to carry out the
 action 
\begin_inset Formula $\alpha$
\end_inset

 in the world, and 
\begin_inset Formula $\epsilon_{F,\alpha}$
\end_inset

 gives the conditions under which action 
\begin_inset Formula $\alpha$
\end_inset

 will cause fluent 
\begin_inset Formula $F$
\end_inset

 to become true.
 Similarly, for each action that could cause a fluent to become false there
 is a negative effect axiom of the form:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\forall\overrightarrow{x},\overrightarrow{y},s\,\pi_{\alpha}(\overrightarrow{x},s)\wedge\epsilon_{F,\alpha}^{-}(\overrightarrow{x},\overrightarrow{y},s)\rightarrow\neg F(\overrightarrow{y},do(\alpha(\overrightarrow{x}),s))\]

\end_inset


\end_layout

\begin_layout Standard
In his landmark paper 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

, Reiter showed how a solution to the frame problem can be compiled from
 a collection of such effect axioms, under the assumption that they specify
 
\emph on
all
\emph default
 the ways in which fluents can change value.
 By utilising the same assumption, we will show how the effect conditions
 
\begin_inset Formula $\pi$
\end_inset

, 
\begin_inset Formula $\epsilon^{+}$
\end_inset

 and 
\begin_inset Formula $\epsilon^{-}$
\end_inset

 can be used in proving state properties.
\end_layout

\begin_layout Standard
TODO: explicitly list the actions affecting a fluent? Useful for rewriting
\end_layout

\begin_layout Subsection
Compound Fluents
\end_layout

\begin_layout Standard
Any situation-suppressed formula can be though of as describing a compound
 property of the world - that is, a property whose truth depends on the
 truth of other properties of the world.
 In other words, we may think of a situation-suppressed formula 
\begin_inset Formula $\phi$
\end_inset

 as a 
\emph on
compound fluent
\emph default
 that is true or false relative to a single situation variable 
\begin_inset Formula $s$
\end_inset

.
 From this perspective, it should be possible to construct compound effect
 axioms for a given compound fluent.
\end_layout

\begin_layout Standard
We define operators 
\begin_inset Formula $\mathcal{E}^{+}[\phi,\alpha]$
\end_inset

 and 
\begin_inset Formula $\mathcal{E}^{-}[\phi,\alpha]$
\end_inset

 that operate on compound fluents 
\begin_inset Formula $\phi$
\end_inset

 to give their positive and negative effect axioms with respect to an action
 
\begin_inset Formula $\alpha$
\end_inset

.
 These operators can be defined inductively on the structure of compound
 fluents:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\begin{array}{c}
\mathcal{E}^{+}[F,\alpha]\isdef\epsilon_{F,\alpha}^{+}\\
\mathcal{E}^{+}[\phi\wedge\psi,\alpha]\isdef(\mathcal{E}^{+}[\phi,\alpha]\wedge\mathcal{E}^{+}[\psi,\alpha])\vee(\mathcal{E}^{+}[\phi,\alpha]\wedge\psi\wedge\neg\mathcal{E}^{-}[\psi,\alpha])\vee(\mathcal{\phi\wedge\neg E}^{-}[\phi,\alpha]\wedge\mathcal{E}^{+}[\psi,\alpha])\\
\mathcal{E}^{+}[\phi\vee\psi,\alpha]\\
\\\\\end{array}\]

\end_inset


\end_layout

\begin_layout Section
Termination
\end_layout

\begin_layout Standard
?? I really have no idea at this stage...
\end_layout

\begin_layout Section
TODO
\end_layout

\begin_layout Standard
Dont use the word 
\begin_inset Quotes eld
\end_inset

state
\begin_inset Quotes erd
\end_inset

 anywhere, use 
\begin_inset Quotes eld
\end_inset

situation
\begin_inset Quotes erd
\end_inset

 instead
\end_layout

\begin_layout Standard
Formal assumption to make this workable: finite number of action types?
 fluents affected by finite number of actions?
\end_layout

\begin_layout Standard
Reference 
\begin_inset LatexCommand \cite{bertossi96automating}

\end_inset

 in related work
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
bibliographystyle{plain}
\end_layout

\end_inset

 
\begin_inset LatexCommand \bibtex[plain]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
