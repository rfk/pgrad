%% LyX 1.4.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[11pt,letterpaper,letterpaper]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.

\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}

\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{ijcai07}

\usepackage{times}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

\makeatother
\begin{document}


\title{Property Persistence in the Situation Calculus\thanks{This research was supported by a grant from the Australian Research Councils (ARCs) Centre for Perceptive and Intelligent Machines in Complex Environments (PIMCE).}}


\author{Ryan F. Kelly and Adrian R. Pearce\\
NICTA Victoria Laboratory\\
 Department of Computer Science and Software Engineering\\
 The University of Melbourne\\
 Victoria, 3010, Australia\\
 \{rfk,adrian\}@csse.unimelb.edu.au}

\maketitle
\begin{abstract}
We develop an algorithm for reducing universally quantified situation
calculus queries to a form more amenable to automated reasoning. Universal
quantification in the situation calculus requires a second-order induction
axiom, making automated reasoning difficult for such queries. We show
how to reduce queries about property persistence, a common family
of universally-quantified query, to an equivalent form that does not
quantify over situations. The algorithm for doing so utilizes only
first-order reasoning. We give several examples of important reasoning
tasks that are facilitated by our approach, including checking for
goal impossibility and reasoning about knowledge with partial observability
of actions.
\end{abstract}

\section{Introduction}

The situation calculus \cite{pirri99contributions_sitcalc} has long
been one of the most popular formalisms for reasoning about dynamic
worlds. It has more recently become a popular choice for \emph{implementing}
systems situated in a dynamic world, as it offers, among other advantages:
a formalism based in first-order logic; an elegant monotonic solution
to the frame problem; and an effective reasoning procedure for the
projection problem \cite{reiter91frameprob}. Coupled with logic programming
languages such as Prolog, it has facilitated the implementation of
a wide range of systems.

The foundational axioms of the situation calculus include a second-order
induction axiom defining the set of all situations \cite{Reiter93proving}.
Sentences that contain only existential quantification over situation
terms can be proven without the induction axiom and so are more amenable
to automated reasoning \cite{pirri99contributions_sitcalc}. It is
therefore important for systems built on a situation calculus theory
of action to limit queries to existential form. Much of the work on
implementing systems with the situation calculus has been on reducing
the number of axioms required to answer a given query, to allow more
efficient reasoning.

Unfortunately there are many reasoning tasks that require universal
quantification over situations. For example, it is often desirable
to show that no situation can satisfy a particular goal. In this paper
we are interested in a subset of such queries which we refer to as
\emph{persistence queries}: under a particular situation calculus
theory $\mathcal{D}$, and given some property $\phi$ and situation
$s$, determine whether $\phi$ will hold in all situations in the
future of $s$:\[
\mathcal{D}\models\forall s'\,.\, s\sqsubseteq s'\,\rightarrow\,\phi[s']\]
The need for second-order logic has traditionally limited automated
reasoning about such queries. We introduce a new approach that is
similar in spirit to the regression operator of \cite{reiter91frameprob}:
define an operator that transforms a formula $\phi$ into a formula
$\mathcal{P}_{\mathcal{D}}[\phi]$, such that $\phi$ persists in
$s$ if and only if $\mathcal{P}_{\mathcal{D}}[\phi]$ holds in $s$.
We term this the \emph{persistence condition} of $\phi$, and show
how to calculate it in a form suitable for effective automated reasoning.

To determine $\mathcal{P}_{\mathcal{D}}[\phi]$, we first define an
operator $\mathcal{P}_{\mathcal{D}}^{1}[\phi]$ that holds in $s$
whenever $\phi$ holds in $s$ and all its immediate successors. The
persistence condition is shown to be a fixed-point of this operator,
which can be sought using a straightforward iterative algorithm. Since
this requires only first-order reasoning with a limited number of
axioms, the result is an effective procedure with which to answer
a family of queries that universally quantify over situations.

The paper is organized as follows: Section \ref{sec:Background} gives
a brief introduction to the situation calculus, formally defines the
persistence problem, discusses related work and gives several examples
of important persistence queries; Section \ref{sec:Persistence-Condition}
formally defines the persistence condition, presents an algorithm
that calculates it, shows that the algorithm is correct and discusses
the conditions necessary for completeness; and Section \ref{sec:Conclusions}
concludes with a summary of our results.


\section{Background\label{sec:Background}}

The situation calculus is a many-sorted language of first-order logic
augmented with a second-order induction axiom. It has the following
sorts: \emph{Action} terms are functions denoting individual instantaneous
events that can cause the state of the world to change; \emph{Situation}
terms are histories of the actions that have occurred in the world,
with the initial situation represented by $S_{0}$ and successive
situations built up using the function $do\,:\, Action\times Situation\rightarrow Situation$;
\emph{Object} terms represent any other object in the domain. It further
distinguishes \emph{Fluents} as predicates or functions representing
properties of the world that may change from one situation to another,
and so take a situation term as their final argument. For a detailed
description consult \cite{pirri99contributions_sitcalc}. 

A \emph{basic action theory} is a set $\mathcal{D}$ of situation
calculus sentences (with a specific syntactic form as specified in
\cite{pirri99contributions_sitcalc}) that describes a particular
dynamic world. Queries about the behavior or evolution of the world
are posed as logical entailment queries relative to this theory. It
consists of the following disjoint sets: the foundational axioms of
the situation calculus ($\Sigma$); successor state axioms describing
how fluents change between situations ($\mathcal{D}_{ss}$); precondition
axioms indicating when actions can be performed ($\mathcal{D}_{ap}$);
unique names axioms ensuring that action terms are distinct ($\mathcal{D}_{una}$);
and axioms describing the value of fluents in the initial situation
($\mathcal{D}_{S_{0}}$):\[
\mathcal{D}=\Sigma\cup\mathcal{D}_{ss}\cup\mathcal{D}_{ap}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\]


The foundational axiom of most import for this paper is the induction
axiom, which defines the set of all situations as the least set containing
$S_{0}$ and closed under application of the $do$ function, as follows:\[
\forall P\,.\,\left[P(S_{0})\wedge\forall s,a\,.\,\left(P(s)\rightarrow P(do(a,s))\right)\rightarrow\forall s\,.\, P(s)\right]\]
The fundamental importance of this axiom is described in \cite{Reiter93proving}.
Much research has focused on identifying sentences of the situation
calculus that can be proven without this axiom, and thus require only
first-order logic. Our work continues this tradition.

There is a distinguished predicate $Poss(a,s)$ that indicates when
it is possible to perform an action in a given situation. The set
of action precondition axioms $\mathcal{D}_{ap}$ contains one axiom
for each type of action $A$, of the general form:\[
\forall s,\overrightarrow{x}\,.\,\left[Poss(A(\overrightarrow{x}),s)\equiv\Pi_{A}(\overrightarrow{x},s)\right]\]
Here $\Pi_{A}$ represents a uniform formula (see below) defining
action possibility on a per-action basis.

It is often useful to introduce analogous predicates to describe different
aspects of action performance. For example, a predicate $CantObs(agt,a,s)$
could indicate when an agent will be unable to observe the occurrence
of an action. Such predicates are easily incorporated into a basic
action theory by axiomatizing them in $\mathcal{D}_{ap}$ in the same
manner as $Poss$. We refer to these predicates in general as \emph{action
description predicate}s, and use the meta-variable $\alpha$ to represent
an arbitrary such predicate.

The \emph{uniform formulae} as defined in \cite{pirri99contributions_sitcalc}
can be thought of as \emph{properties} of the
state of the world. They are basically logical combinations of fluents
referring to a common situation term, which cannot mention action
description predicates nor compare situation terms. We will use the
meta-variable $\phi$ to refer to an arbitrary uniform formula.

It is often useful to determine the truth of a property at a given
situation. The formula $\phi[s]$ represents the uniform formula $\phi$
with all occurrences of its unique situation term replaced by the
situation $s$.


\subsection{Ordering over Situations}

Situations form a tree with $S_{0}$ at the root and $do$ constructing
child situations from parents. There is a basic ordering relation
$\sqsubset$ defined by the following foundational axioms:\[
\forall s\,.\,\neg\left(s\sqsubset S_{0}\right)\]
\[
\forall s,s',a\,.\, s\sqsubset do(a,s')\equiv s\sqsubseteq s'\]
Where $s\sqsubseteq s'$ is the standard abbreviation of $s\sqsubset s'\vee s=s'$.
It is frequently useful to restrict the situations under consideration
to those possible in the real world, by defining an ordering relation
$<$ over only these {}``executable'' situations:\[
\forall s\,.\,\neg\left(s<S_{0}\right)\]
\[
\forall s,s',a\,.\, s<do(a,s')\equiv s\leq s'\wedge Poss(a,s')\]
Many results of the situation calculus are derived relative to the
executable situations - for example, \cite{Reiter93proving} develops
an induction principle for all situations where $S_{0}\leq s$. This
notation is so useful that we propose a parametrization of it: let
$\alpha$ be an action description predicate specifying the actions
of interest, then define the {}``$\alpha$-ordering'' over situations
as follows:\[
\forall s\,.\,\neg\left(s<_{\alpha}S_{0}\right)\]
\[
\forall s,s',a\,.\, s<_{\alpha}do(a,s')\equiv s\leq_{\alpha}s'\wedge\alpha(a,s')\]
The standard ordering over executable situations is clearly $<_{Poss}$.
If $s$ is thought of as the {}``current situation'', then $s<_{\alpha}s'$
means that $s'$ is one potential future, and all actions that will
occur in that future satisfy $\alpha$.


\subsection{Effective Reasoning\label{sub:Effective-Reasoning}}

Answering an arbitrary situation calculus query $\psi$ involves,
in general, an entailment problem in second-order logic (SOL):\[
\mathcal{D}\models_{SOL}\psi\]
This can be problematic for efficient automated reasoning. Fortunately,
there exist particular syntactic forms for which some of the axioms
in $\mathcal{D}$ are not required. In \cite{pirri99contributions_sitcalc}
the {}``$\exists$s sentences'' are defined as those in which every
situation variable is in the scope of a positive existential quantifier.
They show that such sentences can always be proven without the induction
axiom ($I$) and hence are answerable by first-order logical entailment
(FOL):\[
\mathcal{D}\models_{SOL}\exists s\,\psi\,\,\,\mathit{iff}\,\,\,\mathcal{D}-\{ I\}\models_{FOL}\exists s\,\psi\]
Such queries can be approached with standard first-order reasoning
systems. To increase the efficiency of reasoning it is desirable to
eliminate further axioms from $\mathcal{D}$, which \cite{pirri99contributions_sitcalc}
show possible for several syntactic forms.

Axiom reduction is also the key idea behind the regression operator,
the principal tool for effective reasoning in the situation calculus
\cite{reiter91frameprob}. The regression operator $\mathcal{R}_{\mathcal{D}}$
is a syntactic manipulation whose behavior can be summarized%
\footnote{The full behavior of $\mathcal{R}_{\mathcal{D}}$ is beyond the scope
of this paper. Experienced readers please note that we use the single-step
version of the regression operator, as in \cite{Lin94-StateConstraints}.
Since any formula uniform in $do(a,s)$ is by definition single-step
regressable, the development below omits the traditional qualification
that formulae must be regressable.%
} for our purposes as follows: given a formula $\phi$ uniform in $do(a,s)$,
regression transforms it into a formula $\mathcal{R}_{\mathcal{D}}[\phi]$
that is uniform in $s$ and is equivalent to $\phi$ under the theory
of action $\mathcal{D}$:\[
\mathcal{D}\,\models\,\phi\equiv\mathcal{R}_{\mathcal{D}}[\phi]\]
Regression also replaces instances of the $Poss$ predicate with appropriate
instantiations of the corresponding uniform formula from the axioms
in $\mathcal{D}_{ap}$, and other action description predicates can
easily be treated in the same way. In order to regress such a predicate
over an action variable one must assume that there are only a finite
number of action types, so that it can be replaced with the disjunctive
closure of its definitional axioms. We assume this restriction throughout.

If $\phi$ refers to a situation that is rooted at $S_{0}$, repeated
applications of the regression operator (denoted by $\mathcal{R}_{\mathcal{D}}^{*}$)
can transform it into an equivalent formula uniform in the initial
situation. The successor state and action precondition axioms are
{}``compiled into'' the regressed formula, and so are not required
for the reasoning task:\[
\mathcal{D}\models\phi\,\,\,\mathit{iff}\,\,\,\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\models\mathcal{R}_{\mathcal{D}}^{*}[\phi][S_{0}]\]
The trade-off is that the length of $\mathcal{R}_{\mathcal{D}}^{*}[\phi]$
may be exponential in the length of $\phi$. In practice this is typically
more than compensated for by the reduction in the number of axioms
required, and regression has proven a very effective technique.


\subsection{Property Persistence\label{sub:Property-Persistence}}

One important form of situation calculus query is to ask whether a
given property $\phi$ will hold in \emph{all future situations} of
a given situation $s$, as well as at $s$ itself:\[
\mathcal{D}\models\forall s'\,.\, s\sqsubseteq s'\rightarrow\phi(s')\]
More generally, one may wish to limit the futures considered to those
brought about by a certain class of actions $\alpha$:\[
\mathcal{D}\models\forall s'\,.\, s\le_{\alpha}s'\rightarrow\phi[s']\]
In words this states {}``given that all subsequent actions satisfy
$\alpha$, $\phi$ will remain true'' or, more succinctly, {}``$\phi$
persists under $\alpha$''. We term queries of this form \emph{property
persistence} \emph{queries}, and they are involved in many useful
reasoning tasks. The following are a small selection:

\textbf{Goal Impossibility:} Given a goal $G$, establish that there
is no possible situation in which that goal is satisfied:\[
\mathcal{D}\models\forall s\,.\, S_{0}\leq s\rightarrow\neg G(s)\]


\textbf{Goal Futility:} Given a goal $G$ and situation $s$, establish
that the goal cannot be satisfied in any possible situation in the
future of $s$:\[
\mathcal{D}\models\forall s'\,.\, s\leq s'\rightarrow\neg G(s')\]
Note how this is different from goal impossibility: while the agent
may have initially been able to achieve its goal, the actions that
have subsequently been performed have rendered the goal unachievable.
Agents would be well advised to avoid such situations.

\textbf{Checking State Constraints:} This is a variant of goal impossibility
- show that the constraint can never be violated.

\textbf{Need for Cooperation:} To establish that it is absolutely
necessary to cooperate with another agent, an agent must determine
persistence under actions performed by itself:\[
\mathcal{D}\models\forall s'\,.\, s\leq_{OwnAction}s'\rightarrow\neg G[s']\]
Assuming that the action description predicate $OwnAction$ has been
defined to identify actions performed by the agent in question, this
states that no situation in the future of $s$ in which all actions
were performed by that agent can satisfy $G$. If this is the case,
it will need to cooperate with another agent in order to achieve its
goal.

\textbf{Knowledge under Partial Observability:} In recent unpublished
work we develop a new account of knowledge in the situation calculus
when not all actions are observable by all agents. To facilitate reasoning
in this formalism, agents must be able to reason about what cannot
be changed by actions that they cannot observe, a form of persistence
query.

Due to the universal quantification over situations, the techniques
for effective automated reasoning in Section \ref{sub:Effective-Reasoning}
cannot be applied to persistence queries. This paper is devoted to
developing of a complementary technique for handling such queries.


\subsection{Related Work}

While there is a rich and diverse literature base for the situation
calculus, there appears to have been little work dealing with universally
quantified queries. The work of \cite{Reiter93proving} shows how
to handle such queries by hand using an appropriate instantiation
of the induction axiom, but makes no mention of automating this reasoning.

Other work considering persistence focuses exclusively on verifying
state constraints. These are uniform formulae that must hold in every
possible situation, a highly specialized form of persistence query.
The work of \cite{Lin94-StateConstraints} {}``compiles away'' the
induction axiom when verifying a state constraint, by means of the
following equivalence:\begin{gather*}
\Sigma\cup\mathcal{D}_{una}\cup\mathcal{D}_{ss}\models\phi[S_{0}]\rightarrow\left(\forall s\,.\, S_{0}\leq s\rightarrow\phi[s]\right)\\
\mathit{iff}\\
\mathcal{D}_{una}\models\forall s,a\,.\,\phi[s]\wedge\mathcal{R}_{\mathcal{D}}[Poss(a,s)]\,\rightarrow\,\mathcal{R}_{\mathcal{D}}[\phi[do(a,s)]]\end{gather*}
Verification of a state constraint can thus be reduced to reasoning
about a universally quantified uniform formula using only the unique
names axioms, a comparatively straightforward reasoning task. This
problem is also approached by \cite{bertossi96automating}, who develop
a system for automatically verifying state constraints based on an
induction theorem prover.

However, there are many issues related to persistence that are not
addressed by such work, including: persistence at situations other
than $S_{0}$; action description predicates other than $Poss$; how
to combine notions of persistence and regression; and determining
what additional conditions may be necessary to guarantee the persistence
of $\phi$. As our treatment of persistence can provide a concrete
basis for these considerations, it is significantly more general than
existing work.


\section{The Persistence Condition\label{sec:Persistence-Condition}}

For implementing persistence queries in practical systems, we clearly
need to transform the query into a form suitable for effective reasoning.
Specifically, we will transform a persistence query based at $s$
into the evaluation of a uniform formula at $s$, which can be done
effectively using the regression operator. We need some transformation
of a property $\phi$ and action description predicate $\alpha$ into
a uniform formula $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$ that is
true at precisely the situations in which $\phi$ persists under $\alpha$,
given a particular action theory $\mathcal{D}$. We call $\mathcal{P}_{\mathcal{D}}$
the \emph{persistence condition} of $\phi$ under $\alpha$.\begin{definition}

The persistence condition $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$
is a uniform formula that is the weakest precondition for the persistence
of $\phi$ under $\alpha$, given a basic action theory $\mathcal{D}$
without the initial situation axioms. That is:\label{def:persistence-condition}\[
\mathcal{D}-\mathcal{D}_{S_{0}}\models\forall s\,.\,\left(\mathcal{P_{D}}[\phi,\alpha][s]\,\equiv\,\forall s'\,.\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\]
\end{definition} 

Defining $\mathcal{P}_{\mathcal{D}}$ to be independent of the initial
world state allows an agent to calculate it regardless of what (if
anything) is known about the actual state of the world. To see how
$\mathcal{P}_{\mathcal{D}}$ may be calculated, consider the weaker
notion of a formula \emph{persisting to depth $n$} in a situation:\begin{definition}

A uniform formula $\phi$ persists to depth 1 under $\alpha$ in situation
$s$ when the formula $\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha]$
holds in $s$, as defined by:\label{def:persists-depth-n}\[
\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha][s]\,\isdef\,\phi[s]\,\wedge\,\forall a\,.\,\mathcal{R_{D}}[\alpha(a,s)\rightarrow\phi[do(a,s)]]\]
More generally, for any $n\geq0$, a uniform formula $\phi$ persists
to depth $n$ under $\alpha$ in situation $s$ when the formula $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
holds in $s$, as defined by:\[
\mathcal{P}_{\mathcal{D}}^{0}[\phi,\alpha]\,\isdef\,\phi\]
\[
\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]\,\isdef\,\mathcal{P}_{\mathcal{D}}^{1}[\mathcal{P}_{D}^{n-1}[\phi,\alpha],\alpha]\]


\end{definition}

Note that $\mathcal{P}_{\mathcal{D}}^{1}$ is a literal encoding of
the requirement {}``$\phi$ holds in $s$ and in all its direct successors''.
Since $\alpha$ is an action description predicate and $\phi$ is
a uniform formula, the expression $\alpha(a,s)\rightarrow\phi[do(a,s)]$
can always be regressed and the result will always be uniform in $s$.
Successive applications of $\mathcal{P}_{\mathcal{D}}^{1}$ assert
persistence to greater depths.

Intuitively, one would expect $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$
to be a fixed-point of $\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha]$,
since $\mathcal{P}_{\mathcal{D}}[\phi,\alpha]$ implies persistence
up to any depth. Such a fixed-point can then be calculated using standard
iterative approximation techniques. To show that this is in fact the
case we require a number of theoretical results, presented below.


\subsection{Formal Development}

We begin by adapting two existing results involving induction to operate
with our generalized $\leq_{\alpha}$ notation, and be based at situations
other than $S_{0}$:\begin{proposition}

For any action description predicate $\alpha$, the foundational axioms
of the situation calculus entail the following induction principle:\label{prop:a-order-induction}\begin{multline*}
\forall W,s\,.\,\, W(s)\wedge\left[\forall a,s'\,.\,\alpha(a,s')\wedge s\leq_{\alpha}s'\right.\\
\left.\wedge W(s')\rightarrow W(do(a,s'))\right]\rightarrow\forall s'\,.\, s\leq_{\alpha}s'\rightarrow W(s')\end{multline*}


\end{proposition}\begin{proof}

A trivial adaptation of theorem 1 in \cite{Reiter93proving}.

\end{proof}\begin{proposition}

For any basic action theory $\mathcal{D}$, uniform formula $\phi$
and action description predicate $\alpha$:\label{prop:a-order-reduction}\begin{gather*}
\mathcal{D}-\mathcal{D}_{S_{0}}\models\forall s\,.\,\phi[s]\rightarrow\left(\forall s'\,.\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\\
\mathit{iff}\\
\mathcal{D}_{una}\models\forall s,a\,.\,\phi[s]\wedge\mathcal{R}_{\mathcal{D}}[\alpha(a,s)]\rightarrow\mathcal{R}_{\mathcal{D}}[\phi[do(a,s)]]\end{gather*}


\end{proposition}\begin{proof}

A straightforward generalization of Lemma 5 in \cite{Lin94-StateConstraints},
utilizing Proposition \ref{prop:a-order-induction}.

\end{proof}Proposition \ref{prop:a-order-reduction} will be key
in our algorithm for calculating the persistence condition. It allows
one to establish the result {}``if $\phi$ holds in $s$, then $\phi$
persists in $s$'' by checking entailment of a uniform formula by
the unique names axioms, a straightforward first-order reasoning task.

Next we must formalize some basic relationships between $\mathcal{P}_{\mathcal{D}}$
and $\mathcal{P}_{\mathcal{D}}^{n}$, as follows:\begin{lemma}

Given a basic action theory $\mathcal{D}$, uniform formula $\phi$
and action description predicate $\alpha$, then for any $n$:\label{lem:p-equiv-p(pn)}\begin{multline*}
\mathcal{D}-\mathcal{D}_{S_{0}}\models\forall s\,.\,\left[\,\,\forall s'\,.\,\left(s\leq_{\alpha}s'\rightarrow\phi[s']\right)\right.\\
\left.\equiv\forall s'\,.\,\left(s\leq_{\alpha}s'\rightarrow\mathcal{P}_{D}^{n}[\phi,\alpha][s']\right)\,\,\right]\end{multline*}
That is, $\phi$ persists under $\alpha$ iff $\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
persists under $\alpha$.\end{lemma}\begin{proof}

By the definition of $\mathcal{P}_{\mathcal{D}}^{n}$, any $s'$ that
falsifies the right-hand side of this equivalence will also falsify
the left-hand side, and vice-versa. 

\end{proof}\begin{lemma}

Given a basic action theory $\mathcal{D}$, uniform formula $\phi$
and action description predicate $\alpha$, then for any $n$:\label{lem:p-implies-pn}\[
\mathcal{D}-\mathcal{D}_{S_{0}}\models\forall s\,.\,\left(\mathcal{P_{D}}[\phi,\alpha][s]\rightarrow\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\right)\]


\end{lemma}\begin{proof}

$\mathcal{P_{D}}[\phi,\alpha]$ implies the persistence of $\phi$
by definition, which implies $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
by Lemma \ref{lem:p-equiv-p(pn)}.

\end{proof}We are now equipped to prove the major theorem of this
paper: that if $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$ implies
$\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha]$, then $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
is equivalent to the persistence condition for $\phi$ under $\alpha$.\begin{theorem}

Given a basic action theory $\mathcal{D}$, uniform formula $\phi$
and action description predicate $\alpha$, then for any $n$:\label{thm:p(pn)-equiv-p}\begin{gather}
\mathcal{D}_{una}\models\forall s\,.\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\rightarrow\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha][s]\label{eqn:pn_persists}\\
\mathit{iff}\nonumber \\
\mathcal{D}-\mathcal{D}_{s_{0}}\models\forall s\,.\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\equiv\mathcal{P_{D}}[\phi,\alpha][s]\label{eqn:pn_equiv_persists}\end{gather}


\end{theorem}\begin{proof}

For the \emph{if} direction, we first see by the definition of $\mathcal{P}_{\mathcal{D}}^{1}$
that equation (\ref{eqn:pn_persists}) is equivalent to:\begin{multline*}
\mathcal{D}_{una}\models\forall s,a\,.\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\wedge\mathcal{R}_{\mathcal{D}}[\alpha(a,s)]\\
\rightarrow\mathcal{R}_{\mathcal{D}}[\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][do(a,s)]]\end{multline*}
which by Proposition \ref{prop:a-order-reduction} implies the persistence
of $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$ under $\alpha$.
By Lemma \ref{lem:p-equiv-p(pn)} this implies the persistence of
$\phi$ under $\alpha$, which in turn implies $\mathcal{P_{D}}[\phi,\alpha]$,
giving:\[
\mathcal{D}-\mathcal{D}_{s_{0}}\models\forall s\,.\,\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\rightarrow\mathcal{P_{D}}[\phi,\alpha][s]\]
By Lemma \ref{lem:p-implies-pn} this implication is in fact an equivalence,
yielding equation (\ref{eqn:pn_equiv_persists}) as required.

The \emph{only if} direction is a straightforward reversal of this
reasoning: $\mathcal{P_{D}}[\phi,\alpha]$ implies the persistence
of $\phi$, which implies the persistence of $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$,
which implies (\ref{eqn:pn_persists}) by Proposition \ref{prop:a-order-reduction}.

\end{proof}Since $\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha]\rightarrow\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
by definition, equation (\ref{eqn:pn_persists}) identifies $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
as a fixed-point of the $\mathcal{P}_{\mathcal{D}}^{1}$ operator,
as our initial intuition suggested.


\subsection{Algorithm for the Persistence Condition}

Since we can easily calculate $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
for any $n$, we have a straightforward algorithm for determining
$\mathcal{P_{D}}[\phi,\alpha]$: search for an $n$ such that\[
\mathcal{D}_{una}\models\forall s\,.\,\left(\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha][s]\rightarrow\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha][s]\right)\]
Since we expect $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$ to be
simpler than $\mathcal{P}_{\mathcal{D}}^{n+1}[\phi,\alpha]$, we should
look for the smallest such $n$. Algorithm \ref{alg:calc_p} presents
an iterative procedure for doing just that.

\begin{algorithm}
\caption{Calculate $\mathcal{P}_\mathcal{D}[\phi,\alpha]$}
\label{alg:calc_p}
\begin{algorithmic}
\STATE $\mathtt{pn} \Leftarrow \phi$
\STATE $\mathtt{pn1} \Leftarrow \mathcal{P}^1_\mathcal{D}[\mathtt{pn},\alpha]$
\WHILE{$\mathcal{D}_{una} \not\models \forall s\,.\,\mathtt{pn}[s] \rightarrow \mathtt{pn1}[s]$}
  \STATE $\mathtt{pn} \Leftarrow \mathtt{pn1}$
  \STATE $\mathtt{pn1} \Leftarrow \mathcal{P}^1_{\mathcal{D}}[\mathtt{pn},\alpha]$
\ENDWHILE
\STATE return $\mathtt{pn}$
\end{algorithmic}
\end{algorithm}

Note that the calculation of $\mathcal{P}_{\mathcal{D}}^{1}[\phi,\alpha]$
is a straightforward syntactic transformation and so requires no further
treatment.


\subsubsection{Correctness}

If algorithm \ref{alg:calc_p} terminates, it terminates returning
a value of $pn$ for which equation (\ref{eqn:pn_persists}) holds.
By Theorem \ref{thm:p(pn)-equiv-p} this value of $pn$ is equivalent
to the persistence condition for $\phi$ under $\alpha$. The algorithm
therefore correctly calculates the persistence condition.

Note that equation (\ref{eqn:pn_persists}) holds when $\mathcal{P}_{\mathcal{D}}^{n}[\phi,\alpha]$
is unsatisfiable for any situation, as it appears in the antecedent
of the implication. The algorithm thus correctly returns an unsatisfiable
condition (equivalent to $false$) when $\phi$ can never persist
under $\alpha$.


\subsubsection{Completeness}

As Theorem \ref{thm:p(pn)-equiv-p} is an equivalence, the only source
of incompleteness will be failure to terminate. Algorithm \ref{alg:calc_p}
may fail to terminate for two reasons: the loop condition may never
be satisfied, or the first-order logical inference in the loop condition
may be undecidable and fail to terminate.

The later indicates that the basic action theory $\mathcal{D}$ is
undecidable. While this is a concern, it affects more than just our
algorithm - any system implemented around such an action theory will
be incomplete. Thus, with respect to this source of incompleteness,
our algorithm is no more incomplete than any larger system it would
form a part of.

The former is of more direct consequence to our work, and raises two
questions: is the persistence condition guaranteed to exist, and is
it guaranteed to be reachable in a finite number of iterations? Since
$\mathcal{P}_{\mathcal{D}}^{1}$ is clearly monotone, the constructive
proof of Tarski's fixed-point theorem \cite{cousot79constructive_tarski}
guarantees the existence of a fixed-point that can be calculated via
transfinite iteration, as performed by our algorithm. Moreover, this
will be the least fixed-point greater than $\phi$, a satisfying confirmation
of correctness since the persistence condition must be the weakest
precondition for the persistence of $\phi$.

Unfortunately, there is no guarantee that this fixed-point can be
reached via \emph{finite} iteration, which is required for termination.
Indeed, it is straightforward to construct a fluent for which the
algorithm never terminates: consider a fluent $Fp(x,s)$ taking integers
$x$, that is affected by a single action that makes it false whenever
$Fp(x+1,s)$ is false. Letting $\alpha$ be vacuously true, the sequence
of iterations produced by our algorithm would be:\begin{gather*}
\mathcal{P}_{\mathcal{D}}^{1}[Fp(x,s)]\equiv Fp(x,s)\wedge Fp(x+1,s)\\
\mathcal{P}_{\mathcal{D}}^{2}[Fp(x,s)]\equiv Fp(x,s)\wedge Fp(x+1,s)\wedge Fp(x+2,s)\\
\vdots\\
\mathcal{P}_{\mathcal{D}}^{n}[Fp(x,s)]\equiv\bigwedge_{i=0}^{i=n}Fp(x+i,s)\end{gather*}
The persistence condition in this case is $\mathcal{P}_{\mathcal{D}}[Fp(x,s)]\equiv\forall y\,.\, x\leq y\rightarrow Fp(y,s)$,
and while this is the limit of the iteration it is clearly unachievable
in any finite number of steps.

$\mathcal{P}_{\mathcal{D}}^{1}$ operates over the set of equivalence
classes of formulae uniform in $s$, and the theory of fixed-points
requires that this set be a \emph{well-founded partial order} to guarantee
termination of an iterative approximation algorithm. There are certain
classes of basic action theory for which this well-foundedness can
be guaranteed. The most obvious is theories with finite action and
object domains, in which the set of equivalence classes is finite.
Another is the case where successor-state axioms refer only to the
direct arguments of their fluents, in which case repeated applications
of $\mathcal{P}_{\mathcal{D}}^{1}$ will pick out a subset of the
equivalence classes that refers to a finite number of objects, giving
the same guarantee.

In general, termination requires that repeated applications of the
successor-state axioms (via the regression operator) do not construct
infinite chains. We are currently investigating syntactic restrictions
on successor state axioms that can enforce this requirement, and have
found it to be easily met in practice. We are also investigating more
advanced fixed-point algorithms that may give better efficiency and
termination guarantees.


\subsubsection{Effectiveness}

Our algorithm replaces a single reasoning task based on the full action
theory $\mathcal{D}$ with a series of reasoning tasks based on the
unique names axioms $\mathcal{D}_{una}$. Is this a worthwhile trade-off
in practice? The following points weigh strongly in favor of our approach:

First and foremost, we avoid the need for the second-order induction
axiom. All the reasoning tasks can be performed using standard first-order
reasoning, for which there are many high-quality automated provers.
Second, the calculation of $\mathcal{P_{D}}$ only reasons based on
the unique names axioms, which as discussed is a comparatively straightforward
task. Third, $\mathcal{P}_{\mathcal{D}}[\phi,\alpha][s]$ is in a
form amenable to regression, a standard tool for effective reasoning
in the situation calculus. Fourth, the persistence condition for a
given $\phi$ and $\alpha$ can be cached and re-used for a series
of related queries about different situations, a significant gain
in amortized efficiency. Finally, in realistic domains we expect many
properties to fail to persist beyond a few situations into the future,
meaning that our algorithm will require few iterations in a large
number of cases.

Of course, we also inherit the potential disadvantage of the regression
operator: the length of $\mathcal{P_{D}}[\phi,\alpha]$ may be exponential
in the length of $\phi$. As with regression, our experience thus
far has been that this is more than compensated
for by the reduced number of axioms required for reasoning.


\subsection{Applications}

The persistence condition is readily applicable to the persistence
query problems given in Section \ref{sub:Property-Persistence}. Since
$\mathcal{P}_{\mathcal{D}}$ yields a uniform formula, the techniques
outlined in Section \ref{sub:Effective-Reasoning} can be directly
applied to the following transformed queries.

\textbf{Goal Impossibility:} Given a goal $G$, establish that there
is no possible situation in which that goal is satisfied:\[
\mathcal{D}\models\mathcal{P_{D}}[\neg G,Poss][S_{0}]\]
The persistence condition of $\neg G$ with respect to action possibility
allows goal impossibility to be checked easily.

\textbf{Goal Futility:} Given a goal $G$ and situation $s$, establish
that the goal cannot be satisfied in any possible situation in the
future of $s$:\[
\mathcal{D}\models\mathcal{P_{D}}[\neg G,Poss][s]\]
Precisely the same formula is required for checking goal impossibility
and goal futility. This highlights the advantage of re-using the persistence
condition at multiple situations. Our approach makes it feasible for
an agent to check for goal futility each time it considers performing
an action, and avoid situations that would make its goals unachievable. 

\textbf{Checking State Constraints:} This can be handled as per goal
impossibility above. A state constraint $\phi$ must satisfy:\[
\mathcal{D}_{una}\models\phi\equiv\mathcal{P}_{\mathcal{D}}[\phi,Poss]\]


If this is not the case then $\mathcal{P}_{\mathcal{D}}[\phi,Poss]$
indicates the additional conditions that are necessary to ensure that
$\phi$ persists, which may be useful in adjusting the action theory
to accommodate the constraint.

\textbf{Need for Cooperation:} To establish that it is absolutely
necessary to cooperate with another agent, an agent must determine
persistence under actions performed by itself:\[
\mathcal{D}\models\mathcal{P_{D}}[\neg G,OwnAction][s]\]


\textbf{Knowledge under Partial Observability:} 
To know $\phi$ in a world where actions may be unobservable, an agent
must know that $\phi$ will persist under
any actions that it would be unable to observe. This results in a regression
rule for knowledge of the form:\begin{multline*}
\mathcal{R}_{\mathcal{D}}[\mathbf{Knows}(\phi,do(a,s))]=\\
\mathbf{Knows}(\mathcal{R}_{\mathcal{D}}[\mathcal{P}_{\mathcal{D}}[\phi,CantObs][do(a,s)]],s)\end{multline*}



\section{Conclusions\label{sec:Conclusions}}

We have developed an algorithm that transforms persistence queries,
a very general and useful class of situation calculus query, to a
form that is amenable to standard techniques for effective reasoning
in the situation calculus. The algorithm is based on iterative application
of the standard regression operator, and uses only first-order reasoning
with a small number of axioms. Our algorithm is shown to be correct,
and complete given some basic restrictions on the theory of action.

Our approach generalizes previous work on persistence in several important
ways. It can consider sequences of actions satisfying a range of conditions,
not just the standard ordering over possibility, enabling us to treat
problems such as need for cooperation and knowledge under partial
observability. It can establish that properties persist in the future
of an arbitrary situation, not necessarily the initial situation,
enabling us to answer the question of goal futility. The results of
calculating the persistence condition can be cached, allowing for
example the goal futility question to be efficiently posed on a large
number of situations once the persistence condition has been calculated.
Finally, the fact that $\mathcal{P_{D}}$ operates similarly to the
standard regression operator $\mathcal{R}_{\mathcal{D}}$ allows them
to interact in non-trivial ways, such as in the regression of knowledge
formulae under partial observability of actions.

As a result, we have significantly increased the scope of queries
that can be effectively posed in practical systems built on the situation
calculus.

\bibliographystyle{named}

\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Bertossi \bgroup \em et al.\egroup
  }{1996}]{bertossi96automating}
Leopoldo~E. Bertossi, Javier Pinto, Pablo Saez, Deepak Kapur, and Mahadevan
  Subramaniam.
\newblock Automating proofs of integrity constraints in situation calculus.
\newblock In {\em International Syposium on Methodologies for Intelligent
  Systems}, pages 212--222, 1996.

\bibitem[\protect\citeauthoryear{Cousot and
  Cousot}{1979}]{cousot79constructive_tarski}
Patrick Cousot and Radhia Cousot.
\newblock Constructive versions of {T}arski's fixed point theorems.
\newblock {\em Pacific Journal of Maths.}, 82(1):43--57, 1979.

\bibitem[\protect\citeauthoryear{Lin and Reiter}{1994}]{Lin94-StateConstraints}
Fangzhen Lin and Ray Reiter.
\newblock State constraints revisited.
\newblock {\em Journal of Logic and Computation}, 4(5):655--678, 1994.

\bibitem[\protect\citeauthoryear{Pirri and
  Reiter}{1999}]{pirri99contributions_sitcalc}
Fiora Pirri and Ray Reiter.
\newblock Some contributions to the metatheory of the situation calculus.
\newblock {\em Journal of the ACM}, 46(3):325--361, 1999.

\bibitem[\protect\citeauthoryear{Reiter}{1991}]{reiter91frameprob}
Ray Reiter.
\newblock The frame problem in situation the calculus: a simple solution
  (sometimes) and a completeness result for goal regression.
\newblock In Vladimir Lifschitz, editor, {\em Artificial intelligence and
  mathematical theory of computation: papers in honor of John McCarthy}, pages
  359--380, San Diego, CA, USA, 1991. Academic Press Professional, Inc.

\bibitem[\protect\citeauthoryear{Reiter}{1993}]{Reiter93proving}
Ray Reiter.
\newblock Proving properties of states in the situation calculus.
\newblock {\em Artificial Intelligence}, 64:337--351, 1993.

\end{thebibliography}

\end{document}
