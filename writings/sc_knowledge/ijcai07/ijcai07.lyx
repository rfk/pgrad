#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble



\makeatletter



\usepackage{ijcai07}


\usepackage{times}


\usepackage{helvet}


\usepackage{courier}


\usepackage{amsthm}




\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}


\newtheorem{theorem}{Theorem}

\makeatother
\end_preamble
\options letterpaper
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Observation-Based Knowledge in the Multi-Agent Situation Calculus 
\end_layout

\begin_layout Author
Ryan Kelly and Adrian Pearce
\newline
 Department of Computer Science and Software
 Engineering
\newline
 NICTA Victoria Laboratory
\newline
 The University of Melbourne
\newline
 Victoria,
 3010, Australia
\newline
 {rfk,adrian}@csse.unimelb.edu.au
\end_layout

\begin_layout Abstract
We develop a new semantics for knowledge in the situation calculus.
 Situation calculus models of multi-agent domains typically make one of
 two assumptions: that all agents are aware of all actions that have been
 performed, or that each agent is completely ignorant of actions performed
 by others.
 By reifying the observations made by each agent, we develop an improved
 account of knowledge that spans these two extremes.
 Our approach can naturally model agents who monitor the value of fluents
 in their environment, and provides a simpler approach to communication
 actions.
 We show how to reason effectively in this formalism using an extended regressio
n operator that accommodates limited quantification over situations.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus is one of the most popular formalisms for reasoning
 about dynamic worlds.
 Since its inception, many extensions have been proposed to enrich it with
 concepts such as knowledge and concurrent actions.
 These extensions can be combined to provide a rich formalism for modeling
 multi-agent domains.
\end_layout

\begin_layout Standard
A common assumption when working in the situation calculus is that agents
 are fully aware of the actions that have been performed in the world.
 Indeed, the notion of 'situation' is formalized as a history of all actions
 that have occurred.
 In the rare cases that this is not assumed, the opposing extreme is posited
 - that agents are completely ignorant of actions performed by others.
\end_layout

\begin_layout Standard
Both of these assumptions are unrealistic in many domains, and can limit
 the applicability of the situation calculus.
 To overcome this, we reify the notion of 
\emph on
observations
\emph default
 and axiomatize the conditions under which an agent will observe the occurrence
 of an action.
 By ensuring that agents consider possible any situation compatible with
 what they have observed, we develop an improved account of knowledge that
 spans the two extremes.
 We then show that this formulation can be naturally extended to model agents
 who monitor the values of fluents in their environment, rather than directly
 observing actions.
 It also allows communication actions to be added or modified without altering
 the fundamental axioms of knowledge.
\end_layout

\begin_layout Standard
Our new semantics of knowledge depend on universal quantification over situation
 terms, which in the situation calculus requires induction using second-order
 logic and is hence difficult to handle in automated reasoning.
 We show that an extension of the regression operator that handles limited
 quantification over situations can facilitate reasoning within our formulation
 using purely first-order logic.
 The final result is a powerful new account of multi-agent knowledge that
 still permits a suitably efficient reasoning procedure.
\end_layout

\begin_layout Standard
The paper is organized as follows: section 
\begin_inset LatexCommand \ref{sec:ma-sitcalc}

\end_inset

 gives a brief introduction to the situation calculus with knowledge and
 concurrent actions, and highlights some of the limitations of current approache
s; section 
\begin_inset LatexCommand \ref{sec:New-Semantics}

\end_inset

 introduces our improved semantics of knowledge and shows how to reason
 effectively with them; and section 
\begin_inset LatexCommand \ref{sec:Conclusions}

\end_inset

 concludes with a summary of our results.
\end_layout

\begin_layout Section
The Multi-Agent Situation Calculus
\begin_inset LatexCommand \label{sec:ma-sitcalc}

\end_inset


\end_layout

\begin_layout Standard
We work in a version of the the situation calculus as described in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

, enriched with concurrent actions 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 to more realistically represent the dynamics of a multi-agent system.
 We use the approach of 
\begin_inset LatexCommand \cite{shapiro01casl_feat_inter}

\end_inset

 for representing multiple agents, and begin from the standard account of
 knowledge given by 
\begin_inset LatexCommand \cite{scherl03sc_knowledge,scherl03conc_knowledge}

\end_inset

.
 A brief overview is presented below.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic, augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\noun on
Action
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change, with the initiating agent indicated by
 their first argument; 
\noun on
Concurrent
\noun default
 terms are sets of actions that occur simultaneously; 
\noun on
Situation
\noun default
 terms are histories of the concurrent actions that have occurred in the
 world, with the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built up using the function 
\begin_inset Formula $do\,:\, Concurrent\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Result
\noun default
 terms represent sensing results returned by actions, and are written inside
 double-quotes; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 We also distinguish 
\noun on
Fluents
\noun default
 as predicates or functions representing properties of the world that may
 change from one situation to another.
 Fluents take a situation term as their final argument.
\end_layout

\begin_layout Standard
A collection of situation calculus statements that describe the behavior
 of a dynamic world is referred to as a 
\emph on
theory of action
\emph default
 and is typically represented by 
\begin_inset Formula $\Sigma$
\end_inset

.
 Queries about the behavior or evolution of the world are posed as logical
 entailment queries relative to the theory of action.
\end_layout

\begin_layout Subsubsection
Action Precondition Axioms
\end_layout

\begin_layout Standard
There is a distinguished fluent predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 For example, it is only possible for an agent to drop an object if they
 are actually holding it: 
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow the convention that lower-case names indicate variables, with
 free variables being implicitly universally quantified 
\end_layout

\end_inset

 
\begin_inset Formula \[
Poss(drop(agt,obj),s)\equiv Holding(agt,obj,s)\]

\end_inset

 For concurrent actions, an arbitrary combination of actions 
\begin_inset Formula $\{ a_{1},a_{2}\}$
\end_inset

 is not guaranteed to be possible.
 While the actions 
\begin_inset Formula $moveTo(Chair)$
\end_inset

 and 
\begin_inset Formula $moveTo(Table)$
\end_inset

 may individually be possible, performing them concurrently clearly is not.
 This is known as the precondition interaction problem 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

.
 A simple solution is to explicitly state which actions cannot be performed
 together using a predicate 
\begin_inset Formula $Conflicts$
\end_inset

: 
\begin_inset Formula \begin{multline*}
Poss(c,s)\equiv\\
\forall a\left[a\in c\rightarrow Poss(a,s)\right]\wedge\neg Conflicts(c,s)\end{multline*}

\end_inset

 For this paper, we make no particular commitment toward a solution to this
 problem.
\end_layout

\begin_layout Subsubsection
Successor State Axioms
\end_layout

\begin_layout Standard
The truth of the various fluents is specified by defining what is true of
 the initial situation, and collecting the effects of various actions into
 
\emph on
successor state axioms
\emph default
.
 Such axioms provide a monotonic solution to the infamous frame problem
 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

 and are a principle attraction of the situation calculus.
 They have the general form: 
\begin_inset Formula \begin{multline*}
F(\overrightarrow{x},do(c,s))\equiv\\
\Gamma^{+}(\overrightarrow{x},c,s)\,\vee\, F(\overrightarrow{x},s)\wedge\neg\Gamma^{-}(\overrightarrow{x},c,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $F$
\end_inset

 is a fluent with non-situation arguments 
\begin_inset Formula $\overrightarrow{x}$
\end_inset

, 
\begin_inset Formula $\Gamma^{+}$
\end_inset

 is a formula giving the conditions under which 
\begin_inset Formula $F$
\end_inset

 will become true, and 
\begin_inset Formula $\Gamma^{-}$
\end_inset

 a formula giving the conditions under which 
\begin_inset Formula $f$
\end_inset

 will become false.
 In words, these axioms state that 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after doing actions 
\begin_inset Formula $c$
\end_inset

 if 
\begin_inset Formula $c$
\end_inset

 causes 
\begin_inset Formula $F$
\end_inset

 to become true, or 
\begin_inset Formula $F$
\end_inset

 is currently true and 
\begin_inset Formula $c$
\end_inset

 doesn't cause 
\begin_inset Formula $F$
\end_inset

 to become false
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Uniform Formulae
\end_layout

\begin_layout Standard
An important class of formulae in the situation calculus are the 
\emph on
uniform formulae
\emph default
 - those that refer to a single situation term, so representing a property
 of a situation.
 Throughout this paper, we will use the meta-variable 
\begin_inset Formula $\phi$
\end_inset

 to refer to an arbitrary uniform formula.
 Where no confusion can arise, we suppress the situation terms in uniform
 formulae to simplify the presentation.
 It is also standard practice to pass uniform formulae as arguments to other
 functions or predicates - this technically requires an encoding of formulae
 as terms, as discussed in 
\begin_inset LatexCommand \cite{shapiro01casl_feat_inter}

\end_inset

.
 We omit such details for notational simplicity.
\end_layout

\begin_layout Standard
It is often useful to determine the truth of a uniform formula at a given
 situation term.
 The formula 
\begin_inset Formula $\phi[s]$
\end_inset

 represents the uniform formula 
\begin_inset Formula $\phi$
\end_inset

 with all occurrences of its unique situation term replaced by the situation
 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Communication
\end_layout

\begin_layout Standard
Inter-agent communication is typically modeled using special communication
 actions.
 Representative of this approach are the 
\begin_inset Formula $informWhether(agt_{1},agt_{2},\phi)$
\end_inset

 and 
\begin_inset Formula $informRef(agt_{1},agt_{2},\theta)$
\end_inset

 actions of 
\begin_inset LatexCommand \cite{shapiro01casl_feat_inter}

\end_inset

, whereby 
\begin_inset Formula $agt_{1}$
\end_inset

 informs 
\begin_inset Formula $agt_{2}$
\end_inset

 about the truth of a formula or the referent of a function respectively.
 We shorten these to 
\begin_inset Formula $infWhether$
\end_inset

 and 
\begin_inset Formula $infRef$
\end_inset

 in our presentation.
 Such actions are intricately connected with knowledge, and existing accounts
 directly include them in the dynamics of knowledge change.
\end_layout

\begin_layout Subsubsection
Knowledge and Sensing
\end_layout

\begin_layout Standard
The semantics of knowledge in the situation calculus 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

 are based on the popular 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 model.
 A knowledge fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 A knowledge operator 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 is then introduced as a macro: 
\begin_inset Formula \begin{equation}
\mathbf{Knows}(agt,\phi,s)\isdef\forall s'\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Thus an agent knows something if it is true in all situations that the agent
 considers possible.
 This can be specialized with further macros, such as an agent knowing whether
 or not some formula holds: 
\begin_inset Formula \begin{multline*}
\mathbf{KWhether}(agt,\phi,s)\isdef\\
\mathbf{Knows}(agt,\phi,s)\vee\mathbf{Knows}(agt,\neg\phi,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
To allow actions to return sensing information, the sensing result function
 
\begin_inset Formula $SR(a,s)$
\end_inset

 is introduced to give the result returned by the action 
\begin_inset Formula $a$
\end_inset

 when executed in a situation 
\begin_inset Formula $s$
\end_inset

.
 This is defined by axioms of the form: 
\begin_inset Formula \[
SR(a(\overrightarrow{x}),s)=r\equiv\phi_{a}(\overrightarrow{x},r,t,s)\]

\end_inset


\end_layout

\begin_layout Standard
For actions that don't return sensing information, the value of 
\begin_inset Formula $SR$
\end_inset

 is set to some arbitrary constant such as 
\begin_inset Formula $"OK"$
\end_inset

.
 As an example, consider the action 
\begin_inset Formula $sense_{F}$
\end_inset

 which senses whether fluent 
\begin_inset Formula $F$
\end_inset

 is true or false.
 Its sensing result axiom would be given by: 
\begin_inset Formula \begin{multline*}
SR(sense_{F},s)=r\equiv\\
(r="YES"\wedge F(s))\vee(r="NO"\wedge\neg F(s))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Combining the multi-agent semantics of 
\begin_inset LatexCommand \cite{shapiro01casl_feat_inter}

\end_inset

 with the handling of concurrent actions in 
\begin_inset LatexCommand \cite{scherl03conc_knowledge}

\end_inset

, the common form of successor state axiom for the knowledge fluent can
 be written as:
\begin_inset Formula \begin{multline}
K(agt,s'',do(c,s))\equiv\\
\exists s'\,.\, s''=do(c,s')\,\wedge K(agt,s',s)\wedge Poss(c,s')\\
\wedge\,\forall a\left[a\in c\wedge agent(a)=agt\rightarrow SR(a,s)=SR(a,s')\right]\\
\wedge\,\forall agt_{2},\phi\left[infWhether(agt_{2},agt,\phi)\in c\rightarrow\phi[s']\equiv\phi[s]\right]\\
\wedge\,\forall agt_{2},\theta\left[infRef(agt_{2},agt,\theta)\in c\rightarrow\theta[s']=\theta[s]\right]\label{eqn:k_ssa_standard}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
In words, this states that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(c,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing those same actions 
\begin_inset Formula $c$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is a possible alternative to 
\begin_inset Formula $s$
\end_inset

.
 The situation 
\begin_inset Formula $s''$
\end_inset

 must furthermore be possible, the sensing results must be consistent for
 all actions in 
\begin_inset Formula $c$
\end_inset

 that were carried out by the agent, and the situation must be consistent
 with what it has been informed by others.
\end_layout

\begin_layout Standard
Alternate possible worlds to the initial situation are identified by truth
 of the predicate 
\begin_inset Formula $K_{0}(agt,s)$
\end_inset

.
 This allows the 
\begin_inset Formula $K$
\end_inset

 fluent to be fully specified, by asserting that:
\begin_inset Formula \begin{equation}
K(agt,s,S_{0})\equiv K_{0}(agt,s)\end{equation}

\end_inset


\end_layout

\begin_layout Standard
While powerful, this formulation suffers from a severe limitation: each
 agent must be aware of 
\emph on
all
\emph default
 actions that have occurred.
 Responsibility for generating such 
\begin_inset Quotes eld
\end_inset

awareness
\begin_inset Quotes erd
\end_inset

 is abdicated to a separate component of the agent's software.
 Many realistic multi-agent domains clearly do not satsify this assumption.
 An alternate formulation from 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset

 gives the opposite extreme:
\begin_inset Formula \begin{multline}
K(agt,s'',do(c,s))\equiv\\
\exists s',s^{*},c'\,.\, s''=do(c',s^{*})\,\wedge K(s',s)\wedge Poss(c',s^{*})\\
\wedge\,\mathbf{ExoOnly}(agt,s',s^{*})\\
\wedge\,\forall a\left[agent(a)=agt\rightarrow a\in c'\equiv a\in c\right]\\
\wedge\,\forall a\left[a\in c\wedge agent(a)=agt\rightarrow SR(a,s)=SR(a,s')\right]\\
\wedge\,\forall agt_{2},\phi\left[infWhether(agt_{2},agt,\phi)\in c\rightarrow\phi[s']\equiv\phi[s]\right]\\
\wedge\,\forall agt_{2},\theta\left[infRef(agt_{2},agt,\theta)\in c\rightarrow\theta[s']=\theta[s]\right]\label{eqn:k_ssa_exo}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
Where the macro 
\begin_inset Formula $\mathbf{ExoOnly}$
\end_inset

 indicates that two situations are connected only by actions performed by
 other agents:
\begin_inset Formula \begin{multline*}
\mathbf{ExoOnly}(agt,s,s'')\,\isdef\, s\leq s''\wedge\\
\forall s',c,a\left[s<do(c,s')\leq s''\wedge a\in c\rightarrow agent(a)\neq agt\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
With this approach, agents consider possible any situation compatible with
 the actions that they themselves have performed.
 There may have been an arbitrary sequence of situations between 
\begin_inset Formula $s'$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

 which the agent knew nothing about, because they consisted entirely of
 exogenous (from 
\begin_inset Formula $agt$
\end_inset

's point of view) actions.
 But this approach is also limiting, in that agents can 
\emph on
never
\emph default
 be aware of the actions performed by others.
 Full generality requires a middle ground, with agents being aware of 
\emph on
some
\emph default
 of the actions performed by others.
\end_layout

\begin_layout Standard
Furthermore, suppose that 
\begin_inset Formula $agt$
\end_inset

 has just performed action 
\begin_inset Formula $a_{1}$
\end_inset

, so the world is in some situation 
\begin_inset Formula $do(a_{1},s)$
\end_inset

.
 Another agent then performs the action 
\begin_inset Formula $a_{2}$
\end_inset

, leaving the world in situation 
\begin_inset Formula $do(a_{2},do(a_{1},s))$
\end_inset

.
 Since it cannot observe 
\begin_inset Formula $a_{2}$
\end_inset

 occurring, 
\begin_inset Formula $agt$
\end_inset

 would not be aware that the state of the world has changed.
 Its set of possible situations should therefore remain unchanged.
 Unfortunately this is not the case: 
\begin_inset Formula $K(agt,s',do(a_{2},do(a_{1},s)))\not\equiv K(agt,s',do(a_{1},s))$
\end_inset

 under this formulation.
 To faithfully represent this aspect of the knowledge of real-world agents,
 the successor state axiom for 
\begin_inset Formula $K$
\end_inset

 must permit any arbitrary future of 
\begin_inset Formula $do(a_{1},s)$
\end_inset

 that can be brought about by exogenous actions, rather than any arbitrary
 past as done above.
\end_layout

\begin_layout Standard
We overcome these limitations with the development of an improved successor
 state axiom for 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Belief
\end_layout

\begin_layout Standard
We note that this point that we are interested in a logic of 
\emph on
knowledge
\emph default
 - everything known by and agent must actually be true in the world.
 There has also been significant work on modelling 
\emph on
belief
\series bold
\emph default
 
\series default
in the situation calculus, where agents may be mistaken about what is true.
 
\begin_inset LatexCommand \cite{shapiro04sc_belief_exog}

\end_inset

 show how agents may hypothesise the occurance of exogenous actions when
 they discover that they are mistaken, neatly avoiding the issue of being
 aware of the actions performed by others.
 This approach cannot be applied when dealing with knowledge.
 However, we believe that the concrete notion of observations we develop
 below will also be useful for belief-based systems.
\end_layout

\begin_layout Subsubsection
Regression
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of efficient
 reasoning procedures for certain types of query.
 The principle tool is the regression meta-operator 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

 which transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into a formula 
\begin_inset Formula $\mathcal{R}_{\Sigma}(\phi)$
\end_inset

 uniform in 
\begin_inset Formula $s$
\end_inset

, such that the two are equivalent relative to the theory of action 
\begin_inset Formula $\Sigma$
\end_inset

.
 By repeatedly applying the regression operator, 
\begin_inset Formula $\phi$
\end_inset

 can be transformed into an equivalent formula uniform in the initial situation:
\begin_inset Formula \[
\Sigma\models\phi[do(c_{1},do(c_{2},\dots,do(c_{n},S_{0}))]\equiv\mathcal{R}_{\Sigma}^{*}(\phi)[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Many of the axioms from 
\begin_inset Formula $\Sigma$
\end_inset

 are not required for reasoning about the initial situation, and so can
 be discarded when reasoning about 
\begin_inset Formula $\mathcal{R}_{\Sigma}^{*}(\phi)[S_{0}]$
\end_inset

.
 This is frequently more efficient than directly reasoning about 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

, the regression operator is extended to handle to the standard account
 of knowledge (equation 
\begin_inset LatexCommand \ref{eqn:k_ssa_standard}

\end_inset

) by reducing reasoning about formulae containing the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro to 
\emph on
modal
\emph default
 reasoning over the 
\begin_inset Formula $K_{0}$
\end_inset

 relation.
 Regressing such formulae relies on the fact that agents are aware of all
 actions - formulae containing quantification over situations, such as the
 modified successor state axiom for knowledge in equation 
\begin_inset LatexCommand \ref{eqn:k_ssa_exo}

\end_inset

, cannot be handled by the regression operator.
 Indeed, 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset

 offer no procedure for reasoning in their formalism other than using second-ord
er induction.
\end_layout

\begin_layout Standard
By using an extension of the regression idea that can handle limited forms
 of quantification over situations, we provide a purely first-order reasoning
 procedure for our improved account of knowledge.
\end_layout

\begin_layout Section
New Semantics of Knowledge
\begin_inset LatexCommand \label{sec:New-Semantics}

\end_inset


\end_layout

\begin_layout Subsubsection
Observations
\end_layout

\begin_layout Standard
Existing accounts of knowledge in the situation calculus all employ an assumptio
n about when an agent is aware of the occurrence of an action - either 
\begin_inset Quotes eld
\end_inset

agents are always aware of actions
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

agents are only aware of actions that they themselves perform
\begin_inset Quotes erd
\end_inset

.
 We replace such assumptions with a question: 
\begin_inset Quotes eld
\end_inset

when will an agent be aware of the occurrence of an action?
\begin_inset Quotes erd
\end_inset

.
 By providing a way to answer this question within the theory of action,
 a more general account of knowledge can be developed.
\end_layout

\begin_layout Standard
A new fluent is introduced, akin to 
\begin_inset Formula $Poss$
\end_inset

 but describing when actions will be observed by agents: 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 indicates that agent 
\begin_inset Formula $agt$
\end_inset

 would be aware of action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 As before, we assume that in an implemented system this 
\begin_inset Quotes eld
\end_inset

awareness
\begin_inset Quotes erd
\end_inset

 is generated by some other component of the agent's software.
 The important point is that if 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 is true and action 
\begin_inset Formula $a$
\end_inset

 occurs, then 
\begin_inset Formula $agt$
\end_inset

 will be made aware of it.
 Likewise, if 
\begin_inset Formula $agt$
\end_inset

 is not aware that action 
\begin_inset Formula $a$
\end_inset

 occurred, then it did not occur.
 The axiomatisation of this predicate, like that of 
\begin_inset Formula $Poss$
\end_inset

, is the responsibility of the domain modeler.
\end_layout

\begin_layout Standard
There is a related assumption implicit in the handling of sensing actions:
 that only the agent performing a sensing action is aware of its result.
 Such a restriction is common in the real world, but certainly not universal.
 Consider an agent waiting for a train who activates a speaker to acquire
 information about when it will arrive.
 The result of this sensing action would be available to any other agent
 within earshot.
 We add an analogous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 to indicate when the sensing information resulting from an action is available
 to an agent.
\end_layout

\begin_layout Standard
Since we will often want to compare what is observed by an agent in different
 situations, we introduce a new sort 
\noun on
Observations
\noun default
 consisting of sets of action/result pairs.
 We then define the function 
\begin_inset Formula $Observations(agt,c,s)$
\end_inset

 which returns precisely the set of 
\begin_inset Formula $<action,result>$
\end_inset

 pairs that 
\begin_inset Formula $agt$
\end_inset

 would be aware of if the concurrent actions 
\begin_inset Formula $c$
\end_inset

 were performed in situation 
\begin_inset Formula $s$
\end_inset

 .
 The special result term 
\begin_inset Quotes eld
\end_inset

?
\begin_inset Quotes erd
\end_inset

 indicates that the result of an action was not available:
\begin_inset Formula \begin{multline}
Observations(agt,c,s)=o\equiv\\
\forall a,r\,\left[<a,r>\in o\equiv a\in c\wedge CanObs(agt,a,s)\right.\\
\wedge\,\left(CanSense(agt,a,s)\wedge r=SR(a,s)\right.\\
\left.\vee\,\left.\neg CanSense(agt,a,s)\wedge r="?"\right)\right]\label{eqn:observations_orig}\end{multline}

\end_inset

 Like their counterpart 
\begin_inset Formula $Poss$
\end_inset

, 
\begin_inset Formula $CanObs$
\end_inset

 and 
\begin_inset Formula $CanSense$
\end_inset

 may suffer from interaction problems when concurrent actions are considered
 - for example, one agent moving in front of another may mean the second
 agent's actions are no longer observable.
 While we are confident an approach similar to that used for precondition
 interaction can be applied, this remains an open problem.
\end_layout

\begin_layout Subsubsection
Successor State Axiom for 
\begin_inset Formula $K$
\end_inset


\end_layout

\begin_layout Standard
Given an explicit account of the observations made by each agent, the required
 semantics of the 
\begin_inset Formula $K$
\end_inset

 relation are clear: 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 must hold whenever situations 
\begin_inset Formula $s''$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 would result in the same sequence of observations being made by the agent.
 We first introduce the abbreviation 
\begin_inset Formula $\mathbf{Unobs}(agt,s,s')$
\end_inset

, which is true when 
\begin_inset Formula $agt$
\end_inset

 would not be aware of any of the actions leading from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

: 
\begin_inset Formula \begin{multline}
\mathbf{Unobs}(agt,s,s''))\,\isdef\,\neg\exists c',s'\,.\, s<do(c',s')\leq s''\\
\wedge\, Observations(agt,c',s')\neq\{\}\label{eqn:unobs_defn}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
If the agent considers possible a situation 
\begin_inset Formula $s$
\end_inset

 then it must also consider possible any situation 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $\mathbf{Unobs}(s,s')$
\end_inset

, as it would be completely unaware of the world changing from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
 Also note that 
\begin_inset Formula $\mathbf{Unobs}(s,s)$
\end_inset

 is always true.
 Let us further introduce the predicate 
\begin_inset Formula $Legal(s)$
\end_inset

, which states that a situation can legally be brought about in the world.
 For this basic situation calculus, it suffices to constrain all actions
 to be possible: 
\begin_inset Formula \begin{multline}
Legal(s)\equiv\exists c',s'\, s=do(c',s')\rightarrow\\
Poss(c',s')\wedge Legal(s')\end{multline}

\end_inset


\end_layout

\begin_layout Standard
The following successor state axiom for knowledge then captures the desired
 semantics: 
\begin_inset Formula \begin{multline}
K(agt,s'',do(c,s))\equiv\\
Observations(agt,c,s)=\{\}\wedge K(agt,s'',s)\\
\shoveleft{\vee\,\,\exists o\, Observations(agt,c,s)=o\,\wedge}\\
o\neq\{\}\wedge Legal(s'')\,\wedge\\
\exists c',s'\, Observations(agt,c',s')=o\,\wedge\\
K(agt,s',s)\wedge\mathbf{Unobs}(agt,do(c',s'),s'')\label{eqn:new_k_ssa}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $c$
\end_inset

 was totally unobservable, the agent's state of knowledge does not change.
 Otherwise, it considers possible any legal successor to a possible situation
 that can be brought about by actions 
\begin_inset Formula $c'$
\end_inset

 resulting in the same set of observations 
\begin_inset Formula $o$
\end_inset

.
 It also considers possible any unobservable future of such a situation.
\end_layout

\begin_layout Standard
It remains to specify the truth of the 
\begin_inset Formula $K$
\end_inset

 fluent in the initial situation.
 Assuming that alternate initial situations are identified by the truth
 of 
\begin_inset Formula $K_{0}(agt,s)$
\end_inset

 as in previous works, then the following captures the intended semantics:
\begin_inset Formula \begin{multline}
K(agt,s,S_{0})\equiv\\
Legal(s)\wedge\exists s'\,\left[K_{0}(agt,s')\wedge\mathbf{Unobs}(agt,s',s)\right]\label{eqn:new_k_s0}\end{multline}

\end_inset

 This new formulation overcomes the limitations highlighted in previous
 sections.
 By appropriately axiomatizing 
\begin_inset Formula $CanObs$
\end_inset

 and 
\begin_inset Formula $CanSense$
\end_inset

 it is possible to model both total awareness of actions and total ignorance.
 It also enables previously unaccounted-for circumstances, such as only
 being aware of the actions of all agents within one's field of view, or
 all agents on one's own team.
 At the same time, it ensures that an agent's state of knowledge does not
 change if it is not aware of any actions occurring.
 It is thus a true generalization and improvement over previous approaches.
\end_layout

\begin_layout Standard
It is straightforward to verify that important properties of the 
\begin_inset Formula $K$
\end_inset

 relation discussed in 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

 are maintained by our new formulation, including memory, default persistence
 of ignorance, knowledge producing effects, and preservation of transitive,
 symmetric, reflexive and euclidean relations.
 We omit proofs for space reasons.
\end_layout

\begin_layout Subsubsection
Observing Fluent Change
\end_layout

\begin_layout Standard
In many domains it may be infeasible for an agent to be aware that a particular
 action has occurred, instead only being aware that a particular fluent
 has changed.
 For example, suppose that an agent monitors the state of a light bulb in
 its environment, such that it notices it changing from dark to light.
 While it knows that 
\emph on
some
\emph default
 action must have occurred, it is not aware of precisely which action took
 place.
\end_layout

\begin_layout Standard
To model this, we introduce a special class of actions called 
\emph on
change actions
\emph default
, whose sole purpose is to inform agents that some property of the world
 has changed.
 They can never be executed and so never appear in situation terms directly.
 Instead they are included in the list of observations made by an agent,
 by modifying the 
\begin_inset Formula $Observations$
\end_inset

 predicate like so:
\begin_inset Formula \begin{multline}
Observations(agt,c,s)=o\equiv\\
\forall a,r\,\left[<a,r>\in o\equiv\right.\\
\left[a\in c\,\vee\, changeAction(a)\wedge SR(a,s)\neq SR(a,do(c,s))\right]\\
\wedge CanObs(agt,a,s)\\
\wedge\,\left(CanSense(agt,a,s)\wedge SR(a,s)=r\right.\\
\left.\vee\,\left.\neg CanSense(agt,a,s)\wedge r="?"\right)\right]\end{multline}

\end_inset

 According to this definition, change actions appear in the list of observations
 only when the corresponding sensing result changes in the successor situation.
 By defining an appropriate 
\begin_inset Formula $SR$
\end_inset

 function, and making agents aware of such actions using 
\begin_inset Formula $CanObs$
\end_inset

 and 
\begin_inset Formula $CanSense$
\end_inset

, our formalism can neatly handle this form of environmental awareness.
\end_layout

\begin_layout Subsubsection
Communication
\end_layout

\begin_layout Standard
The traditional inclusion of communication actions directly in the successor
 state axiom for 
\begin_inset Formula $K$
\end_inset

 complicates the semantics of knowledge and makes it cumbersome to introduce
 new communication actions.
 Our formulation provides a ready alternative - encode communication actions
 are sensing actions where both sender and recipient are aware of the outcome.
 Consider formulating the action 
\begin_inset Formula $infWhether$
\end_inset

 in this framework:
\begin_inset Formula \begin{multline*}
Poss(infWhether(agt_{1},agt_{2},\phi),s)\equiv\\
\shoveright{\mathbf{KWhether}(agt_{1},\phi,s)}\\
\shoveleft{SR(infWhether(agt_{2},agt_{3},\phi),s)=r\equiv}\\
\shoveright{(r="YES"\wedge\phi[s])\,\vee\,(r="NO"\wedge\neg\phi[s])}\\
\shoveleft{CanObs(agt_{1},infWhether(agt_{2},agt_{3},\phi),s)\equiv}\\
\shoveright{agt_{1}=agt_{2}\,\vee\, agt_{1}=agt_{3}}\\
\shoveleft{CanSense(agt_{1},infWhether(agt_{2},agt_{3},\phi),s)\equiv}\\
agt_{1}=agt_{2}\,\vee\, agt_{1}=agt_{3}\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
It is straightforward to show that the intended semantics of this communication
 are now enforced by the general successor state axiom for 
\begin_inset Formula $K$
\end_inset

.
 Only sender and recipient will be aware that the communication has occurred,
 and their state of knowledge will be updated to take into account the communica
ted truth/falsity of 
\begin_inset Formula $\phi$
\end_inset

 in accordance with 
\begin_inset Formula $SR$
\end_inset

.
 This significantly improves the modularity of communication actions in
 the situation calculus.
\end_layout

\begin_layout Subsubsection
Regression
\end_layout

\begin_layout Standard
The appearance of 
\begin_inset Formula $\mathbf{Unobs}$
\end_inset

 in equation 
\begin_inset LatexCommand \ref{eqn:new_k_ssa}

\end_inset

 means that our new successor state axiom is not regressable using standard
 techniques.
 To permit an effective reasoning procedure, we appeal to the 
\emph on
persistence condition
\emph default
 meta-operator.
 In recent unpublished work [citation omitted] we introduce a new meta-operator
 
\begin_inset Formula $\mathcal{P}_{\Sigma}(\phi,\alpha)$
\end_inset

, taking a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and some action conditions 
\begin_inset Formula $\alpha(c,s)$
\end_inset

 , such that: 
\begin_inset Formula \begin{multline}
\Sigma\models\mathcal{P}_{\Sigma}(\phi,\alpha)[s]\equiv\forall s''\, s\leq s''\wedge\\
\neg\exists c',s'\, s<do(c',s')\leq s''\wedge\neg\alpha(c',s')\rightarrow\phi[s'']\label{eqn:P_defn}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
The truth of 
\begin_inset Formula $\mathcal{P}_{\Sigma}(\phi,\alpha)$
\end_inset

 in a situation 
\begin_inset Formula $s$
\end_inset

 guarantees that, as long as all actions satisfy 
\begin_inset Formula $\alpha$
\end_inset

, the formula 
\begin_inset Formula $\phi$
\end_inset

 will remain true in all situations in the future of 
\begin_inset Formula $s$
\end_inset

.
 It thus represents the conditions under which 
\begin_inset Formula $\phi$
\end_inset

 will 
\emph on
persist
\emph default
 with respect to a given class of actions.
 The procedure for determining 
\begin_inset Formula $\mathcal{P}_{\Sigma}$
\end_inset

 replaces second-order induction with iterated first-order reasoning, and
 always produces a uniform formula.
\end_layout

\begin_layout Standard
By singling out unobservable actions, the persistence condition can be used
 to augment existing techniques for regressing formulae about knowledge.
 Define the macro 
\begin_inset Formula $\mathbf{UA}$
\end_inset

 to identify legal, unobservable sets of actions:
\begin_inset Formula \begin{multline*}
\mathbf{UA}(agt,c,s)\isdef\\
Legal(do(c,s))\wedge Observations(agt,c,s)=\{\}\end{multline*}

\end_inset

Assuming that the 
\begin_inset Formula $K$
\end_inset

 fluent appears only in the context of a 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, we then propose the following to replace the regression of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 given by 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

: 
\begin_inset Formula \begin{multline}
\mathcal{R}_{\Sigma}(\mathbf{Knows}(agt,\phi,do(c,s)))=\\
\left[Observations(agt,c,s)=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
\wedge\left[\exists o\,.\, Observations(agt,c,s)=o\wedge o\neq\{\}\rightarrow\right.\\
\mathbf{Knows}(agt,\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\left.\mathcal{R}_{\Sigma}(\mathcal{P}_{\Sigma}(\phi,\mathbf{UA}(agt))[do(c',s')]),s)\right]\end{multline}

\end_inset

As required, this reduces reasoning about knowledge in 
\begin_inset Formula $do(c,s)$
\end_inset

 to reasoning about knowledge in 
\begin_inset Formula $s$
\end_inset

.
 It is also intuitively appealing: to know that 
\begin_inset Formula $\phi$
\end_inset

 holds, the agent must know that in all situations that agree with its observati
ons, 
\begin_inset Formula $\phi$
\end_inset

 cannot become false without it noticing that an action has occurred.
 We must also specify the regression of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 in the initial situation, as equation 
\begin_inset LatexCommand \ref{eqn:new_k_s0}

\end_inset

 also quantifies over situations:
\begin_inset Formula \begin{multline}
\mathcal{R}_{\Sigma}(\mathbf{Knows}(agt,\phi,S_{0}))=\\
\forall s\, K_{0}(agt,s)\rightarrow\mathcal{P}_{\Sigma}(\phi,\mathbf{UA}(agt))[s]\end{multline}

\end_inset

 This is standard first-order modal reasoning over the 
\begin_inset Formula $K_{0}$
\end_inset

 relation.
 We sketch below the highlights of a proof that our modified regression
 operator preserve equivalence.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a theory of action 
\begin_inset Formula $\Sigma$
\end_inset

 with regression and persistence operators defined relative to it, and a
 ground situation term 
\begin_inset Formula $s$
\end_inset

, it is always the case that: 
\begin_inset Formula \begin{equation}
\Sigma\models\phi[s]\equiv\mathcal{R}_{\Sigma}^{*}(\phi)[S_{0}]\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{theorem}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It suffices to show that 
\begin_inset Formula $\mathcal{R}_{\Sigma}$
\end_inset

 preserves equivalence for 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

, as that it all we have modified from 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

.
 Employing the successor state axiom from equation 
\begin_inset LatexCommand \ref{eqn:new_k_ssa}

\end_inset

, the definition of the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 operator from equation 
\begin_inset LatexCommand \ref{eqn:knows_def}

\end_inset

 can be re-written in the equivalent form: 
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\\
\forall s''\left[Observations(agt,c,s)=\{\}\wedge K(agt,s'',s)\right.\\
\vee\,\,\exists o\, Observations(agt,c,s)=o\wedge\\
o\neq\{\}\wedge Legal(s'')\wedge\\
\exists c',s'\, Observations(agt,c',s')=o\\
\left.\wedge K(agt,s',s)\wedge\mathbf{Unobs}(agt,do(c',s'),s'')\right]\,\rightarrow\,\phi[s'']\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Through a series of equivalence-preserving transformations, this can be
 re-written as: 
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\\
\left[Observations(agt,c,s)=\{\}\rightarrow\forall s''K(agt,s'',s)\rightarrow\phi[s'']\right]\\
\wedge\left[\exists o\,.\, Observations(agt,c,s)=o\wedge o\neq\{\}\rightarrow\right.\\
\forall s'\, K(agt,s',s)\rightarrow\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\left.\forall s''\, Legal(s'')\wedge\mathbf{Unobs}(agt,do(c',s'),s'')\,\rightarrow\,\phi[s'']\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Note that both of these conjuncts now contain sub-formulae matching the
 form of the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro.
 It can thus be substituted back in to give: 
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\\
\left[Observations(agt,c,s)=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
\wedge\left[\exists o\,.\, Observations(agt,c,s)=o\wedge o\neq\{\}\rightarrow\right.\\
\left.\mathbf{Knows}(agt,\mathbf{PK}(\phi,o)),s)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Where we have defined the abbreviation 
\begin_inset Formula $\mathbf{PK}(\phi,o,s')$
\end_inset

 as: 
\begin_inset Formula \begin{multline*}
\mathbf{PK}(\phi,o,s')\isdef\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\forall s''\, Legal(s'')\wedge\mathbf{Unobs}(agt,do(c',s'),s'')\,\rightarrow\,\phi[s'']\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset Formula $\mathbf{PK}(\phi,o,s')$
\end_inset

 to legitimately appear in the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro it must be uniform in the situation variable 
\begin_inset Formula $s'$
\end_inset

.
 Noting that equation 
\begin_inset LatexCommand \ref{eqn:unobs_defn}

\end_inset

 matches the form of equation 
\begin_inset LatexCommand \ref{eqn:P_defn}

\end_inset

, and regressing to make the expression uniform in 
\begin_inset Formula $s'$
\end_inset

, we develop the following equivalence, which is as required: 
\begin_inset Formula \begin{multline*}
\mathbf{PK}(\phi,o,s')\equiv\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\mathcal{R}_{\Sigma}(\mathcal{P}_{\Sigma}(\phi,Legal()\wedge Observations(agt)=\{\})[do(c',s')])\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
For the initial situation, a straightforward transformation of equations
 
\begin_inset LatexCommand \ref{eqn:knows_def}

\end_inset

 and 
\begin_inset LatexCommand \ref{eqn:new_k_s0}

\end_inset

 gives: 
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(\phi,S_{0})\equiv\\
\forall s\, K_{0}(agt,s)\rightarrow\{\forall s'\, Legal(s')\wedge\mathbf{Unobs}(s,s')\rightarrow\phi[s']\}\end{multline*}

\end_inset

 Applying the persistence condition operator, this can easily be re-written
 in the required form: 
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(\phi,S_{0})\equiv\forall s\, K_{0}(agt,s)\rightarrow\\
\mathcal{P}(\phi,Legal()\wedge Observations(agt)=\{\})[s]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can thus reduce reasoning about knowledge to modal reasoning in the initial
 situation, as in previous work.
 Our extension of the regression operator provides a mechanical procedure
 for reasoning in our improved account of knowledge, without requiring second-or
der induction.
\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand \label{sec:Conclusions}

\end_inset


\end_layout

\begin_layout Standard
In this paper we have significantly increased the scope of the situation
 calculus for modeling knowledge in multi-agent domains.
 By explicitly reifying the observations made by each agent as the world
 evolves, we have generalized the dynamics of knowledge update.
 We have shown that this can accommodate the important case where agents
 are aware that a property of their environment has changed, but do not
 know the precise actions responsible.
 A pleasing offshoot of this generalization is that communication actions,
 previously tied intimately to the dynamics of knowledge, can now be added
 or modified with the same ease as regular actions.
 Despite requiring universal quantification over future situations, we have
 shown that the regression operator - the standard tool for efficient reasoning
 in the situation calculus - can be adapted to our new formalism.
\end_layout

\begin_layout Standard
With our new semantics of knowledge, the situation calculus is well positioned
 for representing and reasoning about much more realistic multi-agent domains.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
bibliographystyle{named}
\end_layout

\end_inset

 
\begin_inset LatexCommand \bibtex[named]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
