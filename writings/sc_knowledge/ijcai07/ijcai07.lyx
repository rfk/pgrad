#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble

\usepackage{ijcai07}

\usepackage{times}

\usepackage{helvet}

\usepackage{courier}

\usepackage{amsthm}


\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}


\newtheorem{theorem}{Theorem}
\end_preamble
\options letterpaper
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Knowledge and Observations in the Situation Calculus 
\end_layout

\begin_layout Author
Ryan Kelly and Adrian Pearce
\newline
NICTA Victoria Laboratory
\newline
 Department of Computer
 Science and Software Engineering
\newline
 The University of Melbourne
\newline
 Victoria,
 3010, Australia
\newline
 {rfk,adrian}@csse.unimelb.edu.au
\end_layout

\begin_layout Abstract
We develop a new semantics for knowledge in the situation calculus by reifying
 the observations that each agent makes as the world evolves.
 Our approach is strictly more general than previous formalisms, and can
 easily model agents who monitor the value of fluents in their environment.
 We develop a technique for effective reasoning in this formalism using
 an extended regression operator that facilitates quantification over situations
, and show how it allows agents to reason from their internal history of
 observations, rather than requiring a full history of the world.
 This makes the situation calculus more suitable for implementation in real-worl
d systems.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 is one of the most popular formalisms for reasoning about dynamic worlds.
 Many extensions have been proposed to introduce concepts such as knowledge
 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

 and concurrent actions 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

, which can be combined to provide a rich formalism for modeling complex
 domains such as multi-agent systems.
\end_layout

\begin_layout Standard
A common assumption when working with knowledge in the situation calculus
 is that agents are fully aware of the actions that have been performed
 in the world.
 Indeed, the notion of 'situation' is formalized as a history of all actions
 that have occurred.
 In the rare cases that this is not assumed, the opposing extreme is posited
 - that agents are completely ignorant of actions performed by others 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset

.
\end_layout

\begin_layout Standard
Both of these assumptions are unrealistic in many domains.
 To overcome this, we reify the notion of 
\emph on
observations
\emph default
 and axiomatize the conditions under which an agent will observe the occurrence
 of an action.
 By ensuring that agents consider possible any situation compatible with
 what they have observed, we develop an improved account of knowledge that
 spans the two extremes.
\end_layout

\begin_layout Standard
We introduce the predicate 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 to indicate when an agent would be aware of an action occurring.
 Appropriate axiomatisation of 
\begin_inset Formula $CanObs$
\end_inset

 can model both total awareness of actions and total ignorance.
 It also enables previously unaccounted-for circumstances, such as being
 aware of all actions performed within one's field of view, or by all agents
 on one's own team.
 The formalism can also be extended to model agents who monitor the values
 of fluents in their environment, rather than directly observing actions.
 It is thus a true generalization of previous approaches.
\end_layout

\begin_layout Standard
The full axiomatisation of the situation calculus includes a second-order
 induction axiom.
 For effective automated reasoning, queries must be restricted to syntactic
 forms that can be proven without employing induction 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 Our new semantics does not satisfy this restriction as it employs universal
 quantification over situations.
 Using an extension of the regression operator that can handle such quantificati
on, we show how to transform queries about knowledge into a form amenable
 to purely first-order reasoning.
 The result is a powerful new account of multi-agent knowledge that still
 permits an effective reasoning procedure.
\end_layout

\begin_layout Standard
Reasoning in the situation calculus is traditionally performed from an omniscien
t viewpoint, with queries posed relative to the current situation.
 While this works well for modeling and simulation where a full world history
 is available, it makes it difficult for agents to reason about their own
 world based on their limited observations of what has occurred.
 Our regression technique can be applied to the sequence of observations
 made by a single agent, rather than to a full situation term, facilitating
 reasoning from an internal viewpoint more appropriate for implementation
 in real systems.
 Our work thus has strong parallels with the classic view-based account
 of knowledge 
\begin_inset LatexCommand \cite{halpern90knowledge_distrib}

\end_inset

, but grounded in the situation calculus and with an emphasis on automated
 reasoning.
\end_layout

\begin_layout Standard
The paper is organized as follows: section 
\begin_inset LatexCommand \ref{sec:ma-sitcalc}

\end_inset

 gives a brief introduction to the situation calculus with knowledge and
 concurrent actions, and highlights some of the limitations of current approache
s; section 
\begin_inset LatexCommand \ref{sec:New-Semantics}

\end_inset

 introduces our new semantics and an effective reasoning procedure; and
 section 
\begin_inset LatexCommand \ref{sec:Conclusions}

\end_inset

 concludes with a summary of our results.
 While space restrictions preclude developing a detailed example, we give
 some small motivating examples throughout.
\end_layout

\begin_layout Section
The Multi-Agent Situation Calculus
\begin_inset LatexCommand \label{sec:ma-sitcalc}

\end_inset


\end_layout

\begin_layout Standard
Our work is based in the situation calculus as described by 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

, enriched with concurrent actions 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 to better represent the dynamics of multi-agent systems.
 We use the approach of 
\begin_inset LatexCommand \cite{shapiro01casl_feat_inter}

\end_inset

 for representing multiple agents, and begin from the standard account of
 knowledge given by 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

.
 A brief overview is presented below.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\noun on
Action
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change, with the initiating agent indicated by
 their first argument; 
\noun on
Concurrent
\noun default
 terms are sets of actions that occur simultaneously; 
\noun on
Situation
\noun default
 terms are histories of the concurrent actions that have occurred in the
 world, with the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Concurrent\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Result
\noun default
 terms represent sensing results returned by actions; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 We also distinguish 
\noun on
Fluents
\noun default
 as predicates or functions representing properties of the world that may
 change from one situation to another, and so take a situation term as their
 final argument.
\end_layout

\begin_layout Standard
A set of situation calculus statements 
\begin_inset Formula $\mathcal{D}$
\end_inset

 that describe a dynamic world is referred to as a 
\emph on
theory of action
\emph default
.
 Queries about the behavior of the world are posed as logical entailment
 queries relative to the theory of action.
\end_layout

\begin_layout Subsubsection
Action Precondition Axioms
\end_layout

\begin_layout Standard
There is a distinguished fluent predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 For example, it is only possible for an agent to drop an object if they
 are actually holding it
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow the convention that lower-case roman names indicate variables,
 with free variables being implicitly universally quantified.
\end_layout

\end_inset

: 
\begin_inset Formula \[
Poss(drop(agt,obj),s)\equiv Holding(agt,obj,s)\]

\end_inset

 For concurrent actions, an arbitrary combination of actions 
\begin_inset Formula $\{ a_{1},a_{2}\}$
\end_inset

 is not guaranteed to be possible.
 This is known as the precondition interaction problem 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

.
 A simple solution is to explicitly state which actions cannot be performed
 concurrently using a predicate 
\begin_inset Formula $Conflicts$
\end_inset

: 
\begin_inset Formula \begin{multline*}
Poss(c,s)\equiv\\
\forall a\left[a\in c\rightarrow Poss(a,s)\right]\wedge\neg Conflicts(c,s)\end{multline*}

\end_inset

 This paper requires no particular commitment toward a solution to this
 problem.
\end_layout

\begin_layout Subsubsection
Successor State Axioms
\end_layout

\begin_layout Standard
The truth of a fluent is completely specified by defining its truth in the
 initial situation, and collecting the effects of various actions into 
\emph on
successor state axioms
\emph default
.
 Such axioms provide a monotonic solution to the infamous frame problem,
 and are a principle attraction of the situation calculus.
 They have the following general form, asserting the truth of a fluent 
\begin_inset Formula $F$
\end_inset

 in the successor situation 
\begin_inset Formula $do(c,s)$
\end_inset

 based on the current situation 
\begin_inset Formula $s$
\end_inset

 and the actions 
\begin_inset Formula $c$
\end_inset

 that were performed: 
\begin_inset Formula \[
F(\overrightarrow{x},do(c,s))\equiv\Phi(\overrightarrow{x},c,s)\]

\end_inset


\end_layout

\begin_layout Subsubsection
Uniform Formulae
\end_layout

\begin_layout Standard
The 
\emph on
uniform formulae
\emph default
 are those that refer only to a single situation term and do not mention
 the 
\begin_inset Formula $Poss$
\end_inset

 predicate, and can thus be thought of as formulae about the state of the
 world at a given instant.
 Throughout this paper we use the meta-variable 
\begin_inset Formula $\phi$
\end_inset

 to refer to an arbitrary uniform formula.
 It is often useful to determine the truth of a uniform formula at an alternate
 situation term, and 
\begin_inset Formula $\phi[s]$
\end_inset

 represents the uniform formula 
\begin_inset Formula $\phi$
\end_inset

 with all occurrences of its unique situation term replaced by the situation
 
\begin_inset Formula $s$
\end_inset

.
 Where no confusion can arise, we suppress the situation terms in uniform
 formulae to simplify the presentation.
\end_layout

\begin_layout Subsubsection
Knowledge and Sensing
\end_layout

\begin_layout Standard
The semantics of knowledge 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

 are based on the popular 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 model.
 A knowledge fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 The operator 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 is then introduced as a macro, stating that an agent knows something when
 it is true in all situations considered possible: 
\begin_inset Formula \begin{equation}
\mathbf{Knows}(agt,\phi,s)\isdef\forall s'\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}

\end_inset

 To allow actions to return sensing information the sensing result function
 
\begin_inset Formula $SR(a,s)$
\end_inset

 is introduced, giving the result returned by the action 
\begin_inset Formula $a$
\end_inset

 when executed in a situation 
\begin_inset Formula $s$
\end_inset

.
 For actions that don't return sensing information, the value of 
\begin_inset Formula $SR$
\end_inset

 is set to some arbitrary constant such as 
\begin_inset Formula $"OK"$
\end_inset

.
\end_layout

\begin_layout Standard
Combining the multi-agent semantics of 
\begin_inset LatexCommand \cite{shapiro01casl_feat_inter}

\end_inset

 with the handling of concurrent actions in 
\begin_inset LatexCommand \cite{scherl03conc_knowledge}

\end_inset

, the common form of successor state axiom for the knowledge fluent is
\begin_inset Foot
status open

\begin_layout Standard
We use the standard abbreviation 
\begin_inset Formula $\forall a\in c\,.\,\psi\,\isdef\,\forall a\,.a\in c\rightarrow\psi$
\end_inset

 throughout
\end_layout

\end_inset

: 
\begin_inset Formula \begin{multline}
K(agt,s'',do(c,s))\equiv\\
\exists s'\,\, s''=do(c,s')\,\wedge K(agt,s',s)\wedge Poss(c,s')\\
\wedge\,\forall a\in c\left[agent(a)=agt\rightarrow SR(a,s)=SR(a,s')\right]\label{eqn:k_ssa_standard}\end{multline}

\end_inset

 This states that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(c,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing those same actions 
\begin_inset Formula $c$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is a possible alternative to 
\begin_inset Formula $s$
\end_inset

.
 The situation 
\begin_inset Formula $s''$
\end_inset

 must furthermore be possible, and the sensing results must be consistent
 for all actions in 
\begin_inset Formula $c$
\end_inset

 that were carried out by the agent.
\end_layout

\begin_layout Standard
It is also necessary to permit alternate possible worlds to the initial
 situation 
\begin_inset Formula $S_{0}$
\end_inset

.
 The predicate 
\begin_inset Formula $Init$
\end_inset

 identifies initial situations, and only other initial situations may be
 
\begin_inset Formula $K$
\end_inset

-related to an initial situation.
 We also talk of situations being 
\emph on
rooted at
\emph default
 some initial situation: 
\begin_inset Formula \[
\begin{split} & Init(s)\rightarrow Root(s)=s\\
 & Root(do(c,s))=Root(s)\\
 & Init(s)\rightarrow\left(K(s',s)\rightarrow Init(s')\right)\end{split}
\]

\end_inset

 While powerful, this formulation has an important limitation: each agent
 must be aware of 
\emph on
all
\emph default
 actions that have occurred.
 Note that this awareness is passive - the agents perform no explicit sensing
 actions to determine what has occurred.
 Responsibility for generating such 
\begin_inset Quotes eld
\end_inset

awareness
\begin_inset Quotes erd
\end_inset

 in real systems must thus be abdicated to a lower-level software component,
 such as a visual processing system that identifies change in the environment.
\end_layout

\begin_layout Standard
While suitable for some domains, there are clearly many realistic multi-agent
 domains that do not meet this limitation.
 An alternate formulation from 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset

 can model these:
\begin_inset Formula \begin{multline}
K(agt,s'',do(c,s))\equiv\\
\exists s',s^{*},c'\,\, s''=do(c',s^{*})\,\wedge K(s',s)\wedge Poss(c',s^{*})\\
\wedge\,\mathbf{ExoOnly}(agt,s',s^{*})\\
\wedge\,\forall a\left[agent(a)=agt\rightarrow a\in c'\equiv a\in c\right]\\
\wedge\,\forall a\in c\left[agent(a)=agt\rightarrow SR(a,s)=SR(a,s')\right]\label{eqn:k_ssa_exo}\end{multline}

\end_inset

 Where the macro 
\begin_inset Formula $\mathbf{ExoOnly}$
\end_inset

 indicates that two situations are connected only by actions performed by
 other agents:
\begin_inset Formula \begin{multline*}
\mathbf{ExoOnly}(agt,s,s'')\,\,\isdef\,\, s\leq s''\wedge\\
\forall s',c,a\left[s<do(c,s')\leq s''\wedge a\in c\rightarrow agent(a)\neq agt\right]\end{multline*}

\end_inset

 Here agents consider possible any situation compatible with the actions
 that they themselves have performed.
 There may have been an arbitrary sequence of situations between 
\begin_inset Formula $s'$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

 which the agent knew nothing about, because they consisted entirely of
 exogenous (from 
\begin_inset Formula $agt$
\end_inset

's point of view) actions.
 But this approach is also limiting, in that agents can 
\emph on
never
\emph default
 be aware of the actions performed by others.
 Consider agents occupying a house who are aware of actions performed by
 others in the same room, or even the simple case of an agent being aware
 that another agent has collided with it - full generality requires that
 agents can be aware of 
\emph on
some
\emph default
 of the actions performed by others.
\end_layout

\begin_layout Standard
Furthermore, suppose that 
\begin_inset Formula $agt$
\end_inset

 has just performed action 
\begin_inset Formula $a_{1}$
\end_inset

, so the world is in some situation 
\begin_inset Formula $do(a_{1},s)$
\end_inset

.
 Another agent then performs the action 
\begin_inset Formula $a_{2}$
\end_inset

, leaving the world in situation 
\begin_inset Formula $do(a_{2},do(a_{1},s))$
\end_inset

.
 Since it cannot observe the occurrence of 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $agt$
\end_inset

 would be aware of no change in the world and its state of knowledge should
 therefore remain unchanged.
 Unfortunately this is not the case: 
\begin_inset Formula $K(agt,s',do(a_{2},do(a_{1},s)))\not\equiv K(agt,s',do(a_{1},s))$
\end_inset

 under this formulation.
 To faithfully represent this aspect of the knowledge of real-world agents,
 the successor state axiom for 
\begin_inset Formula $K$
\end_inset

 must permit any 
\emph on
future
\emph default
 of 
\begin_inset Formula $do(a_{1},s)$
\end_inset

 that can be brought about by exogenous actions, rather than any 
\emph on
past
\emph default
 as done above.
\end_layout

\begin_layout Subsubsection
Belief
\end_layout

\begin_layout Standard
We note at this point that we are interested in a logic of 
\emph on
knowledge
\emph default
 - everything known by an agent must actually be true in the world.
 There has also been significant work on 
\emph on
belief
\emph default
 in the situation calculus.
 
\begin_inset LatexCommand \cite{shapiro04sc_belief_exog}

\end_inset

 show how agents may hypothesize the occurrence of exogenous actions when
 they discover that their beliefs are wrong, neatly avoiding the issue of
 being aware of actions performed by others.
 This approach cannot be applied when dealing with knowledge.
 However, we believe that the concrete notion of observations we develop
 below will also be useful for belief-based systems.
\end_layout

\begin_layout Subsubsection
Regression
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 The principle tool is the regression meta-operator 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

 which transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into a formula 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}(\phi)$
\end_inset

 uniform in 
\begin_inset Formula $s$
\end_inset

, such that the two are equivalent relative to the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

.
 By repeatedly applying
\begin_inset Foot
status collapsed

\begin_layout Standard
One can also define a regression operator that reduces to 
\begin_inset Formula $S_{0}$
\end_inset

 in a single pass.
 The two approaches are essentially equivalent, but the repeated-application
 version is simpler to extend for our purposes.
\end_layout

\end_inset

 the regression operator, 
\begin_inset Formula $\phi$
\end_inset

 can be transformed into an equivalent formula uniform in 
\begin_inset Formula $S_{0}$
\end_inset

: 
\begin_inset Formula \[
\mathcal{D}\models\phi[do(c_{n},do(c_{n-1},\dots,do(c_{1},S_{0}))]\equiv\mathcal{R}_{\mathcal{D}}^{*}(\phi)[S_{0}]\]

\end_inset

 Many of the axioms from 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required for reasoning about the initial situation, and so can
 be discarded when reasoning about 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}(\phi)[S_{0}]$
\end_inset

.
 Most importantly, the induction axiom is not needed so the reasoning is
 purely first-order.
 The successor state and action precondition axioms are also not required.
 The trade-off is that the length of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}(\phi)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

, the regression operator is extended to handle the standard account of
 knowledge in equation (
\begin_inset LatexCommand \ref{eqn:k_ssa_standard}

\end_inset

) by reducing reasoning about formulae containing the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro to modal reasoning over the 
\begin_inset Formula $K$
\end_inset

 relation in the initial situation.
 Regressing such formulae relies on the fact that agents are aware of all
 actions - formulae containing quantification over situations, such as the
 modified dynamics of knowledge in equation (
\begin_inset LatexCommand \ref{eqn:k_ssa_exo}

\end_inset

), cannot be regressed.
 Indeed, 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset

 offer no procedure for reasoning in their formalism other than using second-ord
er induction.
 We believe this to be the main reason for the near-ubiquity of the assumption
 of total awareness of actions.
\end_layout

\begin_layout Section
New Semantics of Knowledge
\begin_inset LatexCommand \label{sec:New-Semantics}

\end_inset


\end_layout

\begin_layout Subsubsection
Observations
\end_layout

\begin_layout Standard
Existing situation calculus accounts of knowledge all employ an assumption
 about when an agent is aware of an action occurring - either 
\begin_inset Quotes eld
\end_inset

agents are always aware of actions
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

agents are only aware of actions that they perform
\begin_inset Quotes erd
\end_inset

.
 We replace such assumptions with a question: 
\begin_inset Quotes eld
\end_inset

when will an agent be aware of the occurrence of an action?
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
A new fluent is introduced, akin to 
\begin_inset Formula $Poss$
\end_inset

 but describing when actions will be observed by agents: 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 indicates that agent 
\begin_inset Formula $agt$
\end_inset

 would be aware of action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 As before, we assume that in an implemented system this 
\begin_inset Quotes eld
\end_inset

awareness
\begin_inset Quotes erd
\end_inset

 is generated by some other component of the agent's software.
 The important point is that if 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 is true and action 
\begin_inset Formula $a$
\end_inset

 occurs, then 
\begin_inset Formula $agt$
\end_inset

 will be made aware of it.
 The axiomatisation of this predicate is the responsibility of the domain
 modeler.
\end_layout

\begin_layout Standard
There is a related assumption in the handling of sensing actions: only the
 agent performing a sensing action is aware of its result.
 Such a restriction is common but certainly not universal: if an agent waiting
 for a train activates a speaker to determine when it will arrive, the result
 of this sensing action would be available to any other agent within earshot.
 We add an analogous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 to indicate when sensing information is available to an agent.
\end_layout

\begin_layout Standard
To allow comparison of what is observed by an agent in different situations,
 we introduce a new sort 
\noun on
Observations
\noun default
 consisting of sets of action/result pairs.
 The function 
\begin_inset Formula $Observations(agt,c,s)$
\end_inset

 is defined to return precisely the set of such pairs that 
\begin_inset Formula $agt$
\end_inset

 would be aware of if the actions 
\begin_inset Formula $c$
\end_inset

 were performed in situation 
\begin_inset Formula $s$
\end_inset

 .
 The special result term 
\begin_inset Quotes eld
\end_inset

?
\begin_inset Quotes erd
\end_inset

 indicates that the result of an action was not available: 
\begin_inset Formula \begin{multline}
Observations(agt,c,s)=o\equiv\\
\forall a,r\,\left[<a,r>\in o\equiv a\in c\wedge CanObs(agt,a,s)\right.\\
\wedge\,\left(CanSense(agt,a,s)\wedge r=SR(a,s)\right.\\
\left.\vee\,\left.\neg CanSense(agt,a,s)\wedge r="?"\right)\right]\label{eqn:observations_orig}\end{multline}

\end_inset

 Like their counterpart 
\begin_inset Formula $Poss$
\end_inset

, 
\begin_inset Formula $CanObs$
\end_inset

 and 
\begin_inset Formula $CanSense$
\end_inset

 may suffer from interaction problems when concurrent actions are considered.
 While we are confident an approach similar to that used for precondition
 interaction can be applied, this remains an open problem.
\end_layout

\begin_layout Standard
With a concrete notion of observations in place, the concept of an 
\emph on
observation history
\emph default
 follows naturally - it is a sequence of all the observations made by an
 agent as the world has evolved.
 We introduce the sort 
\noun on
History
\noun default
 consisting of sequences of observations, with 
\begin_inset Formula $\epsilon$
\end_inset

 being the empty sequence, and the fluent 
\begin_inset Formula $ObsHist$
\end_inset

 giving the history associated with a particular situation: 
\begin_inset Formula \begin{multline}
Init(s)\rightarrow ObsHist(agt,h,s)\equiv h=\epsilon\\
\shoveleft{ObsHist(agt,h,do(c,s))\equiv}\\
\,\,\,\, Observations(agt,c',s')=\{\}\rightarrow ObsHist(agt,h,s')\\
\shoveleft{\,\,\,\,\wedge\,\exists o\,.\, Observations(agt,c',s')=o\wedge o\neq\{\}\rightarrow}\\
\exists h'\,\, h=o\cdot h'\wedge ObsHist(agt,s',h')\label{eqn:obshist_defn}\end{multline}

\end_inset


\end_layout

\begin_layout Subsubsection
Successor State Axiom for 
\begin_inset Formula $K$
\end_inset


\end_layout

\begin_layout Standard
In their classic article, 
\begin_inset LatexCommand \cite{halpern90knowledge_distrib}

\end_inset

 assert that 
\emph on

\begin_inset Quotes eld
\end_inset

an agent's knowledge at a given time must depend only on its local history:
 the information that it started out with combined with the events it has
 observed since then
\begin_inset Quotes erd
\end_inset


\emph default
.
 Given an explicit account of the observations made by each agent, the required
 semantics of the 
\begin_inset Formula $K$
\end_inset

 relation are clear: 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 must hold whenever situations 
\begin_inset Formula $s''$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 would result in the same observation history for the agent.
 We first introduce the predicates 
\begin_inset Formula $Legal(c,s)$
\end_inset

 and 
\begin_inset Formula $Legal(s)$
\end_inset

, which single out situations that can actually be brought about in the
 world: 
\begin_inset Formula \begin{equation}
\begin{split} & Legal(c,s)\equiv Poss(c,s)\\
 & Init(s)\rightarrow Legal(s)\\
 & Legal(do(c,s))\equiv Legal(c,s)\wedge Legal(s)\end{split}
\end{equation}

\end_inset

 We further introduce the abbreviation 
\begin_inset Formula $\mathbf{Unobs}(agt,s,s')$
\end_inset

, which is true when 
\begin_inset Formula $agt$
\end_inset

 would not be aware of any of the actions leading from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

: 
\begin_inset Formula \begin{multline}
\mathbf{Unobs}(agt,s,s''))\,\isdef\,\neg\exists c',s'\,.\, s<do(c',s')\leq s''\\
\wedge\, Observations(agt,c',s')\neq\{\}\label{eqn:unobs_defn}\end{multline}

\end_inset

 If the agent considers possible a situation 
\begin_inset Formula $s$
\end_inset

 then it must also consider possible any legal situation 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $\mathbf{Unobs}(s,s')$
\end_inset

.
 Also note that 
\begin_inset Formula $\mathbf{Unobs}(s,s)$
\end_inset

 is always true.
 The following successor state axiom then captures the desired semantics
 of knowledge: 
\begin_inset Formula \begin{multline}
K(agt,s'',do(c,s))\equiv\\
Observations(agt,c,s)=\{\}\wedge K(agt,s'',s)\\
\shoveleft{\vee\,\,\exists o\,\, Observations(agt,c,s)=o\,\wedge}\\
o\neq\{\}\wedge Legal(s'')\,\wedge\\
\exists c',s'\, Observations(agt,c',s')=o\,\wedge\\
K(agt,s',s)\wedge\mathbf{Unobs}(agt,do(c',s'),s'')\label{eqn:new_k_ssa}\end{multline}

\end_inset

 If 
\begin_inset Formula $c$
\end_inset

 was totally unobservable, the agent's state of knowledge does not change.
 Otherwise, it considers possible any legal successor to a possible situation
 that can be brought about by actions 
\begin_inset Formula $c'$
\end_inset

 resulting in identical observations.
 It also considers possible any unobservable future of such a situation.
\end_layout

\begin_layout Standard
It remains to specify 
\begin_inset Formula $K$
\end_inset

 in the initial situation.
 Since situations where 
\begin_inset Formula $\mathbf{Unobs}(agt,s,S_{0})$
\end_inset

 holds must be 
\begin_inset Formula $K$
\end_inset

-related to 
\begin_inset Formula $S_{0}$
\end_inset

, we introduce another relation 
\begin_inset Formula $K_{0}$
\end_inset

 to specify each agent's knowledge in the initial situation: 
\begin_inset Formula \begin{multline}
K_{0}(s',s)\rightarrow Init(s')\wedge Init(s)\\
\shoveleft{Init(s)\rightarrow K(agt,s'',s)\equiv}\\
\,\,\,\, Legal(s)\wedge\exists s'\,\left[K_{0}(agt,s',s)\wedge\mathbf{Unobs}(agt,s',s)\right]\label{eqn:new_k_s0}\end{multline}

\end_inset

 From these definitions, it is straightforward to show that knowledge is
 completely determined by an agent's observations: two legal situations
 are 
\begin_inset Formula $K$
\end_inset

-related iff they have identical observation histories, and are rooted at
 
\begin_inset Formula $K_{0}$
\end_inset

-related situations.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset

 
\begin_inset LatexCommand \label{thm:k_obs_equiv}

\end_inset

For any theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

 with our new semantics of knowledge, any agent 
\begin_inset Formula $agt$
\end_inset

 and legal situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

: 
\begin_inset Formula \begin{multline*}
\mathcal{D}\models K(agt,s',s)\equiv K_{0}(Root(s'),Root(s))\\
\wedge\exists h\, ObsHist(agt,h,s)\wedge ObsHist(agt,h,s')\end{multline*}

\end_inset

 
\begin_inset ERT
status open

\begin_layout Standard


\backslash
end{theorem}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Standard


\backslash
begin{proof}
\end_layout

\end_inset

Straightforward.
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This new formulation overcomes the limitations highlighted previously.
 By appropriately axiomatizing 
\begin_inset Formula $CanObs$
\end_inset

 and 
\begin_inset Formula $CanSense$
\end_inset

 it is possible to model both total awareness of actions and total ignorance,
 as well as previously unaccounted-for circumstances between these extremes.
 It also ensures that an agent's knowledge does not change if it is not
 aware of any actions occurring.
 It is thus a true generalization and improvement over previous approaches.
\end_layout

\begin_layout Subsubsection
Observing Fluent Change
\end_layout

\begin_layout Standard
In many domains it would be infeasible for an agent to observe a particular
 action occurring, but it may be aware that a particular fluent has changed.
 For example, suppose that an agent monitors the state of a light in its
 environment, such that it notices it changing from dark to light.
 While it knows that 
\emph on
some
\emph default
 action must have occurred, it may not be sure precisely what action took
 place.
\end_layout

\begin_layout Standard
This can be modeled by introducing a special class of actions called 
\emph on
change actions
\emph default
 which inform agents that some property of the world has changed.
 They never appear directly in situation terms, but are included in the
 list of observations made by an agent by modifying the 
\begin_inset Formula $Observations$
\end_inset

 predicate as follows:
\begin_inset Formula \begin{multline*}
Observations(agt,c,s)=o\equiv\\
\shoveleft{\,\,\,\,\forall a,r\,\left[<a,r>\in o\equiv\right.}\\
\left[a\in c\,\vee\, ChangeAction(a)\wedge SR(a,s)\neq SR(a,do(c,s))\right]\\
\wedge CanObs(agt,a,s)\\
\wedge\,\left(CanSense(agt,a,s)\wedge SR(a,s)=r\right.\\
\left.\vee\,\left.\neg CanSense(agt,a,s)\wedge r="?"\right)\right]\end{multline*}

\end_inset

 According to this definition, change actions appear in the list of observations
 only when the corresponding sensing result changes in the successor situation.
 By defining an appropriate 
\begin_inset Formula $SR$
\end_inset

 function, and making agents aware of these actions using 
\begin_inset Formula $CanObs$
\end_inset

 and 
\begin_inset Formula $CanSense$
\end_inset

, our formalism can neatly handle this form of environmental awareness.
\end_layout

\begin_layout Subsubsection
Regression
\end_layout

\begin_layout Standard
The appearance of 
\begin_inset Formula $\mathbf{Unobs}$
\end_inset

 in equation (
\begin_inset LatexCommand \ref{eqn:new_k_ssa}

\end_inset

) means that our new successor state axiom universally quantifies over situation
s, and so is not regressable using standard techniques.
 To permit an effective reasoning procedure, we appeal to the 
\emph on
persistence condition
\emph default
 meta-operator.
 In recent unpublished work [citation omitted] we develop a new meta-operator
 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}(\phi,\alpha)$
\end_inset

, taking a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and some action conditions 
\begin_inset Formula $\alpha(c,s)$
\end_inset

 , such that: 
\begin_inset Formula \begin{multline}
\mathcal{D}\models\mathcal{P}_{\mathcal{D}}(\phi,\alpha)[s]\,\,\equiv\,\,\forall s''\, s\leq s''\wedge\\
\neg\exists c',s'\, s<do(c',s')\leq s''\wedge\neg\alpha(c',s')\,\rightarrow\,\phi[s'']\label{eqn:P_defn}\end{multline}

\end_inset

 The truth of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}(\phi,\alpha)$
\end_inset

 in a situation 
\begin_inset Formula $s$
\end_inset

 guarantees that, as long as all subsequent actions satisfy 
\begin_inset Formula $\alpha$
\end_inset

, the formula 
\begin_inset Formula $\phi$
\end_inset

 will remain true in all situations in the future of 
\begin_inset Formula $s$
\end_inset

.
 It thus represents the conditions under which 
\begin_inset Formula $\phi$
\end_inset

 will 
\emph on
persist
\emph default
 with respect to the given class of actions.
 The procedure for determining 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 replaces second-order induction with iterated first-order reasoning.
 It also requires that there be only finitely many types of action, an assumptio
n met by most realistic domains.
\end_layout

\begin_layout Standard
By singling out unobservable actions, the persistence condition can be used
 to augment the existing techniques for regressing knowledge queries developed
 in 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

.
 Define the macro 
\begin_inset Formula $\mathbf{UA}$
\end_inset

 to identify legal, unobservable sets of actions:
\begin_inset Formula \begin{multline*}
\mathbf{UA}(agt,c,s)\isdef\\
Legal(c,s)\wedge Observations(agt,c,s)=\{\}\end{multline*}

\end_inset

 Assuming that the 
\begin_inset Formula $K$
\end_inset

 fluent appears only in the context of a 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, we propose the following to replace the existing regression of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

:
\begin_inset Formula \begin{multline}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,do(c,s)))=\\
\left[Observations(agt,c,s)=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
\wedge\left[\exists o\,\, Observations(agt,c,s)=o\wedge o\neq\{\}\rightarrow\right.\\
\mathbf{Knows}(agt,\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\left.\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,\mathbf{UA}(agt))[do(c',s')]),s)\right]\label{eqn:R_do_c_s}\end{multline}

\end_inset

 As required, this reduces reasoning about knowledge in 
\begin_inset Formula $do(c,s)$
\end_inset

 to reasoning about knowledge in 
\begin_inset Formula $s$
\end_inset

.
 It is also intuitively appealing: to know that 
\begin_inset Formula $\phi$
\end_inset

 holds, the agent must know that in all situations that agree with its observati
ons, 
\begin_inset Formula $\phi$
\end_inset

 cannot become false without it noticing that an action has occurred.
 We must also specify the regression of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 in the initial situation, as equation (
\begin_inset LatexCommand \ref{eqn:new_k_s0}

\end_inset

) also quantifies over situations: 
\begin_inset Formula \begin{multline}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,S_{0}))=\\
\forall s\, K_{0}(agt,s)\rightarrow\mathcal{P}_{\mathcal{D}}(\phi,\mathbf{UA}(agt))[s]\label{eqn:R_s0}\end{multline}

\end_inset

 This is then standard first-order modal reasoning over the 
\begin_inset Formula $K_{0}$
\end_inset

 relation.
 We sketch below the highlights of a proof that our modified regression
 operator preserves equivalence.
 Regression of the additional predicates we have introduced (
\begin_inset Formula $CanObs$
\end_inset

, 
\begin_inset Formula $Observations$
\end_inset

, etc) is identical to that of 
\begin_inset Formula $Poss$
\end_inset

 and requires no special treatment here, except to mention that the restriction
 to a finite number of actions allows regression of such formulae even when
 their arguments are variables.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given a theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

 with regression and persistence operators defined relative to it, a uniform
 formula 
\begin_inset Formula $\phi$
\end_inset

 and a ground situation term 
\begin_inset Formula $s$
\end_inset

, it is always the case that: 
\begin_inset Formula \[
\mathcal{D}\models\phi[s]\equiv\mathcal{R}_{\mathcal{D}}^{*}(\phi)[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{theorem} 
\backslash
begin{proof}
\end_layout

\end_inset

It suffices to show that 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 preserves equivalence for 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

, as that it all we have modified from existing definitions.
 Combining and rearranging equations (
\begin_inset LatexCommand \ref{eqn:knows_def}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:new_k_ssa}

\end_inset

), the definition of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 can be written in the form: 
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\\
\left[Observations(agt,c,s)=\{\}\rightarrow\forall s'K(agt,s',s)\rightarrow\phi[s']\right]\\
\shoveleft{\wedge\left[\exists o\,\, Observations(agt,c,s)=o\wedge o\neq\{\}\rightarrow\right.}\\
\forall s'\, K(agt,s',s)\rightarrow\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\left.\forall s''\, Legal(s'')\wedge\mathbf{Unobs}(agt,do(c',s'),s'')\,\rightarrow\,\phi[s'']\right]\end{multline*}

\end_inset

 Note that both of these conjuncts contain sub-formulae matching the form
 of the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, so it can be substituted back in to give:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\\
\left[Observations(agt,c,s)=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
\shoveleft{\wedge\left[\exists o\,\, Observations(agt,c,s)=o\wedge o\neq\{\}\rightarrow\right.}\\
\left.\mathbf{Knows}(agt,\mathbf{PK}(\phi,o)),s)\right]\end{multline*}

\end_inset

 Where we have defined the abbreviation 
\begin_inset Formula $\mathbf{PK}(\phi,o,s')$
\end_inset

 as:
\begin_inset Formula \begin{multline*}
\mathbf{PK}(\phi,o,s')\isdef\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\forall s''\, Legal(s'')\wedge\mathbf{Unobs}(agt,do(c',s'),s'')\,\rightarrow\,\phi[s'']\end{multline*}

\end_inset

 For 
\begin_inset Formula $\mathbf{PK}(\phi,o,s')$
\end_inset

 to legitimately appear in the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro it must be uniform in the situation variable 
\begin_inset Formula $s'$
\end_inset

.
 Noting that equation (
\begin_inset LatexCommand \ref{eqn:unobs_defn}

\end_inset

) matches the form of equation (
\begin_inset LatexCommand \ref{eqn:P_defn}

\end_inset

), and regressing to make the expression uniform, we develop the following
 equivalence as required:
\begin_inset Formula \begin{multline*}
\mathbf{PK}(\phi,o,s')\equiv\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,Legal()\wedge Observations(agt)=\{\})[do(c',s')])\end{multline*}

\end_inset

 For 
\begin_inset Formula $S_{0}$
\end_inset

, a straightforward transformation of equations (
\begin_inset LatexCommand \ref{eqn:knows_def}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:new_k_s0}

\end_inset

) gives:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(\phi,S_{0})\equiv\forall s\, K_{0}(agt,s)\rightarrow\\
\{\forall s'\, Legal(s')\wedge\mathbf{Unobs}(s,s')\rightarrow\phi[s']\}\end{multline*}

\end_inset

 Applying the persistence condition operator, this can easily be re-written
 in the required form:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(\phi,S_{0})\equiv\forall s\, K_{0}(agt,s)\rightarrow\\
\mathcal{P}_{\mathcal{D}}(\phi,Legal()\wedge Observations(agt)=\{\})[s]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our extension of the regression operator thus provides an effective procedure
 for automated reasoning with our improved account of knowledge.
\end_layout

\begin_layout Subsubsection
Regressing over Observations
\end_layout

\begin_layout Standard
While this reasoning method is suitable for modeling and simulation purposes,
 it would be unreasonable for a situated agent to ask 
\begin_inset Quotes eld
\end_inset

do I know 
\begin_inset Formula $\phi$
\end_inset

 in the current situation?
\begin_inset Quotes erd
\end_inset

 using the situation calculus query 
\begin_inset Formula $\mathcal{D}\models\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as it cannot be expected to have the full current situation 
\begin_inset Formula $s$
\end_inset

.
 However, it will have its current observation history 
\begin_inset Formula $h$
\end_inset

.
 We therefore define knowledge with respect to a history as follows:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,h)\isdef\\
\forall s\, ObsHist(agt,h,s)\wedge Root(s)=S_{0}\rightarrow\mathbf{Knows}(agt,\phi,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
It is then straightforward to establish the following:
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset

 Given a theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

 including our semantics for knowledge, a situation term 
\begin_inset Formula $s$
\end_inset

 rooted at 
\begin_inset Formula $S_{0}$
\end_inset

, and an observation history 
\begin_inset Formula $h$
\end_inset

 such that 
\begin_inset Formula $ObsHist(agt,h,s)$
\end_inset

:
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash

\end_layout

\begin_layout Standard

\end_layout

\end_inset


\begin_inset Formula \[
\mathcal{D}\models\mathbf{Knows}(agt,\phi,s)\equiv\mathbf{Knows}(agt,\phi,h)\]

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{theorem} 
\backslash
begin{proof}
\end_layout

\end_inset

Straightforward consequence of theorem 
\begin_inset LatexCommand \ref{thm:k_obs_equiv}

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Extending the definitions developed in equations (
\begin_inset LatexCommand \ref{eqn:R_do_c_s}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:R_s0}

\end_inset

) to handle regressing formulae of this form is actually simpler than regressing
 over situations, as there are no empty observations in a history: 
\begin_inset Formula \begin{multline*}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,o\cdot h))=\\
\mathbf{Knows}(agt,\forall c'\, Observations(agt,c',s')=o\rightarrow\\
\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,\mathbf{UA}(agt))[do(c',s')]),h)\end{multline*}

\end_inset


\begin_inset Formula \begin{multline*}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,\epsilon))=\\
\forall s\, K_{0}(agt,s)\rightarrow\mathcal{P}_{\mathcal{D}}(\phi,\mathbf{UA}(agt))[s]\end{multline*}

\end_inset

 Using this, agents can reason about their own knowledge using only their
 local information.
 Our work thus makes it possible to include a situation calculus model in
 the implementation of a real-world multi-agent system, even when agents
 have only partial awareness of the actions being performed.
\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand \label{sec:Conclusions}

\end_inset


\end_layout

\begin_layout Standard
In this paper we have significantly increased the scope of the situation
 calculus for modeling knowledge in complex domains, where there may be
 multiple agents and partial awareness of actions.
 By explicitly reifying the observations made by each agent as the world
 evolves, we have generalized the dynamics of knowledge update.
 We have shown that this can accommodate the important case where agents
 are aware that a property of their environment has changed, but do not
 know the precise actions responsible.
 Despite requiring universal quantification over future situations, we have
 shown that the regression operator can be adapted to allow effective reasoning
 within our new formalism.
 It can also be used to reason from the internal perspective of a single
 agent.
\end_layout

\begin_layout Standard
With our new semantics of knowledge, the situation calculus is well positioned
 for representing, reasoning about, and implementing more complex, realistic
 agent systems.
\end_layout

\begin_layout Standard
 
\begin_inset LatexCommand \bibtex[named]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
