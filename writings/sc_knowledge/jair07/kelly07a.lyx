#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass jair
\begin_preamble

\jairheading{0}{0000}{0-0}{0/0}{0/0}
\ShortHeadings{Common Knowledge, Hidden Actions, and the Frame Problem}{R. F. Kelly \& A. R. Pearce}
\firstpageno{0}
\end_preamble
\options jair,twoside,11pt,theapa,letterpaper
\language english
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Common Knowledge, Hidden Actions, and the Frame Problem
\end_layout

\begin_layout Author
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Ryan F.
 Kelly 
\backslash
email rfk@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Adrian R.
 Pearce 
\backslash
email adrian@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addr Department of Computer Science and Software Engineering
\backslash

\backslash

\end_layout

\begin_layout Standard

The University of Melbourne
\backslash

\backslash

\end_layout

\begin_layout Standard

Victoria, 3010, Australia
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a powerful new account of multi-agent knowledge in the situation
 calculus, and an effective reasoning procedure for knowledge queries.
 A key contribution of our approach is the ability to handle partial observabili
ty, including actions that are completely hidden, by explicitly reifying
 the observations made by each agent as the world evolves.
 We also formally treat complex epistemic modalities such as common knowledge,
 which are not available in the standard account of knowledge in the situation
 calculus.
 By using the persistence condition meta-operator to augment traditional
 regression techniques, we allow agents to effectively reason about knowledge
 using only their internal history of observations, rather than requiring
 a full history of the world.
 The result is a more robust and flexible account of knowledge in the situation
 calculus suitable for use in asynchonrous, partially-observable multi-agent
 domains.
 
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isdef}{\stackrel{\mbox{\tiny def}}{=}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Dt}{\mathcal{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Reg}{\mathcal{R}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Pst}{\mathcal{P}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Trn}{\mathcal{T}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Kln}{\mathcal{K}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\TrnA}{\Trn_{a}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EKnows}{\mathbf{EKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Knows}{\mathbf{Knows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\CKnows}{\mathbf{CKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KnowsZ}{\mathbf{Knows_{0}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PKnowsZ}{\mathbf{PKnows_{0}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PKnows}{\mathbf{PKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KTrans}{\mathbf{KTrans}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KDo}{\mathbf{KDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\vars}[1]{\bar{#1}}
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In their landmark paper 
\emph on
Knowledge, Action, and the Frame Problem,
\emph default
 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 extend Reiter's solution to the frame problem in the situation calculus
 
\begin_inset LatexCommand citep
key "reiter91frameprob,pirri99contributions_sitcalc"

\end_inset

 to handle knowledge-producing actions and explicit reasoning about the
 knowledge of an agent.
 Extensions to multiple agents 
\begin_inset LatexCommand citep
key "Lesperance01epi_feas_casl"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

 have produced an expressive logic of knowledge, action and change that
 permits an effective reasoning procedure using standard techniques of the
 situation calculus.
\end_layout

\begin_layout Standard
While powerful, the existing account suffers two major limitations that
 make it unsuitable for modelling complex multi-agent domains.
 First, it requires that whenever an action occurs, all agents 
\emph on
know
\emph default
 that an action has occurred.
 This demands a level of synchronicity that is unreasonable in many multi-agent
 domains.
 Second, there is no account of group-level epistemic modalities such as
 common knowledge, which is difficult to formalize effectively in a dynamic
 setting 
\begin_inset LatexCommand citep
key "baltag98pa_ck"

\end_inset

.
 Given the deep connections between common knowledge and coordination, this
 is a serious shortcoming in multi-agent domains.
\end_layout

\begin_layout Standard
In this paper we overcome these limitations by providing:
\end_layout

\begin_layout Itemize
a formal account of 
\emph on
Common Knowledge
\emph default
 and other complex epistemic modalities, including a regression rule for
 reasoning about common knowledge
\end_layout

\begin_layout Itemize
support for 
\emph on
Hidden Actions
\emph default
 and actions that are partially observable, including a reasoning technique
 to deal with arbitrarily-long sequences of hidden actions
\end_layout

\begin_layout Itemize
a solution to the 
\emph on
Frame Problem
\emph default
 for knowledge, built on the successor state axioms for primitive actions,
 maintaining regression as the primary reasoning tool, and allowing agents
 to reason from a local viewpoint rather than an omniscient one
\end_layout

\begin_layout Standard
The result is a rich account of multi-agent knowledge suitable both for
 reasoning 
\emph on
about,
\emph default
 and reasoning 
\emph on
in,
\emph default
 asynchronous, partially-observable multi-agent domains.
\end_layout

\begin_layout Standard
After some introductory material on the situation calculus in Section 
\begin_inset LatexCommand ref
reference "sec:The-Multi-Agent-Situation"

\end_inset

, we develop our new formalism in two parts:
\end_layout

\begin_layout Subsection*
Individual Knowledge with Hidden Actions
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 treats the indivdual knowledge of each agent in the face of hidden actions,
 by decoupling knowledge from the specific actions that have taken place.
 We develop an explicit reification of the 
\emph on
observations
\emph default
 made by each agent as the world evolves, and formulate each agent's knowldge
 in terms of what it has observed.
 Briefly, each occurrence of an action results in an agent making a (possibly
 empty) set of observations.
 Every situation then has a corresponding 
\emph on
view
\emph default
 for each agent: the sequence of observations the agent has made in that
 situation, excluding cases where the set of observations was empty.
 An agent knows something if it is true in all situations matching its current
 view.
\end_layout

\begin_layout Standard
Decoupling knowledge in this manner makes it easy to express various degrees
 of observability of actions, from public actions through to actions that
 are completely hidden.
 This section is a greatly expanded version of our conference paper on the
 same topic 
\begin_inset LatexCommand citep
key "kelly07sc_know_obs"

\end_inset

 and stands as a significant new account of knowledge in its own right.
\end_layout

\begin_layout Standard
The main challenge in this section is dealing with arbitrarily long sequences
 of hidden actions.
 To ensure their knowledge is valid, each agent must take into account all
 future situations compatible with what they have observed.
 However, queries that universally quantify over situations are not supported
 by the standard tools for effective reasoning in the situation calculus.

\emph on
 
\emph default
In previous work we have developed the persistence condition meta-operator
 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

 to support a limited form of universally quantified query.
 Using this operator to augment the regression techniques developed by 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, we maintain their elegant solution to the frame problem despite dealing
 with arbitrarily long sequences of hidden actions.
\end_layout

\begin_layout Standard
We also show how our regression rules can be applied using an agent's individual
 view, rather than requiring a full situation term.
 Agents can thus use our techniques to reason about their own knowledge
 using only their local information, making our formalism suitable both
 for reasoning 
\emph on
about
\emph default
, and reasoning 
\emph on
in
\emph default
,
\emph on
 
\emph default
rich multi-agent domains.
\end_layout

\begin_layout Subsection*
Complex Epistemic Modalities
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sec:Complex-Epistemic-Modalities"

\end_inset

 builds on our account of individual knowledge by introducing complex epistemic
 modalities.
 While the primary motivation is a formal account of common knowledge, we
 are bound by the following expressivity result from modal logic 
\begin_inset LatexCommand citep
key "baltag98pa_ck"

\end_inset

:
\end_layout

\begin_layout Quote
epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone
\end_layout

\begin_layout Standard
In situation calculus terms, this means that the regression of common knowledge
 cannot be defined in terms of common knowledge, but requires a more powerful
 epistemic language.
 Recent advances in dynamic epistemic logic have shown how to overcome this
 restriction, using two key ideas: use dynamic logic as a power expressive
 epistemic path language; and use regression to encode the effects of actions
 within epistemic paths 
\begin_inset LatexCommand citep
key "vanBenthem06lcc"

\end_inset

.
\end_layout

\begin_layout Standard
The original framework for these ideas is the propositional, syncrhonous
 setting of modal logic.
 We adapt them to the much richer formalism of the situation calculus by
 lifting the regression of epistemic paths to first-order logic, and combine
 them with the techniques for handling sequences of hidden actions developed
 in Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

.
 We demonstrate the effectives of our technique with an example of reasoning
 about common knowledge in a partialy-observable domain, a first for the
 situation calculus.
 The result is a truly multi-agent account of knowledge suitable for rich
 multi-agent domains.
\end_layout

\begin_layout Section
The Multi-Agent Situation Calculus
\begin_inset LatexCommand label
name "sec:The-Multi-Agent-Situation"

\end_inset


\end_layout

\begin_layout Standard
Our work utilizes the situation calculus 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 with multiple agents 
\begin_inset LatexCommand citep
key "shapiro01casl_feat_inter"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "reiter96sc_nat_conc"

\end_inset

, and we begin from the standard account of knowledge due to 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

.
 A brief overview is presented below.
 Readers familiar with the situation calculus should note: our generalization
 of the 
\begin_inset Formula $Poss$
\end_inset

 fluent to action description predicates, our use of the single-step variant
 of the regression operator, and the material on the persistence condition
 meta-operator.
\end_layout

\begin_layout Subsection
Notation and Axioms
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change, with the initiating agent indicated by
 their first argument; 
\noun on
Concurrent
\noun default
 terms are sets of actions that occur simultaneously; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Concurrent\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Result
\noun default
 terms represent sensing results returned by actions; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\emph on
Fluents
\emph default
 are predicates or functions that represent properties of the world that
 may change between situations; they take a situation term as their final
 argument.
 An agent's 
\emph on
knowledge
\emph default
 is represented using the macro 
\begin_inset Formula $\Knows$
\end_inset

.
 We call the fluents that are directly affected by actions 
\emph on
primitive 
\emph default
fluents.
 Although it is defined as a macro, 
\begin_inset Formula $\Knows$
\end_inset

 is treated syntactically as a primitive fluent.
\end_layout

\begin_layout Standard
Throughout the paper we will present examples from a simple multi-agent
 domain, a packing facility in which two agents 
\begin_inset Formula $Sam$
\end_inset

 and 
\begin_inset Formula $Max$
\end_inset

 move boxes between a number of rooms.
 Some example formulas from this domain are 
\begin_inset Quotes eld
\end_inset

Sam is holding Box1 initially
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Sam is not holding Box1 after dropping Box1
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

Max knows Sam is holding Box1 initially
\begin_inset Quotes erd
\end_inset

, written formally as:
\begin_inset Formula \begin{gather*}
Holding(Sam,Box1,S_{0})\\
\neg Holding(Sam,Box1,do(\{drop(Sam,Box1)\},S_{0}))\\
\Knows(Max,Holding(Sam,Box1),S_{0})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The dynamics of a particuar domain are captured by a set of sentences in
 this logic called a 
\emph on
basic action theory
\emph default
.
 Queries about the behavior of the world are posed as logical entailment
 queries relative to this theory.
\end_layout

\begin_layout DefinitionLbld
Basic\InsetSpace ~
Action\InsetSpace ~
Theory A basic action theory, denoted 
\begin_inset Formula $\Dt$
\end_inset

, is a set of situation calculus sentences (with a specific syntactic form
 outlined below) that describes a particular dynamic world.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); unique names axioms ensuring that action terms are distinct (
\begin_inset Formula $\Dt_{una}$
\end_inset

); action description axioms defining fluents that indicate various properties
 of actions, such as when they can be performed (
\begin_inset Formula $\Dt_{ad}$
\end_inset

); successor state axioms describing how primitive fluents change between
 situations (
\begin_inset Formula $\Dt_{ssa}$
\end_inset

); and axioms describing the value of primitive fluents in the initial situation
 (
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{una}\cup\Dt_{ad}\cup\Dt_{ssa}\cup\Dt_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
These axioms must satisfy some consistency criteria to constitute a valid
 domain description - consult the work of 
\begin_inset LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

 for the details.
 We will typically assume that we are working with an arbitrary, but fixed,
 basic action theory 
\begin_inset Formula $\Dt$
\end_inset

.
\end_layout

\begin_layout Standard
The discussion below depends heavily on an important type of formula in
 this logic: the 
\emph on
uniform formulae
\emph default
 can be thought of as 
\emph on
properties
\emph default
 of the state of the world 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 They are basically logical combinations of primitive fluents referring
 to a common situation term.
\end_layout

\begin_layout DefinitionLbld
Uniform\InsetSpace ~
Formulae Let 
\begin_inset Formula $F$
\end_inset

 be an arbitrary primitive fluent, 
\begin_inset Formula $\vars{x}$
\end_inset

 be any vector of terms mentioning no situation term other than 
\begin_inset Formula $s$
\end_inset

, and 
\begin_inset Formula $y$
\end_inset

 be any variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the formulae uniform in 
\begin_inset Formula $s$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists y:\phi\,|\,\forall y:\phi\,|\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout this paper to refer to an arbitrary uniform formula.
 Suppose that 
\begin_inset Formula $\phi$
\end_inset

 is uniform in 
\begin_inset Formula $s'$
\end_inset

, then we will use 
\begin_inset Formula $\phi[s]$
\end_inset

 to stand for 
\begin_inset Formula $\phi$
\end_inset

 with every occurrence of 
\begin_inset Formula $s'$
\end_inset

 replace by 
\begin_inset Formula $s$
\end_inset

.
 This notation means that the particular situation term in a uniform formula
 is often immaterial, so we can suppress the situation terms to simplify
 the presentation (e.g.
 using 
\begin_inset Formula $Holding(Sam,Box1)$
\end_inset

 instead of 
\begin_inset Formula $Holding(Sam,Box1,s)$
\end_inset

)
\end_layout

\begin_layout Subsubsection*
Unique Names Axioms
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{una}$
\end_inset

 restricts action terms to a finite number of action types, and ensures
 that actions with different types or different arguments are in fact different.
 The function 
\begin_inset Formula $actor(a)$
\end_inset

 gives the agent performing an action, which is always the action's first
 argument.
 In our example domain, actions are of the form 
\begin_inset Formula $pickup(Agent,Box)$
\end_inset

, 
\begin_inset Formula $drop(Agent,Box)$
\end_inset

, and 
\begin_inset Formula $move(Agent,Room)$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Action Description Axioms
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 is traditionally called the 
\emph on
action precondition axioms, 
\emph default
but we will need a more general notion later in the paper so we introduce
 the notation now.
 There is a distinguished fluent predicate 
\begin_inset Formula $Poss(Action,Situation)$
\end_inset

 that indicates whether it is possible to perform an action in a given situation.
 For example, it is only possible for an agent to drop an object if they
 are actually holding it:
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow standard naming conventions for the situation calculus: lower-case
 roman names indicate variables, and free variables are implicitly universally
 quantified at the outermost scope
\end_layout

\end_inset


\begin_inset Formula \[
Poss(drop(agt,obj),s)\equiv Holding(agt,obj,s)\]

\end_inset

The axiom set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains one 
\begin_inset Formula $Poss$
\end_inset

 axiom of the form 
\begin_inset Formula $Poss(A(\vars{x}),s)\equiv\phi$
\end_inset

 for each type of action 
\begin_inset Formula $A$
\end_inset

.
 These individual axioms are combined into a generalized 
\begin_inset Formula $Poss$
\end_inset

 axiom for sets of concurrent actions, which in its simplest form is just:
\begin_inset Formula \[
Poss(c,s)\equiv c\neq\{\}\,\wedge\,\forall a\in c:\, Poss(a,s)\]

\end_inset


\end_layout

\begin_layout Standard
Note that it is never possibe to perform the empty set of actions; were
 this permitted, we would need axioms stating that 
\begin_inset Formula $do(\{\},s)=s$
\end_inset

 which would greatly complicate the 
\noun on
Situation
\noun default
 sort.
 In more complex domains, the preconditions of some actions may interact,
 so that they cannot be performed concurrently even if the actions are individiu
ally possible.
 We refer the reader to the work of 
\begin_inset LatexCommand citet
key "pinto94temporal"

\end_inset

 for a full discussion of this issue; for our purposes, it suffices to assume
 that 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains an appripriate axiomatization of such interaction.
\end_layout

\begin_layout Standard
This notion of a predicate that describes the performance of an action can
 be generalized beyond only preconditions, to what we will call 
\emph on
action description predicates
\emph default
.
 These are predicates defined in the same manner as 
\begin_inset Formula $Poss$
\end_inset

, with similar axioms included in 
\begin_inset Formula $\Dt_{ad}$
\end_inset

, that describe some other aspect of the performance of an action.
 For example, in Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Observation"

\end_inset

 we will define an action description predicate 
\begin_inset Formula $CanObs$
\end_inset

 that specifies whether an agent will observe the occurrence of an action.
 Action description 
\emph on
functions
\emph default
 can also be defined in an analogous way.
\end_layout

\begin_layout Standard
Throughout the paper we will use 
\begin_inset Formula $\alpha$
\end_inset

 to refer to an arbitrary action description predicate.
 For notational convenience we allow the use of lambda abstraction and implicit
 currying to form new action description predicates from existing ones,
 with the understanding that these can be handled via macro expansion or
 incorporated directly into 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 if desired.
 For example, we will use 
\begin_inset Formula $CanObs(agt)$
\end_inset

 as a shorthand for 
\begin_inset Formula $\lambda a,s:CanObs(agt,a,s)$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Foundational Axioms
\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 enforce the basic structure of situations as a banching-time account of
 the world state.
 There is a set of initial situations identified by the predicate 
\begin_inset Formula $Init(s)$
\end_inset

, and a distinguished initial situation 
\begin_inset Formula $S_{0}$
\end_inset

 called the 
\emph on
actual 
\emph default
initial situation.
 Other initial situations represent alternatives that the agents think might
 be possible, but in fact are not.
 Situations in general form a tree structure with an initial situation at
 the root and 
\begin_inset Formula $do$
\end_inset

 constructing child situations from parents.
 The foundational axioms define a basic ordering relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 which should be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

 and is defined as follows:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg\left(s'\sqsubset s\right)\\
s\sqsubset do(c,s')\equiv s\sqsubseteq s'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 There is also a second-order induction axiom expressing that situations
 constructed in this way are, in fact, the only situations available.
 This is needed to prove statements that universally quantify over situations.
\end_layout

\begin_layout Standard
This notation for 
\begin_inset Quotes eld
\end_inset

in the future of
\begin_inset Quotes erd
\end_inset

 can be extended to consider only those futures in which all actions satisfy
 a particular action description predicate.
 We use a relation 
\begin_inset Formula $<_{\alpha}$
\end_inset

 for each action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, with the following definitions:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg\left(s'<_{\alpha}s\right)\\
s<_{\alpha}do(c,s')\equiv s\leq_{\alpha}s'\wedge\alpha(c,s')\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
root
\emph default
 of a situation is the initial situation from which it was constructed,
 and is accessed by the function 
\begin_inset Formula $root(s)$
\end_inset

:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\, root(s)=s\\
root(do(c,s))=root(s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
legal situations
\emph default
 are those in which every action was possible to perform in the preceding
 situation.
 These are of fundamental importance, as they are the only situations that
 could actually be brought about in the real world.
\end_layout

\begin_layout DefinitionLbld
Legal\InsetSpace ~
Situation A legal situation, identified by 
\begin_inset Formula $Legal(s)$
\end_inset

, satisfies:
\begin_inset Formula \[
Legal(s)\,\equiv\, root(s)\leq_{Poss}s\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Successor State Axioms
\end_layout

\begin_layout Standard
The truth of a fluent is completely specified by defining its truth in the
 initial situation, and collecting the effects of the various actions into
 
\emph on
successor state axioms
\emph default
.
 Such axioms provide a monotonic solution to the frame problem.
 They have the following general form, asserting the truth of a fluent 
\begin_inset Formula $F$
\end_inset

 in the successor situation 
\begin_inset Formula $do(c,s)$
\end_inset

 based on the current situation 
\begin_inset Formula $s$
\end_inset

 and the actions 
\begin_inset Formula $c$
\end_inset

 that were performed: 
\begin_inset Formula \[
F(\vars{x},do(c,s))\equiv\Phi^{+}(\vars{x},c,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi^{-}(\vars{x},c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi^{+}$
\end_inset

 and 
\begin_inset Formula $\Phi^{-}$
\end_inset

 are formulae uniform in 
\begin_inset Formula $s$
\end_inset

.
 Roughly, this axiom states that 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after performing 
\begin_inset Formula $c$
\end_inset

 if 
\begin_inset Formula $c$
\end_inset

 made it true, or it was previously true and 
\begin_inset Formula $c$
\end_inset

 did not make it false
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Formula $\mathcal{D}_{ssa}$
\end_inset

 contains one such axiom for each fluent.
\end_layout

\begin_layout Subsubsection*
Initial Situation Axioms
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 describes the actual state of the world before any actions are performed.
 It is a collection of sentences of the form 
\begin_inset Formula $\phi[S_{0}]$
\end_inset

 stating what holds in the initial situation.
 Note that it does 
\emph on
not
\emph default
 contain axioms about initial situations other than 
\begin_inset Formula $S_{0}$
\end_inset

.
 As we shall see in the next subsection, these are dealt with implicity
 by sentences of the form 
\begin_inset Formula $\Knows(agt,\phi,S_{0})$
\end_inset

.
\end_layout

\begin_layout Subsection
Knowledge and Sensing
\begin_inset LatexCommand label
name "sub:Knowledge-and-Sensing"

\end_inset


\end_layout

\begin_layout Standard
Epistemic reasoning was first introduced to the situation calculus by 
\begin_inset LatexCommand citet
key "moore80know_act"

\end_inset

, and formalised extensively by 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

 whose paper is now the canonical reference for these techniques.
 The handling of concurrent actions is due to 
\begin_inset LatexCommand citet
key "scherl03conc_knowledge"

\end_inset

.
 It i these techniques that we will extend in this paper.
\end_layout

\begin_layout Standard
The semantics of knowledge are based on a reification of the 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 semantics of modal logic, using situation terms rather than abstract worlds.
 A knowledge fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 The macro 
\begin_inset Formula $\Knows$
\end_inset

 is then defined as a shorthand for the standard possible-worlds definition
 of knowledge, stating that an agent knows something when it is true in
 all situations considered possible: 
\begin_inset Formula \begin{equation}
\Knows(agt,\phi,s)\isdef\forall s':\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}

\end_inset

 
\end_layout

\begin_layout Standard
Readers familiar with modal logic will recognise 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 as the situation calculus analogue of the modal reachability relation 
\begin_inset Formula $K_{agt}$
\end_inset

, and the macro 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 as the equivalent of the modal box operator 
\begin_inset Formula $[K_{agt}]\phi$
\end_inset

.
\end_layout

\begin_layout Standard
To allow actions to return sensing information the sensing result function
 
\begin_inset Formula $SR(a,s)$
\end_inset

 is introduced, giving the result returned by the action 
\begin_inset Formula $a$
\end_inset

 when executed in situation 
\begin_inset Formula $s$
\end_inset

.
 
\begin_inset Formula $SR$
\end_inset

 is an action description function and therefore is axiomatized in 
\begin_inset Formula $\Dt_{ad}$
\end_inset

.
 For actions that don't return sensing information, the value of 
\begin_inset Formula $SR$
\end_inset

 is set to an arbitrary constant such as 
\begin_inset Formula $"OK"$
\end_inset

.
\end_layout

\begin_layout Standard
The standard successor state axiom for the knowledge fluent is:
\begin_inset Formula \begin{align}
K(agt,s'',do(c,s))\equiv\exists s': & \, s''=do(c,s')\,\wedge K(agt,s',s)\wedge Poss(c,s')\nonumber \\
 & \wedge\,\forall a\in c:\,\left(actor(a)=agt\,\rightarrow\, SR(a,s)=SR(a,s')\right)\label{eq:k_ssa_standard}\end{align}

\end_inset

This axiom ensures that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(c,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing the same actions 
\begin_inset Formula $c$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is considered a possible alternative to 
\begin_inset Formula $s$
\end_inset

.
 It must furthermore have been possible to perform those actions in 
\begin_inset Formula $s'$
\end_inset

, and the sensing results must match for each action that was carried out
 by the agent in question.
 Thus an agent's knowledge after the occurrence of an action is completely
 determined by the combination of its knowledge before the action, and the
 sensing results returned by the action.
 
\end_layout

\begin_layout Standard
To complete the axiomatization, one must also specify that initial situations
 may only be 
\begin_inset Formula $K$
\end_inset

-related to other initial situations:
\begin_inset Formula \begin{equation}
Init(s)\rightarrow\left(K(agt,s',s)\rightarrow Init(s')\right)\label{eq:k_s0_standard}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Since we will be developing a number of extensions to this formalism, we
 introduce a notational shorthand to refer to the standard account of knowledge
 throughout the rest of the paper:
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K,std}$
\end_inset

 the axioms of the standard account of knowledge due to 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

 and 
\begin_inset LatexCommand citet
key "scherl03conc_knowledge"

\end_inset

, as detailed in equations (
\begin_inset LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

).
\end_layout

\begin_layout Standard
Note that the 
\begin_inset Formula $\Knows(agt,\phi,S_{0})$
\end_inset

 axioms in 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 along with the axioms in 
\begin_inset Formula $\Dt_{K,std}$
\end_inset

 completely define 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 for any situation rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
 This is why it is not necessary to explicitly axiomatize what holds in
 other initial situations.
 
\end_layout

\begin_layout Standard
While powerful, this formalism has an important limitation: it is fundamentally
 
\emph on
synchronous.
 
\emph default
Each agent is assumed to have full knowledge of all actions that have occurred.
 Note that this awareness is passive, as the agents perform no explicit
 sensing actions to determine what has occurred.
 Responsibility for generating such awareness in real systems is the responsibil
ity of a lower-level software component, such as a continuous sensing system
 that identifies change in the environment and notifies the agent when an
 action occurs.
 While suitable for some domains, there are clearly many multi-agent domains
 where achieving total awareness of actions would be infeasible.
 A major contribution of this paper is a more flexible formalism for knowledge
 that can be applied to a much wider range of domains.
\end_layout

\begin_layout Subsection
Reasoning
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 These are generally based on syntactic manipulation of a query into a form
 that is more amenable to reasoning - for example, because it can be proven
 without using some of the axioms from 
\begin_inset Formula $\Dt$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Types of Reasoning
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\psi$
\end_inset

 be an arbitrary sentence from a particular situation calculus domain 
\begin_inset Formula $\Dt$
\end_inset

.
 In the general case, answering this query is a theorem-priving task in
 second-order logic (denoted SOL) thanks to the induction axioms included
 in 
\begin_inset Formula $\Sigma$
\end_inset

:
\begin_inset Formula \[
\Dt\models_{SOL}\psi\]

\end_inset


\end_layout

\begin_layout Standard
This is clearly problematic for effective automated reasoning.
 Fortunately, there exist particular syntactic forms for which some of the
 axioms in 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required.
 If queries are restricted to the form 
\begin_inset Formula $\forall s\,\phi[s]$
\end_inset

, where 
\begin_inset Formula $\phi$
\end_inset

 is uniform, they can be answered without many of the axioms in 
\begin_inset Formula $\Dt$
\end_inset

 
\begin_inset LatexCommand citep
key "Lin94-StateConstraints,kelly07sc_persistence"

\end_inset

 and in particular, using only first-order logic: 
\begin_inset Formula \[
\mathcal{D}-\Dt_{S_{0}}\models_{SOL}\forall s\,\phi[s]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{una}\models_{FOL}\forall s\,\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
We refer to this as 
\emph on
static domain reasoning
\emph default
, since it does not depend on the axioms about actions or on details of
 the initial situation.
 Still easier to perform is 
\emph on
initial situation reasoning
\emph default
, where the query is further restricted to be a formula uniform in 
\begin_inset Formula $S_{0}$
\end_inset

.
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\forall s\,\phi[s]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{una}\models_{FOL}\phi[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Since the initial situation axioms 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 often satisfy the closed-world assumption, provers such as Prolog can be
 employed to handle this type of query quite effectively.
 In general, effective reasoning depends on transforming queries into these
 more easily-handled forms.
\end_layout

\begin_layout Subsubsection*
Regression
\end_layout

\begin_layout Standard
The principle tool for effective reasoning in the situation calculus is
 the regression meta-operator 
\begin_inset Formula $\Reg_{\Dt}$
\end_inset

 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

, a syntactic manipulation whose behavior can be summarized for our purposes
 as follows: it transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into a formula 
\begin_inset Formula $\Reg_{\Dt}(\phi)$
\end_inset

 that is uniform in 
\begin_inset Formula $s$
\end_inset

 and is equivalent to 
\begin_inset Formula $\phi$
\end_inset

 under the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\phi\equiv\Reg_{\Dt}(\phi)\]

\end_inset


\end_layout

\begin_layout Standard
In the base case, this involves replacing fluents 
\begin_inset Formula $F(\vars{x},do(c,s))$
\end_inset

 with their matching successor state axioms from 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

.
\end_layout

\begin_layout Standard
To ensure that formulae are uniform, regression also replaces instaces of
 action description predicates with their definitions from 
\begin_inset Formula $\Dt_{ad}$
\end_inset

.
 We assume that these definitions are finitely enumerable for each action
 description predicate, so that this replacement can be done even when an
 action variable is used.
 For example, we assume that 
\begin_inset Formula $Poss(c,s)$
\end_inset

 can be replaced by an enumeration over action types such as the following:
\begin_inset Formula \[
\forall a\in c:\,\left(a=Act_{1}\wedge\phi_{a}\,\vee\, a=Act_{2}\wedge\phi_{2}\,\vee\dots\,\vee a=Act_{n}\wedge\phi_{n}\right)\]

\end_inset


\end_layout

\begin_layout Standard
Since regression can be applied to 
\begin_inset Quotes eld
\end_inset

uniformize
\begin_inset Quotes erd
\end_inset

 formulae in this manner, we will sometimes simplify the presentation by
 including action description predicates directly in formulae that we intened
 to treat as uniform; this should be understood as a notational shortcut
 for a proper uniform formula.
 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\phi$
\end_inset

 refers to a situation that is rooted at 
\begin_inset Formula $S_{0}$
\end_inset

, repeated applications of the regression operator (denoted by 
\begin_inset Formula $\Reg_{\Dt}^{*}$
\end_inset

) can transform it into an equivalent formula uniform in the initial situation.
 The successor state and action precondition axioms are 
\begin_inset Quotes eld
\end_inset

compiled in
\begin_inset Quotes erd
\end_inset

 to the formula and so are not required for answering the regressed query,
 making reasoning simpler:
\begin_inset Formula \[
\Dt\models\phi[do(c_{n},do(c_{n-1},\dots,do(c_{1},S_{0}))]\,\,\,\,\,\mathrm{iff}\,\,\,\,\,\Dt_{una}\cup\Dt_{S_{0}}\models\Reg_{\Dt}^{*}(\phi)[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
The trade-off is that the length of 
\begin_inset Formula $\Reg_{\Dt}^{*}(\phi)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice.
\end_layout

\begin_layout Standard
We use two notational short-cuts to simplify the presentation throughout
 the paper.
 First, since we assume we are dealing with a fixed basic action theory
 
\begin_inset Formula $\Dt$
\end_inset

, we will drop the subscript and simply use 
\begin_inset Formula $\Reg$
\end_inset

 for the regression operator.
 Second, we introduce a two-argument version of the regression operator
 that takes a concurrent action as its second argument.
 Suppose that 
\begin_inset Formula $\phi$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

, then define:
\begin_inset Formula \[
\Reg(\phi,c)\,\isdef\,\Reg(\phi[do(c,s)])\]

\end_inset


\end_layout

\begin_layout Standard
Note that the result is also uniform in 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Reasoning about Knowledge
\end_layout

\begin_layout Standard
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 show how to apply the regression operator to formulae containing the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, allowing effective reasoning about epistemic queries using standard
 techniques of the situation calculus.
 Although we have changed the notation somewhat to foreshadow the techniques
 we will develop in Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

, their definition operates as follows::
\begin_inset Formula \begin{align*}
\Reg(\Knows(agt,\phi,do(c,s)))\isdef & \,\,\,\exists y:\, y=\{<a,SR(a,s)>|\, a\in c\wedge actor(a)=agt\}\,\,\wedge\\
 & \,\,\,\,\,\,\,\,\Knows(agt,\left[Poss(c)\wedge\{<a,SR(a)>|\, a\in c\wedge actor(a)=agt\}=y\right]\rightarrow\Reg(\phi[do(a,s)]),s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This works by collecting the sensing results from each action performed
 by the agent into the set 
\begin_inset Formula $y$
\end_inset

, then ensuring matching sensing results in every situation considered possible.
 It expresses the knowledge of the agent after a concurrent action in terms
 of what it knew before the action, along with the information returned
 by the action.
 This technique relies heavily on the fact that all actions are public,
 since it requires every agent's knowledge to be updated in response to
 every action.
\end_layout

\begin_layout Standard
It is possible to formulate an alternate successor state axiom for knowledge
 that does not assume all actions are public, such as of 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

.
 However these formulations invariably require universal quantification
 over situation terms, to account for arbitrarily-long sequences of hidden
 actions.
 Such universal quantification is incompatible with regression rules like
 the above and these formulations offer no reasoning procedure other than
 second-order theorem proving.
 By utilizing a new reasoning technique called 
\begin_inset Quotes eld
\end_inset

property persistence
\begin_inset Quotes erd
\end_inset

 to allow universal quantification over situation terms, our work is the
 first to provide an account of knowledge with hidden actions while maintaining
 regression as an effective reasoning tool.
\end_layout

\begin_layout Subsubsection*
Property Persistence
\end_layout

\begin_layout Standard
As discussed above, traditional regression techniques cannot handle queries
 that universally quantify over situation terms.
 In fact, such queries require the use of a second-order induction axiom
 and therefore need a second-order theorem prover in the general case.
 Fortunately, many queries are in a simple syntactic form called 
\emph on
property persistence
\emph default
 queries 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 Such queries assert that a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 holds in a given situation, and will continue to hold as long as all future
 actions satisfy some action description predicate 
\begin_inset Formula $\alpha$
\end_inset

: 
\begin_inset Formula \[
\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
We have developed a meta-operator called the 
\emph on
persistence condition
\emph default
, denoted 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

, to handle such queries more effectively 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 It produces a uniform formula such that:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Dt\,\models\,\Pst_{\Dt}(\phi,\alpha)[s]\,\equiv\,\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
As before, we will use the simpler notation 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 and leave 
\begin_inset Formula $\Dt$
\end_inset

 implicit.
 Since the persistence condition is used to replace a second-order induction
 axiom, 
\begin_inset Formula $\Pst$
\end_inset

 is actually a fixpoint calculation and it therefore requires some theorem
 proving.
 This is in contrast to the regression operator, which is a purely syntactic
 transformation.
 We breifly describe the operation of 
\begin_inset Formula $\Pst$
\end_inset

 below since we will need some of these details for a later proof; for full
 details consult our previous work 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
\end_layout

\begin_layout Standard
First, the one-step-persistence operator 
\begin_inset Formula $\Pst^{1}$
\end_inset

 is defined to assert that 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate successors:
\begin_inset Formula \[
\Pst^{1}(\phi,\alpha)[s]\,\isdef\,\phi[s]\wedge\forall c:\,\alpha(c,s)\rightarrow\Reg(\phi[do(c,s)])\]

\end_inset


\end_layout

\begin_layout Standard
Note that regression is applied to ensure that the result is uniform in
 
\begin_inset Formula $s$
\end_inset

.
 Repeated application, denoted 
\begin_inset Formula $\Pst^{n}(\phi,\alpha)$
\end_inset

, asserts the persistence of 
\begin_inset Formula $\phi$
\end_inset

 after greater numbers of actions.
 Intuitively 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 should be a fixpoint of 
\begin_inset Formula $\Pst^{1}(\phi,\alpha)$
\end_inset

, and indeed it can be shown that:
\begin_inset Formula \[
\mathcal{D}_{una}\,\models\,\Pst^{n}(\phi,\alpha)\,\rightarrow\,\Pst^{n+1}(\phi,\alpha)\,\,\,\,\,\,\mathrm{iff}\,\,\,\,\,\,\Dt-\Dt_{S_{0}}\,\models\,\Pst^{n}(\phi,\alpha)\,\equiv\,\Pst(\phi,\alpha)\]

\end_inset


\end_layout

\begin_layout Standard
Thus the calculation of 
\begin_inset Formula $\mathcal{P}(\phi,\alpha)$
\end_inset

 replaces a single second-order reasoning task with iterated static domain
 reasoning.
 Our experience has shown this technique to be quite effective in practice,
 as static domain reasoning is significantly easier to perform.
 Moreover, since 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 produces a uniform formula, it allows queries that universally quantify
 over situation terms to be reduced to a form that is compatible with traditiona
l regression techniques.
\end_layout

\begin_layout Section
Individual Knowledge with Hidden Actions
\begin_inset LatexCommand label
name "sec:Obs-Knowledge"

\end_inset


\end_layout

\begin_layout Standard
Existing accounts of knowledge in the situation calculus directly express
 the dynamics of knowledge update in terms of the actions that have occurred
 in the world, as seen in Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Sensing"

\end_inset

.
 An immediate consequence of this is that one can only reason about knowledge
 if one has a rooted situation term, as the required query is:
\begin_inset Formula \[
\Dt\,\models\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
In asynrchonous domains with hidden actions, where agents are not necessarily
 aware of the number of actions that have been performed, the agents cannot
 use this formulation to reason about their own knowledge.
 Since knowledge is directly coupled to actions, and hence to situation
 terms, they cannot construct an appropriate query.
 This section is devoted to removing this troublesome coupling.
\end_layout

\begin_layout Subsection
Observations
\end_layout

\begin_layout Standard
To remove the direct coupling between knowledge and actions, we introduce
 an explicit notion of 
\emph on
observations
\emph default
.
 These are internal notifications that agents receive when an action has
 occurred.
 By expressing knowledge in terms of observations rather than actions, we
 ensure that agents can always reason about their own knowledge based on
 their own internal history of observations.
\end_layout

\begin_layout DefinitionLbld
Observations An observation is a notification event received by an agent,
 making it aware of some change in the state of the world.
 When an agent receives such a notification, we say that it 
\begin_inset Quotes eld
\end_inset

observed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

made
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

perceived
\begin_inset Quotes erd
\end_inset

 that observation.
\end_layout

\begin_layout Standard
Since the state of the world may only change in response to some action,
 observations can only be made as a result of some action.
 For simplicity we assume that agents perceive observations instantaneously,
 i.e.
 in the same instant as the actions that cause them.
\end_layout

\begin_layout Standard
Since 
\begin_inset Quotes eld
\end_inset

observation
\begin_inset Quotes erd
\end_inset

 is quite a loaded term, it is worth re-iterating this point: observations
 are instantanous
\emph on
 events
\emph default
 generated internally by each agent in response to actions occurring in
 the world.
 We make no commitment as to how these events are generated, preferring
 a clean delineation between the task of observing change and the dynamics
 of knowledge update based on those observations.
 As with the work of 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, generating awareness is the responsibility of a lower-level component
 of the agent's control software and we will not consider it further.
\end_layout

\begin_layout Standard
To make this idea concrete, let us introduce an additional sort 
\noun on
Observations
\noun default
 to the language of the situation calculus, for the moment without any particula
r commitment towards what this sort will contain.
 We then introduce the function:
\begin_inset Formula \[
obs(agt,c,s)=o\]

\end_inset

This function returns a set of observations, and should be read as 
\begin_inset Quotes eld
\end_inset

when actions 
\begin_inset Formula $c$
\end_inset

 are performed in situation 
\begin_inset Formula $s$
\end_inset

, agent 
\begin_inset Formula $agt$
\end_inset

 will perceive 
\begin_inset Formula $o$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Using a set of observations allows an agent to perceive any number of observati
ons in response to an action occurrence - perhaps several observations,
 perhaps none.
 We thus write 
\begin_inset Formula $obs(agt,c,s)=\{\}$
\end_inset

 for the case where an agent makes no observations, i.e.
 the actions 
\begin_inset Formula $c$
\end_inset

 are completely hidden.
 
\end_layout

\begin_layout Standard
The concept of a 
\emph on
view
\emph default
 follows naturally - it is the sequence of all the observations made by
 an agent as the world has evolved.
 
\end_layout

\begin_layout DefinitionLbld
Views An agent's view in a given situation 
\begin_inset Formula $\mathrm{s}$
\end_inset

 is the corresponding sequence of observations made by the agent as a result
 of each action in 
\begin_inset Formula $\mathrm{s}$
\end_inset

, exluding those actions for which no observations were made.
\end_layout

\begin_layout Standard
We introduce another sort 
\noun on
Views
\noun default
 consisting of sequences of sets of observations, with 
\begin_inset Formula $\epsilon$
\end_inset

 being the empty sequence, and the function 
\begin_inset Formula $view$
\end_inset

 giving the observation history associated with a particular situation:
\begin_inset Formula \begin{align}
Init(s)\,\rightarrow & \, view(agt,s)=\epsilon\nonumber \\
obs(agt,a,s)=\{\}\,\rightarrow & \, view(agt,do(a,s))=view(agt,s)\nonumber \\
obs(agt,a,s)\neq\{\}\,\rightarrow & \, view(agt,do(a,s))=obs(agt,a,s)\cdot view(agt,s)\label{eq:view_defn}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Observations and views can be seen as localized analogues of actions and
 situations respectively.
 An action is a global event that causes the state of the world to change,
 while an observation is an internal event that causes an agent's awareness
 of the state of the world (i.e.
 its knowledge) to change.
 Similarly, a situation represents a complete, global history of all the
 actions that have occurred in the world, while a view is an agent's local
 history of all the observations it has made.
 The situation is an omniscient perspective on the world, the view a local
 perspective.
 As we shall see, this distinction is fundamental to developing a truly
 general multi-agent semantics for knowledge.
\end_layout

\begin_layout Subsection
Knowledge and Observation
\begin_inset LatexCommand label
name "sub:Knowledge-and-Observation"

\end_inset


\end_layout

\begin_layout Standard
It is a basic tenet of epistemic reasoning that an agent's knowledge at
 any particular time must depend solely on its local history: the knowledge
 that it started out with combined with the observations it has made since
 then 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
 Given an explicit account of the observations made by each agent, the required
 semantics of the 
\begin_inset Formula $K$
\end_inset

 relation are clear: 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 must hold whenever 
\begin_inset Formula $s'$
\end_inset

 is legal, both 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 would result in the same view for the agent, and 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 are rooted at 
\begin_inset Formula $K$
\end_inset

-related initial situations:
\begin_inset Formula \begin{equation}
\mathcal{D}\models K(agt,s',s)\equiv K(root(s'),root(s))\wedge Legal(s')\wedge view(agt,s')=view(agt,s)\label{eq:k-desired}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
While a wonderfully succinct definition of how knowledge should behave,
 this formulation cannot be used directly in a basic action theory.
 Basic action theories require that the dynamics of fluent change be specified
 as a successor state axiom, so we must formulate a successor state axiom
 for the 
\begin_inset Formula $K$
\end_inset

 fluent which enforces the above equivalence.
\end_layout

\begin_layout Standard
For notational convenience, let us first introduce an action description
 predicate 
\begin_inset Formula $PbU$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

possible but unobservable
\begin_inset Quotes erd
\end_inset

) indicating that the actions 
\begin_inset Formula $c$
\end_inset

 are possible in 
\begin_inset Formula $s$
\end_inset

, but no observations will be made by 
\begin_inset Formula $agt$
\end_inset

 if they are performed:
\begin_inset Formula \begin{equation}
PbU(agt,c,s)\isdef Poss(c,s)\wedge obs(agt,c,s)=\{\}\label{eqn:PbU_defn}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
By stating that 
\begin_inset Formula $s\leq_{PbU(agt)}s'$
\end_inset

 we assert that 
\begin_inset Formula $agt$
\end_inset

 would make no observations were the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
 This means that the views of both situations would be identical.
 The two situations would be indistinguishable to the agent, so if it considers
 
\begin_inset Formula $s$
\end_inset

 possible then it must also consider 
\begin_inset Formula $s'$
\end_inset

 possible.
 Following this intuition, we propose the following successor state axiom
 to capture the desired dynamics of the knowledge fluent:
\begin_inset Formula \begin{align}
K(agt,s'',do(c,s))\equiv & \left[\, obs(agt,c,s)=\{\}\rightarrow K(agt,s'',s)\,\right]\nonumber \\
\wedge & \left[\, obs(agt,c,s)\neq\{\}\rightarrow\exists c',s':\, obs(agt,c',s')=obs(agt,c,s)\right.\nonumber \\
 & \left.\,\,\,\,\,\,\,\,\wedge\, Poss(c',s')\wedge K(agt,s',s)\wedge do(c',s')\leq_{PbU(agt)}s''\,\right]\label{eqn:new_k_ssa}\end{align}

\end_inset

 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $c$
\end_inset

 was totally unobservable, the agent's state of knowledge does not change.
 Otherwise, it considers possible any legal successor to a possible alternate
 situation 
\begin_inset Formula $s'$
\end_inset

 that can be brought about by an action 
\begin_inset Formula $c'$
\end_inset

 that would yield identical observations.
 It also considers possible any future of such a situation in which is would
 make no further observations.
 To reiterate: unlike the standard successor state axiom from equation 
\begin_inset LatexCommand eqref
reference "eq:k_s0_standard"

\end_inset

, our new formalism requires agents to consider any possible future situation
 in which they would make no further observations.
\end_layout

\begin_layout Standard
It remains to specify 
\begin_inset Formula $K$
\end_inset

 in the initial situation.
 Since situations where 
\begin_inset Formula $S_{0}\leq_{PbU(agt)}s$
\end_inset

 holds must be 
\begin_inset Formula $K$
\end_inset

-related to 
\begin_inset Formula $S_{0}$
\end_inset

, we introduce another relation 
\begin_inset Formula $K_{0}$
\end_inset

 to specify each agent's initial knowledge:
\begin_inset Formula \begin{gather*}
K_{0}(agt,s',s)\rightarrow Init(s')\wedge Init(s)\\
\KnowsZ(agt,\phi,s)\,\isdef\,\forall s'\, K_{0}(agt,s',s)\rightarrow\phi[s']\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Think of 
\begin_inset Formula $\KnowsZ$
\end_inset

 as the agent's knowledge at the beginning of time, where it is guaranteed
 that no actions have occurred.
 Any knowledge axioms in 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 must be updated to use 
\begin_inset Formula $\KnowsZ$
\end_inset

 rather than 
\begin_inset Formula $\Knows$
\end_inset

.
 We can then use this to define 
\begin_inset Formula $K$
\end_inset

 for initial situations:
\begin_inset Formula \begin{gather}
Init(s)\rightarrow\left[K(agt,s'',s)\equiv\exists s'\,.\, K_{0}(agt,s',s)\wedge s'\leq_{PbU(agt)}s'')\right]\label{eqn:new_k_s0}\end{gather}

\end_inset

These definitions suffice to ensure that knowledge behaves as we require:
 two situations will be related by 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 if and only if they result in identical views for 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $s'$
\end_inset

 is legal, and their root situations were initially related.
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K,obs}$
\end_inset

 the axioms for our new observation-based semantics for knowledge, as detailed
 in equations (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

).
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:k_obs_equiv"

\end_inset

 For a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, for any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge view(agt,s'')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
For the
\series bold
 
\series default
\emph on
if
\emph default
 direction we establish each of the three conjuncts individually.
 The roots case is trivial since equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) always expresses 
\begin_inset Formula $K(s'',do(a,s))$
\end_inset

 in terms of 
\begin_inset Formula $K(s',s)$
\end_inset

.
 Legality relies on the fact that 
\begin_inset Formula $PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

, while the views case relies on the fact that 
\begin_inset Formula $s\leq_{PbU}s'\rightarrow view(s)=view(s')$
\end_inset

.
 For the 
\emph on
only-if
\emph default
 direction we show how to construct an 
\begin_inset Formula $s'$
\end_inset

 satisfying the 
\begin_inset Formula $\exists s'$
\end_inset

 parts of equations (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

), completing the proof.
\end_layout

\begin_layout Standard
Using this new formulation, an agent's knowledge is completely decoupled
 from the global notion of actions, instead depending only on the local
 information that it has observed.
 It remains to specify precisely what the 
\noun on
Observations
\noun default
 sort contains, and how the 
\begin_inset Formula $obs()$
\end_inset

 function behaves.
 This will be the focus of the next subsection.
\end_layout

\begin_layout Subsection
Axiomatizing Observations
\end_layout

\begin_layout Standard
Let us begin by considering again the standard account of knowledge due
 to 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

.
 Its basic assumption that 
\begin_inset Quotes eld
\end_inset

all agents are aware of all actions
\begin_inset Quotes erd
\end_inset

 may be rephrased as 
\begin_inset Quotes eld
\end_inset

when an action occurs, all agents will observe that action
\begin_inset Quotes erd
\end_inset

.
 Allowing the 
\noun on
Observations
\noun default
 sort to contain 
\noun on
Action
\noun default
 terms, this assumption is akin to the following axiom for the 
\begin_inset Formula $obs()$
\end_inset

 function:
\begin_inset Formula \begin{equation}
a\in obs(agt,c,s)\equiv a\in c\label{eq:ax_obs_std1}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
What about sensing information? We can extend the 
\noun on
Observations
\noun default
 sort to contain 
\begin_inset Formula $<Action,Result>$
\end_inset

pairs and axiomatize like so:
\begin_inset Formula \begin{equation}
<a,r>\in obs(agt,c,s)\equiv a\in c\wedge SR(a,s)=r\wedge actor(a)=agt\label{eq:ax_obs_std2}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Using these definitions, our new account of knowledge will behave identically
 to the standard account:
\end_layout

\begin_layout Theorem
Suppose 
\begin_inset Formula $\Dt_{ad}\subset\Dt$
\end_inset

 contains equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) as definitions of the 
\begin_inset Formula $obs()$
\end_inset

 function, then for any situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,std}\models K(agt,s',s)\,\,\,\,\mathrm{iff}\,\,\,\,\Dt\cup\Dt_{K,obs}\models K(agt,s',s)\]

\end_inset


\end_layout

\begin_layout Proof
Equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) mean 
\begin_inset Formula $obs(agt,c,s)$
\end_inset

 cannot be empty for 
\begin_inset Formula $c\neq\{\}$
\end_inset

, so 
\begin_inset Formula $s\leq_{PbU(agt)}s'$
\end_inset

 iff 
\begin_inset Formula $s=s'$
\end_inset

.
 Equations (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) then amount to simple transformations of equations (
\begin_inset LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

) respectively, meaning that 
\begin_inset Formula $K$
\end_inset

 behaves the same under both theories.
\end_layout

\begin_layout Standard
We now discuss one straightforward way to generalize this for partial observabil
ity of actions.
 We introduce a new action description predicate, akin to 
\begin_inset Formula $Poss$
\end_inset

 but describing when actions will be observed by agents: 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 indicates that agent 
\begin_inset Formula $agt$
\end_inset

 would observe action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 We can then formulate the 
\begin_inset Formula $obs()$
\end_inset

 function according to:
\begin_inset Formula \[
a\in obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
There is an additional assumption in the standard handling of sensing actions:
 only the agent performing a sensing action is aware of its result.
 Such a restriction is common but certainly not universal.
 For example, if an agent waiting for a train activates a speaker to determine
 when it will arrive, the result of this sensing action would provide informatio
n to any other agent within earshot.
 We add an analogous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 to indicate when sensing information is available to an agent.
 We then include bare action terms in an agent's observations when it observes
 the action but not its result, and 
\emph on

\begin_inset Formula $<Action,Result>$
\end_inset


\emph default
 terms when it also senses the result:
\begin_inset Formula \begin{gather*}
a\in obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\\
<a,r>\in obs(agt,c,s)\equiv a\in c\wedge SR(a,s)=r\wedge CanObs(agt,a,s)\wedge CanSense(agt,a,s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We feel that this formulation provides a good balance between simplicity
 and expressiveness - it allows the obervability of actions to vary according
 to the state of the world, but provides agents with a complete description
 of each action that they are capable of observing.
 In Section 
\begin_inset LatexCommand ref
reference "sub:An-Illustrative-Example"

\end_inset

 we show how to use this formalism to model a domain in which agents can
 only observe actions performed in the same room as them.
 To show the flexibility of the observation-based approach, Section 
\begin_inset LatexCommand ref
reference "sub:Observing-Effects"

\end_inset

 outlines a more powerful axiomatization of observations in which agents
 may know that some action has occurred without necessarily knowing precisely
 what the action was.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The final component of our new account of knowledge is to extend the techniques
 for effective reasoning in the situation calculus to handle action theories
 based on our formalism.
 The appearance of the 
\begin_inset Formula $\leq_{PbU(agt)}$
\end_inset

 ordering over situations in equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) means that our new successor state axiom universally quantifies over situation
s, so standard regression techniques cannot be applied.
 We must appeal to the persistence condition meta-operator to transform
 this quantification into a uniform formula, so that regression can be applied.
\end_layout

\begin_layout Standard
We propose the following definition for the regression of 
\begin_inset Formula $\Knows$
\end_inset

 under our formalism:
\begin_inset Formula \begin{align}
\Reg(\Knows(agt,\phi,do(c,s)))\isdef\,\, & \exists o:\, obs(agt,c,s)=o\nonumber \\
 & \wedge\,\left[o=\{\}\,\rightarrow\,\Knows(agt,\phi,s)\right]\nonumber \\
 & \wedge\,\left[o\neq\{\}\,\rightarrow\,\Knows(agt,\forall c':\, obs(agt,c')=o\right.\nonumber \\
 & \,\,\,\,\,\,\,\,\,\,\,\wedge Poss(c')\rightarrow\left.\Reg(\Pst(\phi,PbU(agt))[do(c',s)]),s)\right]\label{eqn:R_do_c_s}\end{align}

\end_inset

 As required for a regression rule, this reduces a knowledge query at 
\begin_inset Formula $do(c,s)$
\end_inset

 to a knowledge query at 
\begin_inset Formula $s$
\end_inset

.
 It is also intuitively appealing: to know that 
\begin_inset Formula $\phi$
\end_inset

 holds, the agent must know that in all situations that agree with its observati
ons, 
\begin_inset Formula $\phi$
\end_inset

 cannot become false without it making an observation (this is the meaning
 of 
\begin_inset Formula $\Pst(\phi,PbU(agt))$
\end_inset

 evaluated at 
\begin_inset Formula $do(c',s)$
\end_inset

).
\end_layout

\begin_layout Standard
We must also specify the regression of 
\begin_inset Formula $\Knows$
\end_inset

 in the initial situation, as equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) also uses the 
\begin_inset Formula $\leq_{PbU(agt)}$
\end_inset

 ordering.
 This clause produces an expression in 
\begin_inset Formula $\KnowsZ$
\end_inset

 at 
\begin_inset Formula $S_{0}$
\end_inset

, meaning that it can be handled by epistemic reasoning about the initial
 situation only:
\begin_inset Formula \begin{equation}
\Reg(\Knows(agt,\phi,S_{0}))\,\isdef\,\KnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})\label{eqn:R_s0}\end{equation}

\end_inset


\end_layout

\begin_layout Theorem
Given a basic action theory 
\begin_inset Formula $\Dt\cup\Dt_{K,obs}$
\end_inset

 and a uniform formula 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\phi[do(c,s)]\equiv\Reg(\phi[do(c,s)])\]

\end_inset

 
\end_layout

\begin_layout ProofSketch
We need only consider the case of 
\begin_inset Formula $\phi=\Knows(agt,\phi,s)$
\end_inset

.
 In the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, we proceed by expanding the definition for 
\begin_inset Formula $\Knows$
\end_inset

 using our new successor state axiom for 
\begin_inset Formula $K$
\end_inset

, collecting sub-formulae that match the form of the 
\begin_inset Formula $\Knows$
\end_inset

 macro, and using regression and the persistence condition to render the
 resulting knowledge expressions uniform in 
\begin_inset Formula $s$
\end_inset

.
 In the base case, applying the persistence condition to an expansion of
 
\begin_inset Formula $\Knows$
\end_inset

 at the initial situation completes the proof.
\end_layout

\begin_layout Standard
We can thus handle knowledge queries using regression, the standard technique
 for effective reasoning in the situation calculus.
\end_layout

\begin_layout Standard
While this reasoning method is suitable for modeling and simulation purposes,
 it would be unreasonable for a situated agent to ask 
\begin_inset Quotes eld
\end_inset

do I know 
\begin_inset Formula $\phi$
\end_inset

 in the current situation?
\begin_inset Quotes erd
\end_inset

 using the situation calculus query 
\begin_inset Formula $\Dt\models\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as it cannot be expected to have the full current situation 
\begin_inset Formula $s$
\end_inset

.
 However, it will have its current view 
\begin_inset Formula $v$
\end_inset

.
 We define knowledge with respect to a view as follows:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,v)\,\isdef\,\forall s:\, view(agt,s)=v\wedge root(s)=S_{0}\rightarrow\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
It is a straightforward consequence of Theorem 
\begin_inset LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 that this form of knowledge is equivalent to knowledge based on a situation
 term having that observation history and rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
 Extending the regression rules in equations (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

) to handle formulae of this form is actually simpler than for regression
 over situations, as there are no empty observations in a history.
 The result is:
\begin_inset Formula \begin{align*}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,o\cdot v))\isdef\,\, & \mathbf{Knows}(agt,\forall c:\, obs(agt,c)=o\\
 & \,\,\,\,\,\,\,\,\wedge Poss(c)\rightarrow\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt)),c),v)\\
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,\epsilon))\isdef\,\, & \KnowsZ(agt,\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt)),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Using regression in this way, agents can reason about their own knowledge
 using only their local information.
 Our work thus makes it possible to include a situation calculus model in
 the implementation of a real-world multi-agent system, even when agents
 have only partial awareness of the actions being performed.
\end_layout

\begin_layout Subsection
An Illustrative Example
\begin_inset LatexCommand label
name "sub:An-Illustrative-Example"

\end_inset


\end_layout

\begin_layout Standard
Consider again a package-processing facility where agents are required to
 move boxes between various rooms.
 There are three actions (
\begin_inset Formula $pickup$
\end_inset

, 
\begin_inset Formula $drop$
\end_inset

 and 
\begin_inset Formula $move$
\end_inset

) and two fluents (
\begin_inset Formula $Holding$
\end_inset

 and 
\begin_inset Formula $InRoom$
\end_inset

) whose meanings should be clear.
 There are no sensing actions.
\end_layout

\begin_layout Standard
Agents may pickup a box if they are in the same room and no-one is holding
 it.
 They can drop a box they are holding at any time, and can move freely between
 rooms:
\begin_inset Formula \begin{align*}
Poss(pickup(agt,box),s)\equiv\, & \neg\exists agt:\, Holding(agt,box,s)\\
 & \,\wedge\,\exists rm:\, InRoom(agt,rm)\wedge InRoom(box,rm)\\
Poss(drop(agt,box),s)\equiv & \, Holding(agt,box,s)\\
Poss(move(agt,rm),s)\equiv & \, true\end{align*}

\end_inset


\end_layout

\begin_layout Standard
An agent is holding a box if they picked it up, or were already holding
 it and didn't put it down:
\begin_inset Formula \begin{align*}
Holding(agt,box,do(c,s))\equiv & \, pickup(agt,box)\in c\\
 & \,\vee\, Holding(agt,box,s)\wedge drop(agt,box)\in c\end{align*}

\end_inset


\end_layout

\begin_layout Standard
An object is in a room if it was taken there, or it was already in that
 room and it was not taken elsewhere:
\begin_inset Formula \begin{align*}
InRoom(obj,rm,do(c,s))\equiv\,\, & \exists agt:\, move(agt,rm)\in c\wedge\left[obj=agt\vee Holding(agt,obj,s)\right]\\
 & \vee\, InRoom(obj,rm,s)\wedge\neg\left[\exists agt,rm_{2}:\, move(agt,rm_{2})\in c\right.\\
 & \,\,\,\,\,\,\,\,\,\,\left.\wedge rm_{2}\neq rm\wedge\left(obj=agt\vee Holding(agt,obj,s)\right)\right]\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Agents can observe actions performed by an agent in the same room as themselves,
 and can observe agents entering their room:
\begin_inset Formula \begin{align*}
CanObs(agt,a,s)\equiv\,\, & \exists rm\,.\, InRoom(agt,rm)\wedge\\
 & \wedge\left(InRoom(actor(a),rm)\,\vee\,\exists agt_{2}\,.\, a=move(agt_{2},rm)\right)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Initially, Sam is in Room1 with Box1, Max is in Room2 with Box2, and no-one
 is holding any boxes.
 Everyone has complete knowledge of the initial situation:
\begin_inset Formula \begin{gather*}
InRoom(Sam,Room1,S_{0})\\
InRoom(Box1,Room1,S_{0})\\
InRoom(Max,Room2,S_{0})\\
InRoom(Box2,Room2,S_{0})\\
\neg Holding(agt,box,S_{0})\\
K_{0}(agt,s,S_{0})\equiv s=S_{0}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The following are examples of knowledge queries that can be posed in our
 formalism, a brief explanation of their outcome, and a demonstration of
 how they can be answered using regression.
\end_layout

\begin_layout Example
Initially, Sam knows that Max is not holding Box1:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\models\mathbf{Knows}(Sam,\neg Holding(Max,Box1),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset Formula $Holding(Max,Box1)$
\end_inset

 to be true, he must have picked Box1 up.
 Since Box1 is in the same room as Sam, she would be able to observe him
 doing so.
 Since she has not observed that, she can conclude that 
\begin_inset Formula $Holding(Max,Box1)$
\end_inset

 is false.
 To handle this using regression, we first calculate the following persistence
 condition:
\begin_inset Formula \begin{align*}
\Pst(\neg Holding(Max,Box1),PbU(Sam))\,=\,\, & \neg Holding(Max,Box1)\wedge\exists rm:\, InRoom(Sam,rm)\wedge\\
 & \,\,\,\,\,\, InRoom(Max,rm)\vee InRoom(Box1,rm)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Then we can use it in the following expansion:
\begin_inset Formula \begin{align*}
\Reg(\mathbf{Knows}(Sam,\neg Holding(Max,Box1),S_{0}))\,=\,\, & \KnowsZ(agt,\Pst(\neg Holding(Max,Box1),PbU(Sam)),S_{0})\\
=\,\, & \KnowsZ(agt,\neg Holding(Max,Box1)\wedge\exists rm:\, InRoom(Sam,rm)\wedge\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, InRoom(Max,rm)\vee InRoom(Box1,rm),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Based on the given axioms about 
\begin_inset Formula $S_{0}$
\end_inset

, this is true.
\end_layout

\begin_layout Example
Initially, Sam doesn't know that Max is not holding Box2:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\models\mathbf{\neg Knows}(Sam,\neg Holding(Max,Box2),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
By contrast, Sam does 
\emph on
not
\emph default
 know that Max is not holding Box2.
 Since Box2 is in a different room, Max could have picked it up without
 her observing the action.
 The persistence condition calculation is analogous:
\begin_inset Formula \begin{align*}
\Pst(\neg Holding(Max,Box2),PbU(Sam))\,=\,\, & \neg Holding(Max,Box2)\wedge\exists rm:\, InRoom(Sam,rm)\wedge\\
 & \,\,\,\,\,\, InRoom(Max,rm)\vee InRoom(Box2,rm)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
But this persistence condition is longer entailed by 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

.
 This highlights the difference between our approach and previous work -
 
\begin_inset Formula $Sam$
\end_inset

's knowledge fails in this case because she must consider any possible sequence
 of unobservable actions.
 In previous formalisms, 
\begin_inset Formula $Sam$
\end_inset

 would indeed have known that max was not holding 
\begin_inset Formula $Box2$
\end_inset

, because she would be assumed to know that no actions had occurred.
\end_layout

\begin_layout Example
Sam knows Max is holding Box1 after he moves to Room1 and picks it up:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K,obs}\models\mathbf{Knows}(Sam,Holding(Max,Box1),\\
do(\{pickup(Max,Box1)\},do(\{move(Max,Room1)\},S_{0}))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
For Max to put down Box1 without Sam observing anything, he would have to
 first move to a different room.
 Since the action of moving to a different room would be observed by Sam,
 she knows that he must be holding the box.
\end_layout

\begin_layout Standard
TODO: example of using regression
\end_layout

\begin_layout Example
Sam doesn't know that Max is holding Box1 after he moves it to Room2:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K,obs}\models\mathbf{\neg Knows}(Sam,Holding(Max,Box1),\\
do(\{move(Max,Room2)\},do(\{pickup(Max,Box1)\},do(\{move(Max,Room1)\},S_{0})))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Once 
\begin_inset Formula $Max$
\end_inset

 takes Box1 into a different room he may put it down without 
\begin_inset Formula $Sam$
\end_inset

 observing anything, so she can no longer be sure he is holding it.
\end_layout

\begin_layout Subsection
Observing the Effects of Actions
\begin_inset LatexCommand label
name "sub:Observing-Effects"

\end_inset


\end_layout

\begin_layout Standard
In many domains it would be infeasible for an agent to observe a particular
 action occurring, but it may be able to observe some of the effects of
 that action.
 For example, suppose that an agent monitors the state of a light in its
 environment, such that it notices it changing from dark to light.
 While it knows that 
\emph on
some
\emph default
 action must have occurred to produce that effect, it may not be sure precisely
 what action took place (e.g.
 precisely 
\emph on
who
\emph default
 turned on the light).
\end_layout

\begin_layout Standard
This can be modeled by further extending the 
\noun on
Observations
\noun default
 sort.
 Suppose that the observation term 
\begin_inset Formula $f_{\phi}$
\end_inset

 indicates that a particular property of the world 
\begin_inset Formula $\phi$
\end_inset

 has changed from false to true and (for simplicity) that this information
 would be available to all agents.
 The following could be used to include this information in an agent's observati
ons:
\begin_inset Formula \[
f_{\phi}\in obs(agt,c,s)\equiv\neg\phi[s]\wedge\Reg(\phi[do(c,s)])\]

\end_inset

 
\end_layout

\begin_layout Standard
Note that since 
\begin_inset Formula $obs()$
\end_inset

 is an action description predicate, we must use regression to ensure that
 the right-hand side of this equivalence refers only to 
\begin_inset Formula $s$
\end_inset

.
 Expanding on the example of the light, we might have an axiom like this:
\begin_inset Formula \[
lightCameOn\in obs(agt,c,s)\equiv\neg lightIsOn(s)\wedge\exists agt_{2}:\, turnLightOn(agt_{2})\in c\]

\end_inset


\end_layout

\begin_layout Standard
When the light is switched on, each agent's observation set will contain
 the term 
\begin_inset Formula $lightCameOn$
\end_inset

, and they will know that this change has occurred without necessarily knowing
 the specific action responsible for the change.
 That this powerful new ability is a straightforward extension of our approach
 highlights the flexibility and robustness of the observation-based semantics.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
powerul account of knowledge, subsumes existing appraoches, blah blah blah
\end_layout

\begin_layout Section
Complex Epistemic Modalities
\begin_inset LatexCommand label
name "sec:Complex-Epistemic-Modalities"

\end_inset


\end_layout

\begin_layout Standard
So far we have constructed a powerful new account of 
\emph on
individual 
\emph default
knowledge in a multi-agent setting.
 For rich multi-agent domains, we must also be able to reason about group-level
 knowledge and, in particular, about common knowledge.
 The primary motivation for this section is a formal treatment of common
 knowledge within our framework, but as we shall see, this requires significant
 technical machinery capable of handling much more general epistemic modalities.
\end_layout

\begin_layout Subsection
Group-Level Epistemic Modalities
\end_layout

\begin_layout Standard
We breifly review the various group-level epistemic modalities commonly
 found in the literature; an excellent overview and discussion can be found
 in the work of 
\begin_inset LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

.
 Let 
\begin_inset Formula $G$
\end_inset

 be a finite group of agents.
 The basic group-level modality is 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

, which is defined as:
\begin_inset Formula \[
\mathbf{EKnows}(G,\phi,s)\,\isdef\,\bigwedge_{agt\in G}\,\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
To assert more complete knowledge by members of the group, one can say 
\begin_inset Quotes eld
\end_inset

everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 by nesting 
\begin_inset Formula $\mathbf{EKnows}$
\end_inset

 operators.
 In general:
\begin_inset Formula \begin{gather*}
\mathbf{EKnows}^{1}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\phi,s)\\
\mathbf{EKnows}^{n}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\mathbf{EKnows}^{n-1}(G,\phi),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The higher the value of 
\begin_inset Formula $n$
\end_inset

, the stronger an assertion is made about the knowledge of the group.
 The strongest group-level modality is 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Intuitively this indicates that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, and so on ad infinitum.
 Formally, it can be defined as the infinite conjunction:
\begin_inset Formula \[
\mathbf{CKnows}(G,\phi,s)\,\isdef\,\bigwedge_{n\in\mathbb{N}}\mathbf{EKnows}^{n}(G,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Equivalently, it can be defined as a fixpoint or transitive closure of the
 
\begin_inset Formula $\EKnows$
\end_inset

 relation.
 Common knowledge is an extremely powerful form of knowledge that has deep
 implications for coordinated group behavior 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
 For example, in the famous 
\begin_inset Quotes eld
\end_inset

Coordinated Attack
\begin_inset Quotes erd
\end_inset

 problem, the proof that the generals cannot coordinate an attack depends
 heavily on their inability to obtain common knowledge.
\end_layout

\begin_layout Subsection
The Trouble with Common Knowledge
\end_layout

\begin_layout Standard
We are aware of no formal treatments of common knowledge in the situation
 calculus literature, let alone in domains as rich as those we consider
 here.
 This can be attributed to the difficulty of reasoning about common knowledge
 using techniques such as regression.
\end_layout

\begin_layout Standard
In the related field of dynamic epistemic logic, a famous result of 
\begin_inset LatexCommand cite
key "baltag98pa_ck"

\end_inset

 states that:
\end_layout

\begin_layout Quote
Epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone.
\end_layout

\begin_layout Standard
In our terminology: unlike the case of individual knowledge, 
\begin_inset Formula $\Reg(\CKnows(G,\phi,do(c,s)))$
\end_inset

 cannot be expressed in terms of 
\begin_inset Formula $\CKnows(G,\varphi,s)$
\end_inset

.
 Given the deep similarities between the situation caluclus and epistemic
 modal logic 
\begin_inset LatexCommand citep
key "vanbentham07ml_sitcalc"

\end_inset

, we can be confident that this expressivity limitation also holds in the
 situation calculus.
 Rather than trying to prove the validity of this limitation in our framework,
 we proceed directly with a technique for circumventing it.
\end_layout

\begin_layout Standard
One alternative technique for reasoning about common knowledge would be
 to calculate it directly as a fixpoint of 
\begin_inset Formula $\EKnows$
\end_inset

.
 This process would be immensely computationally expensive, and in complex
 domains would be unlikely to finitely terminate.
 Effective reasoning requires a regression rule.
\end_layout

\begin_layout Standard
Fortunately, recent work by 
\begin_inset LatexCommand citet
key "vanBenthem06lcc"

\end_inset

 has shown that a regression rule can be formulated by increasing the expressive
 power of the epistemic language in use.
 Their basic idea is to use dynamic logic as a more expressive epistemic
 path language.
 During regression, the effects of an action are encoded inside the epistemic
 path expression as well as in the formulae under consideration.
\end_layout

\begin_layout Standard
After introducing these ideas in their original context, we will adapt and
 expand them for use within our framework.
\end_layout

\begin_layout Subsection
The Logic of Communication and Change
\end_layout

\begin_layout Standard
This section is a brief overview of the Logic of Communication and Change
 (hereafter denoted 
\begin_inset Quotes eld
\end_inset

LCC
\begin_inset Quotes erd
\end_inset

) developed by 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

, designed to introduce their ideas and contributions to the field.
 The paper on this logic is quite accessible and should be consulted for
 full details.
 We assume some familiarity with the syntax and semantics of modal logic.
\end_layout

\begin_layout Standard
In traditional modal logics of knowledge, there is one accessibility relation
 
\begin_inset Formula $K_{agt}$
\end_inset

 for each agent.
 Knowledge is expressed using the modal box operator, as in 
\begin_inset Formula $[K_{agt}]\phi$
\end_inset

.
 Common knowledge is handled by introducing additional modalities 
\begin_inset Formula $[C_{G}]\phi$
\end_inset

 and semantically defining the 
\begin_inset Formula $C_{G}$
\end_inset

 relation as the transitive closure of the inidivual agents' knowledge relations.
 As discussed above, such logics do not permit a regression rule for reasoning
 about common knowledge.
\end_layout

\begin_layout Standard
The first major contribution of LCC is to increase the expressiveness of
 the epistemic language by allowing complex 
\emph on
path expressions
\emph default
 in place of these basic knowledge operators.
 Conceptually, knowledge is expressed by propositional dynamic logic interpreted
 over an epistemic frame.
 An epistemic path expression 
\begin_inset Formula $\pi$
\end_inset

 takes the form:
\begin_inset Formula \begin{gather*}
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset LatexCommand ref
reference "tbl:knowledge-exprs"

\end_inset

 shows some standard knowledge expressions with their syntax in the situation
 calculus, traditional epistemic logic, and LCC.
 Here we see the first advantage of the new approach - there is no need
 for a special-purpose common knowledge operator.
 It is directly expressed as the transitive closure of 
\begin_inset Formula $\EKnows$
\end_inset

 using the iteration operator of propositional dynamic logic.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Situation Calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Epistemic Logic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
LCC
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\Knows(agt,\phi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[K_{agt}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[agt]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\Knows(agt_{1},\Knows(agt_{2},\phi))$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[K_{agt_{1}}][K_{agt_{2}}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[agt_{1};agt_{2}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $\Knows(agt_{1},\phi)\wedge\Knows(agt_{2},\phi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[K_{agt_{1}}]\phi\wedge[K_{agt_{2}}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[agt_{1}\cup agt_{2}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\EKnows(G,\phi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[E_{G}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[\bigcup_{agt\in G}agt]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\CKnows(G,\phi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[C_{G}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[(\bigcup_{agt\in G}agt)^{*}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tbl:knowledge-exprs"

\end_inset

Some knowledge expressions in the Situation Calculus, Epistemic Logic, and
 LCC
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Actions in LCC are represented using 
\emph on
update frames
\emph default
.
 These are finite directed graphs (more specifically, Kripke-style modal
 frames) where nodes are labelled from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $n-1$
\end_inset

 and represent possible actions that were performed, and the relations between
 nodes represent epistemic uncertainty about precisely which action was
 performed.
 To express what holds after the ocurrence of an action, one specifies an
 update frame along with the specific action from that frame that actually
 occurred.
 The following formula says 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds after performing action 
\begin_inset Formula $i$
\end_inset

 from update frame 
\begin_inset Formula $\mathrm{U}$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula \[
[\mathrm{U},i]\phi\]

\end_inset


\end_layout

\begin_layout Standard
The semantics of actions are defined in terms of a product update operation
 on the underlying modal frame.
 Briefly, we can think of the state of the world before an action as being
 represented by an epistemic frame 
\begin_inset Formula $\mathcal{M}$
\end_inset

 of modal logic .
 The action 
\begin_inset Formula $[U,i]$
\end_inset

 generates a new epistemic frame representing the state of the world after
 the action.
 The individual worlds in this new frame are the pairs 
\begin_inset Formula $\{(w,j)\,|\, w\in\mathcal{M},j\in\mathrm{U}\}$
\end_inset

, and the relations between these worlds are based on the corresponding
 relations in 
\begin_inset Formula $\mathcal{M}$
\end_inset

 and 
\begin_inset Formula $\mathrm{U}$
\end_inset

.
 The enclosed formula 
\begin_inset Formula $\phi$
\end_inset

 is then interpreted on this updated frame.
\end_layout

\begin_layout Standard
The second major contribution of LCC is a regression rule for handling formulae
 of the following general form:
\begin_inset Formula \[
[\mathrm{U},i][\pi]\phi\]

\end_inset


\end_layout

\begin_layout Standard
Such a formula reads: 
\begin_inset Quotes eld
\end_inset

after performing action 
\begin_inset Formula $i$
\end_inset

 from update frame 
\begin_inset Formula $\mathrm{U}$
\end_inset

, it is 
\begin_inset Formula $\pi$
\end_inset

-known that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 As a more concrete example, the following formula states that 
\begin_inset Quotes eld
\end_inset

after performing action 
\begin_inset Formula $i$
\end_inset

 from update frame 
\begin_inset Formula $\mathrm{U}$
\end_inset

, it is common knowledge among 
\begin_inset Formula $G$
\end_inset

 that 
\begin_inset Formula $\phi$
\end_inset

 holds
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula \[
[\mathrm{U},i][(\bigcup_{agt\in G}agt)^{*}]\phi\]

\end_inset

 Their regression technique works by encoding the effects of the action
 
\begin_inset Formula $[\mathrm{U},i]$
\end_inset

 into both the formula 
\begin_inset Formula $\phi$
\end_inset

 and the epistemic path 
\begin_inset Formula $\pi$
\end_inset

.
 A syntactic transformation 
\begin_inset Formula $\mathcal{T}$
\end_inset

 achieves this according to the following equivalence: 
\begin_inset Formula \[
[\mathrm{U},i][\pi]\phi\,\,\,\equiv\,\,\,\bigwedge_{j=0}^{n-1}[\mathbf{\mathcal{T}}_{ij}^{\mathrm{U}}(\pi)][\mathrm{U},j]\phi\]

\end_inset


\end_layout

\begin_layout Standard
Loosly, this formula says: consider every possible action 
\begin_inset Formula $j=0$
\end_inset

 to 
\begin_inset Formula $j=n-1$
\end_inset

; determine the epistemic paths before the action that would cause action
 
\begin_inset Formula $i$
\end_inset

 to be mistaken for action 
\begin_inset Formula $j$
\end_inset

; and determine the effects of 
\begin_inset Formula $j$
\end_inset

 on the formula in question.
\end_layout

\begin_layout Standard
To understand the operation of 
\begin_inset Formula $\Trn_{ij}^{\mathrm{U}}$
\end_inset

, we reason as follows: suppose that the epistemic frame before the action
 is 
\begin_inset Formula $\mathcal{M}$
\end_inset

 with current world 
\begin_inset Formula $w$
\end_inset

, then the frame after performing action 
\begin_inset Formula $[\mathrm{U},i]$
\end_inset

 is 
\begin_inset Formula $\mathcal{M}'$
\end_inset

 with current world 
\begin_inset Formula $(w,i)$
\end_inset

.
 Further suppose that another world 
\begin_inset Formula $(u,j)\in\mathcal{M}'$
\end_inset

 is reachable from 
\begin_inset Formula $(w,i)$
\end_inset

 by following the path 
\begin_inset Formula $\pi$
\end_inset

.
 Such worlds are precisely those picked out by the modal box 
\begin_inset Formula $[\pi]$
\end_inset

.
 Clearly the corresponding parent world 
\begin_inset Formula $u\in\mathcal{M}$
\end_inset

 must be related to 
\begin_inset Formula $w$
\end_inset

 in some way.
 The translation function gives us a path corresponding to this relationship,
 allowing us to locate such worlds: 
\begin_inset Formula $\mathcal{M}'\models((w,i),(u,j))\in\pi$
\end_inset

 if and only if 
\begin_inset Formula $\mathcal{M}\models(w,u)\in\Trn_{ij}^{\mathrm{U}}(\pi)$
\end_inset

.
\end_layout

\begin_layout Standard
The (partial) definition of the translation function is as follows:
\begin_inset Formula \begin{alignat*}{1}
\mathcal{T}_{ij}^{\mathrm{U}}(agt)= & \begin{cases}
?pre(i);agt & \mathrm{if\, i\stackrel{\tiny agt}{\rightsquigarrow}j}\\
?\bot & otherwise\end{cases}\\
\mathcal{T}_{ij}^{\mathrm{U}}(\pi_{1};\pi_{2})= & \bigcup_{k=0}^{n-1}\left(\mathcal{T}_{ik}^{\mathrm{U}}(\pi_{1});\mathcal{T}_{kj}^{\mathrm{U}}(\pi_{2})\right)\\
\mathcal{T}_{ij}^{\mathrm{U}}(\pi^{*})= & \mathcal{K}_{ijn}^{\mathrm{U}}(\pi)\end{alignat*}

\end_inset


\end_layout

\begin_layout Standard
Most of the cases are straightforward encodings of the semantics of product
 update.
 The only difficult case is the iteration operator 
\begin_inset Formula $\pi*$
\end_inset

 - it is handled using a variant of Kleene's theorem on finite automata
 to finitely express the transitive closure of the expressions produced
 by 
\begin_inset Formula $\Trn_{ij}^{\mathrm{U}}(\pi)$
\end_inset

.
 Reproducing the definition of 
\begin_inset Formula $\Kln$
\end_inset

 here would take us too far afield.
\end_layout

\begin_layout Standard
In summary, LCC handles the regression of common knowledge using two key
 ideas: use dynamic logic to express epistmic paths, and use regression
 to encode the effects of actions inside these paths.
\end_layout

\begin_layout Subsection
From LCC to the Situation Calculus
\end_layout

\begin_layout Standard
In the remainder of this section, we adapt the techniques introduced in
 LCC to handle complex epistemic modalities in our formalism in the situation
 calculus.
 This is far from straightforward, as LCC domains have two restrictions
 which are entirely inappropriate for the situation calculus:
\end_layout

\begin_layout Itemize
LCC is 
\emph on
propositional
\emph default
: actions do not take arguments, there are finitely many actions, and no
 quantification is required.
\end_layout

\begin_layout Itemize
LCC is funamentally 
\emph on
synchronous
\emph default
:
\emph on
 
\emph default
reasoning is performed by regressing one action at a time, without the 
\begin_inset Quotes eld
\end_inset

all possible futures
\begin_inset Quotes erd
\end_inset

 approach needed to handle hidden actions.
\end_layout

\begin_layout Standard
We also gain some simplifications in moving to the situation calculus.
 We have no need for explicit update frames, as the epistemic relationships
 between actions are given implicitly by means of the 
\begin_inset Formula $obs$
\end_inset

 function.
 In moving to a first-order formalism, we also gain the expressivity needed
 to directly express the regression of 
\begin_inset Formula $\pi^{*}$
\end_inset

 paths without having to employ a Kleene-style argument, which would require
 us to finitely enumerate all the possible actions.
\end_layout

\begin_layout Standard
The section proceeds as follows.
 In Subsection 
\begin_inset LatexCommand ref
reference "sub:Epistemic-Paths"

\end_inset

 we define a variant of first-order dynamic logic for use as an epistemic
 path language, and show how to encode it in the situation calculus via
 macro expansion.
 Subsection 
\begin_inset LatexCommand ref
reference "sub:Synchronous-Epistemic-Fluent"

\end_inset

 develops a synchronous account of knowledge, assuming that there are no
 hidden actions.
 We develop regression rules for this version and prove that they respect
 the semantics of the epistemic path language.
 Subsection 
\begin_inset LatexCommand ref
reference "sub:Introducing-Hidden-Actions"

\end_inset

 introduces hidden actions by explicitly representing them using the empty
 action set, and shows how a fixpoint construction can reason about arbitrarily-
long sequences of hidden actions.
 We then relate our construction back to the results of Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 by showing that in the case of a single agent, this fixpoint construction
 precisely matches that produced by the persistence condition in equation
 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

.
 
\end_layout

\begin_layout Standard
To begin, we extend the notation of Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 and let 
\begin_inset Formula $K_{0}(agt,s'',s)$
\end_inset

 denote the 
\emph on
synchronous
\emph default
 knowledge of an agent in situation 
\begin_inset Formula $s$
\end_inset

.
 This is knowledge when the agent knows how many actions have been performed,
 and so is not required to do any 
\begin_inset Quotes eld
\end_inset

all possible futures
\begin_inset Quotes erd
\end_inset

 style reasoning.
 Given synchronicity, the successor state axiom for this fluent is straightforwa
rd:
\begin_inset Formula \begin{align}
K_{0}(agt,s'',do(c,s))\,\equiv\,\, & \exists s',c':\,\left(s''=do(c',s')\wedge Poss(c',s')\,\,\vee\,\, s''=s'\wedge c'=\{\}\right)\nonumber \\
 & \,\,\,\,\,\wedge obs(agt,c,s)=obs(agt,c',s')\wedge K_{0}(agt,s',s)\label{eq:K0_ssa}\end{align}

\end_inset


\end_layout

\begin_layout Standard
The only complication here is handling the empty action 
\begin_inset Formula $\{\}$
\end_inset

.
 When 
\series bold

\begin_inset Formula $obs(agt,c,s)=\{\}$
\end_inset


\series default
 then 
\begin_inset Formula $c'$
\end_inset

 is allowed to be 
\begin_inset Formula $\{\}$
\end_inset

, and the agent considers it possible that no action was performed (i.e.
 
\begin_inset Formula $s''=s'$
\end_inset

).
 Suppose that 
\begin_inset Formula $s$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 action occurrences, then under this formulation the agent considers it
 possible that 
\emph on
at most 
\emph default

\begin_inset Formula $n$
\end_inset

 actions have occurred.
 
\end_layout

\begin_layout Subsection
Epistemic Paths
\begin_inset LatexCommand label
name "sub:Epistemic-Paths"

\end_inset


\end_layout

\begin_layout Standard
Unlike the work of 
\begin_inset LatexCommand citet
key "vanBenthem06lcc"

\end_inset

, we cannot use propositional dynamic logic as an epistemic path language.
 While we have limited ourselves to finitely many primitive action types,
 our use of concurrent actions means there are potentially infinitely many
 different ways in which the world could change.
 Our action types also take arguments.
 To handle these richer domains we need some form of quantification in our
 epistemic path language - in short, we need 
\emph on
first-order dynamic logic
\emph default
.
 The variant we use is based on the dynamic term-modal logic of 
\begin_inset LatexCommand citet
key "kooi07dyn_termmodal_logic"

\end_inset

, with some simplifications.
\end_layout

\begin_layout Standard
First, we must specify the syntax of our epistemic path language.
 We will use 
\begin_inset Formula $\pi$
\end_inset

 to denote an arbitrary epistemic path expression.
 
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path Let 
\begin_inset Formula $agt$
\end_inset

 be an 
\noun on
Agent 
\noun default
term, 
\begin_inset Formula $\phi$
\end_inset

 a uniform formula, 
\begin_inset Formula $x$
\end_inset

 a variable and 
\begin_inset Formula $t$
\end_inset

 a term, then the epistemic path terms 
\begin_inset Formula $\pi$
\end_inset

 are the smallest set matching the following structural rules:
\begin_inset Formula \[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end_inset


\end_layout

\begin_layout Standard
The test (
\begin_inset Formula $?$
\end_inset

), sequence (
\begin_inset Formula $;$
\end_inset

), choice (
\begin_inset Formula $\cup$
\end_inset

) and transitive closure (
\begin_inset Formula $^{*}$
\end_inset

) operators are standard in dynamic logic and have the same meaning as in
 LCC, except that test formulae can now contain variables that need to be
 interpreted.
 The additional operator 
\begin_inset Formula $\exists x$
\end_inset

 allows the value of a variable to change during path traversal, by non-determin
istically re-binding 
\begin_inset Formula $x$
\end_inset

 to some value.
 To set the variable to a specific value 
\begin_inset Formula $t$
\end_inset

, this re-binding can be immediately followed by a test for that value:
 
\begin_inset Formula $\exists x\,;\,?x=t$
\end_inset

.
\end_layout

\begin_layout Standard
In the tradition of the individual-knowledge operator 
\begin_inset Formula $\Knows$
\end_inset

, as well as the programming language Golog 
\begin_inset LatexCommand citet
key "levesque97golog"

\end_inset

 built on the sitation calculus, we develop our epistemic path language
 entirely at the meta-level as a series of macro expansions.
 The full details of this development can be found in Appendix 
\begin_inset LatexCommand ref
reference "sec:Encoding-Dynamic-Logic"

\end_inset

, and would complicate the presentation here.
 Instead, we give a simplified presentation of the semantics of each operator.
\end_layout

\begin_layout Standard
Formulae of first-order dynamic logic are interpreted relative to both a
 
\begin_inset Quotes eld
\end_inset

current world
\begin_inset Quotes erd
\end_inset

 and a 
\begin_inset Quotes eld
\end_inset

current substitution
\begin_inset Quotes erd
\end_inset

 
\begin_inset LatexCommand citep
key "kooi07dyn_termmodal_logic"

\end_inset

.
 We will use 
\begin_inset Formula $\mu$
\end_inset

 to represent a standard first-order substitution, with 
\begin_inset Formula $\mu^{\epsilon}$
\end_inset

 being the empty substituion.
 Below we present a transition-style semantics over pairs 
\begin_inset Formula $(\mu,s)$
\end_inset

.
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path\InsetSpace ~
Semantics A situation 
\begin_inset Formula $s'$
\end_inset

 is reachable from situation 
\begin_inset Formula $s$
\end_inset

 via epistemic path 
\begin_inset Formula $\pi$
\end_inset

, denoted 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

, according to the following definitions.
 These semantics are encoded using macro expansion as detailed in Appendix
 
\begin_inset LatexCommand ref
reference "sec:Encoding-Dynamic-Logic"

\end_inset

.
 
\begin_inset Formula \[
\KDo(\pi,s,s')\,\,\equiv\,\,\exists\mu'\,\KTrans(\pi,\mu^{\epsilon},s,\mu',s')\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather*}
\KTrans(agt,\mu'',s'',\mu,s)\,\equiv\,\mu''=\mu\,\wedge\, K_{0}(agt,s'',s)\\
\KTrans(?\phi,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu\,\wedge\,\mu(\phi)[s]\\
\KTrans(\pi_{1};\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\exists\mu',s':\,\KTrans(\pi_{1},\mu',s',\mu,s)\,\wedge\,\KTrans(\pi_{2},\mu'',s'',\mu',s')\\
\KTrans(\pi_{1}\cup\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\KTrans(\pi_{1},\mu'',s'',\mu,s)\,\vee\,\KTrans(\pi_{2},\mu'',s'',\mu,s)\\
\KTrans(x:=t,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu[x/t]\\
\KTrans(\exists x,\mu'',s'',\mu,s)\,\equiv\,\exists z:\, s''=s\,\wedge\,\mu''=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu'',s'',\mu,s)\rightarrow\KTrans(\pi^{*},\mu'',s'',\mu,s)\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Where we use the following abbreviations (standing for 
\begin_inset Quotes eld
\end_inset

reflexive
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

transitive
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

contains
\begin_inset Quotes erd
\end_inset

 respectively) to define 
\begin_inset Formula $\pi*$
\end_inset

 as the reflexive transitive closure of 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{align*}
\mathbf{refl}\isdef & \,\, P(\mu,s,\mu,s)\\
\mathbf{tran\isdef} & \,\,\forall\mu_{1},s_{1},\mu_{2},s_{2}:\, P(\mu_{1},s_{1},\mu,s)\wedge\KTrans(\pi,\mu_{2},s_{2},\mu_{1},s_{1})\,\rightarrow\, P(\mu_{2},s_{2},\mu,s)\\
\mathbf{cont}\isdef & \,\,\forall\mu',s':\,\KTrans(\pi,\mu',s',\mu,s)\,\rightarrow\, P(\mu',s',\mu,s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Let us re-iterate: these are 
\emph on
not
\emph default
 axioms to be included in our basic action theory, but are intended only
 to demonstrate the semantics of the epistemic path language.
 Paths 
\begin_inset Formula $\pi$
\end_inset

 do not appear in situation calculus terms, but are handled by macro-expansion
 at the meta-level.
\end_layout

\begin_layout Subsection
A Synchronous Epistemic Fluent
\begin_inset LatexCommand label
name "sub:Synchronous-Epistemic-Fluent"

\end_inset


\end_layout

\begin_layout Standard
At this point it's worth reviewing again the purpose of this path language.
 Despite utilising the syntax of dynamic logic, it is 
\emph on
not
\emph default
 related to actions in any way.
 Rather it expresses complex 
\emph on
epistemic
\emph default
 paths, and is interpreted over the epistemic frame generated by the 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 relations.
 We will be introducing a new macro 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 (to stand for 
\begin_inset Quotes eld
\end_inset

Path-Knows
\begin_inset Quotes erd
\end_inset

) to express knowledge using thse paths.
 To make this clear, here is how some standard kinds of knowledge would
 be expressed using the standard account of knowledge, and how we intend
 to express them using complex epistemic modalities:
\end_layout

\begin_layout Itemize
Individual Knowledge: 
\begin_inset Formula $\Knows(agt,\phi,s)\,\,\,\,\Rightarrow\,\,\,\,\PKnows(agt,\phi,s)$
\end_inset


\end_layout

\begin_layout Itemize
Nested Knowledge: 
\begin_inset Formula $\Knows(agt_{1},\Knows(agt_{2},\phi),s)\,\,\,\,\Rightarrow\,\,\,\,\PKnows(agt_{1};agt_{2},\phi,s)$
\end_inset


\end_layout

\begin_layout Itemize
Joint Knowledge: 
\begin_inset Formula $\Knows(agt_{1},\phi,s)\,\wedge\,\Knows(agt_{2},\phi,s)\,\,\,\,\Rightarrow\,\,\,\,\PKnows((agt_{1}\cup agt_{2}),\phi,s)$
\end_inset


\end_layout

\begin_layout Itemize
Common Knowledge: 
\begin_inset Formula $\CKnows(G,\phi,s)\,\,\,\,\Rightarrow\,\,\,\,\PKnows((\bigcup_{agt\in G}agt)^{*},\phi,s)$
\end_inset


\end_layout

\begin_layout Standard
In this section, we develop a synchronous version 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 of our path-knowledge operator, building on the synchronous 
\begin_inset Formula $K_{0}$
\end_inset

 relation defined earlier.
 Its definition is straightforward:
\begin_inset Formula \[
\PKnowsZ(\pi,\phi,s)\isdef\forall s':\,\KDo(\pi,s,s')\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
But this macro expands to a very complicated second-order formula in the
 base language of the situation calculus.
 As with the case of the base 
\begin_inset Formula $\Knows$
\end_inset

 macro, we need to treat 
\begin_inset Formula $\PKnowsZ$
\end_inset

 syntatcically as a primitive fluent.
 This means we need a regression rule for such expressions.
 It is here that we incorporate the second key idea from LCC - use of a
 syntactic transform to encode the effects of actions within epistemic paths
 as well as in primitive formulae.
 Mirrorring LCC, we introduce the meta-operator 
\begin_inset Formula $\Trn$
\end_inset

 for this purpose.
\end_layout

\begin_layout Standard
Let us consider the required operation of 
\begin_inset Formula $\Trn$
\end_inset

 by analogy to the standard regression operator 
\begin_inset Formula $\Reg$
\end_inset

.
 One can think of regression as a 
\begin_inset Quotes eld
\end_inset

pre-encoding
\begin_inset Quotes erd
\end_inset

 of the effects of an action: 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\begin_inset Formula $do(c,s)$
\end_inset

 if and only if 
\begin_inset Formula $\Reg(\phi,c)$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

.
 The path regressor 
\begin_inset Formula $\Trn$
\end_inset

 needs to lift this idea to epistemic paths as follows: there is a 
\begin_inset Formula $\pi$
\end_inset

-path from 
\begin_inset Formula $do(c,s)$
\end_inset

 to 
\begin_inset Formula $do(c',s')$
\end_inset

 if and only if there is a 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

-path from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
\end_layout

\begin_layout Standard
In order to accomplish this task of pre-encoding the effects of actions,
 the path regressor will need to make various assertions about the action
 that is to be performed in each situation traversed by the path.
 In LCC this 
\begin_inset Quotes eld
\end_inset

current action
\begin_inset Quotes erd
\end_inset

 was handled at the meta-level by enumerating each potential action in turn,
 since propositional dynamic logic has no way to express stateful information.
 By moving to first-order dynamic logic, we can use a variable for this
 purpose.
 As well as making the presentation more concise, we avoid the need to resort
 to a Kleene-style argument for handling the iteration operator.
 The basic operation of 
\begin_inset Formula $\Trn$
\end_inset

 will be:
\end_layout

\begin_layout Itemize
introduce a fresh variable 
\begin_inset Formula $x$
\end_inset

 to hold the action that will be performed in the current situation
\end_layout

\begin_layout Itemize
at the beginning of the path, bind 
\begin_inset Formula $x$
\end_inset

 to the known action 
\begin_inset Formula $c$
\end_inset


\end_layout

\begin_layout Itemize
at the end of the path, assert that 
\begin_inset Formula $x$
\end_inset

 is the known action 
\begin_inset Formula $c'$
\end_inset

 
\end_layout

\begin_layout Itemize
whenever the path traverses to a new situation, use 
\begin_inset Formula $\exists x$
\end_inset

 to select a new action to be performed there
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path\InsetSpace ~
Regressor
\begin_inset LatexCommand label
name "def:EpistemicPathRegression"

\end_inset

 The epistemic path regressor 
\begin_inset Formula $\Trn$
\end_inset

 operates according to the definitions below, where 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are fresh variables not appearing in 
\begin_inset Formula $\pi$
\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{align*}
\Trn(\pi,c,c')\,\isdef\,\, & x:=c\,;\,\TrnA(\pi,x)\,;\,?x=c'\\
\\\TrnA(agt,x)\,\isdef\,\, & \exists z\,;\,?obs(agt,x)=z\,;\, agt\,;\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,?obs(agt,x)=z\\
\TrnA(?\phi,x)\isdef\,\, & \Reg(\phi,x)\\
\TrnA(\exists y,x)\isdef\,\, & \exists y\\
\begin{array}{c}
\TrnA(\pi_{1};\pi_{2},x)\isdef\,\,\end{array} & \TrnA(\pi_{1},x)\,;\,\TrnA(\pi_{2},x)\\
\TrnA(\pi_{1}\cup\pi_{2},x)\isdef\,\, & \TrnA(\pi_{1},x)\cup\TrnA(\pi_{2},x)\\
\TrnA(\pi^{*},x)\isdef\,\, & \TrnA(\pi,x)^{*}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The following theorem states that these definitions behave has desired,
 respecting the semantics of the epistemic paths:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Trn-respects-epi-paths"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\models\,\KDo(\pi,s'',do(c,s))\,\equiv\,\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c=\{\}\right)\wedge\KDo(\Trn(\pi,c,c'),s',s)\end{gather*}

\end_inset


\end_layout

\begin_layout ProofSketch
The proof proceeds by cases, covering each path operator in turn.
 In the case of an individual agent the theorem is a direct consequence
 of equation 
\begin_inset LatexCommand eqref
reference "eq:K0_ssa"

\end_inset

.
 The other operators are straightforward using the semantics specified in
 
\begin_inset Formula $\KTrans$
\end_inset

.
\end_layout

\begin_layout Standard
Given that 
\begin_inset Formula $\Trn$
\end_inset

 respects the semantics of our epistemic path language, we are free to use
 it to define the regression of a complex epistemic modality:
\begin_inset Formula \[
\Reg(\PKnowsZ(\pi,\phi,do(c,s)))\isdef\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\]

\end_inset


\end_layout

\begin_layout Theorem
For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action 
\begin_inset Formula $a$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\cup\Dt_{P0}\,\models\,\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
TODO, by expanding macros and re-collecting, as before
\end_layout

\begin_layout Subsection
Introducing Hidden Actions
\begin_inset LatexCommand label
name "sub:Introducing-Hidden-Actions"

\end_inset


\end_layout

\begin_layout Standard
We now have a powerful account of multi-agent knowledge for synchronous
 domains, but it remains to combine this with our handling of arbitrarily-long
 sequences of hidden actions.
 We develop support for hidden actions entirely at the meta-level, defining
 it directly in the operation of the regression operator.
\end_layout

\begin_layout Standard
The idea is to use the empty action term 
\begin_inset Formula $\{\}$
\end_inset

 to explicitly represent the notion that 
\begin_inset Quotes eld
\end_inset

nothing happens
\begin_inset Quotes erd
\end_inset

.
 We simulate agents reasoning about hypothetical futures in which they make
 no more observations by inserting these empty actions onto the head of
 a situation term.
\end_layout

\begin_layout Definition
Define 
\begin_inset Formula $\mathcal{E}^{n}(s)$
\end_inset

 to be 
\begin_inset Formula $s$
\end_inset

 followed by 
\begin_inset Formula $n$
\end_inset

 empty actions, as follows:
\begin_inset Formula \begin{align*}
\mathcal{E}^{0}(s)\,\isdef\, & s\\
\mathcal{E}^{1}(s)\,\isdef\, & do(\{\},s)\\
\mathcal{E}^{n}(s)\,\isdef\, & \mathcal{E}^{1}(\mathcal{E}^{n-1}(s))=do(\{\},do(\{\},...,do(\{\},s)))\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The intuition here is that we want 
\begin_inset Formula $\PKnows(\pi,\phi)$
\end_inset

 to hold if 
\begin_inset Formula $\PKnowsZ(\pi,\phi)$
\end_inset

 holds after allowing for any number of empty actions.
 Formally, we want to use the following infinite conjunction as the definition
 of 
\begin_inset Formula $\PKnows(\pi,\phi,do(c,s))$
\end_inset

:
\begin_inset Formula \[
\PKnows(\pi,\phi,do(c,s))\isdef\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(do(c,s)))\]

\end_inset


\end_layout

\begin_layout Standard
This section is devoted to establishing the validity of this defnition.
\end_layout

\begin_layout Lemma
For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

: 
\begin_inset Formula \[
\Dt\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\PKnowsZ(\pi,\phi,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
By a case analysis on the definition of 
\begin_inset Formula $\Trn$
\end_inset

, we determine that that path 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 always contains the path 
\begin_inset Formula $\pi$
\end_inset

.
 Thus any situations reachable by 
\begin_inset Formula $\pi$
\end_inset

 are also reachable by 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

.
 Since 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 is always part of the regression of 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 and 
\begin_inset Formula $\Reg(\phi,\{\})=\phi$
\end_inset

 always, we conclude that 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 implies 
\begin_inset Formula $\PKnowsZ(\Trn(\pi,\{\},\{\}),\phi,s)$
\end_inset

, which implies 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 as required.
\end_layout

\begin_layout Lemma
For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, if there is some 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

 such that:
\begin_inset Formula \[
\Dt\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{n+1}(s))\]

\end_inset


\end_layout

\begin_layout Standard
Then:
\begin_inset Formula \[
\Dt\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\,\equiv\,\bigwedge_{m\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))\]

\end_inset


\end_layout

\begin_layout Proof
By the previous lemma, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n+1}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))$
\end_inset

 always.
 So for this hypothesised value of 
\begin_inset Formula $n$
\end_inset

, the implication in the current lemma is in fact an equivalence.
 We then have 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m<n$
\end_inset

, and 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\equiv\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m\geq n$
\end_inset

, which is enough to establish the infinite conjunction as required.
\end_layout

\begin_layout Standard
We can thus use the following regression definition, knowing that the infinite
 conjunction can be computed using a fixpoint calculation:
\begin_inset Formula \[
\Reg(\PKnows(\pi,\phi,do(c,s)))\,\isdef\,\Reg(\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(do(c,s))))\]

\end_inset


\end_layout

\begin_layout Standard
To make it clear that a fixpoint calculation is taking place, we introduce
 the following notation:
\begin_inset Formula \[
\Reg(\PKnows(\pi,\phi,do(c,s)))\,\isdef\,\Reg(\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(do(c,s))))\]

\end_inset


\end_layout

\begin_layout Subsection
The Link with Individual Knowledge
\end_layout

\begin_layout Standard
The last remaining link is perhaps most important of all: showing that this
 new account of knowledge actually captures the knowledge of the agents,
 according to the semantics of individual knowledge developed in Section
 
\begin_inset LatexCommand eqref
reference "sec:Obs-Knowledge"

\end_inset

.
 The following theorem establishes this important link, stating that the
 individual knowledge of an agent is the same when using complex epistemic
 modalities as when using ordinary knowledge:
\end_layout

\begin_layout Theorem
For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Theorem
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Theorem
if and only if
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\PKnows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Proof
Begin by considering the sequence of calculations made in regressing 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(s))$
\end_inset

.
 First, we perform some simplification on 
\begin_inset Formula $\Trn$
\end_inset

:
\begin_inset Formula \begin{align*}
\Trn(agt,\{\},c')=\,\,\, & x:=\{\}\,;\,\exists z\,;\,?obs(agt,x)=z\,;\, agt\,;\\
 & \,\,\,\,\,\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,\,?obs(agt,x_{a})=z\,;\, x:=c'\\
=\,\,\, & \exists z\,;\,?obs(agt,\{\})=z\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?obs(agt,c')=z\\
=\,\,\, & agt\,;\,?obs(agt,c')=\{\}\wedge\left(Poss(c')\vee c'=\{\}\right)\\
=\,\,\, & agt\,;\,\left(?PbU(agt,c')\,\cup\, c'=\{\}\right)\end{align*}

\end_inset

 Now we can use this in the regression of 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(s))$
\end_inset

, as follows: 
\begin_inset Formula \begin{align*}
\PKnowsZ(agt,\phi,\mathcal{E}^{1}(s))\equiv\,\, & \forall c':\,\PKnowsZ(\Trn(agt,\{\},c'),\Reg(\phi,c'),s)\\
\equiv\,\, & \PKnowsZ(\exists a'\,;\, agt\,;\,\left(?PbU(agt,c')\,\cup\, c'=\{\}\right),\Reg(\phi,c'),s)\\
\equiv\,\, & \dots\\
\equiv\,\, & \PKnowsZ(agt,\Pst^{1}(\phi,PbU(agt)),s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Using the same construction, we can show that in general:
\begin_inset Formula \begin{align*}
\PKnowsZ(agt,\phi,\mathcal{E}^{n}(s))\equiv\,\, & \PKnowsZ(agt,\Pst^{1}(\phi,PbU(agt)),\mathcal{E}^{n-1}(s))\\
\equiv\,\, & \PKnowsZ(agt,\Pst^{n}(\phi,PbU(agt)),s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Clearly the fixpoint calculation used to find an 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(agt,\phi,\mathcal{E}^{n+1}(s))$
\end_inset

 is the same as the fixpoint calculation used to find 
\begin_inset Formula $\Pst(\phi,PbU(agt))$
\end_inset

.
 Therefore, we have:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\PKnows(agt,\phi,do(c,s))\,\equiv\,\PKnowsZ(agt,\Pst(\phi,PbU(agt)),do(c,s))\]

\end_inset


\end_layout

\begin_layout Proof
Regressing the right-hand side:
\begin_inset Formula \begin{align*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\, & \PKnowsZ(\exists a'\,;\,\Trn(agt;?\neg\phi,a,a'),s)\\
\equiv\,\, & \dots\mathrm{rearrange\, and\, simplify}\dots\\
\equiv\,\, & \exists o:\, obs(agt,c,s)=o\wedge\,\\
 & \left[o=\{\}\,\rightarrow\,\PKnows(\exists c';agt,\phi,s)\right]\\
 & \wedge\,\left[o\neq\{\}\,\rightarrow\,\PKnows(\exists c';agt,\forall c':\, obs(agt,c')=o\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\wedge Poss(c')\rightarrow\left.\Reg(\Pst(\phi,PbU(agt)),c'),s)\right]\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Thus the expressions 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 and 
\begin_inset Formula $\PKnows(agt,\phi,s)$
\end_inset

 are equivalent under out formulation.
 This link is all this is required to validate the additional complex modalities
 - for example, to establish that 
\begin_inset Formula $\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)$
\end_inset

 is equivalent to 
\begin_inset Formula $\CKnows(G,\phi,s)$
\end_inset

 we can now argue as follows: 
\begin_inset Formula $\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)$
\end_inset

 is the transitive closure of the union of 
\begin_inset Formula $\PKnows(a,\phi,s)$
\end_inset

 for 
\begin_inset Formula $a\in G$
\end_inset

, while 
\begin_inset Formula $\CKnows(G,\phi,s)$
\end_inset

 is the transitive closure of the union of 
\begin_inset Formula $\Knows(a,\phi,s)$
\end_inset

 for 
\begin_inset Formula $a\in G$
\end_inset

.
 Since 
\begin_inset Formula $\PKnows(a,\phi,s)$
\end_inset

 is the same relation as 
\begin_inset Formula $\Knows(a,\phi,s)$
\end_inset

, it follows that their transitive closures are also the same.
\end_layout

\begin_layout Subsection
An illustrative Example
\end_layout

\begin_layout Standard
With this technical machinery in place, we are now able to reason about
 the group-level epistemic modalities of a team of agents.
 To demonstrate, we revisit our example domain from Subsection 
\begin_inset LatexCommand ref
reference "sub:An-Illustrative-Example"

\end_inset

.
\end_layout

\begin_layout Example
After Max enters Room1, it is common knowledge between Sam and Max that
 Max is not holding Box1:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\PKnows((Sam\cup Max)^{*},\neg Holding(Max,Box1),do(\{move(Max,Room1\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Example
TODO: fill in this example
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
reasoning procedure: undecidable in general case! Need a decidable domian.
 Here are some things we can do to help the situation:
\end_layout

\begin_layout Subsubsection*
Propositionality
\end_layout

\begin_layout Standard
\begin_inset Formula $K_{DL}$
\end_inset

 reduces to the semantics of propositional dynamic logic, which is decidable.
\end_layout

\begin_layout Subsubsection*
Synchronicity
\end_layout

\begin_layout Standard
By equipping agents with a global clock tick, the persistence condition
 is no longer required.
 Since this is the biggest source for computational complexity, that's a
 big win! 
\end_layout

\begin_layout Subsubsection*
Observability
\end_layout

\begin_layout Standard
Ensure that the update frame is weakly connected, so that most 
\begin_inset Formula $\Trn(\pi,a_{i},a_{j})$
\end_inset

 are vacuously false.
\newline

\end_layout

\begin_layout Section
Related Work
\begin_inset LatexCommand label
name "sec:Related-Work"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "morgenstern90knowledge"

\end_inset

 - hidden actions, appeals to motivated action theory.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "delgrande01sitcalc_cleudo"

\end_inset

 - shows that common knowledge is useful, but appeals to a (non-existent)
 solution from elsewhere
\end_layout

\begin_layout Standard
clearly the long lineage of 
\begin_inset LatexCommand cite
key "baltag99epi_act_structures"

\end_inset

, 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

 that have developed the basis of these techniques.
 
\begin_inset LatexCommand cite
key "moss05iter_pal"

\end_inset

 Iterated PAL is undecidable.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "vanBentham06epi_temporal_logic"

\end_inset

 big discussion and comparison on epistemic temporal logics.
 defines notion of 
\begin_inset Quotes eld
\end_inset

synchronised
\begin_inset Quotes erd
\end_inset

 system that we use above.
\end_layout

\begin_layout Standard
An alternate formulation due to 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

 assumes the opposite extreme, that agents are only aware of the actions
 that they themselves perform:
\begin_inset Formula \begin{align}
K(agt,s'',do(a,s))\equiv\,\,\, & \exists s':\, K(agt,s',s)\nonumber \\
 & \wedge\,(actor(a)\neq agt\,\rightarrow\, s'\leq_{actor(a)\neq agt}s''))\label{eq:k_ssa_exo}\\
 & \wedge\,(actor(a)=agt\,\rightarrow\,\exists s^{*}:\,\left[s'\leq_{actor(a)=agt}s^{*}\wedge\right.\nonumber \\
 & \,\,\,\,\,\,\,\,\,\,\,\,\left.s''=do(a,s^{*})\wedge Poss(a,s^{*})\wedge sr(a,s)=sr(a,s^{*}))\right]\nonumber \end{align}

\end_inset

 Here agents consider possible any situation compatible with the actions
 that they themselves have performed.
 There may have been an arbitrary sequence of situations between 
\begin_inset Formula $s'$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

 of which the agent was unaware, because they consisted entirely of exogenous
 actions (that is, actions where 
\begin_inset Formula $actor(a)\neq agt$
\end_inset

).
 Agents are thus totally ignorant of the actions performed by others.
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K,exo}$
\end_inset

 the axioms for the 
\begin_inset Quotes eld
\end_inset

total ignorance
\begin_inset Quotes erd
\end_inset

 account of knowledge due to 
\begin_inset LatexCommand citet
key "Lesperance99sitcalc_approach"

\end_inset

, as detailed in equations (
\begin_inset LatexCommand ref
reference "eq:k_ssa_exo"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

).
\end_layout

\begin_layout Standard
This approach is also limiting, in that agents can 
\emph on
never
\emph default
 be aware of the actions performed by others.
 Consider our example of agents occupying a building who are aware of all
 actions performed in the same room, or even the simple case of an agent
 being aware that another agent has collided with it; full generality requires
 that agents can be aware of 
\emph on
some
\emph default
 of the actions performed by others.
\end_layout

\begin_layout Standard
Furthermore, suppose that 
\begin_inset Formula $agt$
\end_inset

 has just performed action 
\begin_inset Formula $a_{1}$
\end_inset

, so the world is in some situation 
\begin_inset Formula $do(a_{1},s)$
\end_inset

.
 Another agent then performs the action 
\begin_inset Formula $a_{2}$
\end_inset

, leaving the world in situation 
\begin_inset Formula $do(a_{2},do(a_{1},s))$
\end_inset

.
 Since it is not aware of the occurrence of 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $agt$
\end_inset

 cannot be aware that the state of the world has changed.
 Its knowledge should therefore remain unchanged.
 Unfortunately this is not the case under this formulation:
\begin_inset Formula \[
\Dt\cup\Dt_{K,exo}\not\models actor(a_{2})\neq agt\rightarrow K(agt,s',do(a_{2},do(a_{1},s)))\equiv K(agt,s',do(a_{1},s))\]

\end_inset


\end_layout

\begin_layout Standard
To faithfully represent this aspect of knowledge, the successor state axiom
 for 
\begin_inset Formula $K$
\end_inset

 must consider any 
\emph on
future
\emph default
 that can be brought about by exogenous actions, rather than any 
\emph on
past
\emph default
 as done in equation (
\begin_inset LatexCommand ref
reference "eq:k_ssa_exo"

\end_inset

).
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Standard
hooray for us, this is a great paper :-)
\end_layout

\begin_layout Section
\start_of_appendix
Dynamic Logic via Macro Expansion
\begin_inset LatexCommand label
name "sec:Encoding-Dynamic-Logic"

\end_inset


\end_layout

\begin_layout Standard
This appendix develops an encoding of first-order dynamic logic (hereafter
 denoted 
\begin_inset Quotes eld
\end_inset

FODL
\begin_inset Quotes erd
\end_inset

) into the situation calculus via macro expansion.
 Our encoding is based on the techniques developed for the Golog programming
 language 
\begin_inset LatexCommand citep
key "levesque97golog"

\end_inset

, which can also be considered an embedding of dynamic logic into the situation
 calculus.
 Unfortunately Golog cannot be used directly as it does not have stateful
 variables, which we require.
\end_layout

\begin_layout Standard
We review the operators and required semantics of FODL for convenience:
\begin_inset Formula \[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end_inset


\end_layout

\begin_layout DefinitionLbld
\begin_inset Formula \[
\KDo(\pi,s,s')\,\,\equiv\,\,\exists\mu'\,\KTrans(\pi,\mu^{\epsilon},s,\mu',s')\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather*}
\KTrans(agt,\mu'',s'',\mu,s)\,\equiv\,\mu''=\mu\,\wedge\, K_{0}(agt,s'',s)\\
\KTrans(?\phi,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu\,\wedge\,\mu(\phi)[s]\\
\KTrans(\pi_{1};\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\exists\mu',s':\,\KTrans(\pi_{1},\mu',s',\mu,s)\,\wedge\,\KTrans(\pi_{2},\mu'',s'',\mu',s')\\
\KTrans(\pi_{1}\cup\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\KTrans(\pi_{1},\mu'',s'',\mu,s)\,\vee\,\KTrans(\pi_{2},\mu'',s'',\mu,s)\\
\KTrans(x:=t,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu[x/t]\\
\KTrans(\exists x,\mu'',s'',\mu,s)\,\equiv\,\exists z:\, s''=s\,\wedge\,\mu''=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu'',s'',\mu,s)\rightarrow\KTrans(\pi^{*},\mu'',s'',\mu,s)\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Note that the semantics of FODL explicitly use first-order substitutions
 to manage stateful variables.
 In order to simulate this via macro expansion, we use what is essentially
 a continuation-passing transformation to avoid explicitly mentioning substituti
ons.
\end_layout

\begin_layout Standard
First, note that any epistemic path 
\begin_inset Formula $\pi$
\end_inset

 will be contain only a finite number of FODL variables.
 Without loss of generality, suppose that 
\begin_inset Formula $\pi$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 such variables named 
\begin_inset Formula $x_{1}$
\end_inset

 to 
\begin_inset Formula $x_{n}$
\end_inset

.
 The idea is to translate each component of the path into an 
\begin_inset Formula $n$
\end_inset

-ary predicate, where the 
\begin_inset Formula $i$
\end_inset

th argument is used to pass in the current value of 
\begin_inset Formula $x_{i}$
\end_inset

.
 
\end_layout

\begin_layout Section
Complete Proofs
\begin_inset LatexCommand label
name "sec:Complete-Proofs"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, Legal(s)\wedge s\leq_{PbU(agt)}s'\,\rightarrow\, Legal(s')\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, since 
\begin_inset Formula $PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Legal$
\end_inset

 is equivalent to 
\begin_inset Formula $\leq_{Poss}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, s\leq_{PbU(agt)}s'\,\rightarrow\, view(agt,s')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, by induction on the definition of 
\begin_inset Formula $view$
\end_inset

 from equation (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

).
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-root"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, K(agt,s'',s)\,\rightarrow\, K(agt,root(s''),root(s))\]

\end_inset


\end_layout

\begin_layout Proof
Trivial in the base case.
 For the 
\begin_inset Formula $do(a,s)$
\end_inset

 case, suppose that 
\begin_inset Formula $K(agt,s'',do(a,s))$
\end_inset

.
 Then by equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) there is some 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $s'\sqsubseteq s''$
\end_inset

 and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 Then 
\begin_inset Formula $root(s'')$
\end_inset

 = 
\begin_inset Formula $root(s')$
\end_inset

, and 
\begin_inset Formula $K(root(s'),root(s))$
\end_inset

 by the inductive hypothesis.
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, K(agt,s'',s)\,\rightarrow\, Legal(s'')\]

\end_inset


\end_layout

\begin_layout Proof
All 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 are initial and therefore legal.
 So in the base case we have 
\begin_inset Formula $s'\leq_{PbU(agt)}s''$
\end_inset

 by equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

), making 
\begin_inset Formula $s''$
\end_inset

 is legal by lemma 
\begin_inset LatexCommand ref
reference "lem:pbu-implies-legal"

\end_inset

.
 
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(a,s)$
\end_inset

 case, equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) ensures that 
\begin_inset Formula $do(a',s')\leq_{PbU(agt)}s''$
\end_inset

 for some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $a'$
\end_inset

 satisfying 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 and 
\begin_inset Formula $Poss(a',s')$
\end_inset

.
 Since 
\begin_inset Formula $s'$
\end_inset

 is legal by the inductive hypothesis, 
\begin_inset Formula $s''$
\end_inset

 must be legal.
 
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, K(agt,s'',s)\,\rightarrow view(agt,s'')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the base case, there must be an 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $Init(s')$
\end_inset

 and 
\begin_inset Formula $s'\leq_{PbU(agt)}s''$
\end_inset

.
 Therefore 
\begin_inset Formula $view(s'')$
\end_inset

 = 
\begin_inset Formula $view(s')$
\end_inset

 = 
\begin_inset Formula $\epsilon$
\end_inset

 = 
\begin_inset Formula $view(s)$
\end_inset

, as required.
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(a,s)$
\end_inset

 case, suppose 
\begin_inset Formula $obs(agt,a,s)=\{\}$
\end_inset

.
 Then 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

= 
\begin_inset Formula $view(agt,s)$
\end_inset

, while equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) gives us 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

, which yields 
\begin_inset Formula $view(agt,s'')$
\end_inset

 = 
\begin_inset Formula $view(agt,s)$
\end_inset

 by the inductive hypothesis.
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $obs(agt,a,s)\neq\{\}$
\end_inset

, then we have 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $a'$
\end_inset

 such that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $do(a',s')\leq_{PbU(agt)}s''$
\end_inset

, 
\begin_inset Formula $obs(agt,a,s)$
\end_inset

 = 
\begin_inset Formula $obs(agt,a',s')$
\end_inset

, and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 By the inductive hypothesis 
\begin_inset Formula $view(agt,s')=view(agt,s)$
\end_inset

, and we have the following: 
\begin_inset Formula $view(agt,s'')$
\end_inset

 = 
\begin_inset Formula $view(agt,do(a',s'))$
\end_inset

 = 
\begin_inset Formula $obs(agt,a,s)\cdot view(agt,s')$
\end_inset

 = 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

 as required.
 
\end_layout

\begin_layout Standard
Combining these results, we can state the following theorem:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:k_obs_equiv"

\end_inset

 For a basic action theory 
\begin_inset Formula $\Dt_{obs}$
\end_inset

, for any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt_{obs}\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge view(agt,s'')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the 
\series bold
if
\series default
 direction, we simply combine lemmas 
\begin_inset LatexCommand ref
reference "lem:K-implies-root"

\end_inset

, 
\begin_inset LatexCommand ref
reference "lem:K-implies-legal"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "lem:K-implies-view"

\end_inset

.
 
\end_layout

\begin_layout Proof
For the 
\series bold
only-if
\series default
 base case, the 
\begin_inset Formula $\exists s'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) is trivially satisfied by 
\begin_inset Formula $root(s'')$
\end_inset

 and so the equivalence holds.
\end_layout

\begin_layout Proof
For the 
\series bold
only-if
\series default
 inductive case with 
\begin_inset Formula $do(a,s)$
\end_inset

, we have two sub-cases to consider.
 Suppose 
\begin_inset Formula $obs(agt,a,s)=\{\}$
\end_inset

: then 
\begin_inset Formula $view(agt,s'')$
\end_inset

 = 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

 = 
\begin_inset Formula $view(agt,s)$
\end_inset

 and 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 holds by the inductive hypothesis, satisfying the equivalence in equation
 (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

).
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $obs(agt,a,s)\neq\{\}$
\end_inset

: then we have:
\begin_inset Formula \[
view(agt,do(a,s))=obs(agt,a,s)\cdot view(agt,s)=view(agt,s'')\]

\end_inset

For this to be the case, and since 
\begin_inset Formula $s''$
\end_inset

 is legal, there must be some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $a'$
\end_inset

 satisfying 
\begin_inset Formula $obs(agt,a',s')$
\end_inset

 = 
\begin_inset Formula $obs(agt,a,s)$
\end_inset

, 
\begin_inset Formula $view(agt,s')$
\end_inset

 = 
\begin_inset Formula $view(agt,s)$
\end_inset

 and 
\begin_inset Formula $do(a',s')\leq_{PbU(agt)}s''$
\end_inset

 .
 This is enough to satisfy the 
\begin_inset Formula $\exists s',a'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) and so the equivalence holds.
\end_layout

\begin_layout Theorem
Given a basic action theory 
\begin_inset Formula $\Dt\cup\Dt_{K,obs}$
\end_inset

 and a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

, it is always the case that:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\phi[do(a,s)]\equiv\Reg(\phi[do(a,s)])\]

\end_inset

 
\end_layout

\begin_layout Proof
We need only consider applications of 
\begin_inset Formula $\Reg$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 has the form 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

, as other regression clauses have not been modified.
 For clarity we define the abbreviation 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s)$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

persists under equivalent observations
\begin_inset Quotes erd
\end_inset

) which states that 
\begin_inset Formula $\phi$
\end_inset

 holds in all legal futures of 
\begin_inset Formula $s$
\end_inset

 compatible with observations 
\begin_inset Formula $o$
\end_inset

:
\begin_inset Formula \begin{multline*}
\mathbf{PEO}(agt,\phi,o,s)\,\isdef\,\\
\forall a':\, obs(agt,a',s)=o\wedge Poss(a',s)\rightarrow\left[\forall s':\, do(a',s)\leq_{PbU(agt)}s'\rightarrow\,\phi[s']\right]\end{multline*}

\end_inset

 Combining and rearranging equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) with the definition of the 
\begin_inset Formula $\Knows$
\end_inset

 macro we have:
\begin_inset Formula \begin{align*}
\Knows(agt,\phi,do(a,s))\equiv\, & \exists o\,.\, obs(agt,a,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\forall s'\,.\, K(agt,s',s)\rightarrow\phi[s']\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\forall s'\,.\, K(agt,s',s)\rightarrow\mathbf{PEO}(agt,\phi,o,s')\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Proof
Noting that both conjuncts contain sub-formulae matching the form of the
 
\begin_inset Formula $\Knows$
\end_inset

 macro, it can be substituted back in to give:
\begin_inset Formula \begin{align*}
\mathbf{Knows}(agt,\phi,do(a,s))\equiv\, & \exists o\,.\, Observations(agt,c,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\mathbf{Knows}(agt,\mathbf{PEO}(agt,\phi,o,s'),s)\right]\end{align*}

\end_inset

 For 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s')$
\end_inset

 to legitimately appear inside the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro it must be uniform in the situation variable 
\begin_inset Formula $s'$
\end_inset

.
 Applying the persistence condition and regressing to make the expression
 uniform, we develop the following equivalence:
\begin_inset Formula \[
\mathbf{PEO}(agt,\phi,o,s)\equiv\forall a':\, obs(agt,a',s)=o\wedge Poss(a',s)\rightarrow\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt)),a')\]

\end_inset

 Suppressing the situation term in this uniform formula gives equation (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

) as required.
\end_layout

\begin_layout Proof
For 
\begin_inset Formula $S_{0}$
\end_inset

, a straightforward transformation of equations (
\begin_inset LatexCommand ref
reference "eqn:knows_def"

\end_inset

) and (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) gives:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\left[\forall s'\,.\, s\leq_{PbU(agt)}s'\rightarrow\phi[s']\right]\]

\end_inset

 Applying the persistence condition operator, this can easily be re-written
 as:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\Pst(\phi,PbU(agt))[s]\]

\end_inset


\end_layout

\begin_layout Proof
This matches the form of the definition for 
\begin_inset Formula $\KnowsZ$
\end_inset

, which we can substitute in to give:
\begin_inset Formula \[
\Knows(agt,\phi,S_{0})\equiv\KnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Proof
This is equation (
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

), as required.
\end_layout

\begin_layout Section
TODO
\end_layout

\begin_layout Itemize
formalism the use of 
\begin_inset Formula $K_{0}$
\end_inset

 for initial knowledge across all axiomatizations, so we don't need to explicate
 it in our proofs
\end_layout

\begin_layout Itemize
reference appendix in all 
\begin_inset Quotes eld
\end_inset

proof sketch
\begin_inset Quotes erd
\end_inset

 environments
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "theapa"
bibfiles "../../../library/references"

\end_inset


\end_layout

\end_body
\end_document
