#LyX 1.5.5 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass jair
\begin_preamble

\jairheading{0}{0000}{0-0}{0/0}{0/0}
\ShortHeadings{Common Knowledge, Hidden Actions, and the Frame Problem}{R. F. Kelly \& A. R. Pearce}
\firstpageno{1}

 \renewenvironment{proofsketch}{\begin{proof}[Proof Sketch]}{\\ For the complete proof, see Appendix \ref{sec:Complete-Proofs} \end{proof}}
\end_preamble
\options jair,twoside,11pt,theapa,letterpaper
\language british
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Common Knowledge, Hidden Actions, and the Frame Problem
\end_layout

\begin_layout Author
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Ryan F.
 Kelly 
\backslash
email rfk@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Adrian R.
 Pearce 
\backslash
email adrian@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addr Department of Computer Science and Software Engineering
\backslash

\backslash

\end_layout

\begin_layout Standard

The University of Melbourne
\backslash

\backslash

\end_layout

\begin_layout Standard

Victoria, 3010, Australia
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a powerful new account of multi-agent knowledge in the situation
 calculus and an effective reasoning procedure for knowledge queries.
 Our approach handles partial observability of actions, including actions
 that are completely hidden, by explicitly reifying the observations made
 by each agent as the world evolves.
 It formally treats complex group-level epistemic modalities such as common
 knowledge, which were previously difficult to handle effectively in the
 situation calculus.
 By using the persistence condition meta-operator to augment traditional
 regression techniques, we allow agents to reason about their own knowledge
 using only their internal history of observations, rather than requiring
 a full history of the world.
 The result is a more robust and flexible account of knowledge in the situation
 calculus suitable for asynchronous, partially-observable multi-agent domains.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isdef}{\stackrel{\mbox{\tiny def}}{=}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Dt}{\mathcal{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Reg}{\mathcal{R}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Pst}{\mathcal{P}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Trn}{\mathcal{T}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Kln}{\mathcal{K}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\TrnA}{\Trn_{a}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EKnows}{\mathbf{EKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Knows}{\mathbf{Knows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\CKnows}{\mathbf{CKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KnowsZ}{\mathbf{Knows_{0}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PKnowsZ}{\mathbf{PKnows_{0}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PKnows}{\mathbf{PKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KTrans}{\mathbf{KDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KDo}{\mathbf{KDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EDo}{\mathbf{EDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\vars}[1]{\bar{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PbU}{PbU}
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In their landmark paper 
\emph on
Knowledge, Action, and the Frame Problem,
\emph default
 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 incorporate knowledge-producing actions into the situation calculus 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 and use Reiter's regression operator 
\begin_inset LatexCommand citep
key "reiter91frameprob"

\end_inset

 to reason about the changing knowledge of an agent.
 Extensions to multiple agents 
\begin_inset LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

 have produced an expressive logic of knowledge, action and change in which
 regression provides an effective reasoning procedure.
\end_layout

\begin_layout Standard
While powerful, the existing account suffers two major limitations that
 make it unsuitable for modelling complex multi-agent domains.
 First, it requires that whenever an action occurs, all agents 
\emph on
know
\emph default
 that an action has occurred.
 This demands a level of synchronicity that is unreasonable in many multi-agent
 domains.
 Second, there is no effective technique for handling group-level epistemic
 modalities such as common knowledge.
 Given the deep connections between common knowledge and coordination, this
 is a serious shortcoming in multi-agent domains.
\end_layout

\begin_layout Standard
In this paper we overcome these limitations by providing:
\end_layout

\begin_layout Itemize
a formal account of 
\emph on
Common Knowledge
\emph default
 and other complex epistemic modalities, including a regression rule for
 reasoning about common knowledge.
\end_layout

\begin_layout Itemize
support for 
\emph on
Hidden Actions
\emph default
 and actions that are partially observable, including a reasoning technique
 to deal with arbitrarily-long sequences of hidden actions.
\end_layout

\begin_layout Itemize
a solution to the 
\emph on
Frame Problem
\emph default
 for knowledge, built on the successor state axioms for primitive actions,
 maintaining regression as the primary reasoning tool, and allowing agents
 to reason about their own knowledge using only their local information.
\end_layout

\begin_layout Standard
The result is a rich account of multi-agent knowledge suitable both for
 reasoning 
\emph on
about,
\emph default
 and reasoning 
\emph on
in,
\emph default
 asynchronous, partially-observable multi-agent domains.
 There is a large body of work that can immediately benefit from such a
 formalism, including: specification and verification of multi-agent systems
 
\begin_inset LatexCommand citep
key "shapiro02casl"

\end_inset

; theories of coordination 
\begin_inset LatexCommand citep
key "ghaderi07sc_joint_ability"

\end_inset

 and ability 
\begin_inset LatexCommand citep
key "levesque00knowing_how"

\end_inset

; reasoning about the epistemic feasibility of plans 
\begin_inset LatexCommand citep
key "Lesperance01epi_feas_casl"

\end_inset

; analysing multi-player games 
\begin_inset LatexCommand citep
key "delgrande01sitcalc_cleudo"

\end_inset

; and our own work on the cooperative execution of Golog programs 
\begin_inset LatexCommand citep
key "kelly06hlp_dps"

\end_inset

.
\end_layout

\begin_layout Standard
The paper begins by reviewing the standard account of multi-agent knowledge
 in the situation calculus in Section 
\begin_inset LatexCommand ref
reference "sec:The-Multi-Agent-Situation"

\end_inset

.
 Readers familiar with the situation calculus are encouraged to review this
 material, as we extend some of the standard notation in preparation for
 later sections.
 Our new formalism is then developed in two parts: first by axiomatising
 individual knowledge in the face of hidden actions in Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

, then by adding complex epistemic modalities to model common knowledge
 in Section 
\begin_inset LatexCommand ref
reference "sec:Complex-Epistemic-Modalities"

\end_inset

.
\end_layout

\begin_layout Standard
The challenge in both cases is to increase the expressive power of the logic
 while still allowing regression to be performed.
 That is, it must be possible for an epistemic query about the state of
 the world 
\emph on
after
\emph default
 an action has been performed to be translated into a query about the state
 of the world 
\emph on
before
\emph default
 that action.
 This is achieved using new reasoning techniques to augement the standard
 regression operator, and by carefully constructing our extensions to be
 compatible with these techniques.
 
\end_layout

\begin_layout Subsection*
Individual Knowledge with Hidden Actions
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 treats the individual knowledge of each agent in the face of hidden actions,
 by decoupling knowledge from the specific actions that have occurred.
 We explicitly reify the local 
\emph on
observations
\emph default
 made by each agent, and formulate the agent's knowledge in terms of what
 it has observed.
 Each occurrence of an action results in an agent making a (possibly empty)
 set of observations.
 Every situation then corresponds to a 
\emph on
view
\emph default
: the sequence of all observations made by an agent, excluding cases where
 the set of observations was empty.
 An agent knows something if it is true in all situations matching its current
 view.
\end_layout

\begin_layout Standard
Decoupling knowledge in this manner makes it easy to express various degrees
 of observability of actions, from public actions through to actions that
 are completely hidden.
 This section is a greatly expanded version of our conference paper on the
 same topic, and stands as a significant new account of knowledge in its
 own right 
\begin_inset LatexCommand citep
key "kelly07sc_know_obs"

\end_inset

.
\end_layout

\begin_layout Standard
The main challenge we overcome in this section is handling arbitrarily long
 sequences of hidden actions.
 To ensure its knowledge is valid, an agent must reason about all future
 situations compatible with what it has observed.
 However, the regression meta-operator cannot handle queries that universally
 quantify over situation terms.

\emph on
 
\emph default
In previous work we have developed the persistence condition meta-operator
 to support a limited form of universally quantified query 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 Using this operator to augment the regression techniques developed by 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, we maintain their elegant solution to the frame problem while handling
 arbitrarily long sequences of hidden actions.
\end_layout

\begin_layout Standard
Further demonstrating the power of our approach, we show how the new regression
 rules can be applied using an agent's individual view, rather than requiring
 a full situation term.
 Agents can thus use our techniques to reason about their own knowledge
 using only their local information, making the formalism suitable both
 for reasoning 
\emph on
about
\emph default
, and reasoning 
\emph on
in
\emph default
,
\emph on
 
\emph default
rich multi-agent domains.
\end_layout

\begin_layout Subsection*
Complex Epistemic Modalities
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sec:Complex-Epistemic-Modalities"

\end_inset

 builds on our account of individual knowledge by introducing complex group-leve
l epistemic modalities.
 It is an extension of our conference paper on the topic 
\begin_inset LatexCommand citep
key "kelly08complex_epistemic_modalities"

\end_inset

, modified to incorporate support for hidden actions.
 The primary motivation is a formal account of common knowledge, but achieving
 this requires a much more general formalism.
 
\end_layout

\begin_layout Standard
Simple group-level modalities such as 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 can be expressed as finite combinations of individual-level knowledge operators
, but common knowledge is infinitary and cannot be handled in this way.
 Instead, common knowledge is typically introduced to the situation calculus
 using a separate second-order axiom 
\begin_inset LatexCommand citep
key "davis05fo_ma_theory,ghaderi07sc_joint_ability"

\end_inset

.
 While logically sound, this approach forgoes regression as a reasoning
 tool and in the general case requires a second-order theorem prover to
 answer knowledge queries.
 Our work offers a new approach by combining a rich group-level epistemic
 language with a regression rule for effective reasoning.
\end_layout

\begin_layout Standard
To achieve this, we must overcome the following expressivity result: 
\emph on
epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone
\emph default
 
\begin_inset LatexCommand citep
key "baltag98pa_ck"

\end_inset

.
\end_layout

\begin_layout Standard
This means it is impossible to express the regression of common knowledge
 using only the knowledge and common-knowledge operators.
 We take our cue from recent promising work in the related field of dynamic
 epistemic logic, with the main idea due to 
\begin_inset LatexCommand citet
key "vanBenthem06lcc"

\end_inset

: increase the expressive power of the epistemic language so it is strong
 enough to formulate a proper regression rule.
 They have developed the Logic of Communication and Change (henceforth 
\begin_inset Quotes eld
\end_inset

LCC
\begin_inset Quotes erd
\end_inset

) using propositional dynamic logic to form epistemic modalities, and have
 shown that it allows reasoning about common knowledge using techniques
 akin to regression.
 We follow a similar approach in this paper and introduce complex epistemic
 modalities to the situation calculus.
 
\end_layout

\begin_layout Standard
Following the tradition of 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 we develop our formalism as a series of macro-expansions, with no changes
 to the underlying situation calculus theory.
 The language of first-order dynamic logic is used to construct complex
 epistemic paths, with the macro 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 expressing knowledge using such a path.
 Common knowledge between 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 is expressed in this syntax as 
\begin_inset Formula $\PKnows((A\cup B)^{*},\phi,s)$
\end_inset

, the unbounded iteration of the base knowledge operators for each agent.
 Regression is modified to treat 
\begin_inset Formula $\PKnows(\pi,\phi,do(c,s))$
\end_inset

 as a primitive fluent, producing an equivalent formula 
\begin_inset Formula $\PKnows(\Trn(\pi),\Reg(\phi),s)$
\end_inset

 where 
\begin_inset Formula $\Trn$
\end_inset

 is a new meta-operator called the epistemic path regressor.
 
\end_layout

\begin_layout Standard
While this section naturally parallels the development of LCC, there are
 also substantial differences.
 LCC is built on modal logic and so handles only propositional, synchronous
 domains.
 The richer ontology of the situation calculus means our formalism must
 capture first-order preconditions and effects, quantifying-in and de-dicto/de-r
e, and arbitrary sets of concurrent actions, while incorporating our new
 technique for handling hidden actions.
 
\end_layout

\begin_layout Standard
We demonstrate the effectiveness of our technique with an example of reasoning
 about common knowledge in a partially-observable domain, a first for the
 situation calculus.This paper thus contributes a rich multi-agent theory
 of knowledge and action in which complex group-level epistemic modalities
 are amenable to effective automated reasoning.
\end_layout

\begin_layout Section
The Multi-Agent Situation Calculus
\begin_inset LatexCommand label
name "sec:The-Multi-Agent-Situation"

\end_inset


\end_layout

\begin_layout Standard
Our work utilises the situation calculus 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 with multiple agents 
\begin_inset LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "reiter96sc_nat_conc"

\end_inset

, and we begin from the standard account of knowledge due to 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

.
 A brief overview is presented below.
 Readers familiar with the situation calculus should note: our generalisation
 of the 
\begin_inset Formula $Poss$
\end_inset

 fluent to action description predicates, our use of the single-step variant
 of the regression operator, and the material on the persistence condition
 meta-operator.
\end_layout

\begin_layout Standard
There are a wide range of related formalisms for reasoning about knowledge,
 action and change, which we do not directly consider in this paper.
 We find the notation and meta-theory of the situation calculus particularly
 suitable for expressing our main ideas.
 Moreover, the strong underlying similarities between the major action formalism
s should allow the these ideas to transcend the specifics of the situation
 calculus 
\begin_inset LatexCommand citep
key "thielscher06reconcile_sc_fc,thielscher07unifying_action_calculus,vanbentham07ml_sitcalc"

\end_inset

.
\end_layout

\begin_layout Subsection
Notation and Axioms
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change, with the initiating agent indicated by
 their first argument; 
\noun on
Concurrent
\noun default
 terms are sets of actions that occur simultaneously; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Concurrent\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\emph on
Fluents
\emph default
 are predicates or functions that represent properties of the world that
 may change between situations; they take a situation term as their final
 argument.
\end_layout

\begin_layout Standard
Throughout the paper we will present examples from a simple multi-agent
 domain, in which two agents Ann and Bob are attending a party.
 The location of the party (the fluent 
\begin_inset Formula $loc(s)$
\end_inset

) is either 
\begin_inset Formula $C$
\end_inset

 or 
\begin_inset Formula $D$
\end_inset

 but they do not know which, and they have just received an invitation telling
 them the location of the party.
 Each agent may read the inviation (the action 
\begin_inset Formula $read$
\end_inset

) and leave/enter the room (actions 
\begin_inset Formula $leave$
\end_inset

 and 
\begin_inset Formula $enter$
\end_inset

) at any time.
 Some example formulae from this domain are: 
\begin_inset Quotes eld
\end_inset

Ann is in the room initially
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

Bob is not in the room after leaving it
\begin_inset Quotes erd
\end_inset

.
 Written formally:
\begin_inset Formula \begin{gather*}
InRoom(Ann,S_{0})\\
\neg InRoom(Bob,do(leave(Bob),S_{0}))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The dynamics of a particular domain are captured by a set of sentences called
 a 
\emph on
basic action theory
\emph default
.
 Queries about the behaviour of the world are posed as logical entailment
 queries relative to this theory.
\end_layout

\begin_layout DefinitionLbld
Basic\InsetSpace ~
Action\InsetSpace ~
Theory A basic action theory, denoted 
\begin_inset Formula $\Dt$
\end_inset

, is a set of situation calculus sentences (with a specific syntactic form
 outlined below) describing a particular dynamic world.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); unique names axioms for actions (
\begin_inset Formula $\Dt_{una}$
\end_inset

); action description axioms defining, for example, preconditions for each
 action (
\begin_inset Formula $\Dt_{ad}$
\end_inset

); successor state axioms describing how primitive fluents change between
 situations (
\begin_inset Formula $\Dt_{ssa}$
\end_inset

); and axioms describing the value of primitive fluents in the initial situation
 (
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{una}\cup\Dt_{ad}\cup\Dt_{ssa}\cup\Dt_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
These axioms must satisfy some consistency criteria to constitute a valid
 domain description; consult the work of 
\begin_inset LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

 for details.
 We assume an arbitrary, but fixed, basic action theory.
\end_layout

\begin_layout Standard
The 
\emph on
uniform formulae
\emph default
 can be thought of as properties of the state of the world.
 They are basically logical combinations of fluents referring to a common
 situation term.
 For the moment the following definition will suffice, although we will
 revisit it once the necessary concepts have been introduced.
\end_layout

\begin_layout DefinitionLbld
Uniform\InsetSpace ~
Formulae\InsetSpace ~
-\InsetSpace ~
Preliminary Let 
\begin_inset Formula $s$
\end_inset

 be a situation term, 
\begin_inset Formula $F$
\end_inset

 an arbitrary fluent, 
\begin_inset Formula $\vars{x}$
\end_inset

 a vector of terms mentioning no situation term other than 
\begin_inset Formula $s$
\end_inset

, and 
\begin_inset Formula $y$
\end_inset

 a variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the formulae uniform in 
\begin_inset Formula $s$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists y:\phi\,|\,\forall y:\phi\]

\end_inset


\end_layout

\begin_layout Standard
The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout this paper to refer to an arbitrary uniform formula.
 Suppose that 
\begin_inset Formula $\phi$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

, then we will use 
\begin_inset Formula $\phi[s']$
\end_inset

 to denote 
\begin_inset Formula $\phi$
\end_inset

 with every occurrence of 
\begin_inset Formula $s$
\end_inset

 replaced by 
\begin_inset Formula $s'$
\end_inset

.
 Think of this as 
\begin_inset Quotes eld
\end_inset

evaluating
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $\phi$
\end_inset

 at the situation 
\begin_inset Formula $s'$
\end_inset

.
 When used with this notation, we will often suppress the situation term
 in uniform formulae to simplify the presentation (e.g.
 writing 
\begin_inset Formula $InRoom(Ann)$
\end_inset

 instead of 
\begin_inset Formula $InRoom(Ann,s)$
\end_inset

).
\newline

\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{una}$
\end_inset

 restricts action terms to a finite number of action types, and ensures
 that actions with different types or different arguments are in fact different.
 The function 
\begin_inset Formula $actor(a)$
\end_inset

 gives the agent performing an action, which is always the action's first
 argument.
\newline

\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 contains one 
\emph on
successor state axiom
\emph default
 for each primitive fluent in the domain, providing a monotonic solution
 to the frame problem for that fluent.
 These axioms have the following general form, asserting the truth of a
 fluent 
\begin_inset Formula $F$
\end_inset

 in the successor situation 
\begin_inset Formula $do(c,s)$
\end_inset

 based on the current situation 
\begin_inset Formula $s$
\end_inset

 and the actions 
\begin_inset Formula $c$
\end_inset

 that were performed: 
\begin_inset Formula \[
F(\vars{x},do(c,s))\equiv\Phi_{F}^{+}(\vars{x},c,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi^{+}$
\end_inset

 and 
\begin_inset Formula $\Phi^{-}$
\end_inset

 are formulae uniform in 
\begin_inset Formula $s$
\end_inset

.
 This may be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after performing 
\begin_inset Formula $c$
\end_inset

 if 
\begin_inset Formula $c$
\end_inset

 made it true, or it was previously true and 
\begin_inset Formula $c$
\end_inset

 did not make it false
\begin_inset Quotes erd
\end_inset

.
\newline

\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 generalizes the standard 
\emph on
action precondition axioms
\emph default
 to define fluents describing various aspects of the performance of an action,
 which we call 
\emph on
action description predicates
\emph default
.
 The predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 is the canonical example, indicating whether it is possible to perform
 an action in a given situation.
 For example, it is only possible for an agent to leave the room if they
 are actually in it:
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow standard naming conventions for the situation calculus: lower-case
 roman names indicate variables, and free variables are implicitly universally
 quantified at the outermost scope
\end_layout

\end_inset


\begin_inset Formula \[
Poss(leave(agt),s)\equiv InRoom(agt,s)\]

\end_inset


\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains one axiom of the form 
\begin_inset Formula $Poss(A(\vars{x}),s)\equiv\Phi_{A}(\vars{x},s)$
\end_inset

 for each type of action 
\begin_inset Formula $A$
\end_inset

.
 These are combined into a generalised 
\begin_inset Formula $Poss$
\end_inset

 axiom for sets of concurrent actions, which in its simplest form is just:
\begin_inset Formula \[
Poss(c,s)\equiv c\neq\{\}\,\wedge\,\forall a\in c:\, Poss(a,s)\]

\end_inset

Note that it is never possible to perform an empty set of actions.
 In more complex domains actions may interact, so that they cannot be performed
 concurrently even if possible individually.
 We assume 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains an appropriate axiomatisation of such interaction; 
\begin_inset LatexCommand citet
key "pinto94temporal"

\end_inset

 provides a full discussion of this issue;
\end_layout

\begin_layout Standard
In Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Observation"

\end_inset

 we will define another action description predicate 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

, specifying whether an agent will observe the occurrence of an action.
 In principle any number of predicates and functions can be defined in this
 way.
 Action description 
\emph on
functions
\emph default
 are defined analogously.
 We will use the meta-variable 
\begin_inset Formula $\alpha$
\end_inset

 to represent an arbitrary action description predicate.
\end_layout

\begin_layout Standard
We assume that these definitions are finitely enumerable and well-founded,
 allowing them to be expanded properly even when they refer to an action
 variable.
 For example, we assume that 
\begin_inset Formula $Poss(a,s)$
\end_inset

 can be replaced by an enumeration over action types such as the following:
\begin_inset Formula \[
a=Act_{1}\wedge Poss(Act_{1},s)\,\vee\, a=Act_{2}\wedge Poss(Act_{2},s)\,\vee\,\dots\,\vee a=Act_{n}\wedge Poss(Act_{2},s)\]

\end_inset


\newline

\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Sigma$
\end_inset

 ensures that situations form a branching-time account of the world state.
 There is a set of initial situations identified by the predicate 
\begin_inset Formula $Init(s)$
\end_inset

, and a distinguished initial situation 
\begin_inset Formula $S_{0}$
\end_inset

 called the 
\emph on
actual 
\emph default
initial situation.
 Other initial situations are used to represent the agents' epistemic uncertaint
y, and will be discussed in the following section.
 Situations in general form a tree structure with an initial situation at
 the root and 
\begin_inset Formula $do$
\end_inset

 constructing child situations from parents.
 
\begin_inset Formula $\Sigma$
\end_inset

 defines an ordering relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 which should be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

 and is defined as follows:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg(s'\sqsubset s)\\
s\sqsubset do(c,s')\equiv s\sqsubseteq s'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 There is also a second-order induction axiom asserting that all situations
 must be constructed in this way, which is needed to prove statements that
 universally quantify over situations.
\end_layout

\begin_layout Standard
This notation for 
\begin_inset Quotes eld
\end_inset

in the future of
\begin_inset Quotes erd
\end_inset

 can be extended to consider only those futures in which all actions satisfy
 a particular action description predicate.
 We use a relation 
\begin_inset Formula $<_{\alpha}$
\end_inset

 for each action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, with the following definitions:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg\left(s'<_{\alpha}s\right)\\
s<_{\alpha}do(c,s')\equiv s\leq_{\alpha}s'\wedge\alpha(c,s')\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
legal situations
\emph default
 are those in which every action was possible to perform in the preceding
 situation.
 These are of fundamental importance, as they are the only situations that
 could be reached in the real world.
 The 
\emph on
root
\emph default
 of a situation is the initial situation from which it was constructed:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\, root(s)=s\\
root(do(c,s))=root(s)\\
Legal(s)\,\equiv\, root(s)\leq_{Poss}s\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 describes the actual state of the world before any actions are performed.
 It is a collection of sentences of the form 
\begin_inset Formula $\phi[S_{0}]$
\end_inset

 stating what holds in the actual initial situation.
 It also defines the initial knowledge of each agent, as described in the
 next section.
\end_layout

\begin_layout Subsection
Knowledge and Sensing
\begin_inset LatexCommand label
name "sub:Knowledge-and-Sensing"

\end_inset


\end_layout

\begin_layout Standard
Epistemic reasoning was first introduced to the situation calculus by 
\begin_inset LatexCommand citet
key "moore80know_act"

\end_inset

, and formalised extensively by 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

 whose paper is now the canonical reference for these techniques.
 Their work has been further extended to include concurrent actions 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

 and multiple agents 
\begin_inset LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

.
 We further extend this family of techniques in this paper.
\end_layout

\begin_layout Standard
The semantics of knowledge are based on a reification of the 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 semantics of modal logic, using situation terms rather than abstract worlds.
 A special fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 The macro 
\begin_inset Formula $\Knows$
\end_inset

 is then defined as a shorthand for the standard possible-worlds definition
 of knowledge, stating that an agent knows 
\begin_inset Formula $\phi$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 is true in all situations considered possible: 
\begin_inset Formula \begin{equation}
\Knows(agt,\phi,s)\isdef\forall s':\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}

\end_inset

 
\end_layout

\begin_layout Standard
Readers familiar with modal logic will recognise 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 as the situation calculus analogue of the modal reachability relation 
\begin_inset Formula $K_{agt}$
\end_inset

, and the macro 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 as the equivalent of the modal box operator 
\begin_inset Formula $[K_{agt}]\phi$
\end_inset

.
\end_layout

\begin_layout Standard
The basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 must be enriched to support epistemic reasoning.
 The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 gain a special fluent 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 with which to model the initial epistemic uncertainty of the agents, and
 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 gains sentences of the form 
\begin_inset Formula $\KnowsZ(agt,\phi,S_{0})$
\end_inset

 to specify what is initially known
\begin_inset Foot
status collapsed

\begin_layout Standard
As evidenced by equation 
\begin_inset LatexCommand eqref
reference "eq:k_s0_standard"

\end_inset

, the standard account does not require a separate 
\begin_inset Formula $K_{0}$
\end_inset

 fluent.
 It is required when incorporating hidden actions.
 We introduce it now to maintain consistency of the presentation.
 
\end_layout

\end_inset

:
\begin_inset Formula \begin{gather*}
K_{0}(agt,s',s)\,\rightarrow Init(s)\wedge Init(s')\\
\KnowsZ(agt,\phi,s)\isdef\forall s':\, K_{0}(agt,s',s')\rightarrow\phi[s']\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The action description function 
\begin_inset Formula $SR(a,s)$
\end_inset

 is introduced to specify the sensing result returned by action 
\begin_inset Formula $a$
\end_inset

 when executed in situation 
\begin_inset Formula $s$
\end_inset

.
 For non-sensing actions the value of 
\begin_inset Formula $SR$
\end_inset

 is set to an arbitrary constant.
\end_layout

\begin_layout Standard
The dynamics of knowledge are then specified with an additional set of axioms,
 which we will denote 
\begin_inset Formula $\Dt_{K}$
\end_inset

.
 In the standard account of knowledge 
\begin_inset Formula $\Dt_{K}$
\end_inset

 contains the following axioms:
\begin_inset Formula \begin{equation}
Init(s)\rightarrow\left(K(agt,s',s)\,\equiv\, K_{0}(agt,s',s)\right)\label{eq:k_s0_standard}\end{equation}

\end_inset


\begin_inset Formula \begin{align}
K(agt,s'',do(c,s))\equiv\exists s': & \, s''=do(c,s')\,\wedge K(agt,s',s)\wedge Poss(c,s')\nonumber \\
 & \wedge\,\forall a\in c:\,\left(actor(a)=agt\,\rightarrow\, SR(a,s)=SR(a,s')\right)\label{eq:k_ssa_standard}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Equation 
\begin_inset LatexCommand eqref
reference "eq:k_ssa_standard"

\end_inset

 takes the form of a standard successor state axiom.
 It ensures that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(c,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing the same actions 
\begin_inset Formula $c$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is considered a possible alternative to 
\begin_inset Formula $s$
\end_inset

.
 It must furthermore have been possible to perform those actions in 
\begin_inset Formula $s'$
\end_inset

, and the sensing results must match for each action that was carried out
 by the agent in question.
 Thus an agent's knowledge after the occurrence of an action is completely
 determined by the combination of its knowledge before the action, and the
 sensing results from the action.
 
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K}^{std}$
\end_inset

 the axioms of the standard account of knowledge due to 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, as detailed in equations (
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

) above.
\end_layout

\begin_layout Standard
Finally, the definition of a uniform formula must be updated to include
 statements about the epistemic state of the world.
\end_layout

\begin_layout DefinitionLbld
Uniform\InsetSpace ~
Formulae Let 
\begin_inset Formula $s$
\end_inset

 be a situation term, 
\begin_inset Formula $F$
\end_inset

 a primitive fluent or action description predicate, 
\begin_inset Formula $\vars{x}$
\end_inset

 a vector of terms mentioning no situation term other than 
\begin_inset Formula $s$
\end_inset

, and 
\begin_inset Formula $y$
\end_inset

 a variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the formulae uniform in 
\begin_inset Formula $s$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying
\begin_inset Foot
status collapsed

\begin_layout Standard
This differs from the standard definition, which does not permit action
 description predicates 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 Since we assume that action description predicates can always be expanded
 into finite combinations of primitive fluents, we can safely ignore this
 restriction.
\end_layout

\end_inset

:
\begin_inset Formula \[
\phi::=F(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists y:\phi\,|\,\forall y:\phi\,|\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
While powerful, this formalism has an important limitation: it is fundamentally
 
\emph on
synchronous.
 
\emph default
Each agent is assumed to have full knowledge of all actions that have occurred.
 While suitable for some domains, there are clearly many multi-agent domains
 where achieving total awareness of actions would be infeasible.
 A major contribution of this paper is a more flexible formalism for knowledge
 that can be applied to a much wider range of domains.
\end_layout

\begin_layout Subsection
Reasoning and Regression
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 These are generally based on syntactic manipulation of a query into a form
 that is more amenable to reasoning - for example, because it can be proven
 without using some of the axioms from 
\begin_inset Formula $\Dt$
\end_inset

.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\psi$
\end_inset

 be an arbitrary sentence from a particular situation calculus theory 
\begin_inset Formula $\Dt$
\end_inset

.
 In the general case, answering this query is a theorem-proving task in
 second-order logic (denoted SOL) due to the induction axiom included in
 the foundational axioms:
\begin_inset Formula \[
\Dt\models_{SOL}\psi\]

\end_inset


\end_layout

\begin_layout Standard
This is clearly problematic for effective automated reasoning.
 Fortunately, there exist particular syntactic forms for which some of the
 axioms in 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required.
 If queries are restricted to the form 
\begin_inset Formula $\forall s:\,\phi[s]$
\end_inset

, where 
\begin_inset Formula $\phi$
\end_inset

 is uniform, they can be answered without many of the axioms in 
\begin_inset Formula $\Dt$
\end_inset

 and in particular, using only first-order logic 
\begin_inset LatexCommand citep
key "Lin94-StateConstraints,kelly07sc_persistence"

\end_inset

: 
\begin_inset Formula \[
\mathcal{D}-\Dt_{S_{0}}\models_{SOL}\forall s:\,\phi[s]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{una}\models_{FOL}\forall s:\,\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
We refer to this as 
\emph on
static domain reasoning
\emph default
, since it does not depend on the axioms about actions or on details of
 the initial situation.
 Still easier to perform is 
\emph on
initial situation reasoning
\emph default
, where the query is further restricted to be a formula uniform in 
\begin_inset Formula $S_{0}$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\phi[S_{0}]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{una}\models_{FOL}\phi[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Since the axioms 
\begin_inset Formula $\Dt_{S_{0}}\cup\Dt_{una}$
\end_inset

 often satisfy the closed-world assumption, provers such as Prolog can be
 employed to handle this type of query quite effectively.
 In general, effective reasoning depends on transforming queries into these
 more easily-handled forms.
 
\newline

\end_layout

\begin_layout Standard
The principle tool for effective reasoning in the situation calculus is
 the regression meta-operator 
\begin_inset Formula $\Reg_{\Dt}$
\end_inset

 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

, a syntactic manipulation that can transform a formula uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into an equivalent formula that is uniform in 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\phi[do(c,s)]\equiv\Reg_{\Dt}(\phi[do(c,s)])[s]\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\Dt$
\end_inset

 is fixed, we drop the subscript and use a plain 
\begin_inset Formula $\Reg$
\end_inset

 for regression.
 Its operation is defined by a set of 
\emph on
regression rules
\emph default
 such as those shown below:
\begin_inset Formula \begin{align*}
\Reg(\phi_{1}\wedge\phi_{2})\isdef & \Reg(\phi_{1})\wedge\Reg(\phi_{2})\\
\Reg(Poss(a,s))\isdef & a=Act_{1}\wedge\Reg(\Phi_{Act_{n}}[s])\,\vee\,\dots\,\vee\, a=Act_{n}\wedge\Reg(\Phi_{Act_{n}}[s])\\
\Reg(F(\vars{x},do(c,s)))\isdef & \Phi_{F}^{+}(\vars{x},c,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},c,s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In general, regression replaces action description predicates with their
 definitions from 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and primitive fluents with their successor state axioms from 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

.
 Repeated applications of this operator can transform a query about some
 future situation into a query about the initial situation only, which can
 be answered effectively using initial situation reasoning.
 The axioms 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 are essentially 
\begin_inset Quotes eld
\end_inset

compiled into
\begin_inset Quotes erd
\end_inset

 the query.
 The trade-off is that the length of the regressed query may be exponential
 in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice 
\begin_inset LatexCommand citep
key "levesque97golog,pirri99contributions_sitcalc"

\end_inset

.
\newline

\end_layout

\begin_layout Standard
A key contribution of 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 was showing how to apply the regression operator to formulae containing
 the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, allowing it to be treated syntactically as if it were a primitive
 fluent.
 This means that epistemic queries can be approached using standard reasoning
 techniques of the situation calculus.
 Although we have changed the notation somewhat to foreshadow the techniques
 we will develop in Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

, their definition operates as follows.
 First, define the 
\emph on
results
\emph default
 of an action as the following set:
\begin_inset Formula \[
\mathbf{res}(agt,c,s)\isdef\{<a,SR(a,s)>\,|\, a\in c\,\wedge\, actor(a)=agt\}\]

\end_inset


\end_layout

\begin_layout Standard
This definition is then used to formulate a regression rule as follows:
\begin_inset Formula \begin{multline*}
\Reg(\Knows(agt,\phi,do(c,s))\isdef\\
\exists y:\, y=\mathbf{res}(agt,c,s)\,\wedge\Knows(agt,\left[Poss(c)\wedge\mathbf{res}(agt,c)=y\right]\rightarrow\Reg(\phi[do(c,s)]),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
This works by collecting the sensing results from each action performed
 by the agent into the set 
\begin_inset Formula $y$
\end_inset

, then ensuring matching sensing results in every situation considered possible.
 It expresses the knowledge of the agent after a concurrent action in terms
 of what it knew before the action, along with the information returned
 by the action.
 This technique relies heavily on the fact that all actions are public,
 since it requires every agent's knowledge to be updated in response to
 every action.
\end_layout

\begin_layout Standard
As before, repeated applications of 
\begin_inset Formula $\Reg$
\end_inset

 can transform a query into one that is uniform in the situation situation.
 While it would be valid to then expand the 
\begin_inset Formula $\Knows$
\end_inset

 macros and handle the query using first-order logic, in practice the reasoning
 procudure would leave 
\begin_inset Formula $\Knows$
\end_inset

 intact and use a specialised prover based on modal logic.
\end_layout

\begin_layout Standard
It is possible to formulate an alternate successor state axiom for knowledge
 that does not assume all actions are public, such as that of 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

.
 However these formulations invariably require universal quantification
 over situation terms, to account for arbitrarily-long sequences of hidden
 actions.
 Such universal quantification is incompatible with regression rules like
 the above, these formulations offer no reasoning procedure other than second-or
der theorem proving.
 By utilising a new reasoning technique called 
\begin_inset Quotes eld
\end_inset

property persistence
\begin_inset Quotes erd
\end_inset

 to allow universal quantification over situation terms, our work is the
 first to provide an account of knowledge with hidden actions while maintaining
 regression in the style presented above as an effective reasoning tool.
\end_layout

\begin_layout Subsection
Property Persistence
\end_layout

\begin_layout Standard
As discussed above, traditional regression techniques cannot handle queries
 that universally quantify over situation terms.
 In fact, such queries require the use of a second-order induction axiom
 and therefore need a second-order theorem prover in the general case.
 Fortunately, such queries are often in a simple syntactic form called 
\emph on
property persistence
\emph default
 queries 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 Such queries assert that a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 holds in a given situation, and will continue to hold as long as all future
 actions satisfy some action description predicate 
\begin_inset Formula $\alpha$
\end_inset

: 
\begin_inset Formula \[
\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
We have developed a meta-operator called the 
\emph on
persistence condition
\emph default
, denoted 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

, to handle such queries more effectively 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 It produces a uniform formula such that:
\begin_inset Formula \[
\Dt\,\models\,\Pst_{\Dt}(\phi,\alpha)[s]\,\equiv\,\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
As with regression, we will use the simpler notation 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 and leave 
\begin_inset Formula $\Dt$
\end_inset

 implicit.
 Since the persistence condition is used to replace a second-order induction
 axiom, 
\begin_inset Formula $\Pst$
\end_inset

 is actually a fixpoint calculation and it therefore requires some theorem
 proving.
 This is in contrast to the regression operator, which is a purely syntactic
 transformation.
 We briefly describe the operation of 
\begin_inset Formula $\Pst$
\end_inset

 below since we will need some of these details for a later proof; for full
 details consult our previous work 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
\end_layout

\begin_layout Standard
First, the one-step-persistence operator 
\begin_inset Formula $\Pst^{1}$
\end_inset

 is defined to assert that 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate successors:
\begin_inset Formula \[
\Pst^{1}(\phi,\alpha)[s]\,\isdef\,\phi[s]\wedge\forall c:\,\alpha(c,s)\rightarrow\Reg(\phi,c)[s]\]

\end_inset


\end_layout

\begin_layout Standard
Note that the use of regression ensures that the result is uniform in 
\begin_inset Formula $s$
\end_inset

.
 Repeated application, denoted 
\begin_inset Formula $\Pst^{n}(\phi,\alpha)$
\end_inset

, asserts the persistence of 
\begin_inset Formula $\phi$
\end_inset

 after greater numbers of actions.
 Intuitively 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 should be a fixpoint of 
\begin_inset Formula $\Pst^{1}(\phi,\alpha)$
\end_inset

, and indeed it can be shown that:
\begin_inset Formula \[
\mathcal{D}_{una}\,\models\,\Pst^{n}(\phi,\alpha)\,\rightarrow\,\Pst^{n+1}(\phi,\alpha)\,\,\,\,\,\,\mathrm{iff}\,\,\,\,\,\,\Dt-\Dt_{S_{0}}\,\models\,\Pst^{n}(\phi,\alpha)\,\equiv\,\Pst(\phi,\alpha)\]

\end_inset


\end_layout

\begin_layout Standard
Thus the calculation of 
\begin_inset Formula $\mathcal{P}(\phi,\alpha)$
\end_inset

 replaces a single second-order reasoning task with iterated static domain
 reasoning.
 Our experience has shown this technique to be quite effective in practice,
 as static domain reasoning is significantly easier to perform.
 Since 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 produces a uniform formula, it allows queries that universally quantify
 over situation terms to be reduced to a form that is compatible with traditiona
l regression techniques.
\end_layout

\begin_layout Section
Individual Knowledge with Hidden Actions
\begin_inset LatexCommand label
name "sec:Obs-Knowledge"

\end_inset


\end_layout

\begin_layout Standard
Existing accounts of knowledge in the situation calculus directly express
 the dynamics of knowledge update in terms of the actions that have occurred
 in the world, as seen in Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Sensing"

\end_inset

.
 This works well when agents can be assumed to have full knowledge of the
 actions that have been performed, but quickly becomes cumbersome when trying
 to allow for hidden actions.
 In this section we first develop a principled axiomatisation of the 
\emph on
observability
\emph default
 of actions, then build a powerful yet succinct axiomatisation of knowledge
 upon it.
\end_layout

\begin_layout Standard
The direct coupling between knowledge and action also has undesirable consequenc
es for reasoning about knowledge.
 As a consequence of using regression to handle knowledge queries, one can
 only reason about knowledge if one has a rooted situation term, as the
 required query is:
\begin_inset Formula \[
\Dt_{S_{0}}\cup\Dt_{una}\,\models\,\Reg^{*}(\Knows(agt,\phi,s))\]

\end_inset


\end_layout

\begin_layout Standard
This query requires 
\begin_inset Formula $s$
\end_inset

 to be rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
 In asynchronous domains with hidden actions, where agents are not necessarily
 aware of the number of actions that have been performed, the agents cannot
 use this formulation to reason about their own knowledge.
 Since knowledge is directly coupled to actions, and hence to situation
 terms, they cannot construct an appropriate query.
\end_layout

\begin_layout Standard
This section is devoted to removing this troublesome direct coupling between
 knowledge and action terms.
\end_layout

\begin_layout Subsection
Observations
\end_layout

\begin_layout Standard
To remove the direct coupling between knowledge and actions, we introduce
 an explicit notion of 
\emph on
observations
\emph default
.
 These are internal notifications that agents receive when an action has
 occurred.
 By expressing knowledge in terms of observations rather than actions, we
 ensure that agents can always reason about their own knowledge based on
 their own internal history of observations.
\end_layout

\begin_layout DefinitionLbld
Observations An observation is a notification event received by an agent,
 making it aware of some change in the state of the world.
 When an agent receives such a notification, we say that it 
\begin_inset Quotes eld
\end_inset

observed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

made
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

perceived
\begin_inset Quotes erd
\end_inset

 that observation.
\end_layout

\begin_layout Standard
Since the state of the world may only change in response to some action,
 observations can only be made as a result of some action.
 For simplicity we assume that agents perceive observations instantaneously,
 i.e.
 in the same instant as the actions that cause them.
\end_layout

\begin_layout Standard
Since 
\begin_inset Quotes eld
\end_inset

observation
\begin_inset Quotes erd
\end_inset

 is quite a loaded term, it is worth re-iterating this point: observations
 are instantaneous
\emph on
 events
\emph default
 generated internally by each agent in response to actions occurring in
 the world.
 We make no commitment as to how these events are generated, preferring
 a clean delineation between the task of observing change and the dynamics
 of knowledge update based on those observations.
 As with the work of 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, we consider change-awareness to be the responsibility of a lower-level
 component of the agent's control software.
\end_layout

\begin_layout Standard
To make this idea concrete, let us introduce an additional sort 
\noun on
Observations
\noun default
 to the language of the situation calculus, for the moment without any particula
r commitment towards what this sort will contain.
 We then add to 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 the action description function:
\begin_inset Formula \[
Obs(agt,c,s)=o\]

\end_inset

This function returns a set of observations, and should be read as 
\begin_inset Quotes eld
\end_inset

when actions 
\begin_inset Formula $c$
\end_inset

 are performed in situation 
\begin_inset Formula $s$
\end_inset

, agent 
\begin_inset Formula $agt$
\end_inset

 will perceive 
\begin_inset Formula $o$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Using a set of observations allows an agent to perceive any number of observati
ons in response to an action occurrence - perhaps several observations,
 perhaps none.
 We write 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

 for the case where an agent makes no observations, i.e.
 the actions 
\begin_inset Formula $c$
\end_inset

 are completely hidden.
 
\end_layout

\begin_layout Standard
The concept of a 
\emph on
view
\emph default
 follows naturally - it is the sequence of all the observations made by
 an agent as the world has evolved.
 
\end_layout

\begin_layout DefinitionLbld
Views An agent's view in a given situation 
\begin_inset Formula $\mathrm{s}$
\end_inset

 is the corresponding sequence of observations made by the agent as a result
 of each action in 
\begin_inset Formula $\mathrm{s}$
\end_inset

, excluding those actions for which no observations were made.
\end_layout

\begin_layout Standard
We introduce another sort 
\noun on
Views
\noun default
 consisting of sequences of sets of observations, with 
\begin_inset Formula $\epsilon$
\end_inset

 being the empty sequence and the function 
\begin_inset Formula $View$
\end_inset

 giving the history of observations associated with a particular situation:
\begin_inset Formula \begin{align}
Init(s)\,\rightarrow & \, View(agt,s)=\epsilon\nonumber \\
Obs(agt,a,s)=\{\}\,\rightarrow & \, View(agt,do(a,s))=View(agt,s)\nonumber \\
Obs(agt,a,s)\neq\{\}\,\rightarrow & \, View(agt,do(a,s))=Obs(agt,a,s)\cdot View(agt,s)\label{eq:view_defn}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Observations and views can be seen as localised analogues of actions and
 situations respectively.
 An action is a global event that causes the state of the world to change,
 while an observation is an internal event that causes an agent's knowledge
 of the state of the world to change.
 Similarly, a situation represents a complete, global history of all the
 actions that have occurred in the world, while a view is an agent's local
 history of all the observations it has made.
 The situation is an omniscient perspective on the world, the view a local
 perspective.
 As we shall see, this distinction is fundamental to developing a truly
 general multi-agent semantics for knowledge.
\end_layout

\begin_layout Subsection
Knowledge and Observation
\begin_inset LatexCommand label
name "sub:Knowledge-and-Observation"

\end_inset


\end_layout

\begin_layout Standard
It is a basic tenet of epistemic reasoning that an agent's knowledge at
 any particular time must depend solely on its local history: the knowledge
 that it started out with combined with the observations it has made since
 then 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
 Given an explicit account of the observations made by each agent, the required
 semantics of the 
\begin_inset Formula $K$
\end_inset

 relation are clear: 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 must hold whenever 
\begin_inset Formula $s'$
\end_inset

 is legal, both 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 would result in the same view for the agent, and 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 are rooted at 
\begin_inset Formula $K$
\end_inset

-related initial situations:
\begin_inset Formula \begin{equation}
K(agt,s',s)\equiv K(root(s'),root(s))\wedge Legal(s')\wedge View(agt,s')=View(agt,s)\label{eq:k-desired}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
While a wonderfully succinct definition of how knowledge should behave,
 this formulation cannot be used directly in a basic action theory.
 The dynamics of fluent change must be specified by a successor state axiom,
 so we must formulate a successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent which enforces the above equivalence.
\end_layout

\begin_layout Standard
For notational convenience, let us first introduce an action description
 predicate 
\begin_inset Formula $\PbU$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

possible but unobservable
\begin_inset Quotes erd
\end_inset

) indicating that the actions 
\begin_inset Formula $c$
\end_inset

 are possible in 
\begin_inset Formula $s$
\end_inset

, but no observations will be made by 
\begin_inset Formula $agt$
\end_inset

 if they are performed:
\begin_inset Formula \begin{equation}
\PbU(agt,c,s)\,\equiv\, Poss(c,s)\wedge Obs(agt,c,s)=\{\}\label{eqn:PbU_defn}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
By stating that 
\begin_inset Formula $s\leq_{\PbU(agt)}s'$
\end_inset

 we assert that 
\begin_inset Formula $agt$
\end_inset

 would make no observations were the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
 This means that the views of both situations would be identical, so if
 it considers 
\begin_inset Formula $s$
\end_inset

 possible then it must also consider 
\begin_inset Formula $s'$
\end_inset

 possible.
 Following this intuition, we propose the following successor state axiom
 to capture the desired dynamics of the knowledge fluent:
\begin_inset Formula \begin{align}
K(agt,s'',do(c,s))\equiv & \left[\, Obs(agt,c,s)=\{\}\rightarrow K(agt,s'',s)\,\right]\nonumber \\
\wedge & \left[\, Obs(agt,c,s)\neq\{\}\rightarrow\exists c',s':\, Obs(agt,c',s')=Obs(agt,c,s)\right.\nonumber \\
 & \left.\,\,\,\,\,\,\,\,\wedge\, Poss(c',s')\wedge K(agt,s',s)\wedge do(c',s')\leq_{\PbU(agt)}s''\,\right]\label{eqn:new_k_ssa}\end{align}

\end_inset

 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $c$
\end_inset

 was totally unobservable, the agent's state of knowledge does not change.
 Otherwise, it considers possible any legal successor to a possible alternate
 situation 
\begin_inset Formula $s'$
\end_inset

 that can be brought about by an action 
\begin_inset Formula $c'$
\end_inset

 yielding identical observations.
 It also considers possible any future of such a situation in which is would
 make no further observations.
 To reiterate: unlike the standard successor state axiom from equation 
\begin_inset LatexCommand eqref
reference "eq:k_s0_standard"

\end_inset

, our new formalism requires agents to consider any possible future situation
 in which they would make no further observations.
\end_layout

\begin_layout Standard
It remains to specify 
\begin_inset Formula $K$
\end_inset

 in the initial situation.
 The relation 
\begin_inset Formula $K_{0}$
\end_inset

 defines knowledge before any actions have occurred, but the agent must
 consider the possibility that some hidden actions have occurred.
 In other words, we must include situations where 
\begin_inset Formula $root(s)\leq_{\PbU(agt)}s$
\end_inset

 in the 
\begin_inset Formula $K$
\end_inset

-relation for initial situations:
\begin_inset Formula \begin{gather}
Init(s)\rightarrow\left[K(agt,s'',s)\equiv\exists s'\,.\, K_{0}(agt,s',s)\wedge s'\leq_{\PbU(agt)}s'')\right]\label{eqn:new_k_s0}\end{gather}

\end_inset

These definitions suffice to ensure that knowledge behaves as we require:
 two situations will be related by 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 if and only if they result in identical views for 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $s'$
\end_inset

 is legal, and their root situations were initially related.
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K}^{obs}$
\end_inset

 the axioms for our new observation-based semantics for knowledge, as detailed
 in equations (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) above.
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:k_obs_equiv"

\end_inset

 For any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge View(agt,s'')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
For the
\series bold
 
\series default
\emph on
if
\emph default
 direction we establish each of the three conjuncts individually.
 The 
\begin_inset Formula $root$
\end_inset

 case is trivial since equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) always expresses 
\begin_inset Formula $K(s'',do(c,s))$
\end_inset

 in terms of 
\begin_inset Formula $K(s',s)$
\end_inset

.
 The 
\begin_inset Formula $Legal$
\end_inset

 case relies on the fact that 
\begin_inset Formula $\PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

, while the 
\begin_inset Formula $View$
\end_inset

 case relies on the fact that 
\begin_inset Formula $s\leq_{\PbU}s'\rightarrow View(s)=View(s')$
\end_inset

.
 For the 
\emph on
only-if
\emph default
 direction we show how to construct an 
\begin_inset Formula $s'$
\end_inset

 satisfying the 
\begin_inset Formula $\exists s'$
\end_inset

 parts of equations (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

), completing the proof.
\end_layout

\begin_layout Standard
Using this new formulation, an agent's knowledge is completely decoupled
 from the global notion of actions, instead depending only on the local
 information that it has observed.
 It remains to specify precisely what the 
\noun on
Observations
\noun default
 sort contains, and how the 
\begin_inset Formula $Obs()$
\end_inset

 function behaves.
 This will be the focus of the next subsection.
\end_layout

\begin_layout Subsection
Axiomatising Observations
\end_layout

\begin_layout Standard
Let us begin by considering again the standard account of knowledge due
 to 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

.
 Its basic assumption that 
\begin_inset Quotes eld
\end_inset

all agents are aware of all actions
\begin_inset Quotes erd
\end_inset

 may be rephrased as 
\begin_inset Quotes eld
\end_inset

when an action occurs, all agents will observe that action
\begin_inset Quotes erd
\end_inset

.
 Allowing the 
\noun on
Observations
\noun default
 sort to contain 
\noun on
Action
\noun default
 terms, this assumption is akin to the following axiom for the 
\begin_inset Formula $Obs()$
\end_inset

 function:
\begin_inset Formula \begin{equation}
a\in Obs(agt,c,s)\equiv a\in c\label{eq:ax_obs_std1}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
What about sensing information? We can extend the 
\noun on
Observations
\noun default
 sort to contain 
\begin_inset Formula $<Action,Result>$
\end_inset

 pairs and axiomatise like so:
\begin_inset Formula \begin{equation}
<a,r>\in Obs(agt,c,s)\equiv a\in c\wedge SR(a,s)=r\wedge actor(a)=agt\label{eq:ax_obs_std2}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Using these definitions, our new account of knowledge will behave identically
 to the standard account:
\end_layout

\begin_layout Theorem
Suppose 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) as definitions of the 
\begin_inset Formula $Obs()$
\end_inset

 function, then for any situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{std}\models K(agt,s',s)\,\,\,\,\mathrm{iff}\,\,\,\,\Dt\cup\Dt_{K}^{obs}\models K(agt,s',s)\]

\end_inset


\end_layout

\begin_layout Proof
Equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) mean 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

 cannot be empty for 
\begin_inset Formula $c\neq\{\}$
\end_inset

, so 
\begin_inset Formula $s=s'$
\end_inset

 iff 
\begin_inset Formula $s\leq_{\PbU(agt)}s'$
\end_inset

.
 Equations (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) then amount to simple transformations of equations (
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

) respectively, meaning that 
\begin_inset Formula $K$
\end_inset

 behaves the same under both theories.
\end_layout

\begin_layout Standard
We now discuss one straightforward way to generalise this for partial observabil
ity of actions.
 A new action description predicate 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 is used to indicate that agent 
\begin_inset Formula $agt$
\end_inset

 would observe action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 If 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 is false, then that action will be hidden.
 We can then formulate the 
\begin_inset Formula $Obs()$
\end_inset

 function according to:
\begin_inset Formula \[
a\in Obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
There is also a subtle limitation in the standard handling of sensing actions:
 only the agent performing a sensing action can be aware of its result.
 Such a restriction is common but certainly not universal.
 For example, if an agent waiting for a train activates a speaker to determine
 when it will arrive, the result of this sensing action would provide informatio
n to any other agent within earshot.
 To generalize the formalism, an analogous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 is used indicate when sensing information is available to an agent.
 We then include bare action terms in an agent's observations when it observes
 the action but not its result, and 
\emph on

\begin_inset Formula $<Action,Result>$
\end_inset


\emph default
 terms when it also senses the result:
\begin_inset Formula \begin{gather*}
a\in Obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\\
<a,r>\in Obs(agt,c,s)\equiv a\in c\wedge SR(a,s)=r\wedge CanObs(agt,a,s)\wedge CanSense(agt,a,s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We feel that this formulation provides a good balance between simplicity
 and expressiveness; it allows the observability of actions to vary according
 to the state of the world, but provides agents with a complete description
 of each action that they are capable of observing.
 In Section 
\begin_inset LatexCommand ref
reference "sub:An-Illustrative-Example"

\end_inset

 we show how to use this formalism to model a domain in which agents can
 only observe actions performed in the same room as them.
 To show the flexibility of the observation-based approach, Section 
\begin_inset LatexCommand ref
reference "sub:Observing-Effects"

\end_inset

 outlines a more powerful axiomatisation of observations in which agents
 may know that some action has occurred without necessarily knowing precisely
 what the action was.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The final aspect of our new account of knowledge is to extend the techniques
 for effective reasoning in the situation calculus to handle the modified
 formalism.
 The appearance of 
\begin_inset Formula $\leq_{\PbU(agt)}$
\end_inset

 in equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) means that our new successor state axiom universally quantifies over situation
s, so standard regression techniques cannot be used.
 We must appeal to the persistence condition meta-operator to transform
 this quantification into a uniform formula, so that regression can be applied.
\end_layout

\begin_layout Standard
We propose the following definition for the regression of 
\begin_inset Formula $\Knows$
\end_inset

 under our formalism:
\begin_inset Formula \begin{align}
\Reg(\Knows(agt,\phi),c)\isdef\,\, & \exists o:\, Obs(agt,c,s)=o\nonumber \\
 & \wedge\,\left[o=\{\}\,\rightarrow\,\Knows(agt,\phi)\right]\nonumber \\
 & \wedge\,\left[o\neq\{\}\,\rightarrow\,\Knows(agt,\forall c':\, Obs(agt,c')=o\right.\nonumber \\
 & \,\,\,\,\,\,\,\,\,\,\,\wedge Poss(c')\rightarrow\left.\Reg(\Pst(\phi,\PbU(agt),c')))\right]\label{eqn:R_do_c_s}\end{align}

\end_inset

 As required for a regression rule, this can reduce a knowledge query at
 
\begin_inset Formula $do(c,s)$
\end_inset

 to a knowledge query at 
\begin_inset Formula $s$
\end_inset

.
 It is also intuitively appealing: to know that 
\begin_inset Formula $\phi$
\end_inset

 holds, the agent must know that in all situations that agree with its observati
ons, 
\begin_inset Formula $\phi$
\end_inset

 cannot become false without it making an observation (this is the meaning
 of 
\begin_inset Formula $\Pst(\phi,\PbU(agt))$
\end_inset

 evaluated at 
\begin_inset Formula $do(c',s)$
\end_inset

 in the above).
\end_layout

\begin_layout Standard
We must also specify the regression of 
\begin_inset Formula $\Knows$
\end_inset

 in the initial situation, as equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) also uses the 
\begin_inset Formula $\leq_{\PbU(agt)}$
\end_inset

 ordering.
 This clause produces an expression in 
\begin_inset Formula $\KnowsZ$
\end_inset

 at 
\begin_inset Formula $S_{0}$
\end_inset

, meaning that it can be handled by epistemic reasoning about the initial
 situation only:
\begin_inset Formula \begin{equation}
\Reg(\Knows(agt,\phi,S_{0}))\,\isdef\,\KnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\label{eqn:R_s0}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We can thus handle knowledge queries using regression, the standard technique
 for effective reasoning in the situation calculus.
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Reg_Knows"

\end_inset

Given a basic action theory 
\begin_inset Formula $\Dt\cup\Dt_{K,obs}$
\end_inset

 and a uniform formula 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\phi[do(c,s)]\equiv\Reg(\phi,c)[s]\]

\end_inset

 
\end_layout

\begin_layout ProofSketch
We need only consider the case of 
\begin_inset Formula $\phi=\Knows(agt,\phi,s)$
\end_inset

.
 In the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, we proceed by expanding the definition for 
\begin_inset Formula $\Knows$
\end_inset

 using our new successor state axiom for 
\begin_inset Formula $K$
\end_inset

, collecting sub-formulae that match the form of the 
\begin_inset Formula $\Knows$
\end_inset

 macro, and using regression and the persistence condition to render the
 resulting knowledge expressions uniform in 
\begin_inset Formula $s$
\end_inset

.
 In the base case, applying the persistence condition to an expansion of
 
\begin_inset Formula $\Knows$
\end_inset

 at the initial situation completes the proof.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
While this reasoning method is suitable for modelling and simulation purposes,
 it would be unreasonable for a situated agent to ask 
\begin_inset Quotes eld
\end_inset

do I know 
\begin_inset Formula $\phi$
\end_inset

 in the current situation?
\begin_inset Quotes erd
\end_inset

 using the situation calculus query 
\begin_inset Formula $\Dt\models\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as it cannot be expected to have the full current situation 
\begin_inset Formula $s$
\end_inset

.
 However, it will have its current view 
\begin_inset Formula $v$
\end_inset

.
 We define knowledge with respect to a view as follows:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,v)\,\isdef\,\forall s:\, View(agt,s)=v\wedge root(s)=S_{0}\rightarrow\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
It is a straightforward consequence of Theorem 
\begin_inset LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 that this form of knowledge is equivalent to knowledge based on a situation
 term having that view and rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
 Extending the regression rules in equations (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

) to handle formulae of this form is actually simpler than for regression
 over situations, as there are no empty observations in a history.
 The result is:
\begin_inset Formula \begin{align*}
\Reg(\mathbf{Knows}(agt,\phi,o\cdot v))\isdef\,\, & \mathbf{Knows}(agt,\forall c:\, Obs(agt,c)=o\\
 & \,\,\,\,\,\,\,\,\wedge Poss(c)\rightarrow\Reg(\Pst(\phi,\PbU(agt)),c),v)\\
\Reg(\mathbf{Knows}(agt,\phi,\epsilon))\isdef\,\, & \KnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Using regression in this way, agents can reason about their own knowledge
 using only their local information.
 Our work thus makes it possible to include a situation calculus model in
 the implementation of a real-world multi-agent system, even when agents
 have only partial awareness of the actions being performed.
\end_layout

\begin_layout Standard
It is worth re-iterating that this regression rule is no longer a straightforwar
d syntactic transformation - rather, it involves a fixpoint calculation
 using static domain reasoning to generate 
\begin_inset Formula $\Pst(\phi,\PbU(agt))$
\end_inset

.
 Can this really be considered an effective reasoning technique? Our previous
 work on the persistence condition meta-operator 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

 discusses the advantages of this approach in detail.
 The primary advantage is that this form of reasoning can be performed at
 all, as the alternative is second-order theorem proving.
 In general, the calculation of the persistence condition can be made more
 effective by providing:
\end_layout

\begin_layout Itemize
More effective static-domain reasoning.
 For example, many domains may be propositional, finitary, or otherwise
 lend themselves to more effective reasoning techniques than a full first-order
 theorem prover
\end_layout

\begin_layout Itemize
Simpler axiomatisations of 
\begin_inset Formula $Obs()$
\end_inset

.
 The simpler the formulae produced by expanding the definition of 
\begin_inset Formula $\PbU(agt)$
\end_inset

, the fewer iterations will be needed for the fixpoint calculation to terminate.
\end_layout

\begin_layout Standard
Of course, the ultimate proof is in the implementation.
 We have implemented a preliminary version of our technique and used it
 to verify (and in more complex cases, to generate) the examples found in
 the following section.
 The code is available for download from the author's website.
\begin_inset Foot
status collapsed

\begin_layout Standard
http://www.csse.unimelb.edu.au/~rfk/
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
An Illustrative Example
\begin_inset LatexCommand label
name "sub:An-Illustrative-Example"

\end_inset


\end_layout

\begin_layout Standard
Consider again the example domain of the party invitation.
 The fluents of interest are the location of the party (
\begin_inset Formula $loc$
\end_inset

) and whether each agent is in the room (
\begin_inset Formula $InRoom$
\end_inset

).
 The action 
\begin_inset Formula $read$
\end_inset

 reads the invitation and returns the location of the party, while the non-sensi
ng actions 
\begin_inset Formula $enter$
\end_inset

 and 
\begin_inset Formula $leave$
\end_inset

 cause the agents to move in/out of the room.
 The 
\begin_inset Formula $read$
\end_inset

 action is only observed by agents in the room.
 This domain can be summarized by the following axioms:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather*}
loc(S_{0})=C\\
loc(do(c,s))=l\equiv loc(s)=l\\
\\InRoom(Ann,S_{0})\equiv InRoom(Bob,S_{0})\equiv true\\
InRoom(agt,do(c,s))\equiv enter(agt)\in c\,\vee\, InRoom(agt,s)\wedge leave(agt)\notin c\\
Poss(enter(agt),s)\equiv\neg InRoom(agt,s)\\
Poss(leave(agt),s)\equiv InRoom(agt,s)\\
\\Poss(read(agt),s)\equiv InRoom(agt,s)\\
SR(read(agt),s)=r\equiv r=loc(s)\\
\\\forall l:\,\neg\KnowsZ(Ann,loc=l,S_{0})\,\wedge\,\neg\KnowsZ(Bob,loc=l,S_{0})\\
\KnowsZ(Ann,loc=C\vee loc=D,S_{0})\wedge\KnowsZ(Bob,loc=C\vee loc=D,S_{0})\\
\\CanObs(agt_{1},leave(agt_{2}),s)\equiv CanObs(agt_{1},enter(agt_{2}),s)\equiv true\\
CanObs(agt_{1},read(agt_{2}),s)\equiv InRoom(agt_{1},s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The following are examples of knowledge queries that can be posed in our
 formalism, a brief explanation of their outcome, and a demonstration of
 how they can be answered using regression.
 Appendix 
\begin_inset LatexCommand ref
reference "sec:Execution-Traces"

\end_inset

 shows the full ouput of our reasoning engine running each example.
\end_layout

\begin_layout Example
Initially, Ann doesn't know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\neg\exists l:\,\mathbf{Knows}(Ann,loc=l,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Example
Initially, Bob knows that Ann doesn't know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\mathbf{Knows}(Bob,\neg\exists l:\,\Knows(Ann,loc=l),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Example
After reading the invitation, Bob knows where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\Knows(Bob,loc=C,do(\{read(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Example
After leaving, Bob doesn't know that Ann doesn't know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\mathbf{\neg Knows}(Bob,\neg\exists l:\,\Knows(Ann,loc=l),do(\{leave(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Subsection
Observing the Effects of Actions
\begin_inset LatexCommand label
name "sub:Observing-Effects"

\end_inset


\end_layout

\begin_layout Standard
In many domains it would be infeasible for an agent to observe a particular
 action occurring, but it may be able to observe some of the effects of
 that action.
 For example, suppose that an agent monitors the state of a light in its
 environment, such that it notices it changing from dark to light.
 While it knows that 
\emph on
some
\emph default
 action must have occurred to produce that effect, it may not be sure precisely
 what action took place (e.g.
 precisely 
\emph on
who
\emph default
 turned on the light).
\end_layout

\begin_layout Standard
This can be modelled by further extending the 
\noun on
Observations
\noun default
 sort.
 Suppose that the observation term 
\begin_inset Formula $f_{\phi}$
\end_inset

 indicates that a particular property of the world 
\begin_inset Formula $\phi$
\end_inset

 has changed from false to true and (for simplicity) that this information
 would be available to all agents.
 The following could be used to include this information in an agent's observati
ons:
\begin_inset Formula \[
f_{\phi}\in Obs(agt,c,s)\equiv\neg\phi[s]\wedge\Reg(\phi[do(c,s)])\]

\end_inset

 
\end_layout

\begin_layout Standard
Note that since 
\begin_inset Formula $Obs()$
\end_inset

 is an action description predicate, we must use regression to ensure that
 the right-hand side of this equivalence refers only to 
\begin_inset Formula $s$
\end_inset

.
 Expanding on the example of the light, we might have an axiom like this:
\begin_inset Formula \[
lightCameOn\in Obs(agt,c,s)\equiv\neg lightIsOn(s)\wedge\exists agt_{2}:\, turnLightOn(agt_{2})\in c\]

\end_inset


\end_layout

\begin_layout Standard
When the light is switched on, each agent's observation set will contain
 
\begin_inset Formula $lightCameOn$
\end_inset

, and they will know that this change has occurred without necessarily knowing
 the specific action responsible for the change.
 That this powerful new ability is a straightforward extension of our approach
 highlights the flexibility and robustness of the observation-based semantics.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
In this section, we have first developed a principled axiomatisation of
 the observability of actions, using the notion of observations and views
 as analogues of actions and situations that are localised to an individual
 agent.
 This terminology has been deliberately chosen to coincide with similar
 concepts in other formalisations of knowledge, such as the well-known treatise
 of 
\begin_inset LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

.
 Using these new concepts, we are able to give a succinct definition of
 the dynamics of the knowledge fluent and prove that its behaviour matches
 the expected behaviour of knowledge.
\end_layout

\begin_layout Standard
As an example of why this is important, consider one of the few existing
 formulations of knowledge in the situation calculus that allows for hidden
 actions, that of 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

.
 Their successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent is as follows:
\begin_inset Formula \begin{align*}
K(agt,s'',do(a,s))\equiv\,\,\, & \exists s':\, K(agt,s',s)\\
 & \wedge\,(actor(a)\neq agt\,\rightarrow\, s'\leq_{actor(a)\neq agt}s''))\\
 & \wedge\,(actor(a)=agt\,\rightarrow\,\exists s^{*}:\,\left[s'\leq_{actor(a)=agt}s^{*}\wedge\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\left.s''=do(a,s^{*})\wedge Poss(a,s^{*})\wedge sr(a,s)=sr(a,s^{*}))\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Standard
In this case agents are only aware of the actions that they themselves perform,
 and they consider possible an arbitrary sequence of hidden actions preceding
 each action of their own.
 However, this formulation has a subtle problem: an agent's knowledge can
 change in response to actions performed by others.
 Suppose that 
\begin_inset Formula $agt$
\end_inset

 has just performed action 
\begin_inset Formula $a_{1}$
\end_inset

, so the world is in situation 
\begin_inset Formula $do(a_{1},s)$
\end_inset

.
 Another agent then performs the action 
\begin_inset Formula $a_{2}$
\end_inset

, leaving the world in situation 
\begin_inset Formula $do(a_{2},do(a_{1},s))$
\end_inset

.
 Since it is not aware of the occurrence of 
\begin_inset Formula $a_{2}$
\end_inset

, the knowledge of 
\begin_inset Formula $agt$
\end_inset

 should be unchanged between these two situations.
 This is not the case under the formulation of 
\begin_inset LatexCommand citeauthor
key "Lesperance99sitcalc_approach"

\end_inset

.
 By explicitly formalising the notion of a view, our framework avoids such
 problems.
\end_layout

\begin_layout Standard
A further advantage of our explicit axiomatisation of observations is in
 establishing properties of the knowledge relation.
 A major theorem of 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 states that if the 
\begin_inset Formula $K$
\end_inset

-relation is reflexive, symmetric or transitive at the initial situation,
 then its has that property at every situation.
 In our formulation these are all simple corollaries of Theorem 
\begin_inset LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

.
\end_layout

\begin_layout Standard
We have demonstrated that our formalism is expressive enough to capture
 the standard account of knowledge based on public actions, as well as more
 complex formulations where the observability of actions depends on the
 state of the world.
 We have also demonstrated that despite allowing for arbitrarily-long sequences
 of hidden actions, our formalism still permits automated reasoning for
 handling knowledge queries, including a preliminary implementation of such
 a reasoning system.
\end_layout

\begin_layout Standard
In conclusion, our new observation-based semantics provides a powerful account
 of knowledge suitable both for reasoning 
\emph on
about
\emph default
, and reasoning 
\emph on
in
\emph default
, rich multi-agent domains.
\end_layout

\begin_layout Section
Complex Epistemic Modalities
\begin_inset LatexCommand label
name "sec:Complex-Epistemic-Modalities"

\end_inset


\end_layout

\begin_layout Standard
So far we have constructed a powerful new account of 
\emph on
individual 
\emph default
knowledge in rich multi-agent domains.
 To be truly useful in a multi-agent setting, our formalism must also support
 reasoning about group-level knowledge and, in particular, about common
 knowledge.
 The primary motivation for this section is a formal treatment of common
 knowledge within our framework, but as we shall see, this requires significant
 technical machinery capable of handling much more general epistemic modalities.
\end_layout

\begin_layout Subsection
Group-Level Modalities
\end_layout

\begin_layout Standard
We briefly review the various group-level epistemic modalities commonly
 found in the literature; an excellent overview and discussion can be found
 in the work of 
\begin_inset LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

.
 Let 
\begin_inset Formula $G$
\end_inset

 be a finite group of agents.
 The basic group-level modality is 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

, which is defined as:
\begin_inset Formula \[
\EKnows(G,\phi,s)\isdef\forall agt\in G:\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $G$
\end_inset

 is a finite set, this can be written equivalently as:
\begin_inset Formula \[
\mathbf{EKnows}(G,\phi,s)\,\isdef\,\bigwedge_{agt\in G}\,\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
To assert more complete knowledge by members of the group, one can say 
\begin_inset Quotes eld
\end_inset

everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 by nesting 
\begin_inset Formula $\mathbf{EKnows}$
\end_inset

 operators.
 In general:
\begin_inset Formula \begin{gather*}
\mathbf{EKnows}^{1}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\phi,s)\\
\mathbf{EKnows}^{n}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\mathbf{EKnows}^{n-1}(G,\phi),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The higher the value of 
\begin_inset Formula $n$
\end_inset

, the stronger an assertion is made about the knowledge of the group.
 The strongest group-level modality is 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Intuitively this indicates that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, and so on ad infinitum.
 Formally, it can be defined as the infinite conjunction:
\begin_inset Formula \[
\mathbf{CKnows}(G,\phi,s)\,\isdef\,\bigwedge_{n\in\mathbb{N}}\mathbf{EKnows}^{n}(G,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Equivalently, it can be defined as a fixpoint or transitive closure of the
 
\begin_inset Formula $\EKnows$
\end_inset

 relation.
 Common knowledge is an extremely powerful form of knowledge that has deep
 implications for coordinated group behaviour.
 For example, in the famous 
\begin_inset Quotes eld
\end_inset

Coordinated Attack
\begin_inset Quotes erd
\end_inset

 problem, the proof that the generals cannot coordinate an attack depends
 heavily on their inability to obtain common knowledge 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
\end_layout

\begin_layout Subsection
Reasoning about Common Knowledge
\end_layout

\begin_layout Standard
Existing treaments of common knowledge in the situation calculus and related
 literature specify it as the transitive closure of 
\begin_inset Formula $\EKnows$
\end_inset

 using an explicit second-order axiom 
\begin_inset LatexCommand citep
key "davis05fo_ma_theory,ghaderi07sc_joint_ability"

\end_inset

.
 While logically sound, this approach forgoes the use of regression as an
 effective reasoning technique.
 Indeed, reasoning in such formalisms requires a second-order theorem prover,
 hardly an attractive prospect.
\end_layout

\begin_layout Standard
This difficulty in effectively handling common knowledge can be attributed
 to a famous result from the related field of dynamic epistemic logic:
\end_layout

\begin_layout Quote
Epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone 
\begin_inset LatexCommand cite
key "baltag98pa_ck"

\end_inset


\end_layout

\begin_layout Standard
In our terminology: given a formula 
\begin_inset Formula $\CKnows(G,\phi,do(c,s))$
\end_inset

, it is impossible in general to find an equivalent formula 
\begin_inset Formula $\CKnows(G,\psi,s)$
\end_inset

.
 It is thus impossible to formulate a regression rule for common knowledge
 using only the 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\CKnows$
\end_inset

 operators.
\end_layout

\begin_layout Standard
Given the deep similarities between the situation calculus and epistemic
 modal logic 
\begin_inset LatexCommand citep
key "vanbentham07ml_sitcalc"

\end_inset

, we can be confident that this expressivity limitation also holds in the
 situation calculus.
 To see why...TODO: demo of why this is the case, by regressing nested knowledge
 operators
\end_layout

\begin_layout Standard
To overcome this limitation, we follow the recent promising work of 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

, who use two important new ideas to produce a regression rule for common
 knowledge in their logic LCC:
\end_layout

\begin_layout Itemize
form more expressive epistemic modalities using the syntax of dynamic logic,
 interpreted epistemically
\end_layout

\begin_layout Itemize
apply regression within the modality as well as to the enclosed formula
\end_layout

\begin_layout Standard
We apply these ideas to perform epistemic reasoning in the situation calculus,
 allowing common knowledge to be handled using regression.
 While the development naturally parallels that of LCC, the much richer
 ontology of the situation calculus means there are also substantial differences.
 In particular:
\end_layout

\begin_layout Itemize
LCC is 
\emph on
propositional
\emph default
: actions do not take arguments, there are finitely many actions, and no
 quantification is required.
\end_layout

\begin_layout Itemize
LCC is 
\emph on
synchronous
\emph default
:
\emph on
 
\emph default
reasoning is performed by regressing one action at a time, without the 
\begin_inset Quotes eld
\end_inset

all possible futures
\begin_inset Quotes erd
\end_inset

 approach needed to handle hidden actions.
\end_layout

\begin_layout Standard
By contrast, our formalism must capture first-order preconditions and effects,
 quantifying-in and de-dicto/de-re, and arbitrary sets of concurrent actions,
 while incorporating our new technique for handling hidden actions.
 For a more detailed comparison of our work with that of 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

, see Section TODO.
\end_layout

\begin_layout Standard
The remAinder of this section proceeds as follows.
 In Section 
\begin_inset LatexCommand ref
reference "sub:Epistemic-Paths"

\end_inset

 we define a variant of first-order dynamic logic for use as an epistemic
 path language, which is encoded in the situation calculus via macro expansion.
 Section 
\begin_inset LatexCommand ref
reference "sub:Synchronous-Epistemic-Fluent"

\end_inset

 develops a synchronous account of complex epistemic modalities, assuming
 that there are no hidden actions.
 We develop regression rules for this version and prove that they respect
 the semantics of the epistemic path language.
 Section 
\begin_inset LatexCommand ref
reference "sub:Introducing-Hidden-Actions"

\end_inset

 introduces hidden actions by explicitly representing them using the empty
 action set, and shows how a fixpoint construction can reason about arbitrarily-
long sequences of hidden actions.
 We then relate our construction back to the results of Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 by showing that in the case of a single agent, this fixpoint construction
 precisely matches that produced by the persistence condition operator in
 equation 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

.
 
\end_layout

\begin_layout Standard
The end result is a powerful account of complex epistemic modalities constructed
 almost entirely in the meta-level reasoning machinery of the situation
 calculus.
 We need only a single new successor state axiom, given below.
\end_layout

\begin_layout Standard
To begin, we extend the notation of Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 and let 
\begin_inset Formula $K_{0}(agt,s'',s)$
\end_inset

 denote the 
\emph on
synchronous
\emph default
 knowledge of an agent in an arbitrary situation 
\begin_inset Formula $s$
\end_inset

.
 This is knowledge when the agent knows how many actions have been performed,
 and so is not required to do any 
\begin_inset Quotes eld
\end_inset

all possible futures
\begin_inset Quotes erd
\end_inset

 style reasoning.
 Given synchronicity, the successor state axiom for this fluent is straightforwa
rd and mirrors the standard account of knowledge in equation 
\begin_inset LatexCommand eqref
reference "eq:k_ssa_standard"

\end_inset

:
\begin_inset Formula \begin{align}
K_{0}(agt,s'',do(c,s))\,\equiv\,\, & \exists s',c':\,\left(s''=do(c',s')\wedge Poss(c',s')\,\,\vee\,\, s''=s'\wedge c'=\{\}\right)\nonumber \\
 & \,\,\,\,\,\wedge Obs(agt,c,s)=Obs(agt,c',s')\wedge K_{0}(agt,s',s)\label{eq:K0_ssa}\end{align}

\end_inset


\end_layout

\begin_layout Standard
The only complication here is handling the empty action 
\begin_inset Formula $\{\}$
\end_inset

.
 When 
\series bold

\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset


\series default
 then 
\begin_inset Formula $c'$
\end_inset

 is allowed to be 
\begin_inset Formula $\{\}$
\end_inset

, and the agent considers it possible that no action was performed (i.e.
 
\begin_inset Formula $s''=s'$
\end_inset

).
 Suppose that 
\begin_inset Formula $s$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 action occurrences, then under this formulation the agent considers it
 possible that 
\emph on
at most 
\emph default

\begin_inset Formula $n$
\end_inset

 actions have occurred.
 
\end_layout

\begin_layout Subsection
Epistemic Paths
\begin_inset LatexCommand label
name "sub:Epistemic-Paths"

\end_inset


\end_layout

\begin_layout Standard
Unlike the work of 
\begin_inset LatexCommand citet
key "vanBenthem06lcc"

\end_inset

 with LCC, we cannot use propositional dynamic logic as an epistemic path
 language.
 While we have limited ourselves to finitely many primitive action types,
 our use of concurrent actions means there are potentially infinitely many
 different ways in which the world could change.
 Our action types also take arguments.
 To handle these richer domains we need some form of quantification in our
 epistemic path language; in short, we need 
\emph on
first-order dynamic logic
\emph default
.
 The variant we use is based on the dynamic term-modal logic of 
\begin_inset LatexCommand citet
key "kooi07dyn_termmodal_logic"

\end_inset

, with some simplifications.
\end_layout

\begin_layout Standard
First, we must specify the syntax of our epistemic path language.
 We will use 
\begin_inset Formula $\pi$
\end_inset

 to denote an arbitrary epistemic path expression.
 
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path Let 
\begin_inset Formula $agt$
\end_inset

 be an 
\noun on
Agent 
\noun default
term, 
\begin_inset Formula $\phi$
\end_inset

 a uniform formula and 
\begin_inset Formula $x$
\end_inset

 a variable name, then the epistemic path terms 
\begin_inset Formula $\pi$
\end_inset

 are the smallest set matching the following structural rules:
\begin_inset Formula \[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end_inset


\end_layout

\begin_layout Standard
The test (
\begin_inset Formula $?$
\end_inset

), sequence (
\begin_inset Formula $;$
\end_inset

), choice (
\begin_inset Formula $\cup$
\end_inset

) and transitive closure (
\begin_inset Formula $^{*}$
\end_inset

) operators are standard in dynamic logic and have the same meaning as in
 LCC, except that test formulae can now contain variables that need to be
 interpreted.
 The additional operator 
\begin_inset Formula $\exists x$
\end_inset

 allows the value of a variable to change during path traversal, by non-determin
istically re-binding 
\begin_inset Formula $x$
\end_inset

 to some value.
\end_layout

\begin_layout Standard
In the tradition of the individual-knowledge macro 
\begin_inset Formula $\Knows$
\end_inset

, we develop our epistemic path language entirely at the meta-level as a
 series of macro expansions.
 The full details of this development can be found in Appendix 
\begin_inset LatexCommand ref
reference "sec:Encoding-Dynamic-Logic"

\end_inset

, and would complicate the presentation here.
 Instead, we give a simplified presentation of the semantics of each operator.
\end_layout

\begin_layout Standard
Formulae of first-order dynamic logic are interpreted relative to both a
 
\begin_inset Quotes eld
\end_inset

current world
\begin_inset Quotes erd
\end_inset

 and a 
\begin_inset Quotes eld
\end_inset

current substitution
\begin_inset Quotes erd
\end_inset

 
\begin_inset LatexCommand citep
key "kooi07dyn_termmodal_logic"

\end_inset

.
 We will use 
\begin_inset Formula $\mu$
\end_inset

 to represent a standard first-order substitution, with 
\begin_inset Formula $\varepsilon$
\end_inset

 being the empty substitution.
 Below we present a transition-style semantics over pairs 
\begin_inset Formula $(\mu,s)$
\end_inset

.
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path\InsetSpace ~
Semantics A situation 
\begin_inset Formula $s'$
\end_inset

 is reachable from situation 
\begin_inset Formula $s$
\end_inset

 via epistemic path 
\begin_inset Formula $\pi$
\end_inset

, denoted 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

, according to the following definitions.
 These semantics are encoded using macro expansion as detailed in Appendix
 
\begin_inset LatexCommand ref
reference "sec:Encoding-Dynamic-Logic"

\end_inset

.
\begin_inset Formula \[
\KDo(\pi,s,s')\,\,\equiv\,\,\exists\mu'\,\KTrans(\pi,\varepsilon,s,\mu',s')\]

\end_inset


\begin_inset Formula \begin{gather*}
\KTrans(agt,\mu,s,\mu',s')\,\equiv\,\mu'=\mu\,\wedge\, K_{0}(agt,s',s)\\
\KTrans(?\phi,\mu,s,\mu',s')\,\equiv\, s'=s\,\wedge\,\mu'=\mu\,\wedge\,\mu(\phi)[s]\\
\KTrans(\pi_{1};\pi_{2},\mu,s,\mu',s')\,\equiv\,\exists\mu'',s'':\,\KTrans(\pi_{1},\mu,s,\mu'',s'')\,\wedge\,\KTrans(\pi_{2},\mu'',s'',\mu',s')\\
\KTrans(\pi_{1}\cup\pi_{2},\mu,s,\mu',s')\,\equiv\,\KTrans(\pi_{1},\mu,s,\mu',s')\,\vee\,\KTrans(\pi_{2},\mu,s,\mu',s')\\
\KTrans(\exists x,\mu,s,\mu',s')\,\equiv\,\exists z:\, s'=s\,\wedge\,\mu'=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu,s,\mu',s')\rightarrow\KTrans(\pi^{*},\mu,s,\mu',s')\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Where we use the following abbreviations (standing for 
\begin_inset Quotes eld
\end_inset

reflexive
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

transitive
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

contains
\begin_inset Quotes erd
\end_inset

 respectively) to specify that 
\begin_inset Formula $\pi*$
\end_inset

 is the reflexive transitive closure of 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{align*}
\mathbf{refl}\isdef & \,\, P(\mu,s,\mu,s)\\
\mathbf{tran\isdef} & \,\,\forall\mu_{1},s_{1},\mu_{2},s_{2}:\, P(\mu_{1},s_{1},\mu,s)\wedge\KTrans(\pi,\mu_{2},s_{2},\mu_{1},s_{1})\,\rightarrow\, P(\mu_{2},s_{2},\mu,s)\\
\mathbf{cont}\isdef & \,\,\forall\mu',s':\,\KTrans(\pi,\mu',s',\mu,s)\,\rightarrow\, P(\mu',s',\mu,s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Let us re-iterate: these are 
\emph on
not
\emph default
 axioms to be included in our basic action theory, but are intended only
 to demonstrate the semantics of the epistemic path language and the macro
 
\begin_inset Formula $\KDo$
\end_inset

.
 Paths do not appear in situation calculus terms, but are handled by macro-expan
sion of 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

 into a proper sentence of the situation calculus.
\end_layout

\begin_layout Subsection
A Synchronous Epistemic Fluent
\begin_inset LatexCommand label
name "sub:Synchronous-Epistemic-Fluent"

\end_inset


\end_layout

\begin_layout Standard
At this point it's worth reviewing again the purpose of this path language.
 Despite utilising the syntax of dynamic logic, it is 
\emph on
not
\emph default
 related to actions in any way.
 Rather it expresses complex 
\emph on
epistemic
\emph default
 paths, and is interpreted over the epistemic frame generated by the 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 relations.
 We will be introducing a new macro 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 (read this as 
\begin_inset Quotes eld
\end_inset

Path-Knows
\begin_inset Quotes erd
\end_inset

) to express knowledge using these epistemic paths.
 To make this clear, here is how some different kinds of knowledge would
 be expressed using the standard account of knowledge, and how we intend
 to express them using epistemic paths:
\end_layout

\begin_layout Itemize
Individual Knowledge: 
\begin_inset Formula $\Knows(agt,\phi,s)\,\,\,\,\Rightarrow\,\,\,\,\PKnows(agt,\phi,s)$
\end_inset


\end_layout

\begin_layout Itemize
Nested Knowledge: 
\begin_inset Formula $\Knows(agt_{1},\Knows(agt_{2},\phi),s)\,\,\,\,\Rightarrow\,\,\,\,\PKnows(agt_{1};agt_{2},\phi,s)$
\end_inset


\end_layout

\begin_layout Itemize
Joint Knowledge: 
\begin_inset Formula $\Knows(agt_{1},\phi,s)\,\wedge\,\Knows(agt_{2},\phi,s)\,\,\,\,\Rightarrow\,\,\,\,\PKnows((agt_{1}\cup agt_{2}),\phi,s)$
\end_inset


\end_layout

\begin_layout Itemize
Common Knowledge: 
\begin_inset Formula $\CKnows(G,\phi,s)\,\,\,\,\Rightarrow\,\,\,\,\PKnows((\bigcup_{agt\in G}agt)^{*},\phi,s)$
\end_inset


\end_layout

\begin_layout Standard
In this section, we develop a synchronous version 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 of our path-knowledge operator, building on the synchronous 
\begin_inset Formula $K_{0}$
\end_inset

 relation defined earlier.
 Its definition is straightforward:
\begin_inset Formula \[
\PKnowsZ(\pi,\phi,s)\isdef\forall s':\,\KDo(\pi,s,s')\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
But this macro expands to a complicated second-order formula in the base
 language of the situation calculus.
 As with the case of the basic 
\begin_inset Formula $\Knows$
\end_inset

 macro, we need to treat 
\begin_inset Formula $\PKnowsZ$
\end_inset

 syntactically as a primitive fluent.
 This means we need a regression rule for such expressions.
 It is here that we incorporate the second key idea from LCC - use of a
 syntactic transform to encode the effects of actions within epistemic paths
 as well as in primitive formulae.
 Mirroring LCC, we introduce the meta-operator 
\begin_inset Formula $\Trn$
\end_inset

 for this purpose.
\end_layout

\begin_layout Standard
Let us consider the required operation of 
\begin_inset Formula $\Trn$
\end_inset

 by analogy with the standard regression operator 
\begin_inset Formula $\Reg$
\end_inset

.
 One can think of regression as a 
\begin_inset Quotes eld
\end_inset

pre-encoding
\begin_inset Quotes erd
\end_inset

 of the effects of an action: 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\begin_inset Formula $do(c,s)$
\end_inset

 if and only if 
\begin_inset Formula $\Reg(\phi,c)$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

.
 The path regressor 
\begin_inset Formula $\Trn$
\end_inset

 needs to lift this idea to epistemic paths as follows: there is a 
\begin_inset Formula $\pi$
\end_inset

-path from 
\begin_inset Formula $do(c,s)$
\end_inset

 to 
\begin_inset Formula $do(c',s')$
\end_inset

 if and only if there is a 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

-path from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
\end_layout

\begin_layout Standard
In order to accomplish this task of pre-encoding the effects of actions,
 the path regressor will need to make various assertions about the action
 that is to be performed in each situation traversed by the path.
 In LCC this 
\begin_inset Quotes eld
\end_inset

current action
\begin_inset Quotes erd
\end_inset

 was handled at the meta-level by enumerating each potential action in turn,
 since propositional dynamic logic has no way to express stateful information.
 By moving to first-order dynamic logic, we can use a variable for this
 purpose.
 As well as making the presentation more concise, we avoid the need to resort
 to a Kleene-style argument for handling the iteration operator.
 The basic operation of 
\begin_inset Formula $\Trn$
\end_inset

 will be as follows:
\end_layout

\begin_layout Itemize
introduce a fresh variable 
\begin_inset Formula $x$
\end_inset

 to hold the action to be performed in the current situation
\end_layout

\begin_layout Itemize
at the beginning of the path, bind 
\begin_inset Formula $x$
\end_inset

 to the known action 
\begin_inset Formula $c$
\end_inset


\end_layout

\begin_layout Itemize
at the end of the path, assert that 
\begin_inset Formula $x$
\end_inset

 is the known action 
\begin_inset Formula $c'$
\end_inset

 
\end_layout

\begin_layout Itemize
when the path moves to a new situation, select a new action using 
\begin_inset Formula $\exists x$
\end_inset


\end_layout

\begin_layout Standard
This is accomplished with an auxiliary operator 
\begin_inset Formula $\TrnA(\pi,x)$
\end_inset

, which translates 
\begin_inset Formula $\pi$
\end_inset

 under the assumption that variable 
\begin_inset Formula $x$
\end_inset

 contains the action to be performed in the current situation.
 
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path\InsetSpace ~
Regressor
\begin_inset LatexCommand label
name "def:EpistemicPathRegression"

\end_inset

 The epistemic path regressor 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

 operates according to the definitions below, where 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are fresh variables not appearing in 
\begin_inset Formula $\pi$
\end_inset

 :
\begin_inset Formula \begin{align*}
\Trn(\pi,c,c')\,\isdef\,\, & \exists x\,;\,?x=c\,;\,\TrnA(\pi,x)\,;\,?x=c'\\
\\\TrnA(agt,x)\,\isdef\,\, & \exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\\
\TrnA(?\phi,x)\isdef\,\, & ?\Reg(\phi,x)\\
\TrnA(\exists y,x)\isdef\,\, & \exists y\\
\begin{array}{c}
\TrnA(\pi_{1};\pi_{2},x)\isdef\,\,\end{array} & \TrnA(\pi_{1},x)\,;\,\TrnA(\pi_{2},x)\\
\TrnA(\pi_{1}\cup\pi_{2},x)\isdef\,\, & \TrnA(\pi_{1},x)\cup\TrnA(\pi_{2},x)\\
\TrnA(\pi^{*},x)\isdef\,\, & \TrnA(\pi,x)^{*}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The following theorem states that these definitions behave has desired,
 respecting the semantics of the epistemic paths:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Trn-respects-epi-paths"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\models\,\KDo(\pi,s'',do(c,s))\,\equiv\,\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c=\{\}\right)\wedge\KDo(\Trn(\pi,c,c'),s',s)\end{gather*}

\end_inset


\end_layout

\begin_layout ProofSketch
The proof proceeds by cases, covering each path operator in turn.
 In the case of an individual agent the theorem is a direct consequence
 of equation 
\begin_inset LatexCommand eqref
reference "eq:K0_ssa"

\end_inset

.
 The other operators are straightforward using their semantics as specified
 in 
\begin_inset Formula $\KTrans$
\end_inset

.
\end_layout

\begin_layout Standard
Given that 
\begin_inset Formula $\Trn$
\end_inset

 correctly regresses our epistemic path language, we are free to use it
 to define the regression of a complex epistemic modality.
 We define the regression of a 
\begin_inset Formula $\PKnowsZ$
\end_inset

 expression as follows:
\begin_inset Formula \[
\Reg(\PKnowsZ(\pi,\phi,do(c,s)))\isdef\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Reg_PKnowsZ"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action 
\begin_inset Formula $c$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt_{O}\cup\Dt_{K,obs}\,\models\,\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{gather*}

\end_inset


\end_layout

\begin_layout ProofSketch
The mechanics of this proof mirror that of Theorem 
\begin_inset LatexCommand ref
reference "thm:Reg_Knows"

\end_inset

: expanding the knowledge macro, re-arranging, then collecting terms that
 match the form of 
\begin_inset Formula $\PKnowsZ$
\end_inset

.
 Using the equivalence from Theorem 
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 completes the proof.
\end_layout

\begin_layout Subsection
Introducing Hidden Actions
\begin_inset LatexCommand label
name "sub:Introducing-Hidden-Actions"

\end_inset


\end_layout

\begin_layout Standard
We now have a powerful account of multi-agent knowledge for synchronous
 domains, but it remains to combine this with our handling of arbitrarily-long
 sequences of hidden actions.
 We continue to operate at the meta-level, developing support for hidden
 actions directly in the operation of the regression operator.
\end_layout

\begin_layout Standard
The idea is to use the empty action term 
\begin_inset Formula $\{\}$
\end_inset

 to explicitly represent the notion that 
\begin_inset Quotes eld
\end_inset

nothing happens
\begin_inset Quotes erd
\end_inset

.
 We simulate agents reasoning about hypothetical futures in which they make
 no more observations by inserting these empty actions between each action
 in a situation term.
\end_layout

\begin_layout Definition
Define 
\begin_inset Formula $\mathcal{E}^{n}(s)$
\end_inset

 to be 
\begin_inset Formula $s$
\end_inset

 with 
\begin_inset Formula $n$
\end_inset

 empty actions inserted between each action, as follows:
\begin_inset Formula \begin{align*}
\mathcal{E}^{0}(s)\,\isdef\, & s\\
\mathcal{E}^{1}(S_{0})\,\isdef\, & do(\{\},S_{0})\\
\mathcal{E}^{1}(do(c,s))\,\isdef\, & do(\{\},do(c,\mathcal{E}^{1}(s)))\\
\mathcal{E}^{n}(s)\,\isdef\, & \mathcal{E}^{1}(\mathcal{E}^{n-1}(s))\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The intuition here is that we want 
\begin_inset Formula $\PKnows(\pi,\phi)$
\end_inset

 to hold if 
\begin_inset Formula $\PKnowsZ(\pi,\phi)$
\end_inset

 holds after allowing for any number of empty actions.
 Formally, we want to use the following infinite conjunction as the definition
 of 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

:
\begin_inset Formula \[
\PKnows(\pi,\phi,s)\isdef\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\]

\end_inset


\end_layout

\begin_layout Standard
This section is devoted to establishing the validity of this definition.
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:En_impl_En-1"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

: 
\begin_inset Formula \[
\Dt\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\PKnowsZ(\pi,\phi,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
By a case analysis on the definition of 
\begin_inset Formula $\Trn$
\end_inset

, we determine that that path 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 always contains the path 
\begin_inset Formula $\pi$
\end_inset

.
 Thus any situations reachable by 
\begin_inset Formula $\pi$
\end_inset

 are also reachable by 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

.
 Since 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 is always part of the regression of 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 and 
\begin_inset Formula $\Reg(\phi,\{\})=\phi$
\end_inset

 always, we conclude that 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 implies 
\begin_inset Formula $\PKnowsZ(\Trn(\pi,\{\},\{\}),\phi,s)$
\end_inset

, which implies 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 as required.
\end_layout

\begin_layout Lemma
For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, if there is some 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

 such that:
\begin_inset Formula \[
\Dt\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{n+1}(s))\]

\end_inset

Then:
\begin_inset Formula \[
\Dt\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\,\equiv\,\bigwedge_{m\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))\]

\end_inset


\end_layout

\begin_layout Proof
By lemma 
\begin_inset LatexCommand ref
reference "lem:En_impl_En-1"

\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n+1}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))$
\end_inset

 always.
 So for this hypothesised value of 
\begin_inset Formula $n$
\end_inset

, the implication in the current lemma is in fact an equivalence.
 We then have 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m<n$
\end_inset

, and 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\equiv\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m\geq n$
\end_inset

, which is enough to establish the infinite conjunction as required.
\end_layout

\begin_layout Standard
We can thus replace the infinite conjunction with a fixpoint calculation,
 so we will use the following suggestive notation:
\begin_inset Formula \[
\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(s))\isdef\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\]

\end_inset

 In turn, this allows us to define a regression rule for 
\begin_inset Formula $\PKnows$
\end_inset

, as follows:
\begin_inset Formula \[
\Reg(\PKnows(\pi,\phi,do(c,s)))\,\isdef\,\Reg(\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(do(c,s))))\]

\end_inset


\end_layout

\begin_layout Standard
This equation stands as our final definition of the the 
\begin_inset Formula $\PKnows$
\end_inset

 macro.
\end_layout

\begin_layout Subsection
The Link with Individual Knowledge
\end_layout

\begin_layout Standard
The last remaining link is perhaps most important of all: showing that this
 new account of knowledge actually captures the knowledge of the agents,
 according to the semantics of individual knowledge developed in Section
 
\begin_inset LatexCommand eqref
reference "sec:Obs-Knowledge"

\end_inset

.
 The following theorem establishes this important link, stating that the
 individual knowledge of an agent is the same when using complex epistemic
 modalities as when using ordinary knowledge:
\end_layout

\begin_layout Theorem
For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Theorem
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Theorem
if and only if
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\PKnows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Proof
Begin by considering the sequence of calculations made in regressing 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(s))$
\end_inset

.
 First, we perform some simplification on 
\begin_inset Formula $\Trn(agt,\{\},c')$
\end_inset

:
\begin_inset Formula \begin{align*}
\Trn(agt,\{\},c')=\,\,\, & \exists x\,;\,?x=c\,;\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\\
 & \,\,\,\,\,\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,\,?Obs(agt,x_{a})=z\,;\, x:=c'\\
=\,\,\, & \exists z\,;\,?Obs(agt,\{\})=z\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?Obs(agt,c')=z\\
=\,\,\, & agt\,;\,?Obs(agt,c')=\{\}\wedge\left(Poss(c')\vee c'=\{\}\right)\\
=\,\,\, & agt\,;\,\left(?\PbU(agt,c')\,\cup\, c'=\{\}\right)\end{align*}

\end_inset

 Now we can use this in the regression of 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(s))$
\end_inset

, as follows: 
\begin_inset Formula \begin{align*}
\PKnowsZ(agt,\phi,\mathcal{E}^{1}(s))\equiv\,\, & \forall c':\,\PKnowsZ(\Trn(agt,\{\},c'),\Reg(\phi,c'),s)\\
\equiv\,\, & \PKnowsZ(\exists a'\,;\, agt\,;\,\left(?\PbU(agt,c')\,\cup\, c'=\{\}\right),\Reg(\phi,c'),s)\\
\equiv\,\, & \dots\\
\equiv\,\, & \PKnowsZ(agt,\Pst^{1}(\phi,\PbU(agt)),s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Using the same construction, we can show that in general:
\begin_inset Formula \begin{align*}
\PKnowsZ(agt,\phi,\mathcal{E}^{n}(s))\equiv\,\, & \PKnowsZ(agt,\Pst^{1}(\phi,\PbU(agt)),\mathcal{E}^{n-1}(s))\\
\equiv\,\, & \PKnowsZ(agt,\Pst^{n}(\phi,\PbU(agt)),s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Clearly the fixpoint calculation used to find an 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(agt,\phi,\mathcal{E}^{n+1}(s))$
\end_inset

 is the same as the fixpoint calculation used to find 
\begin_inset Formula $\Pst(\phi,\PbU(agt))$
\end_inset

.
 Therefore, we have:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\PKnows(agt,\phi,do(c,s))\,\equiv\,\PKnowsZ(agt,\Pst(\phi,\PbU(agt)),do(c,s))\]

\end_inset


\end_layout

\begin_layout Proof
Regressing the right-hand side:
\begin_inset Formula \begin{align*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\, & \PKnowsZ(\exists a'\,;\,\Trn(agt;?\neg\phi,a,a'),s)\\
\equiv\,\, & \dots\mathrm{rearrange\, and\, simplify}\dots\\
\equiv\,\, & \exists o:\, Obs(agt,c,s)=o\wedge\,\\
 & \left[o=\{\}\,\rightarrow\,\PKnows(\exists c';agt,\phi,s)\right]\\
 & \wedge\,\left[o\neq\{\}\,\rightarrow\,\PKnows(\exists c';agt,\forall c':\, Obs(agt,c')=o\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\wedge Poss(c')\rightarrow\left.\Reg(\Pst(\phi,\PbU(agt)),c'),s)\right]\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Thus the expressions 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 and 
\begin_inset Formula $\PKnows(agt,\phi,s)$
\end_inset

 are equivalent under out formulation.
 This link is all this is required to validate the additional complex modalities
 - for example, to establish that 
\begin_inset Formula $\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)$
\end_inset

 is equivalent to 
\begin_inset Formula $\CKnows(G,\phi,s)$
\end_inset

 we can now argue as follows: 
\begin_inset Formula $\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)$
\end_inset

 is the transitive closure of the union of 
\begin_inset Formula $\PKnows(a,\phi,s)$
\end_inset

 for 
\begin_inset Formula $a\in G$
\end_inset

, while 
\begin_inset Formula $\CKnows(G,\phi,s)$
\end_inset

 is the transitive closure of the union of 
\begin_inset Formula $\Knows(a,\phi,s)$
\end_inset

 for 
\begin_inset Formula $a\in G$
\end_inset

.
 Since 
\begin_inset Formula $\PKnows(a,\phi,s)$
\end_inset

 is the same relation as 
\begin_inset Formula $\Knows(a,\phi,s)$
\end_inset

, it follows that their transitive closures are also the same.
\end_layout

\begin_layout Subsection
An illustrative Example
\end_layout

\begin_layout Standard
With this technical machinery in place, we are now able to reason about
 the group-level epistemic modalities of a team of agents.
 To demonstrate, we revisit our example domain from Subsection 
\begin_inset LatexCommand ref
reference "sub:An-Illustrative-Example"

\end_inset

.
\end_layout

\begin_layout Example
Initially, it is common knowledge that Ann doesn't know where the party
 is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((Ann\cup Bob)^{*},\neg\exists l:\,\Knows(Ann,loc=l),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Example
After Bob reads the invitation, it is not common knowledge that the party
 is at 
\begin_inset Formula $C$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\not\models\,\PKnows((Ann\cup Bob)^{*},loc=C,do(\{read(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Example
After Bob reads the invitation, is is common knowledge that he knows where
 the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((Ann\cup Bob)^{*},\exists x:\PKnows(Bob,loc=x),do(\{read(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Example
If Alice also reads the invitation, it becomes common knowledge that the
 party is at Cathy's house:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((Ann\cup Bob)^{*},loc=C,do(\{read(Ann)\},do(\{read(Bob)\},S_{0})))\]

\end_inset


\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
In this section we have introduced a technique for representing and reasoning
 about complex epistemic modalities in the situation calculus.
 In order to formulate an effective reasoning procedure, we have had to
 move beyond just 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\CKnows$
\end_inset

 and introduce a powerful epistemic path language based on dynamic logic.
 Mirrorring the development of knowledge for indivudal agents, group-level
 modalities are introduced as macros of the form 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 where 
\begin_inset Formula $\pi$
\end_inset

 is an epistemic path.
 To avoid having to expand these macros during reasoning, we have modified
 the regression operator to treat them as primitive fluents.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Related Work
\begin_inset LatexCommand label
name "sec:Related-Work"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "morgenstern90knowledge"

\end_inset

 - hidden actions, appeals to motivated action theory.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "delgrande01sitcalc_cleudo"

\end_inset

 - shows that common knowledge is useful, but appeals to a (non-existent)
 solution from elsewhere
\end_layout

\begin_layout Standard
clearly the long lineage of 
\begin_inset LatexCommand cite
key "baltag98pa_ck"

\end_inset

, 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

 that have developed the basis of these techniques.
 
\begin_inset LatexCommand cite
key "moss05iter_pal"

\end_inset

 Iterated PAL is undecidable.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "theapa"
bibfiles "../../../library/references"

\end_inset


\newpage

\end_layout

\begin_layout Section
\start_of_appendix
Dynamic Logic via Macro Expansion
\begin_inset LatexCommand label
name "sec:Encoding-Dynamic-Logic"

\end_inset


\end_layout

\begin_layout Standard
This appendix develops an encoding of first-order dynamic logic (hereafter
 denoted 
\begin_inset Quotes eld
\end_inset

FODL
\begin_inset Quotes erd
\end_inset

) into the situation calculus via macro expansion.
 Our encoding is based on embedding FODL into Golog, a programming language
 based on the situation calculus 
\begin_inset LatexCommand citep
key "levesque97golog"

\end_inset

 that has many similarities to dynamic logic.
\end_layout

\begin_layout Standard
This may seem like an unnecessary complication - why not expand FODL directly
 into sentences of the situation calculus? We find the embedding into Golog
 simpler and clearer, and expect many readers familiar with the situation
 calculus will feel likewise.
 As Golog is well-understood, it relieves some our burden of proof in establishi
ng that the embedding works as required.
 Since the semantics of Golog itself it based on macro-expansion, the end-result
 is the the same: sentences of FODL macro-expand into sentences of the situation
 calculus.
 Finally, our modification to Golog so that it is interpreted over epistemic
 frames may further elucidate the intended operation of FODL in this paper.
\end_layout

\begin_layout Standard
First, let us introduce the semantics of Golog.
 In the following, 
\begin_inset Formula $\delta$
\end_inset

 will represent an arbitrary Golog program.
 The semantics are traditionally defined as a macro 
\begin_inset Formula $\mathbf{Do}(\delta,s,s')$
\end_inset

 which stands for 
\begin_inset Quotes eld
\end_inset

it is possible to execute program 
\begin_inset Formula $\delta,$
\end_inset

starting in situation 
\begin_inset Formula $s$
\end_inset

, and ending in situation 
\begin_inset Formula $s'$
\end_inset


\begin_inset Quotes erd
\end_inset

 
\begin_inset LatexCommand citep
key "levesque97golog"

\end_inset

.
 Since we intend to interpret Golog over epistemic frames, we will use the
 macro 
\begin_inset Formula $\EDo$
\end_inset

 to make this distinction clear.
 This requires only one modification to vanilla Golog - the base operators
 are agent terms, rather than actions.
\end_layout

\begin_layout DefinitionLbld
Semantics\InsetSpace ~
of\InsetSpace ~
Epistemic\InsetSpace ~
Golog The semantics of Golog over epistemic frames is
 given by the macro 
\begin_inset Formula $\EDo$
\end_inset

 defined as follows, where 
\begin_inset Formula $P$
\end_inset

 names a predicate symbol:
\begin_inset Formula \[
\delta::=agt\,|\,?\phi\,|\,\delta_{1};\delta_{2}\,|\,\delta_{1}\cup\delta_{2}\,|\,\pi(x)(\delta(x))\,|\,\delta^{*}\,|\,\mathbf{proc}\, P(\vars{x})\,\delta(\vars{x})\,\mathbf{end}\,;\,\delta\,|\, P(\vars{x})\]

\end_inset


\begin_inset Formula \begin{align*}
\EDo(agt,s,s')\,\isdef\,\, & K_{0}(agt,s',s)\\
\EDo(?\phi,s,s')\,\isdef\,\, & s=s'\wedge\phi[s]\\
\EDo(\delta_{1}\,;\,\delta_{2},s,s')\,\isdef\,\, & \exists s'':\,\EDo(\delta_{1},s,s'')\,\wedge\,\EDo(\delta_{2},s'',s')\\
\EDo(\delta_{1}\,\cup\,\delta_{2},s,s')\,\isdef\,\, & \EDo(\delta_{1},s,s')\vee\EDo(\delta_{2},s,s')\\
\EDo(\pi(x)(\delta(x)),s,s')\,\isdef\,\, & \exists x:\,\EDo(\delta(x),s,s')\\
\EDo(\delta^{*},s,s')\,\isdef\,\, & \mathrm{refl.\, trans.\, closure\, of}\,\,\EDo(\delta,s,s')\\
\EDo(P(\vars{x}),s,s')\,\isdef\,\, & P(\vars{x},s,s')\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The final clause identifies a procedure call with arguments 
\begin_inset Formula $\vars{x}$
\end_inset

.
 Defining procedure calls via macro expansion involves a second-order definition
 corresponding to the standard least-fixed-point semantics for recursive
 procedures.
 This operates as follows, taking a list of 
\begin_inset Formula $n$
\end_inset

 procedure definitions followed by a main program invocation:
\begin_inset Formula \begin{multline*}
\EDo(\{\mathbf{proc}\, P_{1}(\vars{v_{1}})\,\delta_{1}\,\mathbf{end}\,;\dots\,;\,\mathbf{proc}\, P_{n}(\vars{v_{n}})\,\delta_{n}\,\mathbf{end}\,;\,\delta_{0}\}\,\isdef\,\\
\forall(P_{1},\dots,P_{n})\left[\bigwedge_{i=1}^{n}\forall s_{1},s_{2},\vars{v_{i}}:\,\EDo(\delta_{i},s_{1},s_{2})\,\rightarrow\,\EDo(P_{i}(\vars{v}_{i}),s_{1},s_{2})\right]\\
\rightarrow\,\,\EDo(\delta_{0},s,s')\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Clearly Golog is a very powerful language, so the question must be asked:
 could we use Golog as our epistemic path language, rather than FODL? Unfortunat
ely not, as Golog has no notion of 
\emph on
state
\emph default
 - while the Golog operator 
\begin_inset Formula $\pi(x)(\delta(x))$
\end_inset

 is similar to the FODL operator 
\begin_inset Formula $\exists x$
\end_inset

, its effect is localised to the contained program 
\begin_inset Formula $\delta(x)$
\end_inset

.
 FODL allows variable assignments to affect the entire remaining program.
\end_layout

\begin_layout Standard
We review the operators and required semantics of FODL for convenience:
\begin_inset Formula \[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end_inset


\begin_inset Formula \[
\KDo(\pi,s,s')\,\,\equiv\,\,\exists\mu'\,\KTrans(\pi,\varepsilon,s,\mu',s')\]

\end_inset


\begin_inset Formula \begin{gather*}
\KTrans(agt,\mu'',s'',\mu,s)\,\equiv\,\mu''=\mu\,\wedge\, K_{0}(agt,s'',s)\\
\KTrans(?\phi,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu\,\wedge\,\mu(\phi)[s]\\
\KTrans(\pi_{1};\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\exists\mu',s':\,\KTrans(\pi_{1},\mu',s',\mu,s)\,\wedge\,\KTrans(\pi_{2},\mu'',s'',\mu',s')\\
\KTrans(\pi_{1}\cup\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\KTrans(\pi_{1},\mu'',s'',\mu,s)\,\vee\,\KTrans(\pi_{2},\mu'',s'',\mu,s)\\
\KTrans(x:=t,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu[x/t]\\
\KTrans(\exists x,\mu'',s'',\mu,s)\,\equiv\,\exists z:\, s''=s\,\wedge\,\mu''=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu'',s'',\mu,s)\rightarrow\KTrans(\pi^{*},\mu'',s'',\mu,s)\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Note that the semantics of FODL explicitly use first-order substitutions
 to manage stateful variables.
 In order to simulate this via macro expansion, we use what is essentially
 a continuation-passing transformation to avoid explicitly mentioning substituti
ons.
\end_layout

\begin_layout Standard
First, note that any epistemic path 
\begin_inset Formula $\pi$
\end_inset

 will be contain only a finite number of FODL variables.
 Without loss of generality, suppose that 
\begin_inset Formula $\pi$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 such variables named 
\begin_inset Formula $x_{1}$
\end_inset

 to 
\begin_inset Formula $x_{n}$
\end_inset

.
 The idea is to translate each component of the path into a Golog procedure
 with 
\begin_inset Formula $n$
\end_inset

 arguments, where the 
\begin_inset Formula $i$
\end_inset

th argument is used to pass in the current value of 
\begin_inset Formula $x_{i}$
\end_inset

.
 After performing the necessary operations to encode the semantics of that
 path component, it calls a continuation procedure containing the next path
 component.
 This translation is based on the macro 
\begin_inset Formula $\KDo_{cps}(\pi,N,C)$
\end_inset

 which is passed the name of the procedure for the given path component
 (
\begin_inset Formula $N$
\end_inset

) and the name of the continuation procedure (
\begin_inset Formula $C$
\end_inset

).
\end_layout

\begin_layout DefinitionLbld
Embedding\InsetSpace ~
FODL\InsetSpace ~
into\InsetSpace ~
Golog The embedding of FODL into Golog is given by the
 macros 
\begin_inset Formula $\KDo$
\end_inset

 and 
\begin_inset Formula $\KDo_{cps}$
\end_inset

 defined as follows, where 
\begin_inset Formula $P_{i}$
\end_inset

 are fresh procedure names and 
\begin_inset Formula $\vars{v}$
\end_inset

 are argument vectors of length 
\begin_inset Formula $n$
\end_inset

:
\begin_inset Formula \begin{align*}
\KDo(\pi,s,s')\,\isdef\,\,\  & \EDo(\{\KDo_{cps}(\pi,P,Nil)\,;\,\mathbf{proc}\, Nil(\vars{v})\,?\top\,\mathbf{end}\,;\,\pi(\vars{v})(P(\vars{v}))\},s,s')\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{align*}
\KDo_{cps}(agt,N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\, agt\,;\, C(\vars{v})\,\mathbf{end}\\
\KDo_{cps}(?\phi(\vars{x}),N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,?\phi(\vars{v})\,;\, C(\vars{v})\,\ \mathbf{end}\\
\KDo_{cps}(\exists x_{i},N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,\pi(x)(C(\vars{v}[v_{i}/x]))\,\mathbf{end}\\
\KDo_{cps}(\pi_{1};\pi_{2},N,C)\,\isdef\,\, & \KDo_{cps}(\pi_{1},N,P)\,;\,\KDo_{cps}(\pi_{2},P,C)\\
\KDo_{cps}(\pi_{1}\cup\pi_{2},N,C)\,\isdef\,\, & \KDo_{cps}(\pi_{1},P_{1},C)\,;\,\KDo_{cps}(\pi_{2},P_{2},C)\,;\,\mathbf{proc}\, N(\vars{v})\, P_{1}(\vars{v})\cup P_{2}(\vars{v})\,\mathbf{end}\\
\KDo_{cps}(\pi^{*},N,C)\,\isdef\,\, & \KDo_{cps}(\pi,P,N)\,;\,\mathbf{proc}\, N(\vars{v})\, C(\vars{v})\cup P(\vars{v})\,\mathbf{end}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Most of these definitions are straightforward translations of equivalent
 operators in FODL to Golog.
 The interesting cases are 
\begin_inset Formula $\exists x_{i}$
\end_inset

, which simply calls the continuation procedure with a fresh variable in
 position 
\begin_inset Formula $i$
\end_inset

, and 
\begin_inset Formula $\pi^{*}$
\end_inset

 which uses recursion to simulate iteration.
\end_layout

\begin_layout Section
Complete Proofs
\begin_inset LatexCommand label
name "sec:Complete-Proofs"

\end_inset


\end_layout

\begin_layout Standard
This appendix contains complete proofs for various lemmas and theorems throughou
t the paper, along with some additional lemmas.
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, Legal(s)\wedge s\leq_{\PbU(agt)}s'\,\rightarrow\, Legal(s')\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, since 
\begin_inset Formula $\PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Legal$
\end_inset

 is equivalent to 
\begin_inset Formula $\leq_{Poss}$
\end_inset

.
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, s\leq_{\PbU(agt)}s'\,\rightarrow\, View(agt,s')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, by induction on the definition of 
\begin_inset Formula $view$
\end_inset

 from equation (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

).
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-root"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, K(agt,s'',s)\,\rightarrow\, K(agt,root(s''),root(s))\]

\end_inset


\end_layout

\begin_layout Proof
Trivial in the base case.
 For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, suppose that 
\begin_inset Formula $K(agt,s'',do(c,s))$
\end_inset

.
 Then by equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) there is some 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $s'\sqsubseteq s''$
\end_inset

 and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 Then 
\begin_inset Formula $root(s'')$
\end_inset

 = 
\begin_inset Formula $root(s')$
\end_inset

, and 
\begin_inset Formula $K(root(s'),root(s))$
\end_inset

 by the inductive hypothesis.
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, K(agt,s'',s)\,\rightarrow\, Legal(s'')\]

\end_inset


\end_layout

\begin_layout Proof
All 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 are initial and therefore legal.
 So in the base case we have 
\begin_inset Formula $s'\leq_{\PbU(agt)}s''$
\end_inset

 by equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

), making 
\begin_inset Formula $s''$
\end_inset

 is legal by lemma 
\begin_inset LatexCommand ref
reference "lem:pbu-implies-legal"

\end_inset

.
 
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) ensures that 
\begin_inset Formula $do(c',s')\leq_{\PbU(agt)}s''$
\end_inset

 for some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $c'$
\end_inset

 satisfying 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 and 
\begin_inset Formula $Poss(c',s')$
\end_inset

.
 Since 
\begin_inset Formula $s'$
\end_inset

 is legal by the inductive hypothesis, 
\begin_inset Formula $s''$
\end_inset

 must be legal.
 
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, K(agt,s'',s)\,\rightarrow View(agt,s'')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the base case, there must be an 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $Init(s')$
\end_inset

 and 
\begin_inset Formula $s'\leq_{\PbU(agt)}s''$
\end_inset

.
 Therefore 
\begin_inset Formula $View(s'')$
\end_inset

 = 
\begin_inset Formula $View(s')$
\end_inset

 = 
\begin_inset Formula $\epsilon$
\end_inset

 = 
\begin_inset Formula $View(s)$
\end_inset

, as required.
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, suppose 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

.
 Then 
\begin_inset Formula $View(agt,do(c,s))$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
= 
\begin_inset Formula $View(agt,s)$
\end_inset

, while equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) gives us 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

, which yields 
\begin_inset Formula $View(agt,s'')$
\end_inset

 = 
\begin_inset Formula $View(agt,s)$
\end_inset

 by the inductive hypothesis.
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $Obs(agt,c,s)\neq\{\}$
\end_inset

, then we have 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $c'$
\end_inset

 such that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $do(c',s')\leq_{\PbU(agt)}s''$
\end_inset

, 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

 = 
\begin_inset Formula $Obs(agt,c',s')$
\end_inset

, and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 By the inductive hypothesis 
\begin_inset Formula $View(agt,s')=View(agt,s)$
\end_inset

, and we have the following: 
\begin_inset Formula $View(agt,s'')$
\end_inset

 = 
\begin_inset Formula $View(agt,do(c',s'))$
\end_inset

 = 
\begin_inset Formula $Obs(agt,c,s)\cdot View(agt,s')$
\end_inset

 = 
\begin_inset Formula $View(agt,do(c,s))$
\end_inset

 as required.
 
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 For any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge View(agt,s'')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the 
\emph on
if
\emph default
 direction, we simply combine lemmas 
\begin_inset LatexCommand ref
reference "lem:K-implies-root"

\end_inset

, 
\begin_inset LatexCommand ref
reference "lem:K-implies-legal"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "lem:K-implies-view"

\end_inset

.
 
\end_layout

\begin_layout Proof
For the 
\emph on
only-if
\emph default
 base case, the 
\begin_inset Formula $\exists s'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) is trivially satisfied by 
\begin_inset Formula $root(s'')$
\end_inset

 and so the equivalence holds.
\end_layout

\begin_layout Proof
For the 
\emph on
only-if
\emph default
 inductive case with 
\begin_inset Formula $do(c,s)$
\end_inset

, we have two sub-cases to consider.
 Suppose 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

: then 
\begin_inset Formula $View(agt,s'')$
\end_inset

 = 
\begin_inset Formula $View(agt,do(c,s))$
\end_inset

 = 
\begin_inset Formula $View(agt,s)$
\end_inset

 and 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 holds by the inductive hypothesis, satisfying the equivalence in equation
 (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

).
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $Obs(agt,c,s)\neq\{\}$
\end_inset

: then we have:
\begin_inset Formula \[
View(agt,do(c,s))=Obs(agt,c,s)\cdot View(agt,s)=View(agt,s'')\]

\end_inset

For this to be the case, and since 
\begin_inset Formula $s''$
\end_inset

 is legal, there must be some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $c'$
\end_inset

 satisfying 
\begin_inset Formula $Obs(agt,c',s')$
\end_inset

 = 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

, 
\begin_inset Formula $View(agt,s')$
\end_inset

 = 
\begin_inset Formula $View(agt,s)$
\end_inset

 and 
\begin_inset Formula $do(c',s')\leq_{\PbU(agt)}s''$
\end_inset

 .
 This is enough to satisfy the 
\begin_inset Formula $\exists s',a'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) and so the equivalence holds.
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Reg_Knows"

\end_inset

 Given a basic action theory 
\begin_inset Formula $\Dt\cup\Dt_{K,obs}$
\end_inset

 and a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

, it is always the case that:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\phi[do(a,s)]\equiv\Reg(\phi[do(a,s)])\]

\end_inset

 
\end_layout

\begin_layout Proof
We need only consider applications of 
\begin_inset Formula $\Reg$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 has the form 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

, as other regression clauses have not been modified.
 For clarity we define the abbreviation 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s)$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

persists under equivalent observations
\begin_inset Quotes erd
\end_inset

) which states that 
\begin_inset Formula $\phi$
\end_inset

 holds in all legal futures of 
\begin_inset Formula $s$
\end_inset

 compatible with observations 
\begin_inset Formula $o$
\end_inset

:
\begin_inset Formula \begin{multline*}
\mathbf{PEO}(agt,\phi,o,s)\,\isdef\,\\
\forall a':\, Obs(agt,a',s)=o\wedge Poss(a',s)\rightarrow\left[\forall s':\, do(a',s)\leq_{\PbU(agt)}s'\rightarrow\,\phi[s']\right]\end{multline*}

\end_inset

 Combining and rearranging equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) with the definition of the 
\begin_inset Formula $\Knows$
\end_inset

 macro we have:
\begin_inset Formula \begin{align*}
\Knows(agt,\phi,do(a,s))\equiv\, & \exists o\,.\, Obs(agt,a,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\forall s'\,.\, K(agt,s',s)\rightarrow\phi[s']\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\forall s'\,.\, K(agt,s',s)\rightarrow\mathbf{PEO}(agt,\phi,o,s')\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Proof
Noting that both conjuncts contain sub-formulae matching the form of the
 
\begin_inset Formula $\Knows$
\end_inset

 macro, it can be substituted back in to give:
\begin_inset Formula \begin{align*}
\mathbf{Knows}(agt,\phi,do(a,s))\equiv\, & \exists o\,.\, Observations(agt,c,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\mathbf{Knows}(agt,\mathbf{PEO}(agt,\phi,o,s'),s)\right]\end{align*}

\end_inset

 For 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s')$
\end_inset

 to legitimately appear inside the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro it must be uniform in the situation variable 
\begin_inset Formula $s'$
\end_inset

.
 Applying the persistence condition and regressing to make the expression
 uniform, we develop the following equivalence:
\begin_inset Formula \[
\mathbf{PEO}(agt,\phi,o,s)\equiv\forall a':\, Obs(agt,a',s)=o\wedge Poss(a',s)\rightarrow\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,\PbU(agt)),a')\]

\end_inset

 Suppressing the situation term in this uniform formula gives equation (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

) as required.
\end_layout

\begin_layout Proof
For 
\begin_inset Formula $S_{0}$
\end_inset

, a straightforward transformation of equations (
\begin_inset LatexCommand ref
reference "eqn:knows_def"

\end_inset

) and (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) gives:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\left[\forall s'\,.\, s\leq_{\PbU(agt)}s'\rightarrow\phi[s']\right]\]

\end_inset

 Applying the persistence condition operator, this can easily be re-written
 as:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\Pst(\phi,\PbU(agt))[s]\]

\end_inset


\end_layout

\begin_layout Proof
This matches the form of the definition for 
\begin_inset Formula $\KnowsZ$
\end_inset

, which we can substitute in to give:
\begin_inset Formula \[
\Knows(agt,\phi,S_{0})\equiv\KnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Proof
This is equation (
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

), as required.
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\models\,\KDo(\pi,s'',do(c,s))\,\equiv\,\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c=\{\}\right)\wedge\KDo(\Trn(\pi,c,c'),s',s)\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
TODO: complete this proof.
\end_layout

\begin_layout Proof
The proof proceeds by cases, covering each path operator in turn.
 In the case of an individual agent the theorem is a direct consequence
 of equation 
\begin_inset LatexCommand eqref
reference "eq:K0_ssa"

\end_inset

.
 The other operators are straightforward using their semantics as specified
 in 
\begin_inset Formula $\KTrans$
\end_inset

.
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Reg_PKnowsZ"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action 
\begin_inset Formula $c$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\cup\Dt_{P0}\,\models\,\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
TODO: complete this proof.
 
\end_layout

\begin_layout Proof
The mechanics of this proof mirror that of Theorem 
\begin_inset LatexCommand ref
reference "thm:Reg_Knows"

\end_inset

: expanding the knowledge macro, re-arranging, then collecting terms that
 match the form of 
\begin_inset Formula $\PKnowsZ$
\end_inset

.
 Using the equivalence from Theorem 
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 completes the proof.
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout LemmaExt
\begin_inset LatexCommand ref
reference "lem:En_impl_En-1"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

: 
\begin_inset Formula \[
\Dt\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\PKnowsZ(\pi,\phi,s)\]

\end_inset


\end_layout

\begin_layout Proof
TODO: complete this proof.
\end_layout

\begin_layout Proof
By a case analysis on the definition of 
\begin_inset Formula $\Trn$
\end_inset

, we determine that that path 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 always contains the path 
\begin_inset Formula $\pi$
\end_inset

.
 Thus any situations reachable by 
\begin_inset Formula $\pi$
\end_inset

 are also reachable by 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

.
 Since 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 is always part of the regression of 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 and 
\begin_inset Formula $\Reg(\phi,\{\})=\phi$
\end_inset

 always, we conclude that 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 implies 
\begin_inset Formula $\PKnowsZ(\Trn(\pi,\{\},\{\}),\phi,s)$
\end_inset

, which implies 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 as required.
\end_layout

\begin_layout Section
Execution Traces for Example Queries
\begin_inset LatexCommand label
name "sec:Execution-Traces"

\end_inset


\end_layout

\begin_layout Section
TODO
\end_layout

\begin_layout Itemize
justify new notation of regression operator, or fix it
\end_layout

\begin_layout Itemize
re-introduce 
\begin_inset Formula $\Reg^{*}$
\end_inset

 notation, properly
\end_layout

\begin_layout Itemize
fix tuple notation to use a#b consitently
\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\end_body
\end_document
