#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass jair
\begin_preamble

\jairheading{0}{0000}{0-0}{0/0}{0/0}
\ShortHeadings{Common Knowledge, Hidden Actions, and the Frame Problem}{R. F. Kelly \& A. R. Pearce}
\firstpageno{0}
\end_preamble
\options jair,twoside,11pt,theapa,letterpaper
\language english
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Common Knowledge, Hidden Actions, and the Frame Problem
\end_layout

\begin_layout Author
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Ryan F.
 Kelly 
\backslash
email rfk@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Adrian R.
 Pearce 
\backslash
email adrian@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addr Department of Computer Science and Software Engineering
\backslash

\backslash

\end_layout

\begin_layout Standard

The University of Melbourne
\backslash

\backslash

\end_layout

\begin_layout Standard

Victoria, 3010, Australia
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a powerful new account of multi-agent knowledge in the situation
 calculus, and an effective reasoning procedure for knowledge queries.
 A key contribution of our approach is the ability to handle partial observabili
ty, including actions that are completely hidden, by explicitly reifying
 the observations made by each agent as the world evolves.
 We also formally treat complex epistemic modalities such as common knowledge,
 which are not available in the standard account of knowledge in the situation
 calculus.
 By using the persistence condition meta-operator to augment traditional
 regression techniques, we allow agents to effectively reason about knowledge
 using only their internal history of observations, rather than requiring
 a full history of the world.
 The result is a more robust and flexible account of knowledge in the situation
 calculus suitable for use in asynchonrous, partially-observable multi-agent
 domains.
 
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isdef}{\stackrel{\mbox{\tiny def}}{=}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Dt}{\mathcal{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Reg}{\mathcal{R}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Pst}{\mathcal{P}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Trn}{\mathcal{T}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Kln}{\mathcal{K}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EKnows}{\mathbf{EKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Knows}{\mathbf{Knows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\CKnows}{\mathbf{CKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KnowsZ}{\mathbf{Knows_{0}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\vars}[1]{\bar{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\TrnA}{\Trn_{a}}
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In their landmark paper 
\emph on
Knowledge, Action, and the Frame Problem,
\emph default
 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 extend Reiter's solution to the frame problem in the situation calculus
 
\begin_inset LatexCommand citep
key "reiter91frameprob,pirri99contributions_sitcalc"

\end_inset

 to handle knowledge-producing actions and explicit reasoning about the
 knowledge of an agent.
 Extensions to multiple agents 
\begin_inset LatexCommand citep
key "Lesperance01epi_feas_casl"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

 have produced an expressive logic of knowledge, action and change that
 permits an effective reasoning procedure using standard techniques of the
 situation calculus.
\end_layout

\begin_layout Standard
While powerful, the existing account suffers two major limitations that
 make it unsuitable for modelling complex multi-agent domains.
 First, it requires that whenever an action occurs, all agents 
\emph on
know
\emph default
 that an action has occurred.
 This demands a level of synchronicity that is unreasonable in many multi-agent
 domains.
 Second, there is no account of group-level epistemic modalities such as
 common knowledge, which is difficult to formalize effectively in a dynamic
 setting 
\begin_inset LatexCommand citep
key "baltag98pa_ck"

\end_inset

.
 Given the deep connections between common knowledge and coordination, this
 is a serious shortcoming in multi-agent domains.
\end_layout

\begin_layout Standard
In this paper we overcome these limitations by providing:
\end_layout

\begin_layout Itemize
a formal account of 
\emph on
Common Knowledge
\emph default
 and other complex epistemic modalities, including a regression rule for
 reasoning about common knowledge
\end_layout

\begin_layout Itemize
support for 
\emph on
Hidden Actions
\emph default
 and actions that are partially observable, including a reasoning technique
 to deal with arbitrarily-long sequences of hidden actions
\end_layout

\begin_layout Itemize
a solution to the 
\emph on
Frame Problem
\emph default
 for knowledge, built on the successor state axioms for primitive actions,
 maintaining regression as the primary reasoning tool, and allowing agents
 to reason from a local viewpoint rather than an omniscient one
\end_layout

\begin_layout Standard
The result is a rich account of multi-agent knowledge suitable both for
 reasoning 
\emph on
about,
\emph default
 and reasoning 
\emph on
in,
\emph default
 asynchronous, partially-observable multi-agent domains.
 After some introductory material on the situation calculus in Section 
\begin_inset LatexCommand ref
reference "sec:The-Multi-Agent-Situation"

\end_inset

, we develop our new formalism in two parts:
\end_layout

\begin_layout Subsection*
Individual Knowledge with Hidden Actions
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 treats the indivdual knowledge of each agent in the face of hidden actions,
 by decoupling knowledge from the specific actions that have taken place.
 We develop an explicit reification of the 
\emph on
observations
\emph default
 made by each agent as the world evolves, and formulate each agent's knowldge
 in terms of what it has observed.
 Briefly, each occurrence of an action results in an agent making a (possibly
 empty) set of observations.
 Every situation then has a corresponding 
\emph on
view
\emph default
 for each agent: the sequence of observations the agent has made in that
 situation, excluding cases where the set of observations was empty.
 An agent knows something if it is true in all situations matching its current
 view.
\end_layout

\begin_layout Standard
Decoupling knowledge in this manner makes it easy to express various degrees
 of observability of actions, from public actions through to actions that
 are completely hidden.
 This section is a greatly expanded version of our conference paper on the
 same topic 
\begin_inset LatexCommand citep
key "kelly07sc_know_obs"

\end_inset

 and stands as a significant new account of knowledge in its own right.
\end_layout

\begin_layout Standard
The main challenge in this section is dealing with arbitrarily long sequences
 of hidden actions.
 To ensure their knowledge is valid, each agent must take into account all
 future situations compatible with what they have observed.
 However, queries that universally quantify over situations are not supported
 by the standard tools for effective reasoning in the situation calculus.

\emph on
 
\emph default
In previous work we have developed the persistence condition meta-operator
 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

 to support a limited form of universally quantified query.
 Using this operator to augment the regression techniques developed by 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, we maintain their elegant solution to the frame problem despite dealing
 with arbitrarily long sequences of hidden actions.
\end_layout

\begin_layout Standard
We also show how our regression rules can be applied using an agent's individual
 view, rather than requiring a full situation term.
 Agents can thus use our techniques to reason about their own knowledge
 using only their local information, making our formalism suitable both
 for reasoning 
\emph on
about
\emph default
, and reasoning 
\emph on
in
\emph default
,
\emph on
 
\emph default
rich multi-agent domains.
\end_layout

\begin_layout Subsection*
Complex Epistemic Modalities
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sec:Complex-Epistemic-Modalities"

\end_inset

 builds on our account of individual knowledge by introducing complex epistemic
 modalities.
 While the primary motivation is a formal account of common knowledge, we
 are bound by the following expressivity result from modal logic 
\begin_inset LatexCommand citep
key "baltag98pa_ck"

\end_inset

:
\end_layout

\begin_layout Quote
epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone
\end_layout

\begin_layout Standard
In situation calculus terms, this means that the regression of common knowledge
 cannot be defined in terms of common knowledge, but requires a more powerful
 epistemic language.
 Recent advances in dynamic epistemic logic have shown how to overcome this
 restriction, using two key ideas: use dynamic logic as a power expressive
 epistemic path language; and use regression to encode the effects of actions
 within epistemic paths 
\begin_inset LatexCommand citep
key "vanBenthem06lcc"

\end_inset

.
\end_layout

\begin_layout Standard
The original framework for these ideas is the propositional, syncrhonous
 setting of modal logic.
 We adapt them to the much richer formalism of the situation calculus by
 lifting the regression of epistemic paths to first-order logic, and combine
 them with the techniques for handling sequences of hidden actions developed
 in Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

.
 We demonstrate the effectives of our technique with an example of reasoning
 about common knowledge in a partialy-observable domain, a first for the
 situation calculus.
 The result is a truly multi-agent account of knowledge suitable for rich
 multi-agent domains.
\end_layout

\begin_layout Section
The Multi-Agent Situation Calculus
\begin_inset LatexCommand label
name "sec:The-Multi-Agent-Situation"

\end_inset


\end_layout

\begin_layout Standard
Our work utilizes the situation calculus 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 with multiple agents 
\begin_inset LatexCommand citep
key "shapiro01casl_feat_inter"

\end_inset

 and we begin from the standard account of knowledge due to 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

.
 A brief overview is presented below.
 Readers familiar with the situation calculus should note: our generalization
 of the 
\begin_inset Formula $Poss$
\end_inset

 fluent to action description predicates, our use of the single-step variant
 of the regression operator, and the material on the persistence condition
 meta-operator.
\end_layout

\begin_layout Subsection
Notation and Axioms
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting instantaneous events that can cause the state
 of the world to change, with the initiating agent indicated by their first
 argument; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Result
\noun default
 terms represent sensing results returned by actions; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\emph on
Fluents
\emph default
 are predicates or functions that represent properties of the world that
 may change between situations; they take a situation term as their final
 argument.
 An agent's 
\emph on
knowledge
\emph default
 is represented by the macro 
\begin_inset Formula $\Knows$
\end_inset

.
 We call the fluents that are directly affected by actions 
\emph on
primitive 
\emph default
fluents.
 Although it is defined as a macro, 
\begin_inset Formula $\Knows$
\end_inset

 is treated syntactically as a primitive fluent.
\end_layout

\begin_layout Standard
Throughout the paper we will present examples from a simple multi-agent
 domain, a packing facility in which two agents 
\begin_inset Formula $Sam$
\end_inset

 and 
\begin_inset Formula $Max$
\end_inset

 move boxes between a number of rooms.
 Some example formulas from this domain are 
\begin_inset Quotes eld
\end_inset

Sam is holding Box1 initially
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Sam is not holding Box1 after dropping Box1
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

Max knows Sam is holding Box1 initially
\begin_inset Quotes erd
\end_inset

, written formally as:
\begin_inset Formula \begin{gather*}
Holding(Sam,Box1,S_{0})\\
\neg Holding(Sam,Box1,do(drop(Sam,Box1),S_{0}))\\
\Knows(Max,Holding(Sam,Box1),S_{0})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The dynamics of a particuar domain are captured by a set of sentences in
 this logic called a 
\emph on
basic action theory
\emph default
.
 Queries about the behavior of the world are posed as logical entailment
 queries relative to this theory.
\end_layout

\begin_layout DefinitionLbld
Basic\InsetSpace ~
Action\InsetSpace ~
Theory A basic action theory, denoted 
\begin_inset Formula $\Dt$
\end_inset

, is a set of situation calculus sentences (with a specific syntactic form
 outlined below) that describes a particular dynamic world.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); unique names axioms ensuring that action terms are distinct (
\begin_inset Formula $\Dt_{una}$
\end_inset

); action description axioms defining fluents that indicate various properties
 of actions, such as when they can be performed (
\begin_inset Formula $\Dt_{ad}$
\end_inset

); successor state axioms describing how primitive fluents change between
 situations (
\begin_inset Formula $\Dt_{ss}$
\end_inset

); and axioms describing the value of primitive fluents in the initial situation
 (
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{una}\cup\Dt_{ad}\cup\Dt_{ss}\cup\Dt_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
These axioms must satisfy some consistency criteria to constitute a valid
 domain description - consult the work of 
\begin_inset LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

 for the details.
\end_layout

\begin_layout Standard
The ensuing discussion requires the definition of a particular kind of formula
 in this logic: the 
\emph on
uniform formulae
\emph default
 can be thought of as 
\emph on
properties
\emph default
 of the state of the world 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 They are basically logical combinations of primitive fluents referring
 to a common situation term.
\end_layout

\begin_layout DefinitionLbld
Uniform\InsetSpace ~
Formulae Let 
\begin_inset Formula $F$
\end_inset

 be an arbitrary primitive fluent and 
\begin_inset Formula $\vars{x}$
\end_inset

 be terms mentioning no situation term other than 
\begin_inset Formula $s$
\end_inset

.
 Then the formulae uniform in 
\begin_inset Formula $s$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists\vars{x}:\phi\,|\,\forall\vars{x}:\phi\,|\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout to refer to an arbitrary uniform formula.
 Suppose that 
\begin_inset Formula $\phi$
\end_inset

 is uniform in 
\begin_inset Formula $s'$
\end_inset

, then we will use 
\begin_inset Formula $\phi[s]$
\end_inset

 to stand for 
\begin_inset Formula $\phi$
\end_inset

 with every occurrence of 
\begin_inset Formula $s'$
\end_inset

 replace by 
\begin_inset Formula $s$
\end_inset

.
 This notation means that the particular situation term in a uniform formula
 is frequently immaterial, so we will sometimes suppress the situation terms
 to simplify the presentation (e.g.
 using 
\begin_inset Formula $Holding(Sam,Box1)$
\end_inset

 instead of 
\begin_inset Formula $Holding(Sam,Box1,s)$
\end_inset

)
\end_layout

\begin_layout DefinitionLbld
Objective\InsetSpace ~
Formulae The objective formulae are those uniform formulae that
 do not mention the 
\begin_inset Formula $\Knows$
\end_inset

 macro.
\end_layout

\begin_layout Subsubsection*
Unique Names Axioms
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{una}$
\end_inset

 restricts action terms to a finite number of action types, and ensures
 that actions with different types or different arguments are in fact different.
 The function 
\begin_inset Formula $actor(a)$
\end_inset

 gives the agent performing an action, which is always the action's first
 argument.
 In our example domain, actions are of the form 
\begin_inset Formula $pickup(Agent,Box)$
\end_inset

, 
\begin_inset Formula $drop(Agent,Box)$
\end_inset

, and 
\begin_inset Formula $move(Agent,Room)$
\end_inset

.
 In general, we will assume there are 
\begin_inset Formula $n$
\end_inset

 action types named 
\begin_inset Formula $A_{0}(\vars{x})$
\end_inset

 through 
\begin_inset Formula $A_{n-1}(\vars{x})$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Action Description Axioms
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 is traditionally called the 
\emph on
action precondition axioms, 
\emph default
but we will need a more general notion later in the paper so we introduce
 the notation now.
 There is a distinguished fluent predicate 
\begin_inset Formula $Poss(Action,Situation)$
\end_inset

 that indicates whether it is possible to perform an action in a given situation.
 For example, it is only possible for an agent to drop an object if they
 are actually holding it:
\begin_inset Formula \[
Poss(drop(agt,obj),s)\equiv Holding(agt,obj,s)\]

\end_inset

This axiom follows the standard naming convention for the situation calculus:
 lower-case roman names indicate variables, and free variables are implicitly
 universally quantified.
 The axiom set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains one 
\begin_inset Formula $Poss$
\end_inset

 axiom of this form for each type of action.
 This notion can be generalized to what we will call 
\emph on
action description predicates
\emph default
.
 These are predicates defined in the same manner as 
\begin_inset Formula $Poss$
\end_inset

 that describe some other aspect of the performance of an action.
 For example, in Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Observation"

\end_inset

 we will define an action description predicate 
\begin_inset Formula $CanObs$
\end_inset

 that specifies whether an agent will observe the occurrence of an action.
\end_layout

\begin_layout Standard
Throughout the paper we will use 
\begin_inset Formula $\alpha$
\end_inset

 to refer to an arbitrary action description predicate.
 For notational convenience, we allow the use of lambda abstraction and
 implicit currying to form new action description predicates from old ones,
 with the understanding that these can be handled via macro expansion or
 incorporated directly into 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 if desired.
 For example, we will use 
\begin_inset Formula $CanObs(agt)$
\end_inset

 as a shorthand for 
\begin_inset Formula $\lambda a,s:CanObs(agt,a,s)$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Foundational Axioms
\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 enforce the basic structure of situations as a banching-time account of
 the world state.
 There is a set of initial situations identified by the predicate 
\begin_inset Formula $Init(s)$
\end_inset

, and a distinguished initial situation 
\begin_inset Formula $S_{0}$
\end_inset

 called the 
\emph on
actual 
\emph default
initial situation.
 Other initial situations represent alternatives that the agents think might
 be possible, but in fact are not.
 Situations in general them form a tree structure with an initial situation
 at the root and 
\begin_inset Formula $do$
\end_inset

 constructing child situations from parents.
 The foundational axioms define a basic ordering relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 which should be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

 and is defined as follows:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg\left(s'\sqsubset s\right)\\
s\sqsubset do(a,s')\equiv s\sqsubseteq s'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 There is also a second-order induction axiom expressing that the situations
 constructed in this way are, in fact, the only situations available.
 This is needed to prove statements that universally quantify over situations.
\end_layout

\begin_layout Standard
This notation for 
\begin_inset Quotes eld
\end_inset

in the future of
\begin_inset Quotes erd
\end_inset

 can be extended to consider only those futures in which all actions satisfy
 a particular action description predicate.
 We use the relation 
\begin_inset Formula $<_{\alpha}$
\end_inset

 for each action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, with the following definitions:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg\left(s'<_{\alpha}s\right)\\
s<_{\alpha}do(a,s')\equiv s\leq_{\alpha}s'\wedge\alpha(a,s')\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
root
\emph default
 of a situation is the initial situation from which it was constructed,
 and is accessed by the function 
\begin_inset Formula $root(s)$
\end_inset

:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\, root(s)=s\\
root(do(a,s))=root(s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
legal situations
\emph default
 are those in which all actions were actually possible to perform in the
 preceding situation - that is, those situations 
\begin_inset Formula $s$
\end_inset

 that satisfy 
\begin_inset Formula $S_{0}\leq_{Poss}s$
\end_inset

.
 These are of fundamental importance, as they are the only situations that
 could possible be brought about in the real world.
\end_layout

\begin_layout DefinitionLbld
Legal\InsetSpace ~
Situation A legal situation, identified by 
\begin_inset Formula $Legal(s)$
\end_inset

, satisfies:
\begin_inset Formula \[
Legal(s)\,\equiv\, root(s)\leq_{Poss}s\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Successor State Axioms
\end_layout

\begin_layout Standard
The truth of a fluent is completely specified by defining its truth in the
 initial situation, and collecting the effects of the various actions into
 
\emph on
successor state axioms
\emph default
.
 Such axioms provide a monotonic solution to the frame problem.
 They have the following general form, asserting the truth of a fluent 
\begin_inset Formula $F$
\end_inset

 in the successor situation 
\begin_inset Formula $do(c,s)$
\end_inset

 based on the current situation 
\begin_inset Formula $s$
\end_inset

 and the actions 
\begin_inset Formula $a$
\end_inset

 that was performed: 
\begin_inset Formula \[
F(\vars{x},do(a,s))\equiv\Phi^{+}(\vars{x},a,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi^{-}(\vars{x},a,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi^{+}$
\end_inset

 and 
\begin_inset Formula $\Phi^{-}$
\end_inset

 are formulae uniform in 
\begin_inset Formula $s$
\end_inset

.
 Roughly, this axiom states that 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after performing 
\begin_inset Formula $a$
\end_inset

 if 
\begin_inset Formula $a$
\end_inset

 made it true, or it was previously true and 
\begin_inset Formula $a$
\end_inset

 did not make it false
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Formula $\mathcal{D}_{ss}$
\end_inset

 contains one such axiom for each fluent.
\end_layout

\begin_layout Subsubsection*
Initial Situation Axioms
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 describes the actual state of the world before any actions are performed.
 It is simply a collection of sentences of the form 
\begin_inset Formula $\phi[S_{0}]$
\end_inset

 stating what holds in the initial situation.
 Note that it does 
\emph on
not
\emph default
 contain axioms about initial situations other than 
\begin_inset Formula $S_{0}$
\end_inset

.
 As we shall see in the next subsection, these are dealt with implicity
 by sentences of the form 
\begin_inset Formula $\Knows(agt,\phi,S_{0})$
\end_inset

.
\end_layout

\begin_layout Subsection
Knowledge and Sensing
\begin_inset LatexCommand label
name "sub:Knowledge-and-Sensing"

\end_inset


\end_layout

\begin_layout Standard
Epistemic reasoning was first introduced to the situation calculus by 
\begin_inset LatexCommand citet
key "moore80know_act"

\end_inset

, and formalised extensively by 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

 whose paper is now the canonical reference for these techniques.
 In turn, it is the techniques of 
\begin_inset LatexCommand citeauthor
key "scherl03sc_knowledge"

\end_inset

 that we build upon in this paper.
\end_layout

\begin_layout Standard
The semantics of knowledge are based on a reification of the 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 semantics of modal logic, using situation terms rather than abstract worlds.
 A knowledge fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 The macro 
\begin_inset Formula $\Knows$
\end_inset

 is then defined as a shorthand for the standard possible-worlds definition
 of knowledge, stating that an agent knows something when it is true in
 all situations considered possible: 
\begin_inset Formula \begin{equation}
\Knows(agt,\phi,s)\isdef\forall s':K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}

\end_inset

 
\end_layout

\begin_layout Standard
Readers familiar with modal logic will recognise 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 as the situation calculus analogue of the modal reachability relation 
\begin_inset Formula $K_{agt}$
\end_inset

, and the macro 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 as the equivalent of the modal box operator 
\begin_inset Formula $[K_{agt}]\phi$
\end_inset

.
\end_layout

\begin_layout Standard
To allow actions to return sensing information the sensing result function
 
\begin_inset Formula $SR(a,s)$
\end_inset

 is introduced, giving the result returned by the action 
\begin_inset Formula $a$
\end_inset

 when executed in situation 
\begin_inset Formula $s$
\end_inset

.
 Its behavior is defined analagously to action description predicates and
 included in 
\begin_inset Formula $\Dt_{ad}$
\end_inset

.
 For actions that don't return sensing information, the value of 
\begin_inset Formula $sr$
\end_inset

 is set to an arbitrary constant such as 
\begin_inset Formula $"OK"$
\end_inset

.
\end_layout

\begin_layout Standard
The successor state axiom for the knowledge fluent is:
\begin_inset Formula \begin{align}
K(agt,s'',do(a,s))\equiv\exists s': & \, s''=do(a,s')\,\wedge K(agt,s',s)\wedge Poss(a,s')\nonumber \\
 & \wedge\, actor(a)=agt\,\rightarrow\, sr(a,s)=sr(a,s')\label{eq:k_ssa_standard}\end{align}

\end_inset

 This axiom ensures that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(a,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing the same action 
\begin_inset Formula $a$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is considered a possible alternative to 
\begin_inset Formula $s$
\end_inset

.
 It must furthermore have been possible to perform that action in 
\begin_inset Formula $s'$
\end_inset

, and the sensing results must match if the action was carried out by the
 agent in question.
 Thus an agent's knowledge after the occurrence of an action is completely
 determined by the combination of its knowledge before the action, and the
 sensing results returned by the action.
 
\end_layout

\begin_layout Standard
One must also specify that initial situations may only be 
\begin_inset Formula $K$
\end_inset

-related to other initial situations:
\begin_inset Formula \begin{equation}
Init(s)\rightarrow\left(K(agt,s',s)\rightarrow Init(s')\right)\label{eq:k_s0_standard}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Since we will be developing a number of extensions to this formalism, we
 introduce a notational shorthand to refer to the standard account of knowledge
 throughout the rest of the paper:
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K,std}$
\end_inset

 the axioms of the standard account of knowledge due to 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, as detailed in equations (
\begin_inset LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

).
\end_layout

\begin_layout Standard
Note that the 
\begin_inset Formula $\Knows(agt,\phi,S_{0})$
\end_inset

 axioms in 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 along with the axioms in 
\begin_inset Formula $\Dt_{K,std}$
\end_inset

 completely define 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 for any situation rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
 This is why it is not necessary to explicitly axiomatize what holds in
 other initial situations.
 
\end_layout

\begin_layout Standard
While powerful, this formalism has an important limitation: it is fundamentally
 
\emph on
synchronous.
 
\emph default
Each agent is assumed to be aware of all actions that have occurred.
 Note that this awareness is passive, as the agents perform no explicit
 sensing actions to determine what has occurred.
 Responsibility for generating such awareness in real systems is the responsibil
ity of a lower-level software component, such as a continuous sensing system
 that identifies change in the environment and notifies the agent when an
 action occurs.
 While suitable for some domains, there are clearly many multi-agent domains
 where achieving total awareness of actions would be infeasible.
 A major contribution of this paper is a more flexible formalism for knowledge
 that can be applied to these domains.
\end_layout

\begin_layout Subsection
Reasoning
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of effective
 reasoning procedures for certain types of query, which we review in this
 section.
 These are generally based on syntactic manipulation of a query into a form
 that is more amenable to reasoning - for example, because it can be proven
 without using some of the axioms from 
\begin_inset Formula $\Dt$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Types of Reasoning
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\psi$
\end_inset

 be an arbitrary sentence from a particular situation calculus domain 
\begin_inset Formula $\Dt$
\end_inset

.
 In the general case, answering this query is a theorem-priving task in
 second-order logic (denoted SOL):
\begin_inset Formula \[
\Dt\models_{SOL}\psi\]

\end_inset


\end_layout

\begin_layout Standard
This is clearly problematic for efficient automated reasoning.
 Fortunately, there exist particular syntactic forms for which some of the
 axioms in 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required.
 If queries are restricted to the form 
\begin_inset Formula $\forall s\,\phi[s]$
\end_inset

, where 
\begin_inset Formula $\phi$
\end_inset

 is uniform, they can be answered without many of the axioms in 
\begin_inset Formula $\Dt$
\end_inset

 
\begin_inset LatexCommand citep
key "Lin94-StateConstraints,kelly07sc_persistence"

\end_inset

: 
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\forall s\,\phi[s]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{una}\models_{FOL}\forall s\,\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
We refer to this as 
\emph on
static domain reasoning
\emph default
, since it does not depend on the effects of actions.
 Still easier to perform is 
\emph on
initial situation reasoning
\emph default
, where the query is restricted to a formula uniform in 
\begin_inset Formula $S_{0}$
\end_inset

.
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\forall s\,\phi[s]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{una}\models_{FOL}\phi[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Since the initial situation axioms 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 are often closed, provers such as Prolog can be employed to handle this
 type of query quite efficiently.
 Effective reasoning depends on transforming queries into these more easily-hand
led forms.
\end_layout

\begin_layout Subsubsection*
Regression
\end_layout

\begin_layout Standard
The principle tool for effective reasoning in the situation calculus is
 the regression meta-operator 
\begin_inset Formula $\Reg$
\end_inset

 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

, a syntactic manipulation whose behavior can be summarized for our purposes
 as follows: it transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

 into a formula 
\begin_inset Formula $\Reg(\phi)$
\end_inset

 that is uniform in 
\begin_inset Formula $s$
\end_inset

 and is equivalent to 
\begin_inset Formula $\phi$
\end_inset

 under the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\phi\equiv\Reg(\phi)\]

\end_inset


\end_layout

\begin_layout Standard
In the base case, this involves replacing fluents 
\begin_inset Formula $F(\vars{x},do(a,s))$
\end_inset

 with their matching successor state axioms from 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

.
 It also replaces action description predicates such as 
\begin_inset Formula $Poss$
\end_inset

 with their appropriate definitions from 
\begin_inset Formula $\Dt_{ad}$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\phi$
\end_inset

 refers to a situation that is rooted at 
\begin_inset Formula $S_{0}$
\end_inset

, repeated applications of the regression operator (denoted by 
\begin_inset Formula $\Reg^{*}$
\end_inset

) can transform it into an equivalent formula uniform in the initial situation.
 The successor state and action precondition axioms are 
\begin_inset Quotes eld
\end_inset

compiled in
\begin_inset Quotes erd
\end_inset

 and so are not required for answering the regressed query, making reasoning
 simpler:
\begin_inset Formula \[
\Dt\models\phi[do(a_{n},do(a_{n-1},\dots,do(a_{1},S_{0}))]\,\,\,\,\,\mathrm{iff}\,\,\,\,\,\Dt_{una}\cup\Dt_{S_{0}}\models\Reg^{*}(\phi)[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
The trade-off is that the length of 
\begin_inset Formula $\Reg^{*}(\phi)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice.
\end_layout

\begin_layout Standard
To simplify the presentation of several equations later in the paper, we
 also introduce a two-argument version of the regression operator.
 Suppose that 
\begin_inset Formula $\phi$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

, then define:
\begin_inset Formula \[
\Reg(\phi,a)\,\isdef\,\Reg(\phi[do(a,s)])\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Reasoning about Knowledge
\end_layout

\begin_layout Standard
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 show how to apply the regression operator to formulae containing the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, allowing effective reasoning about epistemic queries using standard
 techniques of the situation calculus.
 Their definition is as follows:
\begin_inset Formula \begin{align*}
\Reg(\Knows(agt,\phi,do(a,s)))\isdef & \,\,\,\exists y:SR(a,s)=y\,\,\wedge\\
 & \,\,\,\,\,\,\,\,\Knows(agt,\left[Poss(a)\wedge SR(a,s)=y\right]\rightarrow\Reg(\phi[do(a,s)]),s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Note that this expresses the knowledge of the agent after an action in terms
 of what it knew before the action, along with the information returned
 by the action.
 This technique relies heavily on the fact that all actions are public,
 since it requires every agent's knowledge to be updated in response to
 every action.
\end_layout

\begin_layout Standard
It is possible to formulate an alternate successor state axiom for knowledge
 that does not assume all actions are public, such as of 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

.
 However these formulations invariably require universal quantification
 over situation terms, to account for arbitrarily-long sequences of hidden
 actions.
 Such universal quantification is incompatible regression rules like the
 above and these formulations offer no effective reasoning procedure other
 than second-order theorem proving.
 In this paper, we use a new reasoning technique called 
\begin_inset Quotes eld
\end_inset

property persistence
\begin_inset Quotes erd
\end_inset

 to allow universal quantification over situation terms while maintaining
 regression as a reasoning tool.
\end_layout

\begin_layout Subsubsection*
Property Persistence
\end_layout

\begin_layout Standard
As discussed above, traditional regression techniuqes cannot handle queries
 that universally quantify over situation terms.
 In fact, such queries require the use of a second-order induction axiom
 and therefore need a second-order theorem prover in the general case.
 Fortunately, many queries are in a simple syntactic form called 
\emph on
property persistence
\emph default
 queries 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 Such queries assert that a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 holds in a given situation, and will continue to hold as long as all future
 actions satisfy some action description predicate 
\begin_inset Formula $\alpha$
\end_inset

: 
\begin_inset Formula \[
\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
We have developed meta-operator called the 
\emph on
persistence condition
\emph default
, denoted 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

, to handle such queries more effectively 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 It produces a uniform formula such that:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Dt-\Dt_{S_{0}}\,\models\,\Pst(\phi,\alpha)[s]\,\equiv\,\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
The calculation of 
\begin_inset Formula $\Pst$
\end_inset

 requires some theorem proving, unlike that of 
\begin_inset Formula $\Reg$
\end_inset

 which is a simple syntactic transformation.
 Since the persistence condition is used to replace a second-order induction
 axiom, 
\begin_inset Formula $\Pst$
\end_inset

 is actually a fixpoint calculation.
 We breifly describe its operation below since we will need some of these
 details for a later proof; for full details consult the reference 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
\end_layout

\begin_layout Standard
First, the one-step-persistence operator 
\begin_inset Formula $\Pst^{1}$
\end_inset

 is defined to assert that 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate successors:
\begin_inset Formula \[
\Pst^{1}(\phi,\alpha)[s]\,\isdef\,\phi[s]\wedge\bigwedge_{i=0}^{n-1}\forall\vars{x}:\,\Reg(\alpha(A_{i}(\vars{x}),s)\rightarrow\phi[do(A_{i}(\vars{x}),s)])\]

\end_inset


\end_layout

\begin_layout Standard
Note that regression is applied to ensure that the result is uniform in
 
\begin_inset Formula $s$
\end_inset

.
 Repeated application, denoted 
\begin_inset Formula $\Pst^{n}(\phi,\alpha)$
\end_inset

, asserts the persistence of 
\begin_inset Formula $\phi$
\end_inset

 after greater numbers of actions.
 Intuitively 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 should be a fixpoint of 
\begin_inset Formula $\Pst^{1}(\phi,\alpha)$
\end_inset

, and indeed it can be shown that:
\begin_inset Formula \[
\mathcal{D}_{una}\,\models\,\Pst^{n}(\phi,\alpha)\,\rightarrow\,\Pst^{n+1}(\phi,\alpha)\,\,\,\,\,\,\mathrm{iff}\,\,\,\,\,\,\mathcal{D}\,\models\,\Pst^{n}(\phi,\alpha)\,\equiv\,\Pst(\phi,\alpha)\]

\end_inset


\end_layout

\begin_layout Standard
Thus the calculation of 
\begin_inset Formula $\mathcal{P}(\phi,\alpha)$
\end_inset

 replaces a single second-order reasoning task with iterated static domain
 reasoning.
 Our experience has shown this technique to be quite effective in practice.
 Moreover, since 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 produces a uniform formula, it allows queries that universally quantify
 over situation terms to be used in conjunction with traditional regression
 techniques.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Individual Knowledge with Hidden Actions
\begin_inset LatexCommand label
name "sec:Obs-Knowledge"

\end_inset


\end_layout

\begin_layout Standard
Existing accounts of knowledge in the situation calculus directly express
 the dynamics of knowledge update in terms of the actions that have occurred
 in the world, as seen in Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Sensing"

\end_inset

.
 An immediate consequence of this is that one can only reason about knowledge
 if one has a rooted situation term, as the required query is:
\begin_inset Formula \[
\Dt\,\models\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
In asynrchonous domains with hidden actions, where agents are not necessarily
 aware of the number of actions that have been performed, the agents cannot
 use this formulation to reason about their own knowledge.
 Since knowledge is directly coupled to actions, and hence to situation
 terms, they cannot construct an appropriate query.
 This section is devoted to removing this troublesome coupling.
\end_layout

\begin_layout Subsection
Observations
\end_layout

\begin_layout Standard
To remove the direct coupling between knowledge and actions, we introduce
 the notion of 
\emph on
observations
\emph default
.
 These are internal notifications that agents receive when an action has
 occurred.
 By expressing knowledge in terms of observations rather than actions, we
 ensure that agents can always reason about their own knowledge based on
 their own internal history of observations.
\end_layout

\begin_layout DefinitionLbld
Observations An observation is a notification event received by an agent,
 making it aware of some change in the state of the world.
 When an agent receives such a notification, we say that it 
\begin_inset Quotes eld
\end_inset

observed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

made
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

perceived
\begin_inset Quotes erd
\end_inset

 that observation.
\end_layout

\begin_layout Standard
Since the state of the world may only change in response to some action,
 observations can only be made as a result of some action.
 For simplicity we assume that agents perceive observations instantaneously,
 i.e.
 in the same instant as the actions that cause them.
\end_layout

\begin_layout Standard
Since 
\begin_inset Quotes eld
\end_inset

observation
\begin_inset Quotes erd
\end_inset

 is quite a loaded term, it is worth re-iterating this point: observations
 are instantanous
\emph on
 events
\emph default
 generated internally by each agent in response to actions occurring in
 the world.
 We make no commitment as to how these events are generated, preferring
 a clean delineation between the task of observing change and the dynamics
 of knowledge update based on those observations.
 As with the work of 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, generating awareness is the responsibility of a lower-level component
 of the agent's control software and we will not consider it further.
\end_layout

\begin_layout Standard
To make this idea concrete, let us introduce an additional sort 
\noun on
Observations
\noun default
 to the language of the situation calculus, for the moment without any particula
r commitment towards what this sort will contain.
 We then introduce the function:
\begin_inset Formula \[
obs(agt,a,s)=o\]

\end_inset

This function returns a set of observations, and should be read as 
\begin_inset Quotes eld
\end_inset

when action 
\begin_inset Formula $a$
\end_inset

 is performed in situation 
\begin_inset Formula $s$
\end_inset

, agent 
\begin_inset Formula $agt$
\end_inset

 will perceive 
\begin_inset Formula $o$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Using a set of observations allows an agent to perceive any number of observati
ons in response to a single action occurrence - perhaps several observations,
 perhaps none.
\end_layout

\begin_layout Standard
The concept of a 
\emph on
view
\emph default
 follows naturally - it is a sequence of all the observations made by an
 agent as the world has evolved.
\end_layout

\begin_layout DefinitionLbld
Views An agent's view in a given situation 
\begin_inset Formula $\mathrm{s}$
\end_inset

 is the corresponding sequence of observations made by the agent as a result
 of each action in 
\begin_inset Formula $\mathrm{s}$
\end_inset

, exluding those actions for which no observations were made.
\end_layout

\begin_layout Standard
We introduce another sort 
\noun on
Views
\noun default
 consisting of sequences of sets of observations, with 
\begin_inset Formula $\epsilon$
\end_inset

 being the empty sequence, and the function 
\begin_inset Formula $view$
\end_inset

 giving the observation history associated with a particular situation:
\begin_inset Formula \begin{align}
Init(s)\,\rightarrow & \, view(agt,s)=\epsilon\nonumber \\
obs(agt,a,s)=\{\}\,\rightarrow & \, view(agt,do(a,s))=view(agt,s)\nonumber \\
obs(agt,a,s)\neq\{\}\,\rightarrow & \, view(agt,do(a,s))=obs(agt,a,s)\cdot view(agt,s)\label{eq:view_defn}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Observations and views can be seen as localized analogues of actions and
 situations respectively.
 An action is a global event that causes the state of the world to change,
 while an observation is an internal event that causes an agent's awareness
 of the state of the world (i.e.
 its knowledge) to change.
 Similarly, a situation represents a complete, global history of all the
 actions that have occurred in the world, while a view is an agent's local
 history of all the observations it has made.
 The situation is an omniscient perspective on the world, the view a local
 perspective.
 As we shall see, this distinction is fundamental to developing a truly
 general multi-agent semantics for knowledge.
\end_layout

\begin_layout Subsection
Knowledge and Observation
\begin_inset LatexCommand label
name "sub:Knowledge-and-Observation"

\end_inset


\end_layout

\begin_layout Standard
It is a basic tenet of epistemic reasoning that an agent's knowledge at
 any particular time must depend solely on its local history: the knowledge
 that it started out with combined with the observations it has made since
 then 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
 Given an explicit account of the observations made by each agent, the required
 semantics of the 
\begin_inset Formula $K$
\end_inset

 relation are clear: 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 must hold whenever 
\begin_inset Formula $s'$
\end_inset

 is legal, both 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 would result in the same view for the agent, and 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 are rooted at indistinguishable initial situations:
\begin_inset Formula \begin{equation}
\mathcal{D}\models K(agt,s',s)\equiv K(root(s'),root(s))\wedge Legal(s')\wedge view(agt,s')=view(agt,s)\label{eq:k-desired}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
While a wonderfully succinct definition of how knowledge should behave,
 this formulation cannot be used directly in a basic action theory.
 Basic action theories require that the dynamics of fluent change be specified
 as a successor state axiom, so we must formulate a successor state axiom
 for the 
\begin_inset Formula $K$
\end_inset

 fluent which enforces the above relationship.
\end_layout

\begin_layout Standard
For notational convenience, let us first introduce an action description
 predicate 
\begin_inset Formula $PbU$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

possible but unobservable
\begin_inset Quotes erd
\end_inset

) indicating that the action 
\begin_inset Formula $a$
\end_inset

 is possible in 
\begin_inset Formula $s$
\end_inset

, but no observations will be made by 
\begin_inset Formula $agt$
\end_inset

 if it is performed:
\begin_inset Formula \begin{equation}
PbU(agt,a,s)\isdef Poss(a,s)\wedge obs(agt,a,s)=\{\}\label{eqn:PbU_defn}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
By stating that 
\begin_inset Formula $s\leq_{PbU(agt)}s'$
\end_inset

 we assert that an agent would make no observations were the world to move
 from situation 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
 This means that the views of both situations would be identical.
 The two situations would be indistinguishable to the agent, so if it considers
 
\begin_inset Formula $s$
\end_inset

 possible then it must also consider 
\begin_inset Formula $s'$
\end_inset

 possible.
 Following this intuition, the successor state axiom below captures the
 desired dynamics of the knowledge fluent:
\begin_inset Formula \begin{align}
K(agt,s'',do(a,s))\equiv & \left[\, obs(agt,a,s)=\{\}\rightarrow K(agt,s'',s)\,\right]\nonumber \\
\wedge & \left[\, obs(agt,a,s)\neq\{\}\rightarrow\exists a',s':\, obs(agt,a',s')=obs(agt,a,s)\right.\nonumber \\
 & \left.\,\,\,\,\,\,\,\,\wedge\, Poss(a',s')\wedge K(agt,s',s)\wedge do(a',s')\leq_{PbU(agt)}s''\,\right]\label{eqn:new_k_ssa}\end{align}

\end_inset

 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $a$
\end_inset

 was totally unobservable, the agent's state of knowledge does not change.
 Otherwise, it considers possible any legal successor to a possible alternate
 situation 
\begin_inset Formula $s'$
\end_inset

 that can be brought about by an action 
\begin_inset Formula $a'$
\end_inset

 that results in identical observations.
 It also considers possible any future of such a situation in which is would
 make no further observations.
\end_layout

\begin_layout Standard
It remains to specify 
\begin_inset Formula $K$
\end_inset

 in the initial situation.
 Since situations where 
\begin_inset Formula $S_{0}\leq_{PbU(agt)}s$
\end_inset

 holds must be 
\begin_inset Formula $K$
\end_inset

-related to 
\begin_inset Formula $S_{0}$
\end_inset

, we introduce another relation 
\begin_inset Formula $K_{0}$
\end_inset

 to specify each agent's initial knowledge
\begin_inset Formula \begin{gather*}
K_{0}(agt,s',s)\rightarrow Init(s')\wedge Init(s)\\
\KnowsZ(agt,\phi,s)\,\isdef\,\forall s'\, K_{0}(agt,s',s)\rightarrow\phi[s']\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Think of 
\begin_inset Formula $\KnowsZ$
\end_inset

 as the agent's knowledge at the beginning of time, where it is guaranteed
 that no actions have occurred.
 We can then use this to define 
\begin_inset Formula $K$
\end_inset

 for initial situations.
\begin_inset Formula \begin{gather}
Init(s)\rightarrow\left[K(agt,s'',s)\equiv\exists s'\,.\, K_{0}(agt,s',s)\wedge s'\leq_{PbU(agt)}s'')\right]\label{eqn:new_k_s0}\end{gather}

\end_inset

These definitions suffice to ensure that knowledge behaves as we require:
 two situations will be related by 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 if and only if they result in identical views for 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $s'$
\end_inset

 is legal, and their root situations were initially related.
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K,obs}$
\end_inset

 a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 augmented with our new observation-based semantics for knowledge, as detailed
 in equations (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

).
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:k_obs_equiv"

\end_inset

 For a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, for any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge view(agt,s'')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
For the
\series bold
 
\series default
\emph on
if
\emph default
 direction, we establish each of the three conjuncts individually.
 The roots case is trivial since equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) always expresses 
\begin_inset Formula $K(s'',do(a,s))$
\end_inset

 in terms of 
\begin_inset Formula $K(s',s)$
\end_inset

.
 Legality relies on the fact that 
\begin_inset Formula $PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

, while the views case relies on the fact that 
\begin_inset Formula $s\leq_{PbU}s'\rightarrow view(s)=view(s')$
\end_inset

.
 For the 
\emph on
only-if
\emph default
 direction, we show how to construct an 
\begin_inset Formula $s'$
\end_inset

 satisfying the 
\begin_inset Formula $\exists s'$
\end_inset

 parts of equations (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

), completing the proof.
\end_layout

\begin_layout Standard
Using this new formulation, an agent's knowledge is completely decoupled
 from the global notion of actions, instead depending only on the local
 information that it has observed.
 It remains to specify precisely what the 
\noun on
Observations
\noun default
 sort contains, and how the 
\begin_inset Formula $obs()$
\end_inset

 function behaves.
 This will be the focus of the next subsection.
\end_layout

\begin_layout Subsection
Axiomatizing Observations
\end_layout

\begin_layout Standard
Let us begin by considering again the standard account of knowledge due
 to 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

.
 Its basic assumption that 
\begin_inset Quotes eld
\end_inset

all agents are aware of all actions
\begin_inset Quotes erd
\end_inset

 may be rephrased as 
\begin_inset Quotes eld
\end_inset

when an action occurs, all agents will observe that action
\begin_inset Quotes erd
\end_inset

.
 Allowing the 
\noun on
Observations
\noun default
 sort to contain 
\noun on
Action
\noun default
 terms, this assumption is akin to the following assertion about the 
\begin_inset Formula $obs()$
\end_inset

 function:
\begin_inset Formula \begin{equation}
a'\in obs(agt,a,s)\equiv a=a'\label{eq:ax_obs_std1}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
What about sensing information? We can extend the 
\noun on
Observations
\noun default
 sort to contain terms of the form 
\emph on

\begin_inset Formula $(Action=Result)$
\end_inset


\emph default
 and axiomatize like so:
\begin_inset Formula \begin{equation}
(a'=r)\in obs(agt,a,s)\equiv a=a'\wedge SR(a,s)=r\wedge agent(a)=agt\label{eq:ax_obs_std2}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Using these definitions, our new account of knowledge will behave identically
 to the standard account:
\end_layout

\begin_layout Theorem
Suppose 
\begin_inset Formula $\mathcal{D}_{K,obs}$
\end_inset

 uses equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) to define the 
\begin_inset Formula $obs()$
\end_inset

 function, then for any situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,std}\models K(agt,s',s)\,\,\,\,\mathrm{iff}\,\,\,\,\Dt\cup\Dt_{K,obs}\models K(agt,s',s)\]

\end_inset


\end_layout

\begin_layout Proof
Equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) mean 
\begin_inset Formula $obs(agt,a,s)$
\end_inset

 cannot be empty, so 
\begin_inset Formula $s\leq_{PbU(agt)}s'$
\end_inset

 iff 
\begin_inset Formula $s=s'$
\end_inset

.
 Equations (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) then amount to simple transformations of equations (
\begin_inset LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

) respectively, meaning that 
\begin_inset Formula $K$
\end_inset

 behaves the same under both theories.
\end_layout

\begin_layout Standard
To generalize this for partial observability of actions we introduce a new
 action description predicate, akin to 
\begin_inset Formula $Poss$
\end_inset

 but describing when actions will be observed by agents: 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 indicates that agent 
\begin_inset Formula $agt$
\end_inset

 would observe action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 We can then formulate the 
\begin_inset Formula $obs()$
\end_inset

 function according to:
\begin_inset Formula \[
a'\in obs(agt,a,s)\equiv a'=a\wedge CanObs(agt,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
There is an additional assumption in the standard handling of sensing actions:
 only the agent performing a sensing action is aware of its result.
 Such a restriction is common but certainly not universal.
 For example, if an agent waiting for a train activates a speaker to determine
 when it will arrive, the result of this sensing action would be available
 to any other agent within earshot.
 We add an analogous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 to indicate when sensing information is available to an agent.
 We then include bare action terms in an agent's observations when it observes
 the action but not its result, and 
\emph on
(Action=Result)
\emph default
 terms when it also senses the result:
\begin_inset Formula \begin{gather*}
a'\in obs(agt,a,s)\equiv a=a'\wedge CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\\
(a'=r)\in obs(agt,a,s)\equiv a'=a\wedge SR(a,s)=r\wedge CanObs(agt,a,s)\wedge CanSense(agt,a,s)\end{gather*}

\end_inset


\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The appearance of the 
\begin_inset Formula $\leq_{PbU(agt)}$
\end_inset

 ordering over situations in equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) means that our new successor state axiom universally quantifies over situation
s, so standard regression techniques cannot be applied.
 We must appeal to the persistence condition meta-operator to transform
 this quantification into a uniform formula, so that regression can be applied.
\end_layout

\begin_layout Standard
We propose the following definition for the regression of 
\begin_inset Formula $\Knows$
\end_inset

:
\begin_inset Formula \begin{align}
\Reg(\Knows(agt,\phi,do(a,s)))\isdef\,\, & \exists o:\, obs(agt,a,s)=o\nonumber \\
 & \wedge\,\left[o=\{\}\,\rightarrow\,\Knows(agt,\phi,s)\right]\nonumber \\
 & \wedge\,\left[o\neq\{\}\,\rightarrow\,\Knows(agt,\forall a':\, obs(agt,a')=o\right.\nonumber \\
 & \,\,\,\,\,\,\,\,\,\,\,\wedge Poss(a')\rightarrow\left.\Reg(\Pst(\phi,PbU(agt)),a),s)\right]\label{eqn:R_do_c_s}\end{align}

\end_inset

 As required, this reduces a knowledge query at 
\begin_inset Formula $do(a,s)$
\end_inset

 to a knowledge query at 
\begin_inset Formula $s$
\end_inset

.
 It is also intuitively appealing: to know that 
\begin_inset Formula $\phi$
\end_inset

 holds, the agent must know that in all situations that agree with its observati
ons, 
\begin_inset Formula $\phi$
\end_inset

 cannot become false without it making an observation.
\end_layout

\begin_layout Standard
We must also specify the regression of 
\begin_inset Formula $\Knows$
\end_inset

 in the initial situation, as equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) also quantifies over situations.
 This clause produces an expression in 
\begin_inset Formula $\KnowsZ$
\end_inset

 at 
\begin_inset Formula $S_{0}$
\end_inset

, meaning that it can be handled by epistemic reasoning about the initial
 situation only:
\begin_inset Formula \begin{equation}
\Reg(\Knows(agt,\phi,S_{0}))\,\isdef\,\KnowsZ(agt,\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt)),S_{0})\label{eqn:R_s0}\end{equation}

\end_inset


\end_layout

\begin_layout Theorem
Given a basic action theory 
\begin_inset Formula $\Dt\cup\Dt_{K,obs}$
\end_inset

 and a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

, it is always the case that:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\phi[do(a,s)]\equiv\Reg(\phi[do(a,s)])\]

\end_inset

 
\end_layout

\begin_layout ProofSketch
We need only consider the case of 
\begin_inset Formula $\Reg(\Knows(agt,\phi,s))$
\end_inset

.
 In the recursive case of 
\begin_inset Formula $do(a,s)$
\end_inset

, we proceed by expanding the definition for 
\begin_inset Formula $\Knows$
\end_inset

 using our new successor state axiom for 
\begin_inset Formula $K$
\end_inset

, collecting sub-formulae that match the form of the 
\begin_inset Formula $\Knows$
\end_inset

 macro, and using regression and the persistence condition to render the
 resulting knowledge expressions uniform in 
\begin_inset Formula $s$
\end_inset

.
 In the base case, applying the persistence condition to an expansion of
 
\begin_inset Formula $\Knows$
\end_inset

 at the initial situation completes the proof.
\end_layout

\begin_layout Standard
We can thus handle knowledge queries using regression, the standard technique
 for effective reasoning in the situation calculus.
\end_layout

\begin_layout Standard
While this reasoning method is suitable for modeling and simulation purposes,
 it would be unreasonable for a situated agent to ask 
\begin_inset Quotes eld
\end_inset

do I know 
\begin_inset Formula $\phi$
\end_inset

 in the current situation?
\begin_inset Quotes erd
\end_inset

 using the situation calculus query 
\begin_inset Formula $\Dt\models\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as it cannot be expected to have the full current situation 
\begin_inset Formula $s$
\end_inset

.
 However, it will have its current view 
\begin_inset Formula $v$
\end_inset

.
 We define knowledge with respect to a view as follows:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,v)\,\isdef\,\forall s:\, view(agt,s)=v\wedge root(s)=S_{0}\rightarrow\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
It is a straightforward consequence of Theorem 
\begin_inset LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 that this form of knowledge is equivalent to knowledge based on a situation
 term having that observation history and rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
Extending the regression rules in equations (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

) to handle formulae of this form is actually simpler than for regression
 over situations, as there are no empty observations in a history.
 The result is:
\begin_inset Formula \begin{align*}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,o\cdot v))\isdef\,\, & \mathbf{Knows}(agt,\forall a:\, obs(agt,a)=o\\
 & \,\,\,\,\,\,\,\,\wedge Poss(a)\rightarrow\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt)),a),v)\\
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,\epsilon))\isdef\,\, & \KnowsZ(agt,\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt)),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Using regression in this way, agents can reason about their own knowledge
 using only their local information.
 Our work thus makes it possible to include a situation calculus model in
 the implementation of a real-world multi-agent system, even when agents
 have only partial awareness of the actions being performed.
\end_layout

\begin_layout Subsection
An Illustrative Example
\end_layout

\begin_layout Standard
Consider again a package-processing facility where agents are required to
 move boxes between various rooms.
 There are three actions (
\begin_inset Formula $pickup$
\end_inset

, 
\begin_inset Formula $drop$
\end_inset

 and 
\begin_inset Formula $move$
\end_inset

) and two fluents (
\begin_inset Formula $Holding$
\end_inset

 and 
\begin_inset Formula $InRoom$
\end_inset

) whose meanings should be clear.
 There are no sensing actions.
 
\end_layout

\begin_layout Standard
Agents may pickup a box if they are in the same room and no-one is holding
 it.
 They can drop a box they are holding at any time, and can move freely between
 rooms:
\begin_inset Formula \begin{align*}
Poss(pickup(agt,box),s)\equiv\, & \neg\exists agt:\, Holding(agt,box,s)\\
 & \,\wedge\,\exists rm:\, InRoom(agt,rm)\wedge InRoom(box,rm)\\
Poss(drop(agt,box),s)\equiv & \, Holding(agt,box,s)\\
Poss(move(agt,rm),s)\equiv & \, true\end{align*}

\end_inset


\end_layout

\begin_layout Standard
An agent is holding a box if they picked it up, or were already holding
 it and didn't put it down:
\begin_inset Formula \begin{align*}
Holding(agt,box,do(a,s))\equiv & \, a=pickup(agt,box)\\
 & \,\vee\, Holding(agt,box,s)\wedge a\neq drop(agt,box)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
An object is in a room if it was taken there, or it was already in that
 room and it was not taken elsewhere:
\begin_inset Formula \begin{align*}
InRoom(obj,rm,do(a,s))\equiv\,\, & \exists agt:\, a=move(agt,rm)\wedge\left[obj=agt\vee Holding(agt,obj,s)\right]\\
 & \vee\, InRoom(obj,rm,s)\wedge\neg\left[\exists agt,rm_{2}:\, a=move(agt,rm_{2})\right.\\
 & \,\,\,\,\,\,\,\,\,\,\left.\wedge rm_{2}\neq rm\wedge\left(obj=agt\vee Holding(agt,obj,s)\right)\right]\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Agents can observe actions performed by an agent in the same room as themselves,
 and can observe agents entering their room:
\begin_inset Formula \begin{align*}
CanObs(agt,a,s)\equiv\,\, & \exists rm\,.\, InRoom(agt,rm)\wedge\\
 & \wedge\left(InRoom(agent(a),rm)\,\vee\,\exists agt_{2}\,.\, a=move(agt_{2},rm)\right)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Initially, Sam is in Room1 with Box1, Max is in Room2 with Box2, and no-one
 is holding any boxes.
 Everyone has complete knowledge of the initial situation:
\begin_inset Formula \begin{gather*}
InRoom(Sam,Room1,S_{0})\\
InRoom(Box1,Room1,S_{0})\\
InRoom(Max,Room2,S_{0})\\
InRoom(Box2,Room2,S_{0})\\
\neg Holding(agt,box,S_{0})\\
K_{0}(agt,s,S_{0})\equiv s=S_{0}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The following are examples of knowledge queries that can be posed in our
 formalism, and a brief explanation of their outcome:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\models\mathbf{Knows}(Sam,\neg Holding(Max,Box1),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Initially, Sam knows that Max is not holding Box1.
 For 
\begin_inset Formula $Holding(Max,Box1)$
\end_inset

 to be true, he must have picked Box1 up.
 Since Box1 is in the same room as Sam, she would be able to observe him
 doing so.
 Since she has not observed that, she can conclude that 
\begin_inset Formula $Holding(Max,Box1)$
\end_inset

 is false.
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\models\mathbf{\neg Knows}(Sam,\neg Holding(Max,Box2),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
By contrast, Sam does 
\emph on
not
\emph default
 know that Max is not holding Box2.
 Since Box2 is in a different room, Max could have picked it up without
 her observing the action.
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K,obs}\models\mathbf{Knows}(Sam,Holding(Max,Box1),\\
do(pickup(Max,Box1),do(move(Max,Room1),S_{0}))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
For Max to put down Box1 without Sam observing anything, he would have to
 first move to a different room.
 Since the action of moving to a different room would be observed by Sam,
 she knows that he must be holding the box.
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K,obs}\models\mathbf{\neg Knows}(Sam,Holding(Max,Box1),\\
do(move(Max,Room2),do(pickup(Max,Box1),do(move(Max,Room1),S_{0})))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Once Max takes Box1 into a different room, Sam can no longer be sure that
 he is holding it, since he may put it down without her observing anything.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Observing the Effects of Actions
\end_layout

\begin_layout Standard
In many domains it would be infeasible for an agent to observe a particular
 action occurring, but it may be able to observe some of the effects of
 that action.
 For example, suppose that an agent monitors the state of a light in its
 environment, such that it notices it changing from dark to light.
 While it knows that 
\emph on
some
\emph default
 action must have occurred to produce that effect, it may not be sure precisely
 what action took place (e.g.
 precisely 
\emph on
who
\emph default
 turned on the light).
\end_layout

\begin_layout Standard
This can be modeled by further extending the 
\noun on
Observations
\noun default
 sort.
 Suppose that the observation term 
\begin_inset Formula $f_{\phi}$
\end_inset

 indicates that a particular property of the world 
\begin_inset Formula $\phi$
\end_inset

 has changed from false to true and (for simplicity) that this information
 would be available to all agents.
 The following could be used to include this information in an agent's observati
ons:
\begin_inset Formula \[
f_{\phi}\in obs(agt,a,s)\equiv\neg\phi[s]\wedge\Reg(\phi[do(a,s)])\]

\end_inset

 
\end_layout

\begin_layout Standard
Note that since we use 
\begin_inset Formula $obs()$
\end_inset

 as an action description predicate in equation (
\begin_inset LatexCommand ref
reference "eqn:PbU_defn"

\end_inset

), we must use regression to ensure that the right-hand side of this equivalence
 refers only to 
\begin_inset Formula $s$
\end_inset

.
 Expanding on the example of the light, we might have an axiom like this:
\begin_inset Formula \[
lightCameOn\in obs(agt,a,s)\equiv\neg lightIsOn(s)\wedge\exists agt_{2}:\, a=turnLightOn(agt_{2})\]

\end_inset


\end_layout

\begin_layout Standard
When the light is switched on, each agent's observation set will contain
 the term 
\begin_inset Formula $lightCameOn$
\end_inset

, and they will know that this change has occurred without necessarily knowing
 the action responsible for the change.
 That this powerful new ability is a straightforward extension of our approach
 highlights the flexibility and robustness of the observation-based semantics.
\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
powerul account of knowledge, subsumes existing appraoches, blah blah blah
\end_layout

\begin_layout Section
Complex Epistemic Modalities
\begin_inset LatexCommand label
name "sec:Complex-Epistemic-Modalities"

\end_inset


\end_layout

\begin_layout Standard
So far we have constructed a powerful new account of 
\emph on
individual 
\emph default
knowledge in a multi-agent setting.
 For rich multi-agent domains, we must also be able to reason about group-level
 knowledge and, in particular, about common knowledge.
 The primary motivation for this section is a formal treatment of common
 knowledge within our framework, but as we shall see, this requires significant
 technical machinery capable of handling much more general epistmic modalities.
\end_layout

\begin_layout Subsection
Group-Level Epistemic Modalities
\end_layout

\begin_layout Standard
We breifly review the various group-level epistemic modalities found in
 the literature.
 Let 
\begin_inset Formula $G$
\end_inset

 be a finite group of agents.
 The basic group-level modality is 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

, which is defined as:
\begin_inset Formula \[
\mathbf{EKnows}(G,\phi,s)\,\isdef\,\bigwedge_{agt\in G}\,\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
To assert more complete knowledge by members of the group, one can say that
 
\begin_inset Quotes eld
\end_inset

everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 by nesting 
\begin_inset Formula $\mathbf{EKnows}$
\end_inset

 operators.
 In general:
\begin_inset Formula \begin{gather*}
\mathbf{EKnows}^{1}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\phi,s)\\
\mathbf{EKnows}^{n}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\mathbf{EKnows}^{n-1}(G,\phi),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The higher the value of 
\begin_inset Formula $n$
\end_inset

, the stronger an assertion is made about the knowledge of the group.
 The strongest group-level modality is 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Intuitively this indicates that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, and so on ad infinitum.
 Formally, it can be defined as the infinite conjunction:
\begin_inset Formula \[
\mathbf{CKnows}(G,\phi,s)\,\isdef\,\bigwedge_{n\in\mathbb{N}}\mathbf{EKnows}^{n}(G,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Common knowledge can be equivalently defined as a fixpoint or transitive
 closure of the 
\begin_inset Formula $\EKnows$
\end_inset

 relation.
 It is an extremely powerful form of knowledge that has deep implications
 for coordinated group behavior 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
 For example, in the famous 
\begin_inset Quotes eld
\end_inset

Coordinated Attack
\begin_inset Quotes erd
\end_inset

 problem, the proof that the generals cannot coordinate an attack depends
 heavily on their inability to obtain common knowledge.
\end_layout

\begin_layout Subsection
The Trouble with Common Knowledge
\end_layout

\begin_layout Standard
We are aware of no formal treatments of common knowledge in the situation
 calculus literature, and certainly none in domains as rich as those we
 consider here.
 This can be attributed to the difficulty of reasoning about common knowledge
 using techniques such as regression.
\end_layout

\begin_layout Standard
In the related field of dynamic epistemic logic, a famous result of 
\begin_inset LatexCommand cite
key "baltag98pa_ck"

\end_inset

 states that:
\end_layout

\begin_layout Quote
Epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone.
\end_layout

\begin_layout Standard
In our terminology: unlike the case of individual knowledge, 
\begin_inset Formula $\Reg(\CKnows(G,\phi,do(a,s)))$
\end_inset

 cannot be defined in terms of 
\begin_inset Formula $\CKnows$
\end_inset

.
 Given the deep similarities between the situation caluclus and epistemic
 modal logic 
\begin_inset LatexCommand citep
key "vanbentham07ml_sitcalc"

\end_inset

, we can be confident that this expressivity limitation also applies in
 the situation calculus.
\end_layout

\begin_layout Standard
One alternative for reasoning about common knowledge is to calculate it
 directly as a fixpoint of 
\begin_inset Formula $\EKnows$
\end_inset

.
 This process would be immensely computationally expensive, and is not guarantee
d to terminate Effective reasoning requires a regression rule.
\end_layout

\begin_layout Standard
Fortunately, recent work by 
\begin_inset LatexCommand citet
key "vanBenthem06lcc"

\end_inset

 has shown that a regression rule can be formulated by increasing the expressivi
e power of the epistemic language in use.
 Their basic idea is to use dynamic logic as a more expressive epistemic
 path language.
 During regression, the effects of an action are encoded inside the epistemic
 path as well as in the formulae under consideration.
\end_layout

\begin_layout Standard
After introducing these ideas in their original context, we will adapt and
 expand them for use within our framework.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
The Logic of Communication and Change
\end_layout

\begin_layout Standard
This section is a brief overview of the Logic of Communication and Change
 (hereafter denoted 
\begin_inset Quotes eld
\end_inset

LCC
\begin_inset Quotes erd
\end_inset

) developed by 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

, designed to introduce their ideas and contributions to the field.
 The paper on this logic is quite accessible and should be consulted for
 full details.
 This section assumes some familiarity with the syntax and semantics of
 modal logic.
\end_layout

\begin_layout Standard
In traditional modal logics of knowledge, there is one accessibility relation
 
\begin_inset Formula $K_{agt}$
\end_inset

 for each agent.
 Knowledge is expressed using the modal box operator, as in 
\begin_inset Formula $[K_{agt}]\phi$
\end_inset

.
 Common knowledge is handled by introducing additional modalities 
\begin_inset Formula $[C_{G}]\phi$
\end_inset

 and semantically defining the 
\begin_inset Formula $C_{G}$
\end_inset

 relation as the transitive closure of inidivual agent's knowledge relations.
 As discussed above, such logics do not permit a regression rule for reasoning
 about common knowledge.
\end_layout

\begin_layout Standard
The first major contribution of LCC is to increase the expressiveness of
 the epistemic language by allowing complex 
\emph on
path expressions
\emph default
 in place of these knowledge operators.
 Conceptualyly, knowledge is expressed by propositional dynamic logic interprete
d over an epistemic frame.
 An epistemic path expression 
\begin_inset Formula $\pi$
\end_inset

 takes the form:
\begin_inset Formula \begin{gather*}
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset LatexCommand ref
reference "tbl:knowledge-exprs"

\end_inset

 shows some standard knowledge expressions with their syntax in the situation
 calculus, traditional epistemic logic, and LCC.
 Here we see the first advantage of this approach - there is no need for
 a special-purpose common knowledge operator.
 It is directly expressed as the transitive closure of 
\begin_inset Formula $\EKnows$
\end_inset

 using the iteration operator of dynamic logic.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Situation Calculus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Epistemic Logic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
LCC
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\Knows(agt,\phi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[K_{agt}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[agt]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\Knows(agt_{1},\Knows(agt_{2},\phi))$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[K_{agt_{1}}][K_{agt_{2}}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[agt_{1};agt_{2}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula $\Knows(agt_{1},\phi)\wedge\Knows(agt_{2},\phi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[K_{agt_{1}}]\phi\wedge[K_{agt_{2}}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[agt_{1}\cup agt_{2}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\EKnows(G,\phi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[E_{G}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[\bigcup_{agt\in G}agt]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\CKnows(G,\phi)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[C_{G}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $[(\bigcup_{agt\in G}agt)^{*}]\phi$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
\begin_inset LatexCommand label
name "tbl:knowledge-exprs"

\end_inset

Some knowledge expressions in the Situation Calculus, Epistemic Logic, and
 LCC
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Actions in LCC are represented using 
\emph on
update frames
\emph default
.
 These are finite directed graphs (actually, Kripke-style modal frames)
 where nodes are labelled from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $n-1$
\end_inset

 and represent possible actions that were performed, and the relations between
 nodes represent epistemic uncertainty about precisely which action was
 performed.
 To express what holds after the ocurrence of an action, one specifies an
 update frame along with the specific action from that frame that actually
 occurred.
 This formula says 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds after performing action 
\begin_inset Formula $i$
\end_inset

 from update frame 
\begin_inset Formula $\mathrm{U}$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula \[
[\mathrm{U},i]\phi\]

\end_inset


\end_layout

\begin_layout Standard
The semantics of actions are defined in terms of a product update operation
 on the underlying modal frame.
 Briefly, we can think of the state of the world before an action as being
 represented by an epistemic frame 
\begin_inset Formula $\mathcal{M}$
\end_inset

 of modal logic .
 The action 
\begin_inset Formula $[U,i]$
\end_inset

 generates a new epistemic frame representing the state of the world after
 the action.
 The individual worlds in this new frame are the pairs 
\begin_inset Formula $\{(w,j)\,|\, w\in\mathcal{M},j\in\mathrm{U}\}$
\end_inset

, and the relations between these worlds are based on the corresponding
 relations in 
\begin_inset Formula $\mathcal{M}$
\end_inset

 and 
\begin_inset Formula $\mathrm{U}$
\end_inset

.
 The enclosed formula 
\begin_inset Formula $\phi$
\end_inset

 is then interpreted on this updated frame.
\end_layout

\begin_layout Standard
The second major contribution of LCC is a regression rule for handling formulae
 of this general form, namely:
\begin_inset Formula \[
[\mathrm{U},i][\pi]\phi\]

\end_inset


\end_layout

\begin_layout Standard
Such a formula reads: 
\begin_inset Quotes eld
\end_inset

after performing action 
\begin_inset Formula $i$
\end_inset

 from update frame 
\begin_inset Formula $\mathrm{U}$
\end_inset

, it is 
\begin_inset Formula $\pi$
\end_inset

-known that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 As a more concrete example, the following formula states that 
\begin_inset Quotes eld
\end_inset

after performing action 
\begin_inset Formula $i$
\end_inset

 from update frame 
\begin_inset Formula $\mathrm{U}$
\end_inset

, it is common knowledge amount 
\begin_inset Formula $G$
\end_inset

 that 
\begin_inset Formula $\phi$
\end_inset

 holds
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula \[
[\mathrm{U},i][(\bigcup_{agt\in G}agt)^{*}]\phi\]

\end_inset

 Their regression technique works by encoding the effects of the action
 
\begin_inset Formula $[\mathrm{U},i]$
\end_inset

 into both the formula 
\begin_inset Formula $\phi$
\end_inset

 and the epistemic path 
\begin_inset Formula $\pi$
\end_inset

.
 A syntactic transformation 
\begin_inset Formula $\mathcal{T}$
\end_inset

 achieves this according to the following equivalence: 
\begin_inset Formula \[
[\mathrm{U},i][\pi]\phi\,\,\,\equiv\,\,\,\bigwedge_{j=0}^{n-1}[\mathbf{\mathcal{T}}_{ij}^{\mathrm{U}}(\pi)][\mathrm{U},j]\phi\]

\end_inset


\end_layout

\begin_layout Standard
Loosly, this formula says: consider every possible action 
\begin_inset Formula $j=0$
\end_inset

 to 
\begin_inset Formula $j=n-1$
\end_inset

; determine the epistemic paths that would cause action 
\begin_inset Formula $i$
\end_inset

 to be mistaken for action 
\begin_inset Formula $j$
\end_inset

; and determine the effects of 
\begin_inset Formula $j$
\end_inset

 on the formula in question.
\end_layout

\begin_layout Standard
To understand the operation of 
\begin_inset Formula $\Trn_{ij}^{\mathrm{U}}$
\end_inset

, we reason as follows: suppose that the epistemic frame before the action
 is 
\begin_inset Formula $\mathcal{M}$
\end_inset

 with current world 
\begin_inset Formula $w$
\end_inset

, then frame after performing action 
\begin_inset Formula $[\mathrm{U},i]$
\end_inset

 is 
\begin_inset Formula $\mathcal{M}'$
\end_inset

 with current world 
\begin_inset Formula $(w,i)$
\end_inset

.
 Further suppose that another world 
\begin_inset Formula $(u,j)\in\mathcal{M}'$
\end_inset

 is reachable from 
\begin_inset Formula $(w,i)$
\end_inset

 by following the path 
\begin_inset Formula $\pi$
\end_inset

.
 These are the worlds that are picked out by the modal box 
\begin_inset Formula $[\pi]$
\end_inset

.
 Clearly the corresponding parent world 
\begin_inset Formula $u\in\mathcal{M}$
\end_inset

 must be related to 
\begin_inset Formula $w$
\end_inset

 in some way.
 The translation function allows us to locate such worlds: taking some liberties
 with notation, 
\begin_inset Formula $\mathcal{M}'\models((w,i),(u,j))\in\pi$
\end_inset

 if and only if 
\begin_inset Formula $\mathcal{M}\models(w,u)\in\Trn_{ij}^{\mathrm{U}}(\pi)$
\end_inset

.
\end_layout

\begin_layout Standard
The (partial) definition of the translation function is as follows:
\begin_inset Formula \begin{alignat*}{1}
\mathcal{T}_{ij}^{\mathrm{U}}(agt)= & \begin{cases}
?pre(i);agt & \mathrm{if\, i\stackrel{\tiny agt}{\rightsquigarrow}j}\\
?\bot & otherwise\end{cases}\\
\mathcal{T}_{ij}^{\mathrm{U}}(\pi_{1};\pi_{2})= & \bigcup_{k=0}^{n-1}\left(\mathcal{T}_{ik}^{\mathrm{U}}(\pi_{1});\mathcal{T}_{kj}^{\mathrm{U}}(\pi_{2})\right)\\
\mathcal{T}_{ij}^{\mathrm{U}}(\pi^{*})= & \mathcal{K}_{ijn}^{\mathrm{U}}(\pi)\end{alignat*}

\end_inset


\end_layout

\begin_layout Standard
Most of the cases are straightforward encodings of the semantics of product
 update.
 The only difficult case is the iteration operator 
\begin_inset Formula $\pi*$
\end_inset

 - it is handled using a variant of Kleene's theorem on finite automata
 to finitely express the transitive closure of the expressions produced
 by 
\begin_inset Formula $\Trn_{ij}^{*}(\pi)$
\end_inset

.
 Reproducing the definition of 
\begin_inset Formula $\Kln$
\end_inset

 here would take us too far afield.
\end_layout

\begin_layout Subsection
From LCC to the Situation Calculus
\end_layout

\begin_layout Standard
In the remainder of this section, we adapt the techniques introduced in
 LCC to handle complex epistemic modalities in our formalism in the situation
 calculus.
 This is far from straightforward, as LCC domains have two restrictions
 which are entirely inappropriate for the situation calculus:
\end_layout

\begin_layout Itemize
LCC is 
\emph on
propositional
\emph default
: actions do not take arguments and no quantification is required.
\end_layout

\begin_layout Itemize
LCC is funamentally 
\emph on
synchronous
\emph default
:
\emph on
 
\emph default
reasoning is performed by regressing one action at a time, without the 
\begin_inset Quotes eld
\end_inset

all possible futures
\begin_inset Quotes erd
\end_inset

 approach needed to handle hidden actions.
\end_layout

\begin_layout Standard
We also gain some simplifications in moving to the situation calculus.
 We have no need for explicit update frames, as the epistemic relationships
 between actions are given implicitly by means of the 
\begin_inset Formula $obs$
\end_inset

 function.
 In moving to a first-order formalism, we also gain the expressivity needed
 to directly express the regression of 
\begin_inset Formula $\pi^{*}$
\end_inset

 without having to employ a Kleene-style argument.
\end_layout

\begin_layout Standard
The section proceeds as follows.
 In Subsection 
\begin_inset LatexCommand ref
reference "sub:Epistemic-Paths"

\end_inset

 we define a variant of first-order dynamic logic for use as an epistemic
 path language, a show how to encode it in the situation calculus.
 Subsection 
\begin_inset LatexCommand ref
reference "sub:Synchronous-Epistemic-Fluent"

\end_inset

 develops a syncrhonous account of knowledge, assuming that there are no
 hidden actions.
 We develop regression rules for this version and prove that they respect
 the semantics of the epistemic path language.
 Subsection 
\begin_inset LatexCommand ref
reference "sub:Introducing-Hidden-Actions"

\end_inset

 introduces hidden actions by explicitly representing them as a special
 action term, and shows how a fixpoint construction can reason about arbitrarily
-long sequences of hidden actions.
 We then relate our construction back to the results of Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 by showing that in the case of a single agent, this fixpoint construction
 precisely matches that produced by the persistence condition in equation
 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Epistemic Paths
\begin_inset LatexCommand label
name "sub:Epistemic-Paths"

\end_inset


\end_layout

\begin_layout Standard
Unlike the work of 
\begin_inset LatexCommand citet
key "vanBenthem06lcc"

\end_inset

, we cannot use propositional dynamic logic as our epistemic path language.
 While we have limited ourselves to finitely many action types, our action
 types take arguments and we thus have potentially infinitely many individual
 action instances.
 To handle this we need some form of quantification in our epistemic path
 language - in short, we need 
\emph on
first-order dynamic logic
\emph default
.
 The variant we use is the dynamic term-modal logic of 
\begin_inset LatexCommand citet
key "kooi07dyn_termmodal_logic"

\end_inset

.
\end_layout

\begin_layout Standard
The presentation we use below is standard in the situation calculus, but
 unusual for modal logic: we encode the syntax and semantics of our epistemic
 path language in the language of the situation calculus, using terms to
 represent formulae, substitutions, and other semantic objects of dynamic
 logic.
 The details of this encoding are straightforward but tedious, and are ommitted;
 the standard treatment is by 
\begin_inset LatexCommand citet
key "giacomo00congolog"

\end_inset

.
 In the following 
\begin_inset Formula $\phi$
\end_inset

 will be (the encoding of) a uniform formula, and 
\begin_inset Formula $\mu$
\end_inset

 will be (the encoding of) a first-order substitution.
\end_layout

\begin_layout Standard
First, we must specify the syntax of our epistemic path language.
 We will use 
\begin_inset Formula $\pi$
\end_inset

 to denote an arbitrary epistemic path expression.
 
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path Let 
\begin_inset Formula $agt$
\end_inset

 be an 
\noun on
Agent 
\noun default
term, 
\begin_inset Formula $\phi$
\end_inset

 a uniform formula, 
\begin_inset Formula $x$
\end_inset

 a variable and 
\begin_inset Formula $t$
\end_inset

 a term, then the epistemic path terms 
\begin_inset Formula $\pi$
\end_inset

 are the smallest set matching the following structural rules:
\begin_inset Formula \[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\, x:=t\,|\,\exists x\]

\end_inset


\end_layout

\begin_layout Standard
The test (
\begin_inset Formula $?$
\end_inset

), sequence (
\begin_inset Formula $;$
\end_inset

), choice (
\begin_inset Formula $\cup$
\end_inset

) and transitive closure (
\begin_inset Formula $^{*}$
\end_inset

) operators are standard in dynamic logic and have the same meaning as in
 LCC.
 The two additional operators allow the value of variables to change during
 path traversal: 
\begin_inset Formula $x:=t$
\end_inset

 sets the variable 
\begin_inset Formula $x$
\end_inset

 to the specific term 
\begin_inset Formula $t$
\end_inset

, while 
\begin_inset Formula $\exists x$
\end_inset

 non-deterministically binds 
\begin_inset Formula $x$
\end_inset

 to some value.
\end_layout

\begin_layout Standard
It's worth reviewing again the purpose of this language.
 Despite utilising the syntax of dynamic logic, it is 
\emph on
not
\emph default
 related to actions in any way.
 Rather it expresses complex 
\emph on
epistemic
\emph default
 paths, and will be interpreted over the epistemic frame generated by the
 various 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 relations.
 To make this clear, here is some standard kinds of knowledge would be expressed
 using the standard account of knowledge, and using these epistemic modalities:
\end_layout

\begin_layout Itemize
Individual Knowledge: 
\begin_inset Formula $\Knows(agt,\phi,s)\,\,\,\,\Rightarrow\,\,\,\,\Knows(agt,\phi,s)$
\end_inset


\end_layout

\begin_layout Itemize
Nested Knowledge: 
\begin_inset Formula $\Knows(agt_{1},\Knows(agt_{2},\phi),s)\,\,\,\,\Rightarrow\,\,\,\,\Knows(agt_{1};agt_{2},\phi,s)$
\end_inset


\end_layout

\begin_layout Itemize
Joint Knowledge: 
\begin_inset Formula $\Knows(agt_{1},\phi,s)\,\wedge\,\Knows(agt_{2},\phi,s)\,\,\,\,\Rightarrow\,\,\,\,\Knows(agt_{1}\cup agt_{2},\phi,s)$
\end_inset


\end_layout

\begin_layout Itemize
Common Knowledge: 
\begin_inset Formula $\CKnows(G,\phi,s)\,\,\,\,\Rightarrow\,\,\,\,\Knows((\bigcup_{agt\in G}agt)^{*},\phi,s)$
\end_inset


\end_layout

\begin_layout Standard
As discussed above, the first step in this formalisation is to treat only
 the case of 
\emph on
syncrhonous
\emph default
 knowledge - that is, knowledge when everyone is aware that an action has
 occurred.
 To this end, we extend the notation of Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 and let 
\begin_inset Formula $K_{0}(agt,s'',s)$
\end_inset

 (with corresponding macro 
\begin_inset Formula $\KnowsZ(agt,\phi,s)$
\end_inset

) denote the synchronous knowledge of an agent in situation 
\begin_inset Formula $s$
\end_inset

.
 Given synchronicity, the successor state axiom for this fluent is straightforwa
rd:
\begin_inset Formula \begin{multline}
K_{0}(agt,s'',do(a,s))\equiv\\
\exists s',a':\, s''=do(a',s')\wedge Poss(a',s')\wedge obs(agt,a,s)=obs(agt,a',s')\wedge K_{0}(agt,s',s)\label{eq:K0_ssa}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
Now, formulae of first-order dynamic logic are interpreted relative to both
 a 
\begin_inset Quotes eld
\end_inset

current world
\begin_inset Quotes erd
\end_inset

 and a 
\begin_inset Quotes eld
\end_inset

current substitution
\begin_inset Quotes erd
\end_inset

 
\begin_inset LatexCommand citep
key "kooi07dyn_termmodal_logic"

\end_inset

.
 To encode the semantics in the situation calculus, we introduce a new fluent
 
\begin_inset Formula $K_{DL}$
\end_inset

 that gives a transition-style semantics over pairs 
\begin_inset Formula $(\mu,s)$
\end_inset

.
 As is traditional in the situation calculus, the 
\begin_inset Quotes eld
\end_inset

current world
\begin_inset Quotes erd
\end_inset

 is the final argument to the fluent.
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path\InsetSpace ~
Semantics The semantics of an epistemic path 
\begin_inset Formula $\pi$
\end_inset

 are given by the fluent 
\begin_inset Formula $K_{DL}$
\end_inset

, defined as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather*}
K_{DL}(agt,\mu'',s'',\mu,s)\,\equiv\,\mu''=\mu\,\wedge\, K_{0}(agt,s'',s)\\
K_{DL}(?\phi,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu\,\wedge\,\mu(\phi)[s]\\
K_{DL}(\pi_{1};\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\exists\mu',s':\, K_{DL}(\pi_{1},\mu',s',\mu,s)\,\wedge\, K_{DL}(\pi_{2},\mu'',s'',\mu',s')\\
K_{DL}(\pi_{1}\cup\pi_{2},\mu'',s'',\mu,s)\,\equiv\, K_{DL}(\pi_{1},\mu'',s'',\mu,s)\,\vee\, K_{DL}(\pi_{2},\mu'',s'',\mu,s)\\
K_{DL}(x:=t,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu[x/t]\\
K_{DL}(\exists x,\mu'',s'',\mu,s)\,\equiv\,\exists z:\, s''=s\,\wedge\,\mu''=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu'',s'',\mu,s)\rightarrow K_{DL}(\pi^{*},\mu'',s'',\mu,s)\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Where we use the following abbreviations (standing for 
\begin_inset Quotes eld
\end_inset

reflexive
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

transitive
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

contains
\begin_inset Quotes erd
\end_inset

 respectively) to define 
\begin_inset Formula $\pi*$
\end_inset

 as the reflexive transitive closure of 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{align*}
\mathbf{refl}\isdef & \,\, P(\mu,s,\mu,s)\\
\mathbf{tran\isdef} & \,\,\forall\mu_{1},s_{1},\mu_{2},s_{2}:\, P(\mu_{1},s_{1},\mu,s)\wedge K_{DL}(\pi,\mu_{2},s_{2},\mu_{1},s_{1})\,\rightarrow\, P(\mu_{2},s_{2},\mu,s)\\
\mathbf{cont}\isdef & \,\,\forall\mu',s':\, K_{DL}(\pi,\mu',s',\mu,s)\,\rightarrow\, P(\mu',s',\mu,s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Note that we require a second-order axiom to express transitive closure.
\end_layout

\begin_layout Subsection
A Synchronous Epistemic Fluent
\begin_inset LatexCommand label
name "sub:Synchronous-Epistemic-Fluent"

\end_inset


\end_layout

\begin_layout Standard
Using 
\begin_inset Formula $K_{DL}$
\end_inset

 for the path semantics, we can easily extend the synchronous knowledge
 fluent 
\begin_inset Formula $K_{0}$
\end_inset

 to take epistemic paths are its first argument, rather than only taking
 agent terms.
 Let 
\begin_inset Formula $\mu^{\epsilon}$
\end_inset

 denote the empty substituion, then:
\begin_inset Formula \[
\pi\neq agt\,\rightarrow\,\left[K_{0}(\pi,s'',s)\,\equiv\,\exists\mu:\, K_{DL}(\pi,\mu,s'',\mu^{\epsilon},s)\right]\ \]

\end_inset


\end_layout

\begin_layout Standard
The macro 
\begin_inset Formula $\KnowsZ$
\end_inset

 can also be extended to epistemic paths in the obvious way:
\begin_inset Formula \[
\KnowsZ(\pi,\phi,s)\isdef\forall s':\, K_{0}(\pi,s',s)\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K_{0},\pi}$
\end_inset

 the axioms developed above for syncrhonous complex epistemic modalities.
\end_layout

\begin_layout Standard
Now, we are in a similar position to Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Observation"

\end_inset

: we have defined a knowledge fluent, and given axioms for how it should
 behave, but these axioms are not in the correct form to include in a basic
 action theory.
 To overcome this, we define a regression rule for 
\begin_inset Formula $\KnowsZ(\pi,\phi,s)$
\end_inset

 expressions and prove that it respects the semantics of 
\begin_inset Formula $\Dt_{K_{0},\pi}$
\end_inset

.
 It is here that we incorporate the second big idea from LCC - use a syntactic
 transform to encode the effects of actions within epistemic paths as well
 as in primitive formulae.
 Mirrorring LCC, we introduce another meta-operator 
\begin_inset Formula $\Trn$
\end_inset

 for this purpose.
\end_layout

\begin_layout Standard
First, some notation.
 We assume that the domain 
\begin_inset Formula $\Dt$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 distinct action types, which we shall denote 
\begin_inset Formula $A_{0}$
\end_inset

 through 
\begin_inset Formula $A_{n-1}$
\end_inset

.
 We will use 
\begin_inset Formula $\vars{x}$
\end_inset

 to stand for a vector of (enodings of) variables and use 
\begin_inset Formula $\vars{x}:=\vars{y}$
\end_inset

 and 
\begin_inset Formula $\exists\vars{x}$
\end_inset

 as syntactic shortcuts for a series of individual variable assignments.
\end_layout

\begin_layout Standard
Now let us consider the required operation of 
\begin_inset Formula $\Trn$
\end_inset

 by analogy to the standard regression operator 
\begin_inset Formula $\Reg$
\end_inset

.
 One can think of regression as a 
\begin_inset Quotes eld
\end_inset

pre-encoding
\begin_inset Quotes erd
\end_inset

 of the effects of an action: 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\begin_inset Formula $do(a,s)$
\end_inset

 if and only if 
\begin_inset Formula $\Reg(\phi,a)$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

.
 The path regressor 
\begin_inset Formula $\Trn$
\end_inset

 needs to lift this idea to epistemic paths as follows: there is a 
\begin_inset Formula $\pi$
\end_inset

-path from 
\begin_inset Formula $do(a,s)$
\end_inset

 to 
\begin_inset Formula $do(a',s')$
\end_inset

 if and only if there is a 
\begin_inset Formula $\Trn(\pi,a,a')$
\end_inset

-path from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
\end_layout

\begin_layout Standard
Before giving the definition for this operator, let us show how it will
 be used.
 The clause for regressing a complex epistemic modality will be: 
\begin_inset Formula \begin{equation}
\Reg(\KnowsZ(\pi,\phi,do(a,s)))\,\isdef\,\bigwedge_{i=0}^{n-1}\forall\vars{x}:\,\KnowsZ(\Trn(\pi,a,A_{i}(\vars{x})),\Reg(\phi,A_{i}(\vars{x})),s)\label{eq:R_pi}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We consider each action type 
\begin_inset Formula $A_{i}(\vars{x})$
\end_inset

 in turn, using 
\begin_inset Formula $\Trn(\pi,a,A_{i}(\vars{x}))$
\end_inset

 to identify the conditions under which 
\begin_inset Formula $A_{i}(\vars{x})$
\end_inset

 could be confused for 
\begin_inset Formula $a$
\end_inset

, and standard regression to encode the effects of 
\begin_inset Formula $A_{i}(\vars{x})$
\end_inset

 into 
\begin_inset Formula $\phi$
\end_inset

.
\end_layout

\begin_layout Standard
Now, in order to accomplish its task, the path regressor will need to make
 various assertions about the action that is to be performed in each situation
 traversed by the path.
 In LCC this was tracked implicitly, since propositional dynamic logic has
 no way to express this stateful information.
 By moving to first-order dynamic logic, we can use a variable for this
 purpose.
 As well as making the presentation more concise, we avoid the need to resort
 to a Kleene-style argument for handling the iteration operator.
 So the basic operation of 
\begin_inset Formula $\Trn$
\end_inset

 will be:
\end_layout

\begin_layout Itemize
introduce a fresh variable 
\begin_inset Formula $x_{a}$
\end_inset

 to hold the action that will be performed in the current situation
\end_layout

\begin_layout Itemize
whenever the path traverses to a new situation, use 
\begin_inset Formula $\exists x_{a}$
\end_inset

 to select a new action to be performed there
\end_layout

\begin_layout Itemize
at the beginning and end of the path, bind 
\begin_inset Formula $x_{a}$
\end_inset

 to a specific action type
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path\InsetSpace ~
Regressor
\begin_inset LatexCommand label
name "def:EpistemicPathRegression"

\end_inset

 The epistemic path regressor 
\begin_inset Formula $\Trn$
\end_inset

 operates according to the definitions below, where 
\begin_inset Formula $x_{a}$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are fresh variables not appearing in 
\begin_inset Formula $\pi$
\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{align*}
\Trn(agt,A_{i}(\vars{x}),A_{j}(\vars{y}))\,\isdef\,\, & x_{a}:=A_{i}(\vars{x})\,;\,\TrnA(\pi,x_{a})\,;\, x_{a}:=A_{j}(\vars{y})\\
\\\TrnA(agt,x)\,\isdef\,\, & \exists z\,;\,?obs(agt,x)=z\,;\,\exists x\,;\, agt\,;\,?obs(agt,x)=z\,;\,?Poss(x)\\
\TrnA(?\phi,x)\isdef\,\, & \Reg(\phi,x)\\
\TrnA(\exists y,x)\isdef\,\, & \exists z\\
\TrnA(y:=t,x)\isdef\,\, & y:=t\\
\TrnA(\pi_{1};\pi_{2},x)\isdef\,\, & \begin{array}{c}
\TrnA(\pi_{1},x)\,;\,\TrnA(\pi_{2},x)\end{array}\\
\TrnA(\pi_{1}\cup\pi_{2},x)\isdef\,\, & \TrnA(\pi_{1},x)\cup\TrnA(\pi_{2},x)\\
\TrnA(\pi^{*},x)\isdef\,\, & \TrnA(\pi,x)^{*}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The following theorem states that these definitions behave has desired,
 respecting the semantics of the epistemic paths:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Trn-respects-epi-paths"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

 and action 
\begin_inset Formula $a$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\cup\Dt_{K_{0},\pi}\,\models\, K_{0}(\pi,s'',do(a,s))\,\equiv\,\bigvee_{i=0}^{n-1}\exists\vars{x},s':\, s''=do(A_{i}(\vars{x}),s')\wedge K_{0}(\Trn(\pi,a,A_{i}(\vars{x})),s',s)\end{gather*}

\end_inset


\end_layout

\begin_layout ProofSketch
The proof proceeds by cases, covering each path operator in turn.
 In the case of a single agent the theorem is a direct consequence of equation
 
\begin_inset LatexCommand eqref
reference "eq:K0_ssa"

\end_inset

.
 The other operators are straightforward using the definitions of 
\begin_inset Formula $K_{DL}$
\end_inset

.
\end_layout

\begin_layout Standard
Given that 
\begin_inset Formula $\Trn$
\end_inset

 respects the semantics of our epistemic path language, we are free to use
 it to define the regression of a complex epistemic modality.
 The definition given in equation 
\begin_inset LatexCommand eqref
reference "eq:R_pi"

\end_inset

 is justified by the following theorem:
\end_layout

\begin_layout Theorem
For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

 and action 
\begin_inset Formula $a$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\cup\Dt_{K_{0},\pi}\,\models\,\KnowsZ(\pi,\phi,do(a,s))\,\equiv\,\bigwedge_{i=0}^{n-1}\forall\vars{x}:\,\KnowsZ(\Trn(\pi,a,A_{i}(\vars{x})),\Reg(\phi,A_{i}(\vars{x})),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
Expanding the definition of the 
\begin_inset Formula $\KnowsZ$
\end_inset

 macro gives 
\begin_inset Formula $\forall s':\, K_{0}(\pi,s',do(a,s))\rightarrow\phi[s'].$
\end_inset

 Substituting the right-hand side of the equivalence in Theorem 
\begin_inset LatexCommand eqref
reference "thm:Trn-respects-epi-paths"

\end_inset

 for 
\begin_inset Formula $K_{0}$
\end_inset

, the enclosing universal quantification transforms the 
\begin_inset Formula $\bigvee\exists$
\end_inset

 prefix into 
\begin_inset Formula $\bigwedge\forall$
\end_inset

 to give the required equivalence.
 
\end_layout

\begin_layout Subsection
Introducing Hidden Actions
\begin_inset LatexCommand label
name "sub:Introducing-Hidden-Actions"

\end_inset


\end_layout

\begin_layout Standard
We now have a powerful account of multi-agent knowledge for synchronous
 domains, but it remains to combine this with our handling of arbitrarily-long
 sequences of hidden actions.
 We develop support for hidden actions entirely at the meta-level, defining
 it directly in the operation of the regression operator.
\end_layout

\begin_layout Standard
First, we introduce a special action term 
\begin_inset Formula $\varepsilon$
\end_inset

, which should be read as 
\begin_inset Quotes eld
\end_inset

nothing happens
\begin_inset Quotes erd
\end_inset

.
 It has no preconditions, no effects, and results in no observations for
 any agent.
\end_layout

\begin_layout Definition
Let the basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 have 
\begin_inset Formula $n$
\end_inset

 action terms.
 Then denote by 
\begin_inset Formula $\Dt_{\varepsilon}$
\end_inset

 the extension of 
\begin_inset Formula $\Dt$
\end_inset

 with the special action 
\begin_inset Formula $\varepsilon$
\end_inset

 as its 
\begin_inset Formula $(n+1)$
\end_inset

th action, adding the following definitions to 
\begin_inset Formula $\Dt_{ad}$
\end_inset

: 
\begin_inset Formula \begin{gather*}
Poss(\varepsilon,s)\equiv\top\\
obs(agt,\varepsilon,s)=\{\}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We will use this special action term to simulate agents reasoning about
 hypothetical futures in which they make no more observations, by inserting
 these empty actions after the action action in a situation term.
\end_layout

\begin_layout Definition
Define 
\begin_inset Formula $\mathcal{E}^{n}(s)$
\end_inset

 to be 
\begin_inset Formula $s$
\end_inset

 followed by 
\begin_inset Formula $n$
\end_inset

 empty actions, as follows:
\begin_inset Formula \[
\mathcal{E}^{0}(s)=s\]

\end_inset


\begin_inset Formula \[
\mathcal{E}^{1}(s)=do(\varepsilon,s)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{E}^{n}(s)=\mathcal{E}^{1}(\mathcal{E}^{n-1}(s))=do(\varepsilon,do(\varepsilon,...,do(\varepsilon,s)))\]

\end_inset


\end_layout

\begin_layout Standard
The intuition here is that we want 
\begin_inset Formula $\Knows(\pi,\phi)$
\end_inset

 to hold if 
\begin_inset Formula $\KnowsZ(\pi,\phi)$
\end_inset

 holds after allowing for any number of empty actions.
 Formally, we want to use the following infinite conjunction as the definition
 of 
\begin_inset Formula $\Knows(\pi,\phi,do(a,s))$
\end_inset

:
\begin_inset Formula \[
\Reg(\Knows(\pi,\phi,do(a,s)))\isdef\bigwedge_{n\in\mathbb{N}}\KnowsZ(\pi,\phi,\mathcal{E}^{n}(do(a,s)))\]

\end_inset


\end_layout

\begin_layout Standard
This section is devoted to establishing the validity of this defnition.
\end_layout

\begin_layout Lemma
For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

: 
\begin_inset Formula \[
\Dt_{\varepsilon}\cup\Dt_{K_{0},\pi}\models\,\KnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\KnowsZ(\pi,\phi,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
By a case analysis on the definition of 
\begin_inset Formula $\Trn$
\end_inset

, we determine that that path 
\begin_inset Formula $\Trn(\pi,\varepsilon,\varepsilon)$
\end_inset

 is a superset of the path 
\begin_inset Formula $\pi$
\end_inset

.
 Since 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\Reg(\phi,\varepsilon)=\phi$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 always, one of the conjuncts in the regression of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\KnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 will be 
\begin_inset Formula $\KnowsZ(\Trn(\pi,\varepsilon,\varepsilon),\phi,s)$
\end_inset

.
 Since the path 
\begin_inset Formula $\Trn(\pi,\varepsilon,\varepsilon)$
\end_inset

 is a superset of 
\begin_inset Formula $\pi$
\end_inset

, this implies 
\begin_inset Formula $\KnowsZ(\pi,\phi,s)$
\end_inset

 as required.
\end_layout

\begin_layout Lemma
For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, if there is some 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

 such that:
\begin_inset Formula \[
\Dt_{\varepsilon}\cup\Dt_{K_{0},\pi}\models\,\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n+1}(s))\]

\end_inset


\end_layout

\begin_layout Standard
Then:
\begin_inset Formula \[
\Dt_{\varepsilon}\cup\Dt_{K_{0},\pi}\models\,\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n}(s))\,\equiv\,\bigwedge_{m\in\mathbb{N}}\KnowsZ(\pi,\phi,\mathcal{E}^{m}(s))\]

\end_inset


\end_layout

\begin_layout Proof
By the above lemma, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n+1}(s))\rightarrow\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n}(s))$
\end_inset

 always.
 So for this particular 
\begin_inset Formula $n$
\end_inset

, the implication is in fact an equivalence.
 We then have 
\begin_inset Formula $\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m<n$
\end_inset

, and 
\begin_inset Formula $\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n}(s))\equiv\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m\geq n$
\end_inset

, which is enough to establish the infinite conjunction as required.
\end_layout

\begin_layout Standard
We can thus use the following regression definition, knowing that the infinite
 conjunction can be computed using a fixpoint calculation:
\begin_inset Formula \[
\Reg(\Knows(\pi,\phi,do(a,s)))\,\isdef\,\bigwedge_{n\in\mathbb{N}}\KnowsZ(\pi,\phi,\mathcal{E}^{n}(do(a,s)))\]

\end_inset


\end_layout

\begin_layout Subsection
The Link with Individual Knowledge
\end_layout

\begin_layout Standard
The last remaining link is perhaps most important of all: showing that this
 new account of knowledge actually captures the knowledge of the agents,
 according to the semantics of individual knowledge developed in Section
 
\begin_inset LatexCommand eqref
reference "sec:Obs-Knowledge"

\end_inset

.
 The following theorem established this important link - that the individual
 knowledge of an agent is the same using complex epistemic modalities as
 when using ordinary knowledge:
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $\Dt$
\end_inset

 be an arbitrary basic action theory, then for any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Theorem
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Theorem
if and only if
\begin_inset Formula \[
\Dt_{\varepsilon}\cup\Dt_{K_{0},\pi}\,\models\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Proof
Begin by considering the sequence of calculations made in regressing 
\begin_inset Formula $\KnowsZ(agt,\phi,\mathcal{E}^{1}(s))$
\end_inset

.
 First, we perform some simplification on 
\begin_inset Formula $\Trn$
\end_inset

:
\begin_inset Formula \begin{align*}
\Trn(agt,\varepsilon,A_{i}(\vars{x}))=\,\,\, & x_{a}:=\varepsilon\,;\,\exists z\,;\,?obs(agt,x_{a})=z\,;\,\exists x_{a}\\
 & \,\,\,\,\,\,\,;\, agt\,;\,?obs(agt,x_{a})=z\,;\,?Poss(x_{a})\,;\, x_{a}:=A_{i}(\vars{x})\\
=\,\,\, & \exists z\,;\,?obs(agt,\varepsilon)=z\,;\, agt\,;\,?objs(agt,A_{i}(\vars{x}))=z\,;\,?Poss(A_{i}(\vars{x}))\\
=\,\,\, & agt\,;\,?obs(agt,A_{i}(\vars{x}))=\{\}\wedge Poss(A_{i}(\vars{x}))\\
=\,\,\, & agt\,;\,?PbU(agt,A_{i}(\vars{x}))\end{align*}

\end_inset

 Now we can use this in the regression of 
\begin_inset Formula $\KnowsZ(agt,\phi,\mathcal{E}^{1}(s))$
\end_inset

.
 Note that since this regression is with respect to 
\begin_inset Formula $\Dt_{\varepsilon}$
\end_inset

, actions range up the 
\begin_inset Formula $n$
\end_inset

 rather than 
\begin_inset Formula $n-1$
\end_inset

, with the final action being 
\begin_inset Formula $\varepsilon$
\end_inset


\begin_inset Formula \begin{align*}
\KnowsZ(agt,\phi,\mathcal{E}^{1}(s))\equiv\,\, & \bigwedge_{i=0}^{n}\forall\vars{x}:\,\KnowsZ(\Trn(\pi,\varepsilon,A_{i}(\vars{x})),\Reg(\phi,A_{i}(\vars{x})),s)\\
\equiv\,\, & \bigwedge_{i=0}^{n}\forall\vars{x}:\,\KnowsZ(agt;?PbU(agt,A_{i}(\vars{x})),\Reg(\phi,A_{i}(\vars{x})),s)\\
\equiv\,\, & \KnowsZ(agt,\phi,s)\,\,\wedge\\
 & \,\,\,\,\,\,\bigwedge_{i=0}^{n-1}\forall\vars{x}:\,\KnowsZ(agt,PbU(agt,A_{i}(\vars{x}))\rightarrow\Reg(\phi,A_{i}(\vars{x})),s)\\
\equiv\,\, & \KnowsZ(agt,\phi\wedge\forall a:\, PbU(agt,a)\rightarrow\Reg(\phi,a),s)\\
\equiv\,\, & \KnowsZ(agt,\Pst^{1}(\phi,PbU(agt)),s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Using the same construction, we can show that in general:
\begin_inset Formula \begin{align*}
\KnowsZ(agt,\phi,\mathcal{E}^{n}(s))\equiv\,\, & \KnowsZ(agt,\Pst^{1}(\phi,PbU(agt)),\mathcal{E}^{n-1}(s))\\
\equiv\,\, & \KnowsZ(agt,\Pst^{n}(\phi,PbU(agt)),s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Clearly the fixpoint calculation used to find 
\begin_inset Formula $n$
\end_inset

 such that 
\begin_inset Formula $\KnowsZ(agt,\phi,\mathcal{E}^{n}(s))\rightarrow\KnowsZ(agt,\phi\mathcal{E}^{n+1}(s))$
\end_inset

 is the same as the fixpoint calculation used to find 
\begin_inset Formula $\Pst(\phi,PbU(agt))$
\end_inset

.
 Therefore, we have:
\begin_inset Formula \[
\Dt_{\varepsilon}\cup\Dt_{K_{0},\pi}\,\models\,\Knows(agt,\phi,do(a,s))\,\equiv\,\KnowsZ(agt,\Pst(\phi,PbU(agt)),do(a,s))\]

\end_inset


\end_layout

\begin_layout Proof
Regressing the right-hand side:
\begin_inset Formula \begin{align*}
\Knows(agt,\phi,do(a,s))\,\equiv\,\, & \bigwedge_{i=0}^{n}\forall\vars{x}:\,\KnowsZ(\Trn(agt,a,A_{i}(\vars{x})),\Reg(\Pst(\phi,PbU(agt)),A_{i}(\vars{x})),s)\\
\equiv\,\,\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Now, since 
\begin_inset Formula $\varepsilon$
\end_inset

 has no preconditions and no effects, the calculation of 
\begin_inset Formula $\Pst(\phi,PbU(agt))$
\end_inset

 under 
\begin_inset Formula $\Dt_{\varepsilon}$
\end_inset

 will be identical to that under 
\begin_inset Formula $\Dt$
\end_inset

.
 
\end_layout

\begin_layout Section
Simplifying the Reasoning Procedure
\begin_inset LatexCommand label
name "sec:Simplifying-Reasoning"

\end_inset


\end_layout

\begin_layout Standard
reasoning procedure: undecidable in general case! Need a decidable domian.
 Here are some things we can do to help the situation:
\end_layout

\begin_layout Subsection
Propositionality
\end_layout

\begin_layout Standard
\begin_inset Formula $K_{DL}$
\end_inset

 reduces to the semantics of propositional dynamic logic, which is decidable.
\end_layout

\begin_layout Subsection
Synchronicity
\end_layout

\begin_layout Standard
By equipping agents with a global clock tick, the persistence condition
 is no longer required.
 Since this is the biggest source for computational complexity, that's a
 big win! 
\end_layout

\begin_layout Subsection
Observability
\end_layout

\begin_layout Standard
Ensure that the update frame is weakly connected, so that most 
\begin_inset Formula $\Trn(\pi,a_{i},a_{j})$
\end_inset

 are vacuously false.
\newline

\end_layout

\begin_layout Section
Related Work
\begin_inset LatexCommand label
name "sec:Related-Work"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "morgenstern90knowledge"

\end_inset

 - hidden actions, appeals to motivated action theory.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "delgrande01sitcalc_cleudo"

\end_inset

 - shows that common knowledge is useful, but appeals to a (non-existent)
 solution from elsewhere
\end_layout

\begin_layout Standard
clearly the long lineage of 
\begin_inset LatexCommand cite
key "baltag99epi_act_structures"

\end_inset

, 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

 that have developed the basis of these techniques.
 
\begin_inset LatexCommand cite
key "moss05iter_pal"

\end_inset

 Iterated PAL is undecidable.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "vanBentham06epi_temporal_logic"

\end_inset

 big discussion and comparison on epistemic temporal logics.
 defines notion of 
\begin_inset Quotes eld
\end_inset

synchronised
\begin_inset Quotes erd
\end_inset

 system that we use above.
\end_layout

\begin_layout Standard
An alternate formulation due to 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

 assumes the opposite extreme, that agents are only aware of the actions
 that they themselves perform:
\begin_inset Formula \begin{align}
K(agt,s'',do(a,s))\equiv\,\,\, & \exists s':\, K(agt,s',s)\nonumber \\
 & \wedge\,(actor(a)\neq agt\,\rightarrow\, s'\leq_{actor(a)\neq agt}s''))\label{eq:k_ssa_exo}\\
 & \wedge\,(actor(a)=agt\,\rightarrow\,\exists s^{*}:\,\left[s'\leq_{actor(a)=agt}s^{*}\wedge\right.\nonumber \\
 & \,\,\,\,\,\,\,\,\,\,\,\,\left.s''=do(a,s^{*})\wedge Poss(a,s^{*})\wedge sr(a,s)=sr(a,s^{*}))\right]\nonumber \end{align}

\end_inset

 Here agents consider possible any situation compatible with the actions
 that they themselves have performed.
 There may have been an arbitrary sequence of situations between 
\begin_inset Formula $s'$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

 of which the agent was unaware, because they consisted entirely of exogenous
 actions (that is, actions where 
\begin_inset Formula $actor(a)\neq agt$
\end_inset

).
 Agents are thus totally ignorant of the actions performed by others.
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K,exo}$
\end_inset

 the axioms for the 
\begin_inset Quotes eld
\end_inset

total ignorance
\begin_inset Quotes erd
\end_inset

 account of knowledge due to 
\begin_inset LatexCommand citet
key "Lesperance99sitcalc_approach"

\end_inset

, as detailed in equations (
\begin_inset LatexCommand ref
reference "eq:k_ssa_exo"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

).
\end_layout

\begin_layout Standard
This approach is also limiting, in that agents can 
\emph on
never
\emph default
 be aware of the actions performed by others.
 Consider our example of agents occupying a building who are aware of all
 actions performed in the same room, or even the simple case of an agent
 being aware that another agent has collided with it; full generality requires
 that agents can be aware of 
\emph on
some
\emph default
 of the actions performed by others.
\end_layout

\begin_layout Standard
Furthermore, suppose that 
\begin_inset Formula $agt$
\end_inset

 has just performed action 
\begin_inset Formula $a_{1}$
\end_inset

, so the world is in some situation 
\begin_inset Formula $do(a_{1},s)$
\end_inset

.
 Another agent then performs the action 
\begin_inset Formula $a_{2}$
\end_inset

, leaving the world in situation 
\begin_inset Formula $do(a_{2},do(a_{1},s))$
\end_inset

.
 Since it is not aware of the occurrence of 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $agt$
\end_inset

 cannot be aware that the state of the world has changed.
 Its knowledge should therefore remain unchanged.
 Unfortunately this is not the case under this formulation:
\begin_inset Formula \[
\Dt\cup\Dt_{K,exo}\not\models actor(a_{2})\neq agt\rightarrow K(agt,s',do(a_{2},do(a_{1},s)))\equiv K(agt,s',do(a_{1},s))\]

\end_inset


\end_layout

\begin_layout Standard
To faithfully represent this aspect of knowledge, the successor state axiom
 for 
\begin_inset Formula $K$
\end_inset

 must consider any 
\emph on
future
\emph default
 that can be brought about by exogenous actions, rather than any 
\emph on
past
\emph default
 as done in equation (
\begin_inset LatexCommand ref
reference "eq:k_ssa_exo"

\end_inset

).
\end_layout

\begin_layout Section
Future Work
\begin_inset LatexCommand label
name "sec:Future-Work"

\end_inset


\end_layout

\begin_layout Standard
Decidability and effectiveness guarantees.
\end_layout

\begin_layout Standard
Concurrent actions.
\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Standard
hooray for us, this is a great paper :-)
\end_layout

\begin_layout Section
\start_of_appendix
Proofs
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, Legal(s)\wedge s\leq_{PbU(agt)}s'\,\rightarrow\, Legal(s')\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, since 
\begin_inset Formula $PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Legal$
\end_inset

 is equivalent to 
\begin_inset Formula $\leq_{Poss}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, s\leq_{PbU(agt)}s'\,\rightarrow\, view(agt,s')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, by induction on the definition of 
\begin_inset Formula $view$
\end_inset

 from equation (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

).
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-root"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, K(agt,s'',s)\,\rightarrow\, K(agt,root(s''),root(s))\]

\end_inset


\end_layout

\begin_layout Proof
Trivial in the base case.
 For the 
\begin_inset Formula $do(a,s)$
\end_inset

 case, suppose that 
\begin_inset Formula $K(agt,s'',do(a,s))$
\end_inset

.
 Then by equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) there is some 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $s'\sqsubseteq s''$
\end_inset

 and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 Then 
\begin_inset Formula $root(s'')$
\end_inset

 = 
\begin_inset Formula $root(s')$
\end_inset

, and 
\begin_inset Formula $K(root(s'),root(s))$
\end_inset

 by the inductive hypothesis.
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, K(agt,s'',s)\,\rightarrow\, Legal(s'')\]

\end_inset


\end_layout

\begin_layout Proof
All 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 are initial and therefore legal.
 So in the base case we have 
\begin_inset Formula $s'\leq_{PbU(agt)}s''$
\end_inset

 by equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

), making 
\begin_inset Formula $s''$
\end_inset

 is legal by lemma 
\begin_inset LatexCommand ref
reference "lem:pbu-implies-legal"

\end_inset

.
 
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(a,s)$
\end_inset

 case, equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) ensures that 
\begin_inset Formula $do(a',s')\leq_{PbU(agt)}s''$
\end_inset

 for some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $a'$
\end_inset

 satisfying 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 and 
\begin_inset Formula $Poss(a',s')$
\end_inset

.
 Since 
\begin_inset Formula $s'$
\end_inset

 is legal by the inductive hypothesis, 
\begin_inset Formula $s''$
\end_inset

 must be legal.
 
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\, K(agt,s'',s)\,\rightarrow view(agt,s'')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the base case, there must be an 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $Init(s')$
\end_inset

 and 
\begin_inset Formula $s'\leq_{PbU(agt)}s''$
\end_inset

.
 Therefore 
\begin_inset Formula $view(s'')$
\end_inset

 = 
\begin_inset Formula $view(s')$
\end_inset

 = 
\begin_inset Formula $\epsilon$
\end_inset

 = 
\begin_inset Formula $view(s)$
\end_inset

, as required.
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(a,s)$
\end_inset

 case, suppose 
\begin_inset Formula $obs(agt,a,s)=\{\}$
\end_inset

.
 Then 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

= 
\begin_inset Formula $view(agt,s)$
\end_inset

, while equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) gives us 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

, which yields 
\begin_inset Formula $view(agt,s'')$
\end_inset

 = 
\begin_inset Formula $view(agt,s)$
\end_inset

 by the inductive hypothesis.
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $obs(agt,a,s)\neq\{\}$
\end_inset

, then we have 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $a'$
\end_inset

 such that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $do(a',s')\leq_{PbU(agt)}s''$
\end_inset

, 
\begin_inset Formula $obs(agt,a,s)$
\end_inset

 = 
\begin_inset Formula $obs(agt,a',s')$
\end_inset

, and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 By the inductive hypothesis 
\begin_inset Formula $view(agt,s')=view(agt,s)$
\end_inset

, and we have the following: 
\begin_inset Formula $view(agt,s'')$
\end_inset

 = 
\begin_inset Formula $view(agt,do(a',s'))$
\end_inset

 = 
\begin_inset Formula $obs(agt,a,s)\cdot view(agt,s')$
\end_inset

 = 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

 as required.
 
\end_layout

\begin_layout Standard
Combining these results, we can state the following theorem:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:k_obs_equiv"

\end_inset

 For a basic action theory 
\begin_inset Formula $\Dt_{obs}$
\end_inset

, for any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt_{obs}\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge view(agt,s'')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the 
\series bold
if
\series default
 direction, we simply combine lemmas 
\begin_inset LatexCommand ref
reference "lem:K-implies-root"

\end_inset

, 
\begin_inset LatexCommand ref
reference "lem:K-implies-legal"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "lem:K-implies-view"

\end_inset

.
 
\end_layout

\begin_layout Proof
For the 
\series bold
only-if
\series default
 base case, the 
\begin_inset Formula $\exists s'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) is trivially satisfied by 
\begin_inset Formula $root(s'')$
\end_inset

 and so the equivalence holds.
\end_layout

\begin_layout Proof
For the 
\series bold
only-if
\series default
 inductive case with 
\begin_inset Formula $do(a,s)$
\end_inset

, we have two sub-cases to consider.
 Suppose 
\begin_inset Formula $obs(agt,a,s)=\{\}$
\end_inset

: then 
\begin_inset Formula $view(agt,s'')$
\end_inset

 = 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

 = 
\begin_inset Formula $view(agt,s)$
\end_inset

 and 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 holds by the inductive hypothesis, satisfying the equivalence in equation
 (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

).
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $obs(agt,a,s)\neq\{\}$
\end_inset

: then we have:
\begin_inset Formula \[
view(agt,do(a,s))=obs(agt,a,s)\cdot view(agt,s)=view(agt,s'')\]

\end_inset

For this to be the case, and since 
\begin_inset Formula $s''$
\end_inset

 is legal, there must be some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $a'$
\end_inset

 satisfying 
\begin_inset Formula $obs(agt,a',s')$
\end_inset

 = 
\begin_inset Formula $obs(agt,a,s)$
\end_inset

, 
\begin_inset Formula $view(agt,s')$
\end_inset

 = 
\begin_inset Formula $view(agt,s)$
\end_inset

 and 
\begin_inset Formula $do(a',s')\leq_{PbU(agt)}s''$
\end_inset

 .
 This is enough to satisfy the 
\begin_inset Formula $\exists s',a'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) and so the equivalence holds.
\end_layout

\begin_layout Theorem
Given a basic action theory 
\begin_inset Formula $\Dt\cup\Dt_{K,obs}$
\end_inset

 and a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

, it is always the case that:
\begin_inset Formula \[
\Dt\cup\Dt_{K,obs}\,\models\,\phi[do(a,s)]\equiv\Reg(\phi[do(a,s)])\]

\end_inset

 
\end_layout

\begin_layout Proof
We need only consider applications of 
\begin_inset Formula $\Reg$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 has the form 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

, as other regression clauses have not been modified.
 For clarity we define the abbreviation 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s)$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

persists under equivalent observations
\begin_inset Quotes erd
\end_inset

) which states that 
\begin_inset Formula $\phi$
\end_inset

 holds in all legal futures of 
\begin_inset Formula $s$
\end_inset

 compatible with observations 
\begin_inset Formula $o$
\end_inset

:
\begin_inset Formula \begin{multline*}
\mathbf{PEO}(agt,\phi,o,s)\,\isdef\,\\
\forall a':\, obs(agt,a',s)=o\wedge Poss(a',s)\rightarrow\left[\forall s':\, do(a',s)\leq_{PbU(agt)}s'\rightarrow\,\phi[s']\right]\end{multline*}

\end_inset

 Combining and rearranging equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) with the definition of the 
\begin_inset Formula $\Knows$
\end_inset

 macro we have:
\begin_inset Formula \begin{align*}
\Knows(agt,\phi,do(a,s))\equiv\, & \exists o\,.\, obs(agt,a,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\forall s'\,.\, K(agt,s',s)\rightarrow\phi[s']\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\forall s'\,.\, K(agt,s',s)\rightarrow\mathbf{PEO}(agt,\phi,o,s')\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Proof
Noting that both conjuncts contain sub-formulae matching the form of the
 
\begin_inset Formula $\Knows$
\end_inset

 macro, it can be substituted back in to give:
\begin_inset Formula \begin{align*}
\mathbf{Knows}(agt,\phi,do(a,s))\equiv\, & \exists o\,.\, Observations(agt,c,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\mathbf{Knows}(agt,\mathbf{PEO}(agt,\phi,o,s'),s)\right]\end{align*}

\end_inset

 For 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s')$
\end_inset

 to legitimately appear inside the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro it must be uniform in the situation variable 
\begin_inset Formula $s'$
\end_inset

.
 Applying the persistence condition and regressing to make the expression
 uniform, we develop the following equivalence:
\begin_inset Formula \[
\mathbf{PEO}(agt,\phi,o,s)\equiv\forall a':\, obs(agt,a',s)=o\wedge Poss(a',s)\rightarrow\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt)),a')\]

\end_inset

 Suppressing the situation term in this uniform formula gives equation (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

) as required.
\end_layout

\begin_layout Proof
For 
\begin_inset Formula $S_{0}$
\end_inset

, a straightforward transformation of equations (
\begin_inset LatexCommand ref
reference "eqn:knows_def"

\end_inset

) and (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) gives:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\left[\forall s'\,.\, s\leq_{PbU(agt)}s'\rightarrow\phi[s']\right]\]

\end_inset

 Applying the persistence condition operator, this can easily be re-written
 as:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\Pst(\phi,PbU(agt))[s]\]

\end_inset


\end_layout

\begin_layout Proof
This matches the form of the definition for 
\begin_inset Formula $\KnowsZ$
\end_inset

, which we can substitute in to give:
\begin_inset Formula \[
\Knows(agt,\phi,S_{0})\equiv\KnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Proof
This is equation (
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

), as required.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "theapa"
bibfiles "/storage/uni/pgrad/library/references"

\end_inset


\end_layout

\end_body
\end_document
