#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass jair
\begin_preamble

\jairheading{0}{0000}{0-0}{0/0}{0/0}
\ShortHeadings{Common Knowledge, Hidden Actions, and the Frame Problem}{R. F. Kelly \& A. R. Pearce}
\firstpageno{0}

\newcommand{\isdef}{\ensuremath{\stackrel{\mbox{\tiny def}}{=}}}
\newcommand{\MOP}[1]{\ensuremath{\pmb{\mathcal{#1}}}}

\newcommand{\Reg}{\ensuremath{\MOP{R}_{\Dt}}}
\newcommand{\Pst}{\ensuremath{\MOP{P}_{\Dt}}}
\newcommand{\Trn}{\ensuremath{\MOP{T}_{\Dt}}}
\newcommand{\Kln}{\ensuremath{\MOP{T}_{\Dt}}}
\newcommand{\Dt}{\ensuremath{\mathcal{D}}}
\newcommand{\Knows}{\ensuremath{\mathbf{Knows}}}
\newcommand{\EKnows}{\ensuremath{\mathbf{EKnows}}}
\newcommand{\CKnows}{\ensuremath{\mathbf{CKnows}}}
\newcommand{\KnowsZ}{\ensuremath{\mathbf{Knows_0}}}
\end_preamble
\options jair,twoside,11pt,theapa,letterpaper
\language english
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Common Knowledge, Hidden Actions, and the Frame Problem
\end_layout

\begin_layout Author
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Ryan F.
 Kelly 
\backslash
email rfk@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Adrian R.
 Pearce 
\backslash
email adrian@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addr Department of Computer Science and Software Engineering
\backslash

\backslash

\end_layout

\begin_layout Standard

The University of Melbourne
\backslash

\backslash

\end_layout

\begin_layout Standard

Victoria, 3010, Australia
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a powerful new account of multi-agent knowledge in the situation
 calculus, and an effective reasoning procedure for knowledge queries.
 A key contribution of our approach is the ability to handle partial observabili
ty, including actions that are completely hidden, by explicitly reifying
 the observations made by each agent as the world evolves.
 We also formally treat complex epistemic modalities such as common knowledge,
 which are not available in the standard account of knowledge in the situation
 calculus.
 By using the persistence condition meta-operator to augment traditional
 regression techniques, we allow agents to effectively reason about knowledge
 using only their internal history of observations, rather than requiring
 a full history of the world.
 The result is a more robust and flexible account of knowledge in the situation
 calculus suitable for use in asynchonrous, partially-observable multi-agent
 domains.
 
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
In their landmark paper 
\emph on
Knowledge, Action, and the Frame Problem,
\emph default
 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 extend Reiter's solution to the frame problem in the situation calculus
 
\begin_inset LatexCommand citep
key "reiter91frameprob,pirri99contributions_sitcalc"

\end_inset

 to handle knowledge-producing actions and explicit reasoning about the
 knowledge of an agent.
 Extensions to multiple agents 
\begin_inset LatexCommand citep
key "Lesperance01epi_feas_casl"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

 have produced an expressive logic of knowledge, action and change that
 permits an effective reasoning procedure using standard techniques of the
 situation calculus.
\end_layout

\begin_layout Standard
While powerful, the existing account suffers two major limitations that
 make it unsuitable for modelling complex multi-agent domains.
 First, it requires that whenever an action occurs, all agents 
\emph on
know
\emph default
 that an action has occurred.
 This demands a level of synchronicity that is unreasonable in many multi-agent
 domains.
 Second, there is no account of group-level epistemic modalities such as
 common knowledge, which is difficult to formalize effectively in a dynamic
 setting 
\begin_inset LatexCommand citep
key "vanBenthem06lcc"

\end_inset

.
 Given the deep connections between common knowledge and coordination 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

, this is a serious shortcoming in multi-agent domains.
\end_layout

\begin_layout Standard
In this paper we overcome these limitations by providing:
\end_layout

\begin_layout Itemize
a formal account of 
\emph on
Common Knowledge
\emph default
 and other complex epistemic modalities, including a regression rule for
 reasoning about common knowledge
\end_layout

\begin_layout Itemize
support for 
\emph on
Hidden Actions
\emph default
 and actions that are partially observable, including a reasoning technique
 to deal with arbitrarily-long sequences of hidden actions
\end_layout

\begin_layout Itemize
a solution to the 
\emph on
Frame Problem
\emph default
 for knowledge, built on the successor state axioms for primitive actions,
 and maintaining regression as the primary reasoning tool
\end_layout

\begin_layout Standard
A further advantage of our approach is that it allows an agent to reason
 about its own knowledge using only its local information.
 Reasoning in the situation calculus typically takes an omniscient viewpoint,
 with queries posed in the form 
\begin_inset Quotes eld
\end_inset

does 
\begin_inset Formula $\phi$
\end_inset

 hold in situation 
\begin_inset Formula $s$
\end_inset

?
\begin_inset Quotes erd
\end_inset

.
 An agent cannot use such techniques to reason about its own world, since
 it may not know the full current situation term.
 With our new approach, it can pose the query 
\begin_inset Quotes eld
\end_inset

do I know 
\begin_inset Formula $\phi$
\end_inset

, given my local history 
\begin_inset Formula $h$
\end_inset

?
\begin_inset Quotes eld
\end_inset

 and utilise the techniques developed in this paper to reason about its
 own world.
 The end result is a rich account of multi-agent knowledge suitable both
 for reasoning 
\emph on
about,
\emph default
 and reasoning 
\emph on
in,
\emph default
 asynchronous, partially-observable multi-agent domains.
\end_layout

\begin_layout Standard
After some introductory material on the situation calculus in Section 
\begin_inset LatexCommand ref
reference "sec:The-Multi-Agent-Situation"

\end_inset

, we develop our new formalism in two parts.
 Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 treats the indivdual knowledge of each agent in the face of hidden actions,
 by decoupling knowledge from the specific actions that have taken place.
 We develop an explicit reification of the 
\emph on
observations
\emph default
 made by each agent as the world evolves, and formulate each agent's knowldge
 in terms of what it has observed.
 By utilizing the persistence condition meta-operator 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

 to augment the regression techniques developed by Scherl and Levesque (2003),
 we maintain their elegant solution to the frame problem despite dealing
 with potentially infinite sequences of hidden actions.
 This section is a greatly expanded version of our conference paper on the
 same topic 
\begin_inset LatexCommand citep
key "kelly07sc_know_obs"

\end_inset

 and stands as a significant new account of knowledge in its own right.
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sec:Complex-Epistemic-Modalities"

\end_inset

 builds on this by introducing complex epistemic modalities.
 While the primary motivation is a formal account of common knowledge, we
 are bound by the following expressivity result from modal logic: epistemic
 logic with actions and common knowledge is more expressive than epistemic
 logic with common knowledge alone.
 
\begin_inset LatexCommand citep
key "baltag98pa_ck"

\end_inset

.
 In situation calculus terms, this means that the regression of common knowledge
 cannot be defined in terms of common knowledge, but requires a more expressive
 epistemic language.
 After summarizing recent advances in this related field, we follow the
 work of 
\begin_inset LatexCommand citet
key "vanBenthem06lcc"

\end_inset

 and use a variant of Propositional Dynamic Logic as a general epistemic
 path language.
 With some restrictions on the interaction between actions and observations,
 we show how to extend the results of Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 to these complex epistemic modalities, and demonstrate the use of this
 technique to reason about common knowledge.
 
\end_layout

\begin_layout Standard
Since our account of knowledge is very general, reasoning with it can be
 very expensive.
 In Section 
\begin_inset LatexCommand ref
reference "sec:Simplifying-Reasoning"

\end_inset

 we discuss a number of ways to simplify the reasoning procedure by placing
 further restrictions on the domain.
 Sections 
\begin_inset LatexCommand ref
reference "sec:Related-Work"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "sec:Future-Work"

\end_inset

 discuss related and future work respectively, and Section 
\begin_inset LatexCommand ref
reference "sec:Conclusions"

\end_inset

 concludes with a summary of our achievements in this paper.
\end_layout

\begin_layout Section
The Multi-Agent Situation Calculus
\begin_inset LatexCommand label
name "sec:The-Multi-Agent-Situation"

\end_inset


\end_layout

\begin_layout Standard
Our work utilizes the situation calculus 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 with multiple agents 
\begin_inset LatexCommand citep
key "shapiro01casl_feat_inter"

\end_inset

 and we begin from the standard account of knowledge due to 
\begin_inset LatexCommand citep
key "scherl03sc_knowledge"

\end_inset

.
 A brief overview is presented below.
 Readers familiar with the situation calculus should note: our generalization
 of the 
\begin_inset Formula $Poss$
\end_inset

 fluent to action description predicates, our use of the single-step variant
 of the regression operator, and the material on the persistence condition
 meta-operator.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting instantaneous events that can cause the state
 of the world to change, with the initiating agent indicated by their first
 argument; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Result
\noun default
 terms represent sensing results returned by actions; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\emph on
Fluents
\emph default
 are predicates or functions that represent properties of the world that
 may change between situations; they take a situation term as their final
 argument.
\end_layout

\begin_layout Standard
Throughout the paper we will present examples from a simple multi-agent
 domain, a packing facility in which two agents 
\begin_inset Formula $Sam$
\end_inset

 and 
\begin_inset Formula $Max$
\end_inset

 move between a number of rooms while picking up or dropping boxes.
 Some example formulas from this domain are 
\begin_inset Quotes eld
\end_inset

Sam is holding Box1 initially
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Sam is not holding Box1 after dropping Box1
\begin_inset Quotes erd
\end_inset

, written formally as:
\begin_inset Formula \begin{gather*}
Holding(Sam,Box1,S_{0})\\
\neg Holding(Sam,Box1,do(drop(Sam,Box1),S_{0})\end{gather*}

\end_inset


\end_layout

\begin_layout DefinitionLbld
Basic\InsetSpace ~
Action\InsetSpace ~
Theory A basic action theory, denoted 
\begin_inset Formula $\Dt$
\end_inset

, is a set of situation calculus sentences (with a specific syntactic form
 outlined below) that describes a particular dynamic world.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); unique names axioms ensuring that action terms are distinct (
\begin_inset Formula $\Dt_{una}$
\end_inset

); precondition axioms indicating when actions can be performed (
\begin_inset Formula $\Dt_{ap}$
\end_inset

); successor state axioms describing how fluents change between situations
 (
\begin_inset Formula $\Dt_{ss}$
\end_inset

); and axioms describing the value of fluents in the initial situation (
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{una}\cup\Dt_{ap}\cup\Dt_{ss}\cup\Dt_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
Queries about the behavior of the world are posed as logical entailment
 queries relative to this theory.
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{una}$
\end_inset

 restricts action terms to a finite number of action types, and ensures
 that actions with different types or different arguments are in fact different.
 In our example domain, actions are of the form 
\begin_inset Formula $pickup(Agent,Box)$
\end_inset

, 
\begin_inset Formula $drop(Agent,Box)$
\end_inset

, and 
\begin_inset Formula $move(Agent,Room)$
\end_inset

.
\end_layout

\begin_layout Standard
For action preconditions, there is a distinguished fluent predicate 
\begin_inset Formula $Poss(Action,Situation)$
\end_inset

 that indicates whether it is possible to perform an action in a given situation.
 For example, it is only possible for an agent to drop an object if they
 are actually holding it:
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow the convention that lower-case roman names indicate variables,
 with free variables being implicitly universally quantified.
\end_layout

\end_inset

 
\begin_inset Formula \[
Poss(drop(agt,obj),s)\equiv Holding(agt,obj,s)\]

\end_inset


\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{ap}$
\end_inset

 contains one 
\begin_inset Formula $Poss$
\end_inset

 axiom of this form for each type of action.
 This notion can be generalized to what we will call 
\emph on
action description predicates
\emph default
.
 These are predicates defined in the same manner as 
\begin_inset Formula $Poss$
\end_inset

 that describe some other aspect of the performance of an action.
 For example, we will define below an action description predicate 
\begin_inset Formula $CanObs$
\end_inset

 that specifies when an agent will observe the occurrence of an action.
\end_layout

\begin_layout Standard
Situations form a tree structure with 
\begin_inset Formula $S_{0}$
\end_inset

 at the root and 
\begin_inset Formula $do$
\end_inset

 constructing child situations from parents.
 The foundational axioms define a basic ordering relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 which should be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

 and is defined as follows:
\begin_inset Formula \[
\neg\left(s\sqsubset S_{0}\right)\]

\end_inset


\begin_inset Formula \[
s\sqsubset do(a,s')\equiv s\sqsubseteq s'\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 More generally, one may consider only those futures in which all actions
 satisfy a particular action description predicate 
\begin_inset Formula $\alpha$
\end_inset

 by using the notation 
\begin_inset Formula $<_{\alpha}$
\end_inset

:
\begin_inset Formula \[
\neg\left(s<_{\alpha}S_{0}\right)\]

\end_inset


\begin_inset Formula \[
s<_{\alpha}do(a,s')\equiv s\leq_{\alpha}s'\wedge\alpha(a,s')\]

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
legal situations
\emph default
 are those in which all actions were actually possible to perform in the
 preceding situation - that is, those situations 
\begin_inset Formula $s$
\end_inset

 that satisfy 
\begin_inset Formula $S_{0}\leq_{Poss}s$
\end_inset

.
 Legal situations are of such fundamental importance that 
\begin_inset Formula $\leq$
\end_inset

 is used as a shorthand for 
\begin_inset Formula $\leq_{Poss}$
\end_inset

.
\end_layout

\begin_layout Standard
The 
\emph on
uniform formulae
\emph default
 as defined in 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

 can be thought of as 
\emph on
properties
\emph default
 of the state of the world.
 They are basically logical combinations of fluents referring to a common
 situation term, and cannot mention action description predicates nor compare
 situation terms.
 The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout to refer to an arbitrary uniform formula.
 It is often useful to determine the truth of a uniform formula at an alternate
 situation term, and 
\begin_inset Formula $\phi[s]$
\end_inset

 represents the uniform formula 
\begin_inset Formula $\phi$
\end_inset

 with all occurrences of its unique situation term replaced by the situation
 
\begin_inset Formula $s$
\end_inset

.
 Where no confusion can arise, we suppress the situation terms in uniform
 formulae to simplify the presentation (e.g.
 using 
\begin_inset Formula $Holding(Max,Box1)$
\end_inset

 instead of 
\begin_inset Formula $Holding(Max,Box1,s)$
\end_inset

)
\end_layout

\begin_layout Standard
The truth of a fluent is completely specified by defining its truth in the
 initial situation, and collecting the effects of the various actions into
 
\emph on
successor state axioms
\emph default
.
 Such axioms provide a monotonic solution to the frame problem.
 They have the following general form, asserting the truth of a fluent 
\begin_inset Formula $F$
\end_inset

 in the successor situation 
\begin_inset Formula $do(c,s)$
\end_inset

 based on the current situation 
\begin_inset Formula $s$
\end_inset

 and the actions 
\begin_inset Formula $c$
\end_inset

 that were performed: 
\begin_inset Formula \[
F(\overrightarrow{x},do(c,s))\equiv\Phi^{+}(\overrightarrow{x},c,s)\,\,\vee\,\, F(\overrightarrow{x},s)\wedge\neg\Phi^{-}(\overrightarrow{x},c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi^{+}$
\end_inset

 and 
\begin_inset Formula $\Phi^{-}$
\end_inset

 are formulae uniform in 
\begin_inset Formula $s$
\end_inset

.
 Roughly, this axiom states that 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after performing 
\begin_inset Formula $c$
\end_inset

 if 
\begin_inset Formula $c$
\end_inset

 made it true, or it was previously true and 
\begin_inset Formula $c$
\end_inset

 did not make it false
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Formula $\mathcal{D}_{ss}$
\end_inset

 contains one such axiom for each fluent.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 The principle tool is the regression meta-operator 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

, a syntactic manipulation whose behavior can be summarized for our purposes
 as follows: it transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

 into a formula 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}(\phi)$
\end_inset

 that is uniform in 
\begin_inset Formula $s$
\end_inset

 and is equivalent to 
\begin_inset Formula $\phi$
\end_inset

 under the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\,\models\,\phi\equiv\mathcal{R}_{\mathcal{D}}(\phi)\]

\end_inset


\end_layout

\begin_layout Standard
In the base case, this involves replacing fluents 
\begin_inset Formula $F(\overrightarrow{x},do(a,s))$
\end_inset

 with their matching successor state axioms.
 It also replaces action description predicates such as 
\begin_inset Formula $Poss$
\end_inset

 with their appropriate definitions.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\phi$
\end_inset

 refers to a situation that is rooted at 
\begin_inset Formula $S_{0}$
\end_inset

, repeated applications of the regression operator (denoted by 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}$
\end_inset

) can transform it into an equivalent formula uniform in the initial situation.
 The successor state and action precondition axioms are 
\begin_inset Quotes eld
\end_inset

compiled in
\begin_inset Quotes erd
\end_inset

 and so are not required for answering the regressed query, making reasoning
 simpler:
\begin_inset Formula \begin{gather*}
\mathcal{D}\models\phi[do(a_{n},do(a_{n-1},\dots,do(a_{1},S_{0}))]\\
\mathrm{iff}\\
\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\models\mathcal{R}_{\mathcal{D}}^{*}(\phi)[S_{0}]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The trade-off is that the length of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}^{*}(\phi)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice.
\end_layout

\begin_layout Standard
TODO: finite number of actions
\end_layout

\begin_layout Subsection
Knowledge and Sensing
\begin_inset LatexCommand label
name "sub:Knowledge-and-Sensing"

\end_inset


\end_layout

\begin_layout Standard
The standard semantics of knowledge 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

 are based on the popular 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 model from modal logic.
 A knowledge fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 The macro 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 is then introduced as a shorthand for the standard possible-worlds definition
 of knowledge, stating that an agent knows something when it is true in
 all situations considered possible: 
\begin_inset Formula \begin{equation}
\mathbf{Knows}(agt,\phi,s)\,\isdef\,\forall s'\,.\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}

\end_inset

 To allow actions to return sensing information the sensing result function
 
\begin_inset Formula $SR(a,s)$
\end_inset

 is introduced, giving the result returned by the action 
\begin_inset Formula $a$
\end_inset

 when executed in situation 
\begin_inset Formula $s$
\end_inset

.
 For actions that don't return sensing information, the value of 
\begin_inset Formula $SR$
\end_inset

 is set to some arbitrary constant such as 
\begin_inset Formula $"OK"$
\end_inset

.
\end_layout

\begin_layout Standard
The common form of successor state axiom for the knowledge fluent is: 
\begin_inset Formula \begin{multline}
K(agt,s'',do(a,s))\equiv\exists s'\,.\, s''=do(a,s')\,\wedge K(agt,s',s)\wedge Poss(a,s')\\
\wedge\, agent(a)=agt\,\rightarrow\, SR(a,s)=SR(a,s')\label{eqn:k_ssa_standard}\end{multline}

\end_inset

 
\end_layout

\begin_layout Standard
The function 
\begin_inset Formula $agent(a)$
\end_inset

 is a convenient shorthand for extracting the agent performing an action.
 This successor state axiom ensures that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(a,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing the same action 
\begin_inset Formula $a$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is considered a possible alternative to 
\begin_inset Formula $s$
\end_inset

.
 It must furthermore have been possible to perform that action in 
\begin_inset Formula $s'$
\end_inset

, and the sensing results must match if the action was carried out by the
 agent in question.
\end_layout

\begin_layout Standard
It is also necessary to permit alternate possible worlds to the initial
 situation 
\begin_inset Formula $S_{0}$
\end_inset

, to represent incomplete initial knowledge.
 The predicate 
\begin_inset Formula $Init$
\end_inset

 identifies initial situations, and only other initial situations may be
 
\begin_inset Formula $K$
\end_inset

-related to an initial situation.
 We also talk of situations being 
\emph on
rooted at
\emph default
 some initial situation: 
\begin_inset Formula \begin{equation}
\begin{split} & Init(s)\rightarrow Root(s)=s\\
 & Root(do(c,s))=Root(s)\\
 & Init(s)\rightarrow\left(K(s',s)\rightarrow Init(s')\right)\end{split}
\label{eq:k_s0_standard}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
We introduce a notational shorthand to refer to this standard account of
 knowledge throughout the rest of the paper:
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\mathcal{D}_{Std}$
\end_inset

 a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

 augmented with the standard account of knowledge from 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, as detailed in equations (
\begin_inset LatexCommand ref
reference "eqn:k_ssa_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

).
\end_layout

\begin_layout Standard
While powerful, this formulation has an important limitation: each agent
 is assumed to be aware of 
\emph on
all
\emph default
 actions that have occurred.
 Note that this awareness is passive - the agents perform no explicit sensing
 actions to determine what has occurred.
 Responsibility for generating such 
\begin_inset Quotes eld
\end_inset

awareness
\begin_inset Quotes erd
\end_inset

 in real systems is the responsibility of a lower-level software component,
 such as a continuous sensing system that identifies change in the environment
 and notifies the agent when an action occurs.
 While suitable for some domains, there are clearly many multi-agent domains
 where achieving total awareness of actions would be infeasible.
\end_layout

\begin_layout Standard
An alternate formulation from 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

 assumes the opposite extreme, that agents are only aware of the actions
 that they themselves perform:
\begin_inset Formula \begin{multline}
K(agt,s'',do(a,s))\equiv\\
\exists s',s^{*},a'\,.\, s''=do(a',s^{*})\,\wedge K(s',s)\wedge Poss(a',s^{*})\\
\wedge\,\mathbf{ExoOnly}(agt,s',s^{*})\\
\wedge\,\forall a\left[agent(a)=agt\rightarrow a\in c'\equiv a\in c\right]\\
\wedge\,\forall a\in c\left[agent(a)=agt\rightarrow SR(a,s)=SR(a,s')\right]\label{eqn:k_ssa_exo}\end{multline}

\end_inset

 Where the macro 
\begin_inset Formula $\mathbf{ExoOnly}$
\end_inset

 indicates that two situations are connected only by actions performed by
 other agents:
\begin_inset Formula \begin{multline*}
\mathbf{ExoOnly}(agt,s,s'')\,\,\isdef\,\, s\leq s''\wedge\\
\forall s',c,a\left[s<do(c,s')\leq s''\wedge a\in c\rightarrow agent(a)\neq agt\right]\end{multline*}

\end_inset

 Here agents consider possible any situation compatible with the actions
 that they themselves have performed.
 There may have been an arbitrary sequence of situations between 
\begin_inset Formula $s'$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

 of which the agent was unaware, because they consisted entirely of exogenous
 actions.
\end_layout

\begin_layout Standard
We will denote by 
\begin_inset Formula $\mathcal{D}_{Exo}$
\end_inset

 a basic action theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

 augmented with the 
\begin_inset Quotes eld
\end_inset

total ignorance
\begin_inset Quotes erd
\end_inset

 account of knowledge from 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

, as detailed in equations (
\begin_inset LatexCommand ref
reference "eqn:k_ssa_exo"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

).
\end_layout

\begin_layout Standard
This approach is also limiting, in that agents can 
\emph on
never
\emph default
 be aware of the actions performed by others.
 Consider our example of agents occupying a building who are aware of all
 actions performed in the same room, or even the simple case of an agent
 being aware that another agent has collided with it - full generality requires
 that agents can be aware of 
\emph on
some
\emph default
 of the actions performed by others.
\end_layout

\begin_layout Standard
Furthermore, suppose that 
\begin_inset Formula $agt$
\end_inset

 has just performed action 
\begin_inset Formula $a_{1}$
\end_inset

, so the world is in some situation 
\begin_inset Formula $do(\{a_{1}\},s)$
\end_inset

.
 Another agent then performs the action 
\begin_inset Formula $a_{2}$
\end_inset

, leaving the world in situation 
\begin_inset Formula $do(\{a_{2}\},do(\{a_{1}\},s))$
\end_inset

.
 Since it is not aware of the occurrence of 
\begin_inset Formula $a_{2}$
\end_inset

, 
\begin_inset Formula $agt$
\end_inset

 cannot be aware that the state of the world has changed.
 Its state of knowledge should therefore remain unchanged.
 Unfortunately this is not the case under this formulation:
\begin_inset Formula \begin{multline*}
\mathcal{D}_{Exo}\not\models agent(a_{2})\neq agt\rightarrow\\
K(agt,s',do(\{a_{2}\},do(\{a_{1}\},s)))\equiv K(agt,s',do(\{a_{1}\},s))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
To faithfully represent this aspect of knowledge, the successor state axiom
 for 
\begin_inset Formula $K$
\end_inset

 must consider any 
\emph on
future
\emph default
 that can be brought about by exogenous actions, rather than any 
\emph on
past
\emph default
 as done above.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, the regression operator is extended to handle the standard account of
 knowledge by reducing reasoning about formulae containing the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro to modal reasoning over the 
\begin_inset Formula $K$
\end_inset

 relation in the initial situation.
 This technique relies heavily on the fact that agents are aware of all
 actions, since formulae such as equation (
\begin_inset LatexCommand ref
reference "eqn:k_ssa_exo"

\end_inset

) that quantify over situations cannot be regressed.
 Indeed, 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

 offer no procedure for reasoning in their formalism other than second-order
 reasoning using the entire action theory.
 We believe the ability to regress knowledge queries to be the main reason
 for the near-ubiquity of the assumption of total awareness of actions.
\end_layout

\begin_layout Subsection
Property Persistence
\end_layout

\begin_layout Standard
As evidenced by the use of 
\begin_inset Formula $\mathbf{ExoOnly}$
\end_inset

 in equation (
\begin_inset LatexCommand ref
reference "eqn:k_ssa_exo"

\end_inset

), richer axiomatizations of knowledge require reasoning about aribtrarily
 long sequences of hidden actions.
 Not only can such reasoning not be performed using traditional regression,
 but it requires the use of a second-order induction axiom.
 We have introduced another meta-operator called the 
\emph on
persistence condition
\emph default
 to allow more effective reasoning of this kind 
\begin_inset LatexCommand cite
key "kelly07sc_persistence"

\end_inset

.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\alpha$
\end_inset

 be an action description predicate and 
\begin_inset Formula $\phi$
\end_inset

 a uniform formula.
 Then 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}(\phi,\alpha)$
\end_inset

 is a uniform formula such that:
\begin_inset Formula \[
\mathcal{D}-\mathcal{D}_{S_{0}}\,\,\models\,\,\mathcal{P}_{\mathcal{D}}(\phi,\alpha)[s]\equiv\forall s'\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
In words, 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}(\phi,\alpha)$
\end_inset

 holds in a situation 
\begin_inset Formula $s$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

, and after any sequence of actions satisfying 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 will continue to hold.
 This is quite a general assertion, and the definition of 
\begin_inset Formula $\mathbf{ExoOnly}$
\end_inset

 fits this form.
\end_layout

\begin_layout Standard
Unfortunately the calculation of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 requires first-order theorem proving, unlike that of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 which is a simple syntactic transformation.
 Since the persistence condition is used to replace a second-order induction
 axiom, 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 is actually a fixpoint calculation.
 We breifly describe its operation below, for full details consult the reference
 
\begin_inset LatexCommand cite
key "kelly07sc_persistence"

\end_inset

.
\end_layout

\begin_layout Standard
The one-step-persistence operator 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}^{1}$
\end_inset

 asserts that 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediately successors, and is defined by:
\begin_inset Formula \[
\mathcal{P}_{\mathcal{D}}^{1}(\phi[s],\alpha)\,\isdef\,\phi[s]\wedge\mathcal{R}_{\mathcal{D}}(\forall c\,\alpha(c,s)\rightarrow\phi[do(c,s)])\]

\end_inset


\end_layout

\begin_layout Standard
Note that regression is applied to ensure that this is a unform formula.
 Repeated application asserts the persistence of 
\begin_inset Formula $\phi$
\end_inset

 after more and more actions.
 Intuitively 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}(\phi,\alpha)$
\end_inset

 should be a fixpoint of 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}(\phi,\alpha)$
\end_inset

, and indeed it can be shown that if:
\begin_inset Formula \[
\mathcal{D}_{una}\,\models\,\mathcal{P}_{\mathcal{D}}^{n}(\phi,\alpha)\,\rightarrow\,\mathcal{P}_{\mathcal{D}}^{n+1}(\phi,\alpha)\]

\end_inset


\end_layout

\begin_layout Standard
then:
\begin_inset Formula \[
\mathcal{D}\,\models\,\mathcal{P}_{\mathcal{D}}^{n}(\phi,\alpha)\,\equiv\,\mathcal{P}_{\mathcal{D}}(\phi,\alpha)\]

\end_inset


\end_layout

\begin_layout Standard
Thus the calculatiion of 
\begin_inset Formula $\mathcal{P}(\phi,\alpha)$
\end_inset

 replaces a single second-order reasoning task with several reasoning tasks
 based on 
\begin_inset Formula $\mathcal{D}_{una}$
\end_inset

.
 Can this be considered an effective technique for dealing with such queries?
 The following points weigh strongly in favor of the approach:
\end_layout

\begin_layout Standard
First and foremost, we avoid the need for the second-order induction axiom.
 All the reasoning tasks can be performed using standard first-order reasoning,
 for which there are many high-quality automated provers.
 Second, the calculation of 
\begin_inset Formula $\mathcal{P_{D}}$
\end_inset

 only reasons based on the unique names axioms, which is a comparatively
 straightforward task.
 Third, 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}(\phi,\alpha)[s]$
\end_inset

 is in a form amenable to regression, a standard tool for effective reasoning
 in the situation calculus.
 Fourth, the persistence condition for a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

 can be cached and re-used for a series of related queries about different
 situations, a significant gain in amortized efficiency.
 Finally, in realistic domains we expect many properties to fail to persist
 beyond a few situations into the future, meaning that our algorithm will
 require few iterations in a large number of cases.
\end_layout

\begin_layout Subsection
Things to Define
\end_layout

\begin_layout Standard
rooted situation term
\end_layout

\begin_layout Standard
objective formula
\end_layout

\begin_layout Standard
uniform formula
\end_layout

\begin_layout Section
Observation-Based Semantics for Knowledge
\begin_inset LatexCommand label
name "sec:Obs-Knowledge"

\end_inset


\end_layout

\begin_layout Standard
Existing accounts of knowledge in the situation calculus directly express
 the dynamics of knowledge update in terms of the actions that have occurred
 in the world, as seen in Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Sensing"

\end_inset

.
 An immediate consequence of this is that one can only reason about knowledge
 if one has a rooted situation term, as the required query is:
\begin_inset Formula \[
\Dt\,\models\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
In asynrchonous domains with hidden actions, where agents are not necessarily
 aware of the number of actions that have been performed, the agents cannot
 use this formulation to reason about their own knowledge.
 Since knowledge is directly coupled to actions, and hence to situation
 terms, they cannot construct an appropriate query.
 This section is devoted to removing this troublesome coupling.
\end_layout

\begin_layout Subsection
Observations
\end_layout

\begin_layout Standard
To remove the the direct coupling between knowledge and actions, we introduce
 the notion of 
\emph on
observations
\emph default
.
 These are internal notifications that agents receive when an action has
 occurred.
 By expressing knowledge in terms of observations rather than actions, we
 ensure that agents can always reason about their own knowledge based on
 their own internal history of observations.
\end_layout

\begin_layout DefinitionLbld
Observations An observation is a notification event received by an agent,
 making it aware of some change in the state of the world.
 When an agent receives such a notification, we say that it 
\begin_inset Quotes eld
\end_inset

observed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

made
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

perceived
\begin_inset Quotes erd
\end_inset

 that observation.
\end_layout

\begin_layout Standard
Since the state of the world may only change in response to some action,
 observations can only be made as a result of some action.
 For simplicity we assume that agents perceive observations instantaneously,
 i.e.
 in the same instant as the actions that cause them.
\end_layout

\begin_layout Standard
Since 
\begin_inset Quotes eld
\end_inset

observation
\begin_inset Quotes erd
\end_inset

 is quite a loaded term, it is worth re-iterating this point: observations
 are instantanous
\emph on
 events
\emph default
 generated internally by each agent in response to actions occurring in
 the world.
 We make no commitment as to how these events are generated, preferring
 a clean delineation between the task of observing change and the dynamics
 of knowledge update based on those observations.
 As with the work of 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, generating awareness is the responsibility of a lower-level component
 of the agent's control software and we will not consider it further.
\end_layout

\begin_layout Standard
To make this idea concrete, let us introduce an additional sort 
\noun on
Observations
\noun default
 to the language of the situation calculus, for the moment without any particula
r commitment towards what this sort will contain.
 We then introduce the function:
\begin_inset Formula \[
obs(agt,a,s)=o\]

\end_inset

This function returns a set of observations, and should be read as 
\begin_inset Quotes eld
\end_inset

when action 
\begin_inset Formula $a$
\end_inset

 is performed in situation 
\begin_inset Formula $s$
\end_inset

, agent 
\begin_inset Formula $agt$
\end_inset

 will perceive 
\begin_inset Formula $o$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Using a set of observations allows an agent to perceive multiple observations
 in response to a single action occurrence.
\end_layout

\begin_layout Standard
The concept of an 
\emph on
view
\emph default
 follows naturally - it is a sequence of all the observations made by an
 agent as the world has evolved.
\end_layout

\begin_layout DefinitionLbld
View An agent's view in a given situation 
\begin_inset Formula $\mathrm{s}$
\end_inset

 is the corresponding sequence of observations made by the agent as a result
 of each action in 
\begin_inset Formula $\mathrm{s}$
\end_inset

, exluding those actions for which no observations were made.
\end_layout

\begin_layout Standard
We introduce another sort 
\noun on
Views
\noun default
 consisting of sequences of sets of observations, with 
\begin_inset Formula $\epsilon$
\end_inset

 being the empty sequence, and the function 
\begin_inset Formula $view$
\end_inset

 giving the observation history associated with a particular situation:
\begin_inset Formula \begin{align}
Init(s)\,\rightarrow & \, view(agt,s)=\epsilon\nonumber \\
obs(agt,a,s)=\{\}\,\rightarrow & \, view(agt,do(a,s))=view(agt,s)\nonumber \\
obs(agt,a,s)\neq\{\}\,\rightarrow & \, view(agt,do(a,s))=obs(agt,a,s)\cdot view(agt,s)\label{eq:view_defn}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Observations and views can be seen as localized analogues of actions and
 situations respectively.
 An action is a global event that causes the state of the world to change,
 while an observation is an internal event that causes an agent's awareness
 of the state of the world (i.e.
 its knowledge) to change.
 Similarly, a situation represents a complete, global history of all the
 actions that have occurred in the world, while a view is an agent's local
 history of all the observations it has made.
 The situation is an omniscient perspective on the world, the view a local
 perspective.
 As we shall see, this distinction is fundamental to developing a truly
 general multi-agent semantics for knowledge.
\end_layout

\begin_layout Subsection
Knowledge and Observation
\end_layout

\begin_layout Standard
It is a basic tenet of epistemic reasoning that an agent's knowledge at
 any particular time must depend solely on its local history: the knowledge
 that it started out with combined with the observations it has made since
 then 
\begin_inset LatexCommand cite
key "halpern90knowledge_distrib"

\end_inset

.
 Given an explicit account of the observations made by each agent, the required
 semantics of the 
\begin_inset Formula $K$
\end_inset

 relation are clear: 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 must hold whenever 
\begin_inset Formula $s'$
\end_inset

 is legal and both 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 would result in the same view for the agent:
\begin_inset Formula \begin{equation}
\mathcal{D}\models K(agt,s',s)\equiv K(root(s'),root(s))\wedge Legal(s')\wedge view(agt,s')=view(agt,s)\label{eq:k-desired}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
While a wonderfully succinct definition of how knowledge should behave,
 this formulation cannot be used directly in a basic action theory.
 Basic action theories require that the dynamics of fluent change be specified
 as a successor state axiom, so we must formulate a successor state axiom
 for the 
\begin_inset Formula $K$
\end_inset

 fluent which enforces the above relationship.
\end_layout

\begin_layout Standard
For notational convenience, let us first introduce an action description
 predicate 
\begin_inset Formula $PbU(agt,a,s)$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

possible but unobservable
\begin_inset Quotes erd
\end_inset

) indicating that the actions 
\begin_inset Formula $c$
\end_inset

 are possible in 
\begin_inset Formula $s$
\end_inset

, but no observations will be made by the agent 
\begin_inset Formula $agt$
\end_inset

 if they are performed:
\begin_inset Formula \begin{equation}
PbU(agt,a,s)\isdef Poss(a,s)\wedge obs(agt,a,s)=\{\}\label{eqn:PbU_defn}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
By stating that 
\begin_inset Formula $s\leq_{PbU(agt)}s'$
\end_inset

 we assert that an agent would make no observations were the world to move
 from situation 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
 This means that the views of both situations would be identical.
 The two situations would be indistinguishable to the agent, so if it considers
 
\begin_inset Formula $s$
\end_inset

 possible then it must also consider 
\begin_inset Formula $s'$
\end_inset

 possible.
 Following this intuition, the successor state axiom below captures the
 desired dynamics of the knowledge fluent:
\begin_inset Formula \begin{align}
K(agt,s'',do(a,s))\equiv & \left[\, obs(agt,a,s)=\{\}\rightarrow K(agt,s'',s)\,\right]\nonumber \\
\wedge & \left[\, obs(agt,a,s)\neq\{\}\rightarrow\exists a',s'\,.\, obs(agt,a',s')=obs(agt,a,s)\right.\nonumber \\
 & \left.\,\,\,\,\,\,\,\,\wedge\, Poss(a',s')\wedge K(agt,s',s)\wedge do(a',s')\leq_{PbU(agt)}s''\,\right]\label{eqn:new_k_ssa}\end{align}

\end_inset

 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $a$
\end_inset

 was totally unobservable, the agent's state of knowledge does not change.
 Otherwise, it considers possible any legal successor to a possible alternate
 situation 
\begin_inset Formula $s'$
\end_inset

 that can be brought about by an action 
\begin_inset Formula $a'$
\end_inset

 that result in identical observations.
 It also considers possible any future of such a situation in which is would
 make no more observations.
\end_layout

\begin_layout Standard
It remains to specify 
\begin_inset Formula $K$
\end_inset

 in the initial situation.
 Since situations where 
\begin_inset Formula $S_{0}\leq_{PbU(agt)}s$
\end_inset

 holds must be 
\begin_inset Formula $K$
\end_inset

-related to 
\begin_inset Formula $S_{0}$
\end_inset

, we introduce another relation 
\begin_inset Formula $K_{0}$
\end_inset

 to specify each agent's initial knowledge:
\begin_inset Formula \begin{gather}
K_{0}(agt,s',s)\rightarrow Init(s')\wedge Init(s)\nonumber \\
Init(s)\rightarrow\left[K(agt,s'',s)\equiv\exists s'\,.\, K_{0}(agt,s',s)\wedge s'\leq_{PbU(agt)}s'')\right]\label{eqn:new_k_s0}\end{gather}

\end_inset

 These definitions suffice to ensure that knowledge behaves as we require.
\end_layout

\begin_layout DefinitionLbld
Observation-Based\InsetSpace ~
Semantics\InsetSpace ~
of\InsetSpace ~
Knowledge We will denote by 
\begin_inset Formula $\Dt_{obs}$
\end_inset

 a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 augmented with our new observation-based semantics for knowledge, as detailed
 in equations (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

).
\end_layout

\begin_layout Standard
We close this section with a proof that our formulation of knowledge behaves
 as intended: two situations will be related by 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 if and only if they result in identical views for 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $s'$
\end_inset

 is legal, and their root situations were initially related.
 All proofs proceed by induction on situation terms, establishng the base
 case of 
\begin_inset Formula $Init(s)$
\end_inset

 and the inductive case of 
\begin_inset Formula $do(a,s)$
\end_inset

.
\end_layout

\begin_layout Standard
Using this new formulation, an agent's knowledge is completely decoupled
 from the global notion of actions, instead depending only on the local
 information that it has observed.
 It remains to specify precisely what the 
\noun on
Observations
\noun default
 sort contains, and how the 
\begin_inset Formula $obs()$
\end_inset

 function behaves.
 This will be the focus of the next section.
\newline

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt_{obs}\,\models\, Legal(s)\wedge s\leq_{PbU(agt)}s'\,\rightarrow\, Legal(s')\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, since 
\begin_inset Formula $PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Legal$
\end_inset

 is equivalent to 
\begin_inset Formula $\leq_{Poss}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt_{obs}\,\models\, s\leq_{PbU(agt)}s'\,\rightarrow\, view(agt,s')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, by induction on the definition of 
\begin_inset Formula $view$
\end_inset

 from equation (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

).
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-root"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt_{obs}\,\models\, K(agt,s'',s)\,\rightarrow\, K(agt,root(s''),root(s))\]

\end_inset


\end_layout

\begin_layout Proof
Trivial in the base case.
 For the 
\begin_inset Formula $do(a,s)$
\end_inset

 case, suppose that 
\begin_inset Formula $K(agt,s'',do(a,s))$
\end_inset

.
 Then by equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) there is some 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $s'\sqsubseteq s''$
\end_inset

 and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 Then 
\begin_inset Formula $root(s'')$
\end_inset

 = 
\begin_inset Formula $root(s')$
\end_inset

, and 
\begin_inset Formula $K(root(s'),root(s))$
\end_inset

 by the inductive hypothesis.
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt_{obs}\,\models\, K(agt,s'',s)\,\rightarrow\, Legal(s'')\]

\end_inset


\end_layout

\begin_layout Proof
All 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 are initial and therefore legal.
 So in the base case when 
\begin_inset Formula $s$
\end_inset

 is initial, by equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) we have 
\begin_inset Formula $s'\leq_{PbU(agt)}s''$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

 is legal by lemma 
\begin_inset LatexCommand ref
reference "lem:pbu-implies-legal"

\end_inset

.
 
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(a,s)$
\end_inset

 case, equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) ensures that 
\begin_inset Formula $do(a',s')\leq_{PbU(agt)}s''$
\end_inset

 for some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $a'$
\end_inset

 satisfying 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 and 
\begin_inset Formula $Poss(a',s')$
\end_inset

.
 Since 
\begin_inset Formula $s'$
\end_inset

 is legal by the inductive hypothesis, 
\begin_inset Formula $s''$
\end_inset

 must be legal.
 
\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt_{obs}\,\models\, K(agt,s'',s)\,\rightarrow view(agt,s'')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the base case, there must be an 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $Init(s')$
\end_inset

 and 
\begin_inset Formula $s'\leq_{PbU(agt)}s''$
\end_inset

.
 Therefore 
\begin_inset Formula $view(s'')$
\end_inset

 = 
\begin_inset Formula $view(s')$
\end_inset

 = 
\begin_inset Formula $\epsilon$
\end_inset

 = 
\begin_inset Formula $view(s)$
\end_inset

, as required.
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(a,s)$
\end_inset

 case, suppose 
\begin_inset Formula $obs(agt,a,s)=\{\}$
\end_inset

.
 Then 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

= 
\begin_inset Formula $view(agt,s)$
\end_inset

, while equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) gives us 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

, which yields 
\begin_inset Formula $view(agt,s'')$
\end_inset

 = 
\begin_inset Formula $view(agt,s)$
\end_inset

 by the inductive hypothesis.
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $obs(agt,a,s)\neq\{\}$
\end_inset

, then we have 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $a'$
\end_inset

 such that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $do(a',s')\leq_{PbU(agt)}s''$
\end_inset

, 
\begin_inset Formula $obs(agt,a,s)$
\end_inset

 = 
\begin_inset Formula $obs(agt,a',s')$
\end_inset

, and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 By the inductive hypothesis 
\begin_inset Formula $view(agt,s')=view(agt,s)$
\end_inset

, and we have the following: 
\begin_inset Formula $view(agt,s'')$
\end_inset

 = 
\begin_inset Formula $view(agt,do(a',s'))$
\end_inset

 = 
\begin_inset Formula $obs(agt,a,s)\cdot view(agt,s')$
\end_inset

 = 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

 as required.
 
\end_layout

\begin_layout Standard
Combining these results, we can state the following theorem:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:k_obs_equiv"

\end_inset

 For a basic action theory 
\begin_inset Formula $\Dt_{obs}$
\end_inset

, for any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt_{obs}\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge view(agt,s'')=view(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the 
\series bold
if
\series default
 direction, we simply combine lemmas 
\begin_inset LatexCommand ref
reference "lem:K-implies-root"

\end_inset

, 
\begin_inset LatexCommand ref
reference "lem:K-implies-legal"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "lem:K-implies-view"

\end_inset

.
 
\end_layout

\begin_layout Proof
For the 
\series bold
only-if
\series default
 base case, the 
\begin_inset Formula $\exists s'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) is trivially satisfied by 
\begin_inset Formula $root(s'')$
\end_inset

 and so the equivalence holds.
\end_layout

\begin_layout Proof
For the 
\series bold
only-if
\series default
 inductive case with 
\begin_inset Formula $do(a,s)$
\end_inset

, we have two sub-cases to consider.
 Suppose 
\begin_inset Formula $obs(agt,a,s)=\{\}$
\end_inset

: then 
\begin_inset Formula $view(agt,s'')$
\end_inset

 = 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

 = 
\begin_inset Formula $view(agt,s)$
\end_inset

 and 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 holds by the inductive hypothesis, satisfying the equivalence in equation
 (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

).
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $obs(agt,a,s)\neq\{\}$
\end_inset

: then we have 
\begin_inset Formula $view(agt,do(a,s))$
\end_inset

 = 
\begin_inset Formula $obs(agt,a,s)\cdot view(agt,s)$
\end_inset

 = 
\begin_inset Formula $view(agt,s'')$
\end_inset

.
 For this to be the case, and since 
\begin_inset Formula $s''$
\end_inset

 is legal, there must be some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $a'$
\end_inset

 satisfying 
\begin_inset Formula $obs(agt,a',s')$
\end_inset

 = 
\begin_inset Formula $obs(agt,a,s)$
\end_inset

, 
\begin_inset Formula $view(agt,s')$
\end_inset

 = 
\begin_inset Formula $view(agt,s)$
\end_inset

 and 
\begin_inset Formula $do(a',s')\leq_{PbU(agt)}s''$
\end_inset

 .
 This is enough to satisfy the 
\begin_inset Formula $\exists s',a'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) and so the equivalence holds.
\end_layout

\begin_layout Subsection
Axiomatizing Observations
\end_layout

\begin_layout Standard
Let us begin by considering the standard account of knowledge from 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

.
 Its basic assumption that 
\begin_inset Quotes eld
\end_inset

all agents are aware of all actions
\begin_inset Quotes erd
\end_inset

 may be rephrased as 
\begin_inset Quotes eld
\end_inset

when an action occurs, all agents will observe that action
\begin_inset Quotes erd
\end_inset

.
 Allowing the 
\noun on
Observations
\noun default
 sort to contain 
\noun on
Action
\noun default
 terms, this assumption is akin to the following assertion about the 
\begin_inset Formula $obs()$
\end_inset

 function:
\begin_inset Formula \begin{equation}
a'\in obs(agt,a,s)\equiv a=a'\label{eq:ax_obs_std1}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
What about sensing information? We can extend the 
\noun on
Observations
\noun default
 sort to contain terms of the form 
\emph on

\begin_inset Formula $(Action=Result)$
\end_inset


\emph default
 and axiomatize like so:
\begin_inset Formula \begin{multline}
(a'=r)\in obs(agt,a,s)\equiv a=a'\wedge SR(a,s)=r\wedge agent(a)=agt\label{eq:ax_obs_std2}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
Using these definitions, our new account of knowledge will behave identically
 to the standard account:
\end_layout

\begin_layout Theorem
For basic action theories 
\begin_inset Formula $\Dt_{std}$
\end_inset

 and 
\begin_inset Formula $\Dt_{obs}$
\end_inset

 describing the same world, and where 
\begin_inset Formula $\mathcal{D}_{Obs}$
\end_inset

 uses equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) to define the 
\begin_inset Formula $obs()$
\end_inset

 function, then for any situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{std}\models K(agt,s',s)\,\,\,\,\mathrm{iff}\,\,\,\,\Dt\cup\Dt_{obs}\models K(agt,s',s)\]

\end_inset


\end_layout

\begin_layout Proof
Equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) mean 
\begin_inset Formula $obs(agt,a,s)$
\end_inset

 cannot be empty, so 
\begin_inset Formula $s\leq_{PbU(agt)}s'$
\end_inset

 iff 
\begin_inset Formula $s=s'$
\end_inset

.
 Equations (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) then amount to simple transformations of equations (
\begin_inset LatexCommand ref
reference "eqn:k_ssa_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

) respectively, meaning that 
\begin_inset Formula $K$
\end_inset

 behaves the same under both theories.
\end_layout

\begin_layout Standard
If we remove equation (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

), a similar result holds between 
\begin_inset Formula $\Dt_{obs}$
\end_inset

 and 
\begin_inset Formula $\Dt_{exo}$
\end_inset

.
\end_layout

\begin_layout Standard
To generalize this for partial observability of actions we introduce a new
 action description predicate, akin to 
\begin_inset Formula $Poss$
\end_inset

 but describing when actions will be observed by agents: 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 indicates that agent 
\begin_inset Formula $agt$
\end_inset

 would observe action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 We can then formulate the 
\begin_inset Formula $obs()$
\end_inset

 function according to:
\begin_inset Formula \[
a'\in obs(agt,a,s)\equiv a'=a\wedge CanObs(agt,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
There is an additional assumption in the standard handling of sensing actions:
 only the agent performing a sensing action is aware of its result.
 Such a restriction is common but certainly not universal.
 For example, if an agent waiting for a train activates a speaker to determine
 when it will arrive, the result of this sensing action would be available
 to any other agent within earshot.
 We add an analogous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 to indicate when sensing information is available to an agent.
 We then include bare action terms in an agent's observations when it observes
 the action but not its result, and 
\emph on
(Action=Result)
\emph default
 terms when it also senses the result:
\begin_inset Formula \[
a'\in obs(agt,a,s)\equiv a=a'\wedge CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\]

\end_inset


\begin_inset Formula \begin{multline*}
(a'=r)\in obs(agt,a,s)\equiv a'=a\wedge SR(a,s)=r\wedge CanObs(agt,a,s)\wedge CanSense(agt,a,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Subsection
Observing the Effects of Actions
\end_layout

\begin_layout Standard
In many domains it would be infeasible for an agent to observe a particular
 action occurring, but it may be able to observe some of the effects of
 that action.
 For example, suppose that an agent monitors the state of a light in its
 environment, such that it notices it changing from dark to light.
 While it knows that 
\emph on
some
\emph default
 action must have occurred to produce that effect, it may not be sure precisely
 what action took place (e.g.
 precisely 
\emph on
who
\emph default
 turned on the light).
\end_layout

\begin_layout Standard
This can be modeled by further extending the 
\noun on
Observations
\noun default
 sort.
 Suppose that the observation term 
\begin_inset Formula $f_{\phi}$
\end_inset

 indicates that a particular property of the world 
\begin_inset Formula $\phi$
\end_inset

 has changed from false to true and (for simplicity) that this information
 would be available to all agents.
 The following could be used to include this information in an agent's observati
ons: 
\begin_inset Formula \begin{multline*}
f_{\phi}\in obs(agt,a,s)\equiv\neg\phi[s]\wedge\Reg(\phi[do(a,s)])\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Note that since we use 
\begin_inset Formula $obs()$
\end_inset

 as an action description predicate in equation (
\begin_inset LatexCommand ref
reference "eqn:PbU_defn"

\end_inset

), we must use regression to ensure that the right-hand side of this equivalence
 refers only to 
\begin_inset Formula $s$
\end_inset

.
 Expanding on the example of the light, we might have an axiom like this:
\begin_inset Formula \begin{multline*}
lightCameOn\in obs(agt,a,s)\equiv\neg lightIsOn(s)\wedge\exists agt2\,.\, a=turnLightOn(agt2)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
When the light is switched on, each agent's observations will contain the
 term 
\begin_inset Formula $lightCameOn$
\end_inset

, and they will know that this change has occurred without necessarily knowing
 the action responsible for the change.
 That this powerful new ability is a straightforward extension of our approach
 highlights the flexibility and robustness of the observation-based semantics.
\end_layout

\begin_layout Subsection
An Illustrative Example
\end_layout

\begin_layout Standard
Consider again a package-processing facility where agents are required to
 move boxes between various rooms.
 There are three actions (pickUp, putDown, and goRoom) and two fluents (Holding
 and InRoom) whose meanings should be clear.
 There are no sensing actions.
 
\end_layout

\begin_layout Standard
Agents may pickup a box if they are in the same room and no-one is holding
 it.
 They can putdown a box they are holding at any time, and can move freely
 between rooms:
\begin_inset Formula \begin{multline*}
Poss(pickUp(agt,box),s)\equiv\neg\exists x\,.\, Holding(x,box,s)\\
\wedge\exists rm\,.\, InRoom(agt,rm)\wedge InRoom(box,rm)\end{multline*}

\end_inset


\begin_inset Formula \[
Poss(putDown(agt,box),s)\equiv Holding(agt,box,s)\]

\end_inset


\begin_inset Formula \[
Poss(goRoom(agt,room),s)\equiv true\]

\end_inset


\end_layout

\begin_layout Standard
An agent is holding a box if they picked it up, or were already holding
 it and didn't put it down:
\begin_inset Formula \begin{multline*}
Holding(agt,box,do(c,s))\equiv pickUp(agt,box)\in c\,\vee\\
Holding(agt,box,s)\wedge putdDown(agt,box)\not\in c\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
An object is in a room if it was taken there, or it was already in that
 room and it was not taken elsewhere:
\begin_inset Formula \begin{multline*}
InRoom(obj,rm,do(c,s))\equiv\exists agt\,.\, goRoom(agt,rm)\in c\wedge\\
\left[obj=agt\vee Holding(agt,obj,s)\right]\,\,\vee\\
InRoom(obj,rm,s)\wedge\neg\left(\exists agt,rm2\,.\, goRoom(agt,rm2)\in c\wedge\right.\\
\left.rm2\neq rm\wedge\left[obj=agt\vee Holding(agt,obj,s)\right]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Agents can observe actions performed by an agent in the same room as themselves,
 and can observe agents entering their room:
\begin_inset Formula \begin{multline*}
CanObs(agt,a,s)\equiv\exists rm\,.\, InRoom(agt,rm)\wedge\\
\left(InRoom(agent(a),rm)\,\vee\,\exists agt2\,.\, a=goRoom(agt2,rm)\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Initially, Sam is in Room1 with Box1, Max is in Room2 with Box2, and no-one
 is holding any boxes.
 Everyone has complete knowledge of the initial situation:
\begin_inset Formula \begin{gather*}
InRoom(Sam,Room1,S_{0})\\
InRoom(Box1,Room1,S_{0})\\
InRoom(Max,Room2,S_{0})\\
InRoom(Box2,Room2,S_{0})\\
\neg Holding(agt,box,S_{0})\\
K_{0}(agt,s,S_{0})\rightarrow s=S_{0}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The following are examples of knowledge queries that can be posed in our
 formalism, and a brief explanation of their outcome:
\begin_inset Formula \[
\mathcal{D}_{Obs}\models\mathbf{Knows}(Sam,\neg Holding(Max,Box1),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Initially, Sam knows that Max is not holding Box1.
 For 
\begin_inset Formula $Holding(Max,Box1)$
\end_inset

 to be true, he must have picked Box1 up.
 Since Box1 is in the same room as Sam, she would be able to observe him
 doing so.
 Since she has not observed that, she can conclude that 
\begin_inset Formula $Holding(Max,Box1)$
\end_inset

 is false.
\begin_inset Formula \[
\mathcal{D}_{Obs}\models\mathbf{\neg Knows}(Sam,\neg Holding(Max,Box2),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
By contrast, Sam does 
\emph on
not
\emph default
 know that Max is not holding Box2.
 Since Box2 is in a different room, Max could have picked it up without
 her observing the action.
\begin_inset Formula \begin{multline*}
\mathcal{D}_{Obs}\models\mathbf{Knows}(Sam,Holding(Max,Box1),\\
do(\{pickUp(Max,Box1)\},\\
do(\{goRoom(Max,Room1)\},S_{0}))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
For Max to put down Box1 without Sam observing anything, he would have to
 first move to a different room.
 Since the action of moving to a different room would be observed by Sam,
 she knows that he must be holding the box.
\begin_inset Formula \begin{multline*}
\mathcal{D}_{Obs}\models\mathbf{\neg Knows}(Sam,Holding(Max,Box1),\\
do(\{goRoom(Max,Room2)\},\\
do(\{pickUp(Max,Box1)\},\\
do(\{goRoom(Max,Room1)\},S_{0})))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Once Max takes Box1 into a different room, Sam can no longer be sure that
 he is holding it, since he may put it down without her observing anything.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The appearance of the 
\begin_inset Formula $\leq_{PbU(agt)}$
\end_inset

 ordering over situations in equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) means that our new successor state axiom universally quantifies over situation
s, so standard regression techniques cannot be applied.
 To permit an effective reasoning procedure, we appeal to the 
\emph on
persistence condition
\emph default
 meta-operator 
\begin_inset LatexCommand cite
key "kelly07sc_persistence"

\end_inset

.
 This operator transforms a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

 into a uniform formula 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}(\phi,\alpha)$
\end_inset

 that is true in all situations where 
\begin_inset Formula $\phi$
\end_inset

 will persist if all future actions satisfy 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\mathcal{P}_{\mathcal{D}}(\phi,\alpha)[s]\equiv\forall s'\,.\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
The procedure for determining 
\begin_inset Formula $\mathcal{P}_{\mathcal{D}}$
\end_inset

 replaces second-order induction with iterated first-order reasoning.
 It also requires that there be only finitely many types of action, an assumptio
n met by most realistic domains.
\end_layout

\begin_layout Standard
The persistence condition can be used to augment the technique for regressing
 knowledge queries developed in 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

.
 Assuming that the knowledge fluent 
\begin_inset Formula $K$
\end_inset

 appears only in the context of a 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, we propose the following to replace the existing regression clause
 for 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

:
\begin_inset Formula \begin{multline}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,do(c,s)))=\\
\exists o\,.\, Observations(agt,c,s)=o\\
\wedge\left[o=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
\wedge\,\left[o\neq\{\}\rightarrow\mathbf{Knows}(agt,\forall c'.\, Observations(agt,c',s)=o\right.\\
\left.\wedge Poss(c',s)\rightarrow\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt))[do(c',s)]),s)\right]\label{eqn:R_do_c_s}\end{multline}

\end_inset

 As required, this reduces a knowledge query at 
\begin_inset Formula $do(c,s)$
\end_inset

 to a knowledge query at 
\begin_inset Formula $s$
\end_inset

.
 It is also intuitively appealing: to know that 
\begin_inset Formula $\phi$
\end_inset

 holds, the agent must know that in all situations that agree with its observati
ons, 
\begin_inset Formula $\phi$
\end_inset

 cannot become false without it making an observation.
\end_layout

\begin_layout Standard
We must also specify the regression of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 in the initial situation, as equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) also quantifies over situations.
 This clause results in standard first-order modal reasoning over the 
\begin_inset Formula $K_{0}$
\end_inset

 relation, as required by the procedure in 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

:
\begin_inset Formula \begin{multline}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,S_{0}))=\\
\forall s\, K_{0}(agt,s,S_{0})\rightarrow\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt))[s]\label{eqn:R_s0}\end{multline}

\end_inset

 Regression of the additional predicates we have introduced (
\begin_inset Formula $CanObs$
\end_inset

, 
\begin_inset Formula $Observations$
\end_inset

, etc) is identical to that of 
\begin_inset Formula $Poss$
\end_inset

 and requires no special treatment here, except to mention that the restriction
 to a finite number of actions allows regression of such predicates even
 when their arguments are variables.
\end_layout

\begin_layout Standard
We briefly sketch the highlights of a proof that our modified regression
 operator in equations (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

) preserves equivalence.
 It proceeds by expanding the definition for 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 using our new successor state axiom for 
\begin_inset Formula $K$
\end_inset

, collecting sub-formulae that match the form of the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, and using regression and persistence to render the resulting knowledge
 expression uniform in 
\begin_inset Formula $s$
\end_inset

.
 Applying persistence to an expansion of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 at the initial situation completes the proof.
\end_layout

\begin_layout Standard
Given a basic action theory 
\begin_inset Formula $\mathcal{D}_{Obs}$
\end_inset

 and a formula 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

, it is always the case that:
\begin_inset Formula \[
\mathcal{D}_{Obs}\models\phi[do(c,s)]\equiv\mathcal{R}_{\mathcal{D}}(\phi[do(c,s)])\]

\end_inset

 
\end_layout

\begin_layout Standard
We need only consider applications of 
\begin_inset Formula $\mathcal{R}_{\mathcal{D}}$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 has the form 
\begin_inset Formula $\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as other regression clauses are not modified from 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

.
 For clarity we define the abbreviation 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s)$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

persists under equivalent observations
\begin_inset Quotes erd
\end_inset

) which states that 
\begin_inset Formula $\phi$
\end_inset

 holds in all legal futures of 
\begin_inset Formula $s$
\end_inset

 compatible with observations 
\begin_inset Formula $o$
\end_inset

:
\begin_inset Formula \begin{multline*}
\mathbf{PEO}(agt,\phi,o,s)\,\isdef\,\\
\forall c'\,.\, Observations(agt,c',s)=o\wedge Poss(c',s)\rightarrow\\
\left[\forall s'\,.\, do(c',s)\leq_{PbU(agt)}s'\rightarrow\,\phi[s']\right]\end{multline*}

\end_inset

 Combining and rearranging equations (
\begin_inset LatexCommand ref
reference "eqn:knows_def"

\end_inset

) and (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

), the definition of 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 at 
\begin_inset Formula $do(c,s)$
\end_inset

 can be written in the form: 
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\\
\exists o\,.\, Observations(agt,c,s)=o\\
\wedge\,\left[o=\{\}\rightarrow\forall s'\,.\, K(agt,s',s)\rightarrow\phi[s']\right]\\
\wedge\,\left[o\neq\{\}\rightarrow\forall s'\,.\, K(agt,s',s)\rightarrow\mathbf{PEO}(agt,\phi,o,s')\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Noting that both conjuncts contain sub-formulae matching the form of the
 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, it can be substituted back in to give:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\\
\exists o\,.\, Observations(agt,c,s)=o\\
\wedge\,\left[o=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
\wedge\,\left[o\neq\{\}\rightarrow\mathbf{Knows}(agt,\mathbf{PEO}(agt,\phi,o,s'),s)\right]\end{multline*}

\end_inset

 For 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s')$
\end_inset

 to legitimately appear inside the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro it must be uniform in the situation variable 
\begin_inset Formula $s'$
\end_inset

.
 Applying the persistence condition and regressing to make the expression
 uniform, we develop the following equivalence:
\begin_inset Formula \begin{multline*}
\mathbf{PEO}(agt,\phi,o,s)\equiv\\
\forall c'\,.\, Observations(agt,c',s)=o\wedge Poss(c',s)\rightarrow\\
\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt))[do(c',s)])\end{multline*}

\end_inset

 Finally, since the situation variable inside the formula in a 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro is renamed when the macro is expanded, we can rename 
\begin_inset Formula $s'$
\end_inset

 to 
\begin_inset Formula $s$
\end_inset

 to avoid having an additional variable.
 This gives equation (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

) as required.
\end_layout

\begin_layout Standard
For 
\begin_inset Formula $S_{0}$
\end_inset

, a straightforward transformation of equations (
\begin_inset LatexCommand ref
reference "eqn:knows_def"

\end_inset

) and (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) gives:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,S_{0})\equiv\\
\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\left[\forall s'\,.\, s\leq_{PbU(agt)}s'\rightarrow\phi[s']\right]\end{multline*}

\end_inset

 Applying the persistence condition operator, this can easily be re-written
 as:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,S_{0})\equiv\\
\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt))[s]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
This is equation (
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

), as required.
\end_layout

\begin_layout Standard
We can thus handle knowledge queries using regression, the standard technique
 for effective reasoning in the situation calculus.
\end_layout

\begin_layout Subsection
Reasoning from Observations
\end_layout

\begin_layout Standard
While this reasoning method is suitable for modeling and simulation purposes,
 it would be unreasonable for a situated agent to ask 
\begin_inset Quotes eld
\end_inset

do I know 
\begin_inset Formula $\phi$
\end_inset

 in the current situation?
\begin_inset Quotes erd
\end_inset

 using the situation calculus query 
\begin_inset Formula $\mathcal{D}\models\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as it cannot be expected to have the full current situation 
\begin_inset Formula $s$
\end_inset

.
 However, it will have its current observation history 
\begin_inset Formula $h$
\end_inset

.
 We define knowledge with respect to an observation history as follows:
\begin_inset Formula \begin{multline*}
\mathbf{Knows}(agt,\phi,h)\,\isdef\\
\forall s.ObsHist(agt,s)=h\wedge Root(s)=S_{0}\rightarrow\mathbf{Knows}(agt,\phi,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
It is a straightforward consequence of Theorem 
\begin_inset LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 that this form of knowledge is equivalent to knowledge based on a situation
 term having that observation history and rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
\end_layout

\begin_layout Standard
Extending the regression rules in equations (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

) to handle formulae of this form is actually simpler than for regression
 over situations, as there are no empty observations in a history.
 The result is: 
\begin_inset Formula \begin{multline*}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,o\cdot h))=\\
\mathbf{Knows}(agt,\forall c\,.\, Observations(agt,c,s)=o\\
\wedge Poss(c,s)\rightarrow\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt))[do(c,s)]),h)\end{multline*}

\end_inset


\begin_inset Formula \begin{multline*}
\mathcal{R}_{\mathcal{D}}(\mathbf{Knows}(agt,\phi,\epsilon))=\\
\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\mathcal{P}_{\mathcal{D}}(\phi,PbU(agt))[s]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Using regression in this way, agents can reason about their own knowledge
 using only their local information.
 Our work thus makes it possible to include a situation calculus model in
 the implementation of a real-world multi-agent system, even when agents
 have only partial awareness of the actions being performed.
\end_layout

\begin_layout Section
Complex Epistemic Modalities
\begin_inset LatexCommand label
name "sec:Complex-Epistemic-Modalities"

\end_inset


\end_layout

\begin_layout Standard
So far we have constructed a powerful new account of 
\emph on
individual 
\emph default
knowledge in a multi-agent setting.
 For rich multi-agent domains, we must also be able to reason about group-level
 knowledge and, in particular, about common knowledge.
 The primary motivation for this section is a formal treatment of common
 knowledge within our framework, but as we shall see, this requires significant
 technical machinery capable of handling much more general epistmic modalities.
\end_layout

\begin_layout Subsection
Group-Level Epistemic Modalities
\end_layout

\begin_layout Standard
We breifly review the various group-level epistemic modalities found in
 the literature.
 Let 
\begin_inset Formula $G$
\end_inset

 be a finite group of agents.
 The basic group-level modality is 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

, which is defined as:
\begin_inset Formula \[
\mathbf{EKnows}(G,\phi,s)\,\isdef\,\bigwedge_{agt\in G}\,\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
To assert more complete knowledge by members of the group, one can say that
 
\begin_inset Quotes eld
\end_inset

everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 by nesting 
\begin_inset Formula $\mathbf{EKnows}$
\end_inset

 operators.
 In general: 
\begin_inset Formula \begin{multline*}
\mathbf{EKnows}^{1}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\phi,s)\\
\mathbf{EKnows}^{n}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\mathbf{EKnows}^{n-1}(G,\phi),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
The most powerful group-level modality is 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Intuitively this indicates that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, and so on ad infinitum.
 Formally, it can be defined as the infinite conjunction:
\begin_inset Formula \[
\mathbf{CKnows}(G,\phi,s)\,\isdef\,\bigwedge_{n\in\mathbb{N}}\mathbf{EKnows}^{n}(G,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Common knowledge is an extremely powerful form of knowledge that has deep
 implications for coordinated group behavior 
\begin_inset LatexCommand cite
key "halpern90knowledge_distrib"

\end_inset

.
 For example, in the famous Byzantine Generals problem (TODO) the proof
 that the generals cannot coordinate an attack depends heavily on their
 inability to obtain common knowledge.
\end_layout

\begin_layout Subsection
The Trouble with Common Knowledge
\end_layout

\begin_layout Standard
We are aware of no formal treatments of common knowledge in the situation
 calculus literature, and certainly none in domains as rich as those we
 consider here.
 This can be attributed to the difficulty of handling common knowledge using
 the regression operator.
\end_layout

\begin_layout Standard
In the related field of dynamic epistemic logic, a famous result of 
\begin_inset LatexCommand cite
key "baltag98pa_ck"

\end_inset

 states that:
\end_layout

\begin_layout Verse
Epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone.
\end_layout

\begin_layout Standard
In our terminology: 
\begin_inset Formula $\Reg(\CKnows(G,\phi,do(a,s)))$
\end_inset

 cannot be defined using only 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\CKnows$
\end_inset

.
 Given the deep similarities between the situation caluclus and epistemic
 modal logic 
\begin_inset LatexCommand cite
key "vanbentham07ml_sitcalc"

\end_inset

, we should expect this result to apply in the situation calculus.
\end_layout

\begin_layout Standard
While one could reason about common knowledge by calculating it directly
 as a fixpoint of 
\begin_inset Formula $\EKnows$
\end_inset

, this process would be immensely computationally expensive and unlikely
 to terminate.
 Effective reasoning requires a regression rule.
\end_layout

\begin_layout Standard
Fortunately, recent work by 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

 has shown that this limitation can be overcome by increasing the expressivity
 of the epistemic language in use.
 Their solution rests on three main ideas:
\end_layout

\begin_layout Enumerate
Use the syntax of propositional dynamic logic as a more expressive epistemic
 path language
\end_layout

\begin_layout Enumerate
Explicitly represent and reason about the epistemic uncertainty between
 actions
\end_layout

\begin_layout Enumerate
Regress epistemic path expressions as well as the contained formulae
\end_layout

\begin_layout Standard
After introducing these ideas in their original context, we will adapt and
 expand them for use within our framework.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
The Logic of Communication and Change
\end_layout

\begin_layout Standard
This section is a brief overview of the Logic of Communication and Change
 (hereafter denoted 
\begin_inset Quotes eld
\end_inset

LCC
\begin_inset Quotes erd
\end_inset

) developed by 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

, designed to introduce their ideas and contributions to the field.
 The paper on this logic 
\begin_inset LatexCommand citep
key "vanBenthem06lcc"

\end_inset

 is quite accessible and should be consulted for full details.
 This section assumes some familiarity with the syntax and semantics of
 modal logic.
\end_layout

\begin_layout Standard
In traditional modal logics of knowledge, there is one accessibility relation
 
\begin_inset Formula $K_{agt}$
\end_inset

 for each agent.
 Knowledge is expressed using the modal box operator, as in 
\begin_inset Formula $[K_{agt}]\phi$
\end_inset

.
 The first major contribution of LCC is to increase the expressiveness of
 the epistemic language by allowing complex 
\emph on
path expressions
\emph default
 in place of the base knowledge operators.
 Path expressions are based on propositional dynamic logic and take the
 following forms:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather*}
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Some common kinds of knowledge:
\begin_inset Formula \[
\Knows(agt,\phi)\,\,\,\,\,\,[K_{agt}]\phi\,\,\,\,\,\,[agt]\phi\]

\end_inset


\begin_inset Formula \[
\Knows(agt_{1},\Knows(agt_{2},\phi))\,\,\,\,\,\,[K_{agt_{1}}][K_{agt_{2}}]\phi\,\,\,\,\,\,[agt_{1};agt_{2}]\phi\]

\end_inset


\begin_inset Formula \[
\Knows(agt_{1},\phi)\vee\Knows(agt_{2},\phi)\,\,\,\,\,\,[K_{agt_{1}}]\phi\vee[K_{agt_{2}}]\phi\,\,\,\,\,\,[agt_{1}\cup agt_{2}]\phi\]

\end_inset


\begin_inset Formula \[
\CKnows(G,\phi)\,\,\,\,\,\,[C_{G}]\phi\,\,\,\,\,\,[(\bigcup_{agt\in G}agt)^{*}]\phi\]

\end_inset


\end_layout

\begin_layout Standard
Here we see the first advantage of this approach - there is no need for
 a special-purpose common knowledge operator.
 It is simply expressed as one specific instance of the iteration operator.
\end_layout

\begin_layout Standard
The next major idea is the explicitly represent the epistemic uncertainty
 about the actions that are performed.
 This is done by means of 
\emph on
update frames
\emph default
, which are a finite set of actions connected by indistinguishability relations.
 The actions are labelled 
\begin_inset Formula $1$
\end_inset

 through 
\begin_inset Formula $n$
\end_inset

.
\newline

\end_layout

\begin_layout Standard
Example goes here
\newline

\end_layout

\begin_layout Standard
To express what happens after the ocurrence of an action, one specified
 the update frame along with the specific action that actually occurred.
 This formula says 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds after performing action 
\begin_inset Formula $i$
\end_inset

 from update frame 
\begin_inset Formula $\mathrm{U}$
\end_inset

:
\begin_inset Formula \[
[\mathrm{U},i]\phi\]

\end_inset


\end_layout

\begin_layout Standard
When 
\begin_inset Formula $\phi$
\end_inset

 does not contain any epistemic modalities, this is straightforward dynamic
 logic.
 The third major contribution of LCC is a technique for handling formula
 of the form:
\begin_inset Formula \[
[\mathrm{U},i][\pi]\phi\]

\end_inset


\end_layout

\begin_layout Standard
This reads: 
\begin_inset Quotes eld
\end_inset

after performing action 
\begin_inset Formula $i$
\end_inset

 from update frame 
\begin_inset Formula $\mathrm{U}$
\end_inset

, it is 
\begin_inset Formula $\pi$
\end_inset

-known that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 They use a syntactic transformation 
\begin_inset Formula $\mathcal{T}$
\end_inset

 to reduce this formula to an equivalent, simpler form as follows: 
\begin_inset Formula \[
[\mathrm{U},i][\pi]\phi\,\,\,\equiv\,\,\,\bigwedge_{j=1}^{n}[\mathbf{\mathcal{T}}_{ij}^{\mathrm{U}}(\pi)][\mathrm{U},j]\phi\]

\end_inset


\end_layout

\begin_layout Standard
The transform 
\begin_inset Formula $\mathbf{\mathcal{T}}$
\end_inset

 takes the update frame, the actual action 
\begin_inset Formula $i$
\end_inset

, another action 
\begin_inset Formula $j$
\end_inset

 , and transforms 
\begin_inset Formula $\pi$
\end_inset

 into another (more complex) epistemic path.
 Basically, this formula says: consider every possible action 
\begin_inset Formula $j=1$
\end_inset

 to 
\begin_inset Formula $j=n$
\end_inset

), determine the epistemic paths that would cause the agents to mistake
 action 
\begin_inset Formula $i$
\end_inset

 for 
\begin_inset Formula $j$
\end_inset

, and determine the effects of 
\begin_inset Formula $j$
\end_inset

 on the formula in question.
\end_layout

\begin_layout Standard
The (partial) definition of the translation function is as follows:
\begin_inset Formula \begin{alignat*}{1}
\mathcal{T}_{ij}^{\mathrm{U}}(agt)= & \begin{cases}
?pre(i);agt & \mathrm{if\, iR(a)j}\\
?\bot & otherwise\end{cases}\\
\mathcal{T}_{ij}^{\mathrm{U}}(\pi_{1};\pi_{2})= & \bigcup_{k=1}^{n}\left(\mathcal{T}_{ik}^{\mathrm{U}}(\pi_{1});\mathcal{T}_{kj}^{\mathrm{U}}(\pi_{2})\right)\\
\mathcal{T}_{ij}^{\mathrm{U}}(\pi^{*})= & \mathcal{K}_{ijn}^{\mathrm{U}}(\pi)\end{alignat*}

\end_inset


\end_layout

\begin_layout Standard
The most prominent innovation of LCC is the use of a variant of Kleene's
 theorem on finite automata to handle the 
\begin_inset Formula $\pi^{*}$
\end_inset

 case.
 
\begin_inset Formula \begin{alignat*}{1}
\mathcal{K}_{ij0}^{\mathrm{U}}= & \begin{cases}
?\top\cup\mathcal{T}_{ij}^{\mathrm{U}}(\pi) & if\, i=j\\
\mathcal{T}_{ij}^{\mathrm{U}}(\pi) & otherwise\end{cases}\\
\mathcal{K}_{ij(k+1)}^{\mathrm{U}}= & \begin{cases}
(\mathcal{K}_{kkk}^{\mathrm{U}}(\pi))^{*} & if\, i=k=j\\
(\mathcal{K}_{kkk}^{\mathrm{U}}(\pi))^{*};\mathcal{K}_{kjk}^{\mathrm{U}}(\pi) & if\, i=k\neq j\\
\mathcal{K}_{ikk}^{\mathrm{U}}(\pi);(\mathcal{K}_{kkk}^{\mathrm{U}}(\pi))^{*} & if\, i\neq k=j\\
\mathcal{K}_{ijk}^{\mathrm{U}}(\pi)\cup\left(\mathcal{K}_{ikk}^{\mathrm{U}}(\pi);(\mathcal{K}_{kkk}^{\mathrm{U}}(\pi))^{*};\mathcal{K}_{kjk}^{\mathrm{U}}(\pi)\right) & otherwise\end{cases}\end{alignat*}

\end_inset


\end_layout

\begin_layout Standard
Key to understanding this construction is to consider the update frame as
 a finite automaton, and 
\begin_inset Formula $\mathcal{T}_{ij}^{\mathrm{U}}(\pi)$
\end_inset

 as a regular expression generated by the automaton when travelling a 
\begin_inset Formula $\pi$
\end_inset

-path from state 
\begin_inset Formula $i$
\end_inset

 to state 
\begin_inset Formula $j$
\end_inset

.
 Then 
\begin_inset Formula $\mathcal{K}_{ijk}^{\mathrm{U}}(\pi)$
\end_inset

 is the language generated by taking a 
\begin_inset Formula $\pi^{*}$
\end_inset

-path from 
\begin_inset Formula $i$
\end_inset

 to 
\begin_inset Formula $j$
\end_inset

 without stopovers through states labelled higher than 
\begin_inset Formula $k$
\end_inset

.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\mathcal{K}_{ijn}^{\mathrm{U}}(\pi)$
\end_inset

 allows stopovers at any state, and so is the entire language.
\end_layout

\begin_layout Subsection
From LCC to the Situation Calculus
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Unlike the explicit update frames used in the semantics of LCC, the our
 framework defines the epistemic relationships between actions implicitly
 by means of the 
\begin_inset Formula $obs$
\end_inset

 function.
 We can therefore omit the notion of update frames
\end_layout

\begin_layout Subsection
A Complex Epistemic Fluent
\end_layout

\begin_layout Standard
We need to define 
\begin_inset Formula $K(\pi,s'',s)$
\end_inset

 for a general path expression 
\begin_inset Formula $\pi$
\end_inset

.
 To do so, we begin with a straightforward import of LCC into the situation
 calculus, treating 
\begin_inset Formula $\epsilon$
\end_inset

 as an ordinary action.
 We shall use 
\begin_inset Formula $K_{0}$
\end_inset

 to denote this version.
 Then:
\begin_inset Formula \[
K_{0}(\pi,s'',do(a,s))\equiv\exists a',s':\, K_{0}(\mathcal{T}[\pi,a,a'],s',s)\wedge s''=do(a',s)\]

\end_inset


\end_layout

\begin_layout Standard
We can use analogous arguments to those for LCC to show that this works
 as intended, preserving the semantics of PDL.
 Now let us make an intuitive argument for dealing with 
\begin_inset Formula $\epsilon$
\end_inset

 actions.
 Define 
\begin_inset Formula $\mathcal{E}^{n}(s)$
\end_inset

 to be 
\begin_inset Formula $s$
\end_inset

 followed by 
\begin_inset Formula $n$
\end_inset

 empty actions, as follows:
\begin_inset Formula \[
\mathcal{E}^{0}(s)=s\]

\end_inset


\begin_inset Formula \[
\mathcal{E}^{1}(s)=do(\epsilon,s)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \[
\mathcal{E}^{n}(s)=\mathcal{E}^{1}(\mathcal{E}^{n-1}(s))=do(\epsilon,do(\epsilon,...,do(\epsilon,s)))\]

\end_inset


\end_layout

\begin_layout Standard
Lemma: 
\begin_inset Formula \[
\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\mathbf{Knows}_{0}(\pi,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
By a similar construction to the persistence condition, if
\begin_inset Formula \[
\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n+1}(s))\]

\end_inset


\end_layout

\begin_layout Standard
then we have a fixpoint:
\begin_inset Formula \[
\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\mathbf{Knows}_{0}(\pi,\phi,\mathcal{E}^{m}(s))\,\,,\,\, m\geq n\]

\end_inset


\end_layout

\begin_layout Standard
Use the following regression definitions:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Reg(\KnowsZ(\pi,\phi,do(a,s)))\,\isdef\,\forall a':\,\Knows(\Trn(\pi,a,a'),\Reg(\phi,a'),s)\]

\end_inset


\begin_inset Formula \[
\Reg(\KnowsZ(\pi,\phi,do(\epsilon,s))\,\isdef\,\forall c':\,\KnowsZ(\Trn(\pi,a,a'),\Reg(\phi,a'),s)\]

\end_inset


\begin_inset Formula \[
\Reg(\Knows(\pi,\phi,do(a,s)))\,\isdef\,\bigwedge_{n\in\mathbb{N}}\KnowsZ(\pi,\phi,\mathcal{E}^{n}(do(a,s)))\]

\end_inset


\end_layout

\begin_layout Section
Simplifying the Reasoning Procedure
\begin_inset LatexCommand label
name "sec:Simplifying-Reasoning"

\end_inset


\end_layout

\begin_layout Subsection
Synchronicity
\end_layout

\begin_layout Standard
By equipping agents with a global clock tick, the persistence condition
 is no longer required.
 Since this is the biggest source for computational complexity, that's a
 big win! 
\end_layout

\begin_layout Subsection
Observability
\end_layout

\begin_layout Standard
Ensure that the update frame is weakly connected, so that most 
\begin_inset Formula $\mathcal{T}[\pi,a,a']$
\end_inset

 are vacuously false.
\newline

\end_layout

\begin_layout Standard
anything else?
\end_layout

\begin_layout Section
Related Work
\begin_inset LatexCommand label
name "sec:Related-Work"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "morgenstern90knowledge"

\end_inset

 - hidden actions, appeals to motivated action theory.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "delgrande01sitcalc_cleudo"

\end_inset

 - shows that common knowledge is useful, but appeals to a (non-existent)
 solution from elsewhere
\end_layout

\begin_layout Standard
clearly the long lineage of 
\begin_inset LatexCommand cite
key "baltag99epi_act_structures"

\end_inset

, 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

 that have developed the basis of these techniques.
 
\begin_inset LatexCommand cite
key "moss05iter_pal"

\end_inset

 Iterated PAL is undecidable.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand cite
key "vanBentham06epi_temporal_logic"

\end_inset

 big discussion and comparison on epistemic temporal logics.
 defines notion of 
\begin_inset Quotes eld
\end_inset

synchronised
\begin_inset Quotes erd
\end_inset

 system that we use above.
\end_layout

\begin_layout Section
Future Work
\begin_inset LatexCommand label
name "sec:Future-Work"

\end_inset


\end_layout

\begin_layout Standard
Lifting the restrictions on the update frame.
 Can this be done using a stronger path language?
\end_layout

\begin_layout Standard
Decidability and effectiveness guarantees.
\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Standard
hooray for us, this is a great paper :-)
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "theapa"
bibfiles "/storage/uni/pgrad/library/references"

\end_inset


\end_layout

\end_body
\end_document
