#LyX 1.5.5 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass jair
\begin_preamble

\jairheading{0}{0000}{0-0}{0/0}{0/0}
\ShortHeadings{Common Knowledge, Hidden Actions, and the Frame Problem}{R. F. Kelly \& A. R. Pearce}
\firstpageno{1}

 \renewenvironment{proofsketch}{\begin{proof}[Proof Sketch]}{ For the complete proof, see Appendix \ref{sec:Complete-Proofs}. \end{proof}}
\end_preamble
\options jair,twoside,11pt,theapa,letterpaper
\language british
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Common Knowledge, Hidden Actions, and the Frame Problem
\end_layout

\begin_layout Author
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Ryan F.
 Kelly 
\backslash
email rfk@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Adrian R.
 Pearce 
\backslash
email adrian@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addr Department of Computer Science and Software Engineering
\backslash

\backslash

\end_layout

\begin_layout Standard

The University of Melbourne
\backslash

\backslash

\end_layout

\begin_layout Standard

Victoria, 3010, Australia
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a powerful new account of multi-agent knowledge in the situation
 calculus and an effective reasoning procedure for knowledge queries.
 Our approach handles partial observability of actions, including actions
 that are completely hidden, by explicitly reifying the observations made
 by each agent as the world evolves.
 It formally treats complex group-level epistemic modalities such as common
 knowledge, which were previously difficult to handle effectively in the
 situation calculus.
 By using the persistence condition meta-operator to augment traditional
 regression techniques, we allow agents to reason about their own knowledge
 using only their internal history of observations, rather than requiring
 a full history of the world.
 The result is a more robust and flexible account of knowledge in the situation
 calculus suitable for asynchronous, partially-observable multi-agent domains.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isdef}{\stackrel{\mbox{\tiny def}}{=}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Dt}{\mathcal{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Reg}{\mathcal{R}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Pst}{\mathcal{P}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Trn}{\mathcal{T}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Kln}{\mathcal{K}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\TrnA}{\Trn_{a}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EKnows}{\mathbf{EKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Knows}{\mathbf{Knows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\CKnows}{\mathbf{CKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KnowsZ}{\mathbf{Knows_{0}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PKnowsZ}{\mathbf{PKnows_{0}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PKnows}{\mathbf{PKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KTrans}{\mathbf{KDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KDo}{\mathbf{KDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EDo}{\mathbf{EDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\vars}[1]{\bar{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PbU}{PbU}
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In their landmark paper 
\emph on
Knowledge, Action, and the Frame Problem,
\emph default
 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 incorporate knowledge-producing actions into the situation calculus 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

, inheriting Reiter's solution to the frame problem 
\begin_inset LatexCommand citep
key "reiter91frameprob"

\end_inset

 and so enabling use of the regression operator to reason about the changing
 knowledge of an agent.
 Extensions to multiple agents 
\begin_inset LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

 have produced an expressive logic of knowledge, action and change in which
 regression provides an effective reasoning procedure.
 But while powerful, this formalism suffers two major limitations that make
 it unsuitable for modelling complex multi-agent domains.
\end_layout

\begin_layout Standard
First, it lacks a comprehensive treatment of group-level epistemic modalities.
 Simple group-level modalities such as 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 can be expressed as finite combinations of individual-level knowledge operators
, but more complex modalities such as 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 cannot be handled in this way.
 Instead, common knowledge is typically introduced via a separate second-order
 axiom 
\begin_inset LatexCommand citep
key "davis05fo_ma_theory,ghaderi07sc_joint_ability"

\end_inset

.
 While logically sound, this approach means regression can no longer be
 used for effective automated reasoning.
 Given the deep connections between common knowledge and coordination, this
 is a serious shortcoming in multi-agent domains.
\end_layout

\begin_layout Standard
Second, it requires that whenever an action occurs, all agents 
\emph on
know
\emph default
 that an action has occurred.
 This demands a level of synchronicity that is unreasonable in many multi-agent
 domains.
 But if the restriction is lifted, each agent's knowledge must account for
 arbitrarily-long sequences of hidden actions 
\begin_inset LatexCommand citep
key "Lesperance99sitcalc_approach"

\end_inset

.
 Such a formulation must utilise a second-order induction axiom, again precludin
g the use of regression for effective automated reasoning.
\end_layout

\begin_layout Standard
In this paper we overcome these limitations, extending the standard account
 of knowledge in the situation calculus with the following technical results:
\end_layout

\begin_layout Itemize
a formal account of 
\emph on
Common Knowledge
\emph default
 and other group-level epistemic modalities, including a regression rule
 for reasoning about common knowledge.
\end_layout

\begin_layout Itemize
support for 
\emph on
Hidden Actions
\emph default
 and actions that are partially observable, including a reasoning technique
 to deal with arbitrarily-long sequences of hidden actions.
\end_layout

\begin_layout Itemize
a solution to the 
\emph on
Frame Problem
\emph default
 for knowledge, built on the successor state axioms for primitive actions,
 maintaining regression as the primary reasoning tool, and allowing agents
 to reason about their own knowledge using only their local information.
\end_layout

\begin_layout Standard
The result is a rich account of knowledge for asynchronous, partially-observable
 domains, in which group-level epistemic modalities are amenable to effective
 automated reasoning.
\end_layout

\begin_layout Standard
There is a large body of work that can immediately benefit from such a formalism
, including: specification and verification of multi-agent systems 
\begin_inset LatexCommand citep
key "shapiro02casl"

\end_inset

; theories of coordination 
\begin_inset LatexCommand citep
key "ghaderi07sc_joint_ability"

\end_inset

 and ability 
\begin_inset LatexCommand citep
key "levesque00knowing_how"

\end_inset

; reasoning about the epistemic feasibility of plans 
\begin_inset LatexCommand citep
key "Lesperance01epi_feas_casl"

\end_inset

; analysing multi-player games 
\begin_inset LatexCommand citep
key "delgrande01sitcalc_cleudo"

\end_inset

; and our own work on the cooperative execution of Golog programs 
\begin_inset LatexCommand citep
key "kelly06hlp_dps"

\end_inset

.
\end_layout

\begin_layout Standard
The paper begins by reviewing the standard account of multi-agent knowledge
 in the situation calculus in Section 
\begin_inset LatexCommand ref
reference "sec:The-Multi-Agent-Situation"

\end_inset

.
 Readers familiar with the situation calculus are encouraged to review this
 material, as we extend some of the standard notation in preparation for
 later sections.
 Our new formalism is then developed in two parts: first by axiomatising
 individual knowledge in the face of hidden actions in Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

, then by adding complex group-level epistemic modalities to model common
 knowledge in Section 
\begin_inset LatexCommand ref
reference "sec:Complex-Epistemic-Modalities"

\end_inset

.
\end_layout

\begin_layout Standard
The challenge in both cases is to increase the expressive power of the logic
 while still allowing regression to be performed.
 That is, it must be possible for an epistemic query about the state of
 the world 
\emph on
after
\emph default
 an action has been performed to be translated into a query about the state
 of the world 
\emph on
before
\emph default
 that action.
 This is achieved by using new reasoning techniques to augment the standard
 regression operator, and by carefully constructing our extensions to be
 compatible with these techniques.
 
\end_layout

\begin_layout Subsection*
Individual Knowledge with Hidden Actions
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 treats the individual knowledge of each agent in the face of hidden actions,
 by decoupling knowledge from the specific actions that have occurred.
 We explicitly reify the local 
\emph on
observations
\emph default
 made by each agent, and formulate the agent's knowledge in terms of what
 it has observed.
 Each occurrence of an action results in an agent making a (possibly empty)
 set of observations.
 Every situation then corresponds to a 
\emph on
view
\emph default
: the sequence of all observations made by an agent, excluding cases where
 the set of observations was empty.
 An agent knows something if it is true in all situations matching its current
 view.
 Our work thus has strong parallels with the classic view-based account
 of knowledge of 
\begin_inset LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

, but grounded in the situation calculus and with an emphasis on regression.
\end_layout

\begin_layout Standard
Decoupling knowledge in this manner makes it easy to express various degrees
 of observability of actions, from public actions through to actions that
 are completely hidden.
 This section is a greatly expanded version of our conference paper on the
 same topic, and stands as a significant new account of knowledge in its
 own right 
\begin_inset LatexCommand citep
key "kelly07sc_know_obs"

\end_inset

.
\end_layout

\begin_layout Standard
The main challenge we overcome in this section is developing regression
 rules that can handle arbitrarily long sequences of hidden actions.
 To ensure its knowledge is valid, an agent must reason about all future
 situations that are compatible with what it has observed.
 Such universal quantification over situation terms requires a second-order
 induction axiom, which the standard regression operator cannot handle.

\emph on
 
\emph default
In previous work we have developed the persistence condition operator to
 support a limited form of universally quantified query 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 Using this operator to augment the regression techniques developed by 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, we maintain their elegant solution to the frame problem while handling
 arbitrarily long sequences of hidden actions.
\end_layout

\begin_layout Standard
Further demonstrating the power of our approach, we show how the new regression
 rules can be applied using an agent's individual view, rather than requiring
 a full situation term.
 Agents can thus use our techniques to reason about their own knowledge
 using only their local information, making the formalism suitable both
 for reasoning 
\emph on
about
\emph default
, and reasoning 
\emph on
in
\emph default
,
\emph on
 
\emph default
rich multi-agent domains.
\end_layout

\begin_layout Subsection*
Complex Epistemic Modalities
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sec:Complex-Epistemic-Modalities"

\end_inset

 builds on our account of individual knowledge by introducing complex group-leve
l epistemic modalities.
 The primary motivation is a formal account of common knowledge that is
 compatible with the use of regression, but achieving this requires a much
 more general formalism.
 This section is an expanded version of our conference paper on the topic
 
\begin_inset LatexCommand citep
key "kelly08complex_epistemic_modalities"

\end_inset

, modified to incorporate support for hidden actions.
\end_layout

\begin_layout Standard
Simple group-level modalities such as 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 can be expressed as finite combinations of individual-level knowledge operators
, but common knowledge is infinitary and cannot be handled in this way.
 To avoid introducing it via a separate second-order axiom and thus forgoing
 regression as a reasoning tool, we must overcome a fundamental expressivity
 limitation:
\end_layout

\begin_layout Quote
epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone
\emph on
 
\begin_inset LatexCommand citep
key "baltag98pa_ck"

\end_inset

.
\end_layout

\begin_layout Standard
Since regression operates by systematically removing action terms from a
 query, this means it is impossible to express the regression of common
 knowledge using only the knowledge and common-knowledge operators.
\end_layout

\begin_layout Standard
To overcome this limitation, we take our cue from recent promising work
 in the related field of dynamic epistemic logic, with the main idea due
 to 
\begin_inset LatexCommand citet
key "vanBenthem06lcc"

\end_inset

: increase the expressive power of the epistemic language so it is strong
 enough to formulate a proper regression rule.
 They have developed the Logic of Communication and Change (henceforth 
\begin_inset Quotes eld
\end_inset

LCC
\begin_inset Quotes erd
\end_inset

) using the syntax of propositional dynamic logic to form epistemic modalities,
 and have shown that it allows reasoning about common knowledge with techniques
 akin to regression.
 We follow a similar approach in this paper and introduce complex epistemic
 modalities to the situation calculus.
 
\end_layout

\begin_layout Standard
Following the tradition of 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 we develop our formalism as a series of macro-expansions, with no changes
 to the underlying situation calculus theory.
 The language of first-order dynamic logic is used to construct complex
 epistemic paths, with the macro 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 expressing knowledge using such a path.
 Common knowledge between 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 is expressed in this syntax as 
\begin_inset Formula $\PKnows((A\cup B)^{*},\phi,s)$
\end_inset

, the unbounded iteration of the base knowledge operators for each agent.
 Regression is modified to treat 
\begin_inset Formula $\PKnows(\pi,\phi,do(c,s))$
\end_inset

 as a primitive fluent, producing an equivalent formula 
\begin_inset Formula $\PKnows(\Trn(\pi),\Reg(\phi),s)$
\end_inset

 where 
\begin_inset Formula $\Trn$
\end_inset

 is a new operator called the epistemic path regressor.
 
\end_layout

\begin_layout Standard
While this section naturally parallels the development of LCC, there are
 also substantial differences.
 LCC is built on modal logic and so handles only propositional, synchronous
 domains.
 The richer ontology of the situation calculus means our formalism must
 support first-order preconditions and effects, quantifying-in and de-dicto/de-r
e, and arbitrary sets of concurrent actions, while incorporating our new
 technique for handling hidden actions and remaining compatible with other
 extensions to the situation calculus.
 The macro-expansion approach, coupled with our rigorous observation-based
 semantics, allow our formalism to neatly capture all these aspects.
\end_layout

\begin_layout Standard
We demonstrate the effectiveness of our technique with an example of reasoning
 about common knowledge in a partially-observable domain, a first for the
 situation calculus.This paper thus contributes a rich multi-agent theory
 of knowledge and action in which complex group-level epistemic modalities
 are amenable to effective automated reasoning.
\end_layout

\begin_layout Section
The Multi-Agent Situation Calculus
\begin_inset LatexCommand label
name "sec:The-Multi-Agent-Situation"

\end_inset


\end_layout

\begin_layout Standard
Our work utilises the situation calculus 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 with multiple agents 
\begin_inset LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "reiter96sc_nat_conc"

\end_inset

, and we begin from the standard account of knowledge due to 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

.
 A brief overview is presented below.
 Readers familiar with the situation calculus should note: our generalisation
 of the 
\begin_inset Formula $Poss$
\end_inset

 fluent to action description predicates, our use of the single-step variant
 of the regression operator, and the material on the persistence condition
 meta-operator.
\end_layout

\begin_layout Standard
There are a wide range of related formalisms for reasoning about knowledge,
 action and change, which we do not directly consider in this paper.
 We find the notation and meta-theory of the situation calculus particularly
 suitable for expressing our main ideas.
 Moreover, the strong underlying similarities between the major action formalism
s should allow the these ideas to transcend the specifics of the situation
 calculus 
\begin_inset LatexCommand citep
key "thielscher06reconcile_sc_fc,thielscher07unifying_action_calculus,vanbentham07ml_sitcalc"

\end_inset

.
\end_layout

\begin_layout Subsection
Notation and Axioms
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change, with the initiating agent indicated by
 their first argument; 
\noun on
Concurrent
\noun default
 terms are sets of actions that occur simultaneously; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Concurrent\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\emph on
Fluents
\emph default
 are predicates or functions that represent properties of the world that
 may change between situations; they take a situation term as their final
 argument.
\end_layout

\begin_layout Standard
Throughout the paper we will present examples from a simple multi-agent
 domain, in which two agents Ann and Bob are attending a party.
 The location of the party (the fluent 
\begin_inset Formula $loc(s)$
\end_inset

) is either 
\begin_inset Formula $C$
\end_inset

 or 
\begin_inset Formula $D$
\end_inset

 but they do not know which, and they have just received an invitation telling
 them the location of the party.
 Each agent may read the invitation (the action 
\begin_inset Formula $read$
\end_inset

) and leave/enter the room (the actions 
\begin_inset Formula $leave$
\end_inset

 and 
\begin_inset Formula $enter$
\end_inset

) at any time.
 Some example formulae from this domain are: 
\begin_inset Quotes eld
\end_inset

Ann is in the room initially
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

Bob is not in the room after leaving it
\begin_inset Quotes erd
\end_inset

.
 Written formally:
\begin_inset Formula \begin{gather*}
InRoom(Ann,S_{0})\\
\neg InRoom(Bob,do(leave(Bob),S_{0}))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The dynamics of a particular domain are captured by a set of sentences called
 a 
\emph on
basic action theory
\emph default
.
 Queries about the behaviour of the world are posed as logical entailment
 queries relative to this theory.
\end_layout

\begin_layout DefinitionLbld
Basic\InsetSpace ~
Action\InsetSpace ~
Theory A basic action theory, denoted 
\begin_inset Formula $\Dt$
\end_inset

, is a set of situation calculus sentences (with a specific syntactic form
 outlined below) describing a particular dynamic world.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); unique names axioms for actions (
\begin_inset Formula $\Dt_{una}$
\end_inset

); action description axioms defining preconditions etc for each action
 (
\begin_inset Formula $\Dt_{ad}$
\end_inset

); successor state axioms describing how primitive fluents change between
 situations (
\begin_inset Formula $\Dt_{ssa}$
\end_inset

); and axioms describing the value of primitive fluents in the initial situation
 (
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{una}\cup\Dt_{ad}\cup\Dt_{ssa}\cup\Dt_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
These axioms must satisfy some simple consistency criteria to constitute
 a valid domain description 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 We assume an arbitrary, but fixed, basic action theory.
\end_layout

\begin_layout Standard
The 
\emph on
uniform formulae
\emph default
 can be thought of as properties of the state of the world.
 They are basically logical combinations of fluents referring to a common
 situation term.
 For the moment we restrict ourselves to 
\emph on
objective
\emph default
 uniform formulae; the complete definition includes statements about knowledge
 and will be introduced in the next section.
\end_layout

\begin_layout DefinitionLbld
Objective\InsetSpace ~
Uniform\InsetSpace ~
Formulae Let 
\begin_inset Formula $s$
\end_inset

 be a fixed situation term, 
\begin_inset Formula $F$
\end_inset

 an arbitrary fluent, 
\begin_inset Formula $\vars{x}$
\end_inset

 a vector of terms mentioning no situation term other than 
\begin_inset Formula $s$
\end_inset

, and 
\begin_inset Formula $y$
\end_inset

 a variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the objective formulae uniform in 
\begin_inset Formula $s$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists y:\phi\,|\,\forall y:\phi\]

\end_inset


\end_layout

\begin_layout Standard
The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout this paper to refer to an arbitrary uniform formula.
 Since they represent properties of the world, it is often useful to evaluate
 uniform formulae at several different situation terms.
 We will frequently suppress the situation term in 
\begin_inset Formula $\phi$
\end_inset

 to simplify the presentation.
 The notation 
\begin_inset Formula $\phi[s']$
\end_inset

 represents a uniform formula with the particular situation 
\begin_inset Formula $s'$
\end_inset

 inserted into all its fluents, while 
\begin_inset Formula $\phi^{-1}$
\end_inset

 represents a uniform formula with the situation argument removed from all
 its fluents.
\newpage

\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{una}$
\end_inset

 restricts action terms to a finite number of action types, and ensures
 that actions with different types or different arguments are in fact different.
 The function 
\begin_inset Formula $actor(a)$
\end_inset

 gives the agent performing an action, which is always the action's first
 argument.
\newline

\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 contains one 
\emph on
successor state axiom
\emph default
 for each primitive fluent in the domain, providing a monotonic solution
 to the frame problem for that fluent.
 These axioms have the following general form
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow standard naming conventions for the situation calculus: lower-case
 roman names indicate variables, and free variables are implicitly universally
 quantified at the outermost scope
\end_layout

\end_inset

: 
\begin_inset Formula \[
F(\vars{x},do(c,s))\equiv\Phi_{F}^{+}(\vars{x},c,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi_{F}^{+}$
\end_inset

 and 
\begin_inset Formula $\Phi_{F}^{-}$
\end_inset

 are formulae uniform in 
\begin_inset Formula $s$
\end_inset

.
 This may be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after performing 
\begin_inset Formula $c$
\end_inset

 if 
\begin_inset Formula $c$
\end_inset

 made it true, or it was previously true and 
\begin_inset Formula $c$
\end_inset

 did not make it false
\begin_inset Quotes erd
\end_inset

.
\newline

\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 generalises the standard 
\emph on
action precondition axioms
\emph default
 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 to define fluents describing various aspects of the performance of an action,
 which we call 
\emph on
action description predicates
\emph default
.
 The predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 is the canonical example, indicating whether it is possible to perform
 an action in a given situation.
 For example, it is only possible for an agent to leave the room if they
 are actually in it:
\begin_inset Formula \[
Poss(leave(agt),s)\equiv InRoom(agt,s)\]

\end_inset


\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains one axiom of the form 
\begin_inset Formula $Poss(A(\vars{x}),s)\equiv\Phi_{Poss}^{A}(\vars{x},s)$
\end_inset

 for each type of action 
\begin_inset Formula $A$
\end_inset

.
 These are combined into a generalised 
\begin_inset Formula $Poss$
\end_inset

 axiom for sets of concurrent actions, which in its simplest form is just:
\begin_inset Formula \[
Poss(c,s)\equiv c\neq\{\}\,\wedge\,\forall a\in c:\, Poss(a,s)\]

\end_inset

Note that it is never possible to perform an empty set of actions.
 In more complex domains actions may interact, so that they cannot be performed
 concurrently even if possible individually.
 We simply assume 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains an appropriate axiomatisation of such interaction; 
\begin_inset LatexCommand citet
key "pinto94temporal"

\end_inset

 provides a full discussion of this issue;
\end_layout

\begin_layout Standard
In principle any number of predicates and functions can be defined in this
 way, and we will use the meta-variable 
\begin_inset Formula $\alpha$
\end_inset

 to represent an arbitrary action description predicate.
 Some examples include the sensing-result function 
\begin_inset Formula $SR(a,s)$
\end_inset

 of Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Sensing"

\end_inset

 and the observability predicate 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 of Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Observation"

\end_inset

.
\end_layout

\begin_layout Standard
We assume that these definitions are finitely enumerable and well-founded,
 allowing them to be expanded into primitive fluents even when they refer
 to an action variable.
 For example, we assume that 
\begin_inset Formula $Poss(a,s)$
\end_inset

 can be replaced by an enumeration over action types such as the following:
\begin_inset Formula \[
Poss(a,s)\equiv\,\, a=A_{1}(\vars{x}_{1})\wedge\Phi_{Poss}^{A_{1}}(\vars{x}_{1},s)\,\vee\,\dots\,\vee a=A_{n}(\vars{x}_{n})\wedge\Phi_{Poss}^{A_{n}}(\vars{x}_{n},s)\]

\end_inset


\end_layout

\begin_layout Standard

\newpage
The set 
\begin_inset Formula $\Sigma$
\end_inset

 ensures that situations form a branching-time account of the world state.
 There are initial situations identified by the predicate 
\begin_inset Formula $Init(s)$
\end_inset

, and a distinguished initial situation 
\begin_inset Formula $S_{0}$
\end_inset

 called the 
\emph on
actual 
\emph default
initial situation.
 Other initial situations are used to represent the agents' epistemic uncertaint
y, and will be discussed in the following section.
 Situations in general form a tree structure with an initial situation at
 the root and 
\begin_inset Formula $do(c,s)$
\end_inset

 constructing the successor situation resulting when the actions 
\begin_inset Formula $c$
\end_inset

 are performed in 
\begin_inset Formula $s$
\end_inset

.
 We abbreviate the performance of several successive actions by writing:
\begin_inset Formula \[
do([c_{1},\dots,c_{n}],s)\,\isdef\, do(c_{n},do(\dots,do(c_{1},s)))\]

\end_inset


\end_layout

\begin_layout Standard
The relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 indicates that 
\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset

 and is defined as follows:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg(s'\sqsubset s)\\
s\sqsubset do(c,s')\equiv s\sqsubseteq s'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 There is also a second-order induction axiom asserting that all situations
 must be constructed in this way, which is needed to prove statements that
 universally quantify over situations
\end_layout

\begin_layout Standard
This notation for 
\begin_inset Quotes eld
\end_inset

in the future of
\begin_inset Quotes erd
\end_inset

 can be extended to consider only those futures in which all actions satisfy
 a particular action description predicate.
 We include a relation 
\begin_inset Formula $<_{\alpha}$
\end_inset

 for each action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, with the following definitions:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg\left(s'<_{\alpha}s\right)\\
s<_{\alpha}do(c,s')\equiv s\leq_{\alpha}s'\wedge\alpha(c,s')\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
legal situations
\emph default
 are those in which every action was possible to perform in the preceding
 situation.
 These are of fundamental importance, as they are the only situations that
 could be reached in the real world.
 The 
\emph on
root
\emph default
 of a situation is the initial situation from which it was constructed:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\, root(s)=s\\
root(do(c,s))=root(s)\\
Legal(s)\,\equiv\, root(s)\leq_{Poss}s\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 describes the actual state of the world before any actions are performed.
 It is a collection of sentences of the form 
\begin_inset Formula $\phi[S_{0}]$
\end_inset

 stating what holds in the actual initial situation.
 It also defines the initial knowledge of each agent, as described in the
 next section.
\end_layout

\begin_layout Subsection
Knowledge and Sensing
\begin_inset LatexCommand label
name "sub:Knowledge-and-Sensing"

\end_inset


\end_layout

\begin_layout Standard
Epistemic reasoning was first introduced to the situation calculus by 
\begin_inset LatexCommand citet
key "moore80know_act"

\end_inset

, and formalised extensively by 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

 whose paper is now the canonical reference for these techniques.
 Their work has been extended to include concurrent actions 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

 and multiple agents 
\begin_inset LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

.
 We further extend this family of techniques in this paper.
\end_layout

\begin_layout Standard
The semantics of knowledge are based on a reification of the 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 semantics of modal logic, using situation terms rather than abstract worlds.
 A special fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 The macro 
\begin_inset Formula $\Knows$
\end_inset

 is then defined as a shorthand for the standard possible-worlds definition
 of knowledge, stating that an agent knows 
\begin_inset Formula $\phi$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 is true in all situations considered possible: 
\begin_inset Formula \begin{equation}
\Knows(agt,\phi,s)\isdef\forall s':\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}

\end_inset

 
\end_layout

\begin_layout Standard
Readers familiar with modal logic will recognise 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 as the situation calculus analogue of the modal reachability relation 
\begin_inset Formula $K_{agt}$
\end_inset

, and the macro 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 as the equivalent of the modal box operator 
\begin_inset Formula $[K_{agt}]\phi$
\end_inset

.
\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 specify a special fluent 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 that is used to model the initial epistemic uncertainty of the agents,
 with 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 containing sentences of the form 
\begin_inset Formula $\KnowsZ(agt,\phi,S_{0})$
\end_inset

 to specify what is initially known
\begin_inset Foot
status collapsed

\begin_layout Standard
The standard account does not require a separate 
\begin_inset Formula $K_{0}$
\end_inset

 fluent, as evidenced by equation 
\begin_inset LatexCommand eqref
reference "eq:k_s0_standard"

\end_inset

.
 It is required when incorporating hidden actions, so we introduce it now
 to maintain consistency.
 
\end_layout

\end_inset

:
\begin_inset Formula \begin{gather*}
K_{0}(agt,s',s)\,\rightarrow Init(s)\wedge Init(s')\\
\KnowsZ(agt,\phi,s)\isdef\forall s':\, K_{0}(agt,s',s')\rightarrow\phi[s']\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The action description function 
\begin_inset Formula $SR(a,s)$
\end_inset

 specifies the sensing result returned by action 
\begin_inset Formula $a$
\end_inset

 when executed in situation 
\begin_inset Formula $s$
\end_inset

.
 For non-sensing actions the value of 
\begin_inset Formula $SR$
\end_inset

 is set to an arbitrary constant.
\end_layout

\begin_layout Standard
The dynamics of knowledge are then specified by an additional set of axioms,
 which we will denote 
\begin_inset Formula $\Dt_{K}$
\end_inset

.
 In the standard account of knowledge 
\begin_inset Formula $\Dt_{K}$
\end_inset

 contains the following axioms:
\begin_inset Formula \begin{equation}
Init(s)\rightarrow\left(K(agt,s',s)\,\equiv\, K_{0}(agt,s',s)\right)\label{eq:k_s0_standard}\end{equation}

\end_inset


\begin_inset Formula \begin{align}
K(agt,s'',do(c,s))\equiv\exists s': & \, s''=do(c,s')\,\wedge K(agt,s',s)\wedge Poss(c,s')\nonumber \\
 & \wedge\,\forall a\in c:\,\left(actor(a)=agt\,\rightarrow\, SR(a,s)=SR(a,s')\right)\label{eq:k_ssa_standard}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Equation 
\begin_inset LatexCommand eqref
reference "eq:k_s0_standard"

\end_inset

 ensures that the agents begin with their knowledge as specified by 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

.
 Equation 
\begin_inset LatexCommand eqref
reference "eq:k_ssa_standard"

\end_inset

 takes the form of a standard successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent.
 It ensures that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(c,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing the same actions 
\begin_inset Formula $c$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is considered a possible alternative to 
\begin_inset Formula $s$
\end_inset

.
 It must furthermore have been possible to perform those actions in 
\begin_inset Formula $s'$
\end_inset

, and the sensing results must match for each action that was carried out
 by the agent in question.
 Thus an agent's knowledge after the occurrence of an action is completely
 determined by the combination of its knowledge before the action, and the
 sensing results from the action.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K}^{std}$
\end_inset

 the axioms of the standard account of knowledge due to 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, as detailed in equations (
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

) above.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard
We can now present the complete definition of a uniform formula, which may
 include both action description predicates
\begin_inset Foot
status collapsed

\begin_layout Standard
This differs from the standard definition, which does not permit action
 description predicates 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 We include them to simplify notation throughout the paper.
 This is purely a cosmetic change, since we assume that action description
 predicates can always be expanded into a finite combination of primitive
 fluents.
\end_layout

\end_inset

 and knowledge expressions.
\end_layout

\begin_layout DefinitionLbld
Uniform\InsetSpace ~
Formulae Let 
\begin_inset Formula $s$
\end_inset

 be a fixed situation term, 
\begin_inset Formula $F$
\end_inset

 a primitive fluent, 
\begin_inset Formula $\alpha$
\end_inset

 an action description predicate, 
\begin_inset Formula $\vars{x}$
\end_inset

 a vector of terms mentioning no situation term other than 
\begin_inset Formula $s$
\end_inset

, and 
\begin_inset Formula $y$
\end_inset

 a variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the formulae uniform in 
\begin_inset Formula $s$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{x},s)\,|\,\alpha(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists y:\phi\,|\,\forall y:\phi\,|\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
While powerful, this knowledge-representation formalism has an important
 limitation: it is fundamentally 
\emph on
synchronous.
 
\emph default
Each agent is assumed to have full knowledge of all actions that have occurred
 - in other words, all actions are public.
 While suitable for some domains, there are clearly many multi-agent domains
 where achieving total awareness of actions would be infeasible.
 A major contribution of this paper is a more flexible formalism for knowledge
 that can be applied to a much wider range of domains.
\end_layout

\begin_layout Subsection
Reasoning and Regression
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 These are generally based on syntactic manipulation of a query into a form
 that is more amenable to reasoning - for example, because it can be proven
 without using some of the axioms from 
\begin_inset Formula $\Dt$
\end_inset

.
\end_layout

\begin_layout Standard
In the general case, answering a query about a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 is a theorem-proving task in second-order logic (denoted SOL) due to the
 induction axiom included in the foundational axioms.
 This is clearly problematic for effective automated reasoning, but fortunately
 there exist particular syntactic forms for which some of the axioms in
 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 In particular, queries about the initial situation can be answered using
 only first-order logic (FOL) and a limited set of axioms:
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\phi[S_{0}]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{una}\models_{FOL}\phi[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Since the axioms 
\begin_inset Formula $\Dt_{S_{0}}\cup\Dt_{una}$
\end_inset

 often satisfy the closed-world assumption, provers such as Prolog can be
 employed to handle this type of query quite effectively.
 Effective reasoning depends on transforming queries into more easily-handled
 forms such as this.
 
\newline

\end_layout

\begin_layout Standard
The principle tool for effective reasoning in the situation calculus is
 the regression meta-operator 
\begin_inset Formula $\Reg_{\Dt}$
\end_inset

 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

, a syntactic manipulation that can transform a formula uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into an equivalent formula that is uniform in 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\phi[do(c,s)]\equiv\Reg_{\Dt}(\phi[do(c,s)])[s]\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\Dt$
\end_inset

 is fixed, we drop the subscript and simply write 
\begin_inset Formula $\Reg$
\end_inset

 for regression.
 Its operation is defined by a set of 
\emph on
regression rules
\emph default
 such as those shown below:
\begin_inset Formula \begin{align*}
\Reg(\phi_{1}\wedge\phi_{2})\isdef & \,\,\,\Reg(\phi_{1})\wedge\Reg(\phi_{2})\\
\Reg(Poss(a,s))\isdef & \,\,\, a=A{}_{1}(\vars{x}_{1})\wedge\Reg(\Phi_{Poss}^{A_{1}}(\vars{x}_{1},s))\,\vee\,\dots\,\vee\, a=A_{n}(\vars{x}_{n})\wedge\Reg(\Phi_{Poss}^{A_{n}}(\vars{x}_{n},s))\\
\Reg(F(\vars{x},do(c,s)))\isdef & \,\,\,\Phi_{F}^{+}(\vars{x},c,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},c,s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Each application of the regression operator replaces action description
 predicates with their definitions from 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and primitive fluents with their successor state axioms from 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

, 
\begin_inset Quotes eld
\end_inset

unwinding
\begin_inset Quotes erd
\end_inset

 a single action from each situation term in the query.
\end_layout

\begin_layout Standard
Repeated applications of this operator, denoted by 
\begin_inset Formula $\Reg^{*}$
\end_inset

, can transform a query about some future situation into a query about the
 initial situation only, which is much easier to answer.
 The axioms 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 are essentially 
\begin_inset Quotes eld
\end_inset

compiled into
\begin_inset Quotes erd
\end_inset

 the query.
 The trade-off is that the length of the regressed query may be exponential
 in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice 
\begin_inset LatexCommand citep
key "levesque97golog,pirri99contributions_sitcalc"

\end_inset

.
\end_layout

\begin_layout Standard
When dealing with situation-suppressed uniform formulae, we will use a two-argum
ent operator 
\begin_inset Formula $\Reg(\phi,c)$
\end_inset

 to indicate the regression of 
\begin_inset Formula $\phi$
\end_inset

 over the action 
\begin_inset Formula $c$
\end_inset

.
 It should be read as a shorthand for 
\begin_inset Formula $\Reg(\phi[do(c,s)])^{-1}$
\end_inset

.
\newline

\end_layout

\begin_layout Standard
A key contribution of 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 was showing how to apply the regression operator to formulae containing
 the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, allowing it to be treated syntactically as if it were a primitive
 fluent.
 This means that epistemic queries can be approached using standard reasoning
 techniques of the situation calculus.
 Although we have changed the notation somewhat to foreshadow the techniques
 we will develop in Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

, their definition operates as follows.
 First, define the 
\emph on
results
\emph default
 of a concurrent action to be the set of 
\begin_inset Formula $action\#result$
\end_inset

 pairs for all primitive actions perform by the agent in question:
\begin_inset Formula \[
\mathbf{res}(agt,c,s)\isdef\{a\#SR(a,s)\,\,|\,\, a\in c\,\wedge\, actor(a)=agt\}\]

\end_inset


\end_layout

\begin_layout Standard
This definition is then used to formulate a regression rule as follows:
\begin_inset Formula \begin{multline}
\Reg(\Knows(agt,\phi,do(c,s))\isdef\\
\exists y:\, y=\mathbf{res}(agt,c,s)\,\wedge\Knows(agt,\left[Poss(c)\wedge\mathbf{res}(agt,c)=y\right]\rightarrow\Reg(\phi[do(c,s)]),s)\label{eq:reg_k_std}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
This works by collecting the sensing results from each action performed
 by the agent into the set 
\begin_inset Formula $y$
\end_inset

, then ensuring matching sensing results in every situation considered possible.
 It expresses the knowledge of the agent after a concurrent action in terms
 of what it knew before the action, along with the information returned
 by the action.
 This technique relies heavily on the fact that all actions are public,
 since it requires every agent's knowledge to be updated in response to
 every action.
\end_layout

\begin_layout Standard
Repeated applications of 
\begin_inset Formula $\Reg$
\end_inset

 can thus transform a knowledge query into one that is uniform in the initial
 situation.
 While it would be valid to then expand the 
\begin_inset Formula $\Knows$
\end_inset

 macros and handle the query using first-order logic, in practice the reasoning
 procedure would leave 
\begin_inset Formula $\Knows$
\end_inset

 intact and use a specialised prover based on modal logic.
\end_layout

\begin_layout Standard
It is possible to formulate an alternate successor state axiom for knowledge
 that does not assume all actions are public, such as that of 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

.
 Such formulations invariably require universal quantification over situation
 terms, to account for arbitrarily-long sequences of hidden actions.
 This is incompatible with regression rules like the above, and these formulatio
ns offer no reasoning procedure other than general second-order theorem
 proving.
 By utilising a new reasoning technique called the 
\begin_inset Quotes eld
\end_inset

persistence condition
\begin_inset Quotes erd
\end_inset

 to reason about universal quantification over situation terms, our work
 is the first to provide an account of knowledge with hidden actions while
 maintaining regression in the style presented above as an effective reasoning
 tool.
\end_layout

\begin_layout Subsection
Property Persistence and the Persistence Condition
\end_layout

\begin_layout Standard
Queries that universally quantify over situation terms are often in a simple
 syntactic form called 
\emph on
property persistence
\emph default
 queries 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 Such queries assert that a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 holds in a given situation, and will continue to hold as long as all future
 actions satisfy some action description predicate 
\begin_inset Formula $\alpha$
\end_inset

: 
\begin_inset Formula \[
\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
We have developed the 
\emph on
persistence condition
\emph default
 meta-operator 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 to handle such queries more effectively 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 It produces a uniform formula such that:
\begin_inset Formula \[
\Dt\,\models\,\Pst_{\Dt}(\phi,\alpha)[s]\,\equiv\,\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
As with regression, we will use the simpler notation 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 and leave 
\begin_inset Formula $\Dt$
\end_inset

 implicit.
 Since the persistence condition is used to replace a second-order induction
 axiom, 
\begin_inset Formula $\Pst$
\end_inset

 is actually a fixpoint calculation and it therefore requires some theorem
 proving.
 This is in contrast to the regression operator, which is a purely syntactic
 transformation.
 We briefly describe the operation of 
\begin_inset Formula $\Pst$
\end_inset

 below since we will need some of these details for a later proof; for full
 details consult our previous work 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
\end_layout

\begin_layout Standard
First, the one-step-persistence operator 
\begin_inset Formula $\Pst^{1}$
\end_inset

 is defined to assert that 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate successors:
\begin_inset Formula \[
\Pst^{1}(\phi,\alpha)[s]\,\isdef\,\phi[s]\wedge\forall c:\,\alpha(c,s)\rightarrow\Reg(\phi,c)[s]\]

\end_inset


\end_layout

\begin_layout Standard
Repeated application asserts persistence after greater numbers of actions:
\begin_inset Formula \[
\Pst^{n}(\phi,\alpha)\,\isdef\,\Pst^{1}(\Pst^{n-1}(\phi,\alpha),\alpha)\]

\end_inset

 
\end_layout

\begin_layout Standard
Intuitively 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 should be a fixpoint of 
\begin_inset Formula $\Pst^{1}(\phi,\alpha)$
\end_inset

, and indeed it can be shown that:
\begin_inset Formula \[
\mathcal{D}_{una}\,\models\,\Pst^{n}(\phi,\alpha)\,\rightarrow\,\Pst^{n+1}(\phi,\alpha)\,\,\,\,\,\,\mathrm{iff}\,\,\,\,\,\,\Dt-\Dt_{S_{0}}\,\models\,\Pst^{n}(\phi,\alpha)\,\equiv\,\Pst(\phi,\alpha)\]

\end_inset


\end_layout

\begin_layout Standard
Thus the calculation of 
\begin_inset Formula $\mathcal{P}(\phi,\alpha)$
\end_inset

 replaces a single second-order reasoning task with iterated first-order
 reasoning using only the unique names axioms.
 Our experience has shown this technique to be quite effective in practice
 thanks to the simple form of axioms in 
\begin_inset Formula $\Dt_{una}$
\end_inset

.
 Since 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 produces a uniform formula, it allows queries that universally quantify
 over situation terms to be reduced to a form that is compatible with traditiona
l regression techniques.
\end_layout

\begin_layout Section
Individual Knowledge with Hidden Actions
\begin_inset LatexCommand label
name "sec:Obs-Knowledge"

\end_inset


\end_layout

\begin_layout Standard
Existing accounts of knowledge in the situation calculus directly express
 the dynamics of knowledge update in terms of the actions that have occurred
 in the world, as seen in Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Sensing"

\end_inset

.
 This works well when agents can be assumed to have full knowledge of the
 actions that have been performed, but quickly becomes cumbersome when trying
 to allow for hidden actions.
 In this section we first develop a principled axiomatisation of the 
\emph on
observability
\emph default
 of actions, then build a powerful yet succinct axiomatisation of knowledge
 upon it.
\end_layout

\begin_layout Standard
The basic idea is as follows: each occurrence of an action results in an
 agent making a set of 
\emph on
observations
\emph default
.
 Every situation then corresponds to a local 
\emph on
view
\emph default
 for that agent: the sequence of all its observations, excluding cases where
 the set of observations was empty.
 An agent then knows something if it is true in all situations matching
 its current view.
 Decoupling knowledge in this manner makes it easy to express various degrees
 of observability of actions, from public actions through to actions that
 are completely hidden.
 
\end_layout

\begin_layout Standard
To maintain the elegant solution to the frame problem for knowledge developed
 by 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, the regression rule of knowledge must be modified to account for arbitrarily
 long sequences of hidden actions.
 We present a new regression rule for knowledge that uses the persistence
 condition meta-operator to augment standard regression and perform the
 necessary inductive reasoning.
\end_layout

\begin_layout Standard
The direct coupling between knowledge and action also has undesirable implicatio
ns for situated agents reasoning about their own knowledge.
 As a consequence of using regression to handle knowledge queries, one can
 only reason about knowledge if one has a rooted situation term, as the
 required query is:
\begin_inset Formula \[
\Dt_{S_{0}}\cup\Dt_{una}\,\models\,\Reg^{*}(\Knows(agt,\phi,do([c_{1},\dots,c_{n}],S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
In asynchronous domains with hidden actions, where agents are not necessarily
 aware how many actions have been performed, the agents cannot use this
 formulation to reason about their own knowledge.
 Since knowledge is directly coupled to actions, and hence to situation
 terms, they cannot construct the appropriate query.
\end_layout

\begin_layout Standard
Further demonstrating the power of our approach, we show how the new regression
 rules can be applied using an agent's individual view, rather than requiring
 a full situation term.
 Agents can thus use our techniques to reason about their own knowledge
 using only their local information, making the formalism suitable both
 for reasoning 
\emph on
about
\emph default
, and reasoning 
\emph on
in
\emph default
,
\emph on
 
\emph default
rich multi-agent domains.
\end_layout

\begin_layout Subsection
Observations
\end_layout

\begin_layout Standard
To remove the direct coupling between knowledge and actions, we introduce
 an explicit notion of 
\emph on
observations
\emph default
.
 These are internal notifications that agents receive when an action has
 occurred.
 By expressing knowledge in terms of observations rather than actions, we
 ensure that agents can always reason about their own knowledge based on
 their own internal history of observations.
\end_layout

\begin_layout DefinitionLbld
Observations An observation is a notification event received by an agent,
 making it aware of some change in the state of the world.
 When an agent receives such a notification, we say that it 
\begin_inset Quotes eld
\end_inset

observed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

made
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

perceived
\begin_inset Quotes erd
\end_inset

 that observation.
\end_layout

\begin_layout Standard
Since the state of the world may only change in response to some action,
 observations can only be made as a result of some action.
 For simplicity we assume that agents perceive observations instantaneously,
 i.e.
 in the same instant as the actions that cause them.
\end_layout

\begin_layout Standard
Since 
\begin_inset Quotes eld
\end_inset

observation
\begin_inset Quotes erd
\end_inset

 is quite a loaded term, it is worth re-iterating this point: observations
 are instantaneous
\emph on
 events
\emph default
 generated internally by each agent in response to actions occurring in
 the world.
 We make no commitment as to how these events are generated, preferring
 a clean delineation between the task of observing change and the dynamics
 of knowledge update based on those observations.
 As with the work of 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, we consider change-awareness to be the responsibility of a lower-level
 component of the agent's control software.
\end_layout

\begin_layout Standard
To make this idea concrete, let us introduce an additional sort 
\noun on
Observations
\noun default
 to the language of the situation calculus, for the moment without any particula
r commitment towards what this sort will contain.
 We then add to 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 the action description function:
\begin_inset Formula \[
Obs(agt,c,s)=o\]

\end_inset

This function returns a set of observations, and should be read as 
\begin_inset Quotes eld
\end_inset

when actions 
\begin_inset Formula $c$
\end_inset

 are performed in situation 
\begin_inset Formula $s$
\end_inset

, agent 
\begin_inset Formula $agt$
\end_inset

 will perceive 
\begin_inset Formula $o$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Using a set of observations allows an agent to perceive any number of observati
ons in response to an action occurrence - perhaps several observations,
 perhaps none.
 We write 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

 for the case where an agent makes no observations, i.e.
 the actions 
\begin_inset Formula $c$
\end_inset

 are completely hidden.
 
\end_layout

\begin_layout Standard
The concept of a 
\emph on
view
\emph default
 follows naturally - it is the sequence of all the observations made by
 an agent as the world has evolved.
 
\end_layout

\begin_layout DefinitionLbld
Views An agent's view in a given situation 
\begin_inset Formula $\mathrm{s}$
\end_inset

 is the corresponding sequence of observations made by the agent as a result
 of each action in 
\begin_inset Formula $\mathrm{s}$
\end_inset

, excluding those actions for which no observations were made.
\end_layout

\begin_layout Standard
We introduce another sort 
\noun on
Views
\noun default
 consisting of sequences of sets of observations, with 
\begin_inset Formula $\epsilon$
\end_inset

 being the empty sequence and the functional fluent 
\begin_inset Formula $View$
\end_inset

 giving the history of observations associated with a particular situation:
\begin_inset Formula \begin{align}
Init(s)\,\rightarrow & \, View(agt,s)=\epsilon\nonumber \\
Obs(agt,a,s)=\{\}\,\rightarrow & \, View(agt,do(a,s))=View(agt,s)\nonumber \\
Obs(agt,a,s)\neq\{\}\,\rightarrow & \, View(agt,do(a,s))=Obs(agt,a,s)\cdot View(agt,s)\label{eq:view_defn}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Observations and views can be seen as localised analogues of actions and
 situations respectively.
 An action is a global event that causes the state of the world to change,
 while an observation is an internal event that causes an agent's knowledge
 of the state of the world to change.
 Similarly, a situation represents a complete, global history of all the
 actions that have occurred in the world, while a view is an agent's local
 history of all the observations it has made.
 The situation is an omniscient perspective on the world, the view a local
 perspective.
 As we shall see, this distinction is fundamental to developing a truly
 general multi-agent semantics for knowledge.
\end_layout

\begin_layout Subsection
Knowledge and Observation
\begin_inset LatexCommand label
name "sub:Knowledge-and-Observation"

\end_inset


\end_layout

\begin_layout Standard
It is a basic tenet of epistemic reasoning that an agent's knowledge at
 any particular time must depend solely on its local history: the knowledge
 that it started out with combined with the observations it has made since
 then 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
 Given an explicit account of the observations made by each agent, the required
 semantics of the 
\begin_inset Formula $K$
\end_inset

 relation are clear: 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 must hold whenever 
\begin_inset Formula $s'$
\end_inset

 is legal, both 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 would result in the same view for the agent, and 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 are rooted at 
\begin_inset Formula $K$
\end_inset

-related initial situations:
\begin_inset Formula \begin{equation}
K(agt,s',s)\equiv K(root(s'),root(s))\wedge Legal(s')\wedge View(agt,s')=View(agt,s)\label{eq:k-desired}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
While a wonderfully succinct definition of how knowledge should behave,
 this formulation cannot be used directly in a basic action theory.
 The dynamics of fluent change must be specified by a successor state axiom,
 so we must formulate a successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent which enforces the above equivalence.
\end_layout

\begin_layout Standard
For notational convenience, let us first introduce an action description
 predicate 
\begin_inset Formula $\PbU$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

possible but unobservable
\begin_inset Quotes erd
\end_inset

) indicating that the actions 
\begin_inset Formula $c$
\end_inset

 are possible in 
\begin_inset Formula $s$
\end_inset

, but no observations will be made by 
\begin_inset Formula $agt$
\end_inset

 if they are performed:
\begin_inset Formula \begin{equation}
\PbU(agt,c,s)\,\equiv\, Poss(c,s)\wedge Obs(agt,c,s)=\{\}\label{eqn:PbU_defn}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
By stating that 
\begin_inset Formula $s\leq_{\PbU(agt)}s'$
\end_inset

 we assert that 
\begin_inset Formula $agt$
\end_inset

 would make no observations were the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
 This means that its view in both situations would be identical, so if it
 considers 
\begin_inset Formula $s$
\end_inset

 possible then it must also consider 
\begin_inset Formula $s'$
\end_inset

 possible.
 Following this intuition, we propose the following successor state axiom
 to capture the desired dynamics of the knowledge fluent:
\begin_inset Formula \begin{align}
K(agt,s'',do(c,s))\equiv & \left[\, Obs(agt,c,s)=\{\}\rightarrow K(agt,s'',s)\,\right]\nonumber \\
\wedge & \left[\, Obs(agt,c,s)\neq\{\}\rightarrow\exists c',s':\, Obs(agt,c',s')=Obs(agt,c,s)\right.\nonumber \\
 & \left.\,\,\,\,\,\,\,\,\wedge\, Poss(c',s')\wedge K(agt,s',s)\wedge do(c',s')\leq_{\PbU(agt)}s''\,\right]\label{eqn:new_k_ssa}\end{align}

\end_inset

 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $c$
\end_inset

 was totally unobservable, the agent's state of knowledge does not change.
 Otherwise, it considers possible any legal successor to a possible alternate
 situation 
\begin_inset Formula $s'$
\end_inset

 that can be brought about by an action 
\begin_inset Formula $c'$
\end_inset

 yielding identical observations.
 It also considers possible any future of such a situation in which is would
 make no further observations.
 To reiterate: unlike the standard successor state axiom from equation 
\begin_inset LatexCommand eqref
reference "eq:k_ssa_standard"

\end_inset

, our new formalism requires agents to consider any possible future situation
 in which they would make no further observations.
\end_layout

\begin_layout Standard
It remains to specify 
\begin_inset Formula $K$
\end_inset

 in the initial situation.
 The relation 
\begin_inset Formula $K_{0}$
\end_inset

 defines knowledge before 
\emph on
any
\emph default
 actions have occurred, but the agents must consider the possibility that
 some hidden actions have occurred.
 In other words, we must include situations where 
\begin_inset Formula $root(s)\leq_{\PbU(agt)}s$
\end_inset

 in the 
\begin_inset Formula $K$
\end_inset

-relation for initial situations.
 We therefore propose the following axiom:
\begin_inset Formula \begin{gather}
Init(s)\rightarrow\left[K(agt,s'',s)\equiv\exists s'\,.\, K_{0}(agt,s',s)\wedge s'\leq_{\PbU(agt)}s'')\right]\label{eqn:new_k_s0}\end{gather}

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K}^{obs}$
\end_inset

 the axioms for our new observation-based semantics for knowledge, as detailed
 in equations (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) above.
\end_layout

\begin_layout Standard
These axioms suffice to ensure that knowledge behaves as we require: two
 situations will be related by 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 if and only if they result in identical views for that agent, 
\begin_inset Formula $s'$
\end_inset

 is legal, and their root situations were initially related.
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:k_obs_equiv"

\end_inset

 For any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge View(agt,s'')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
For the
\series bold
 
\series default
\emph on
if
\emph default
 direction we establish each of the three conjuncts individually.
 The 
\begin_inset Formula $root$
\end_inset

 case is trivial since equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) always expresses 
\begin_inset Formula $K(s'',do(c,s))$
\end_inset

 in terms of 
\begin_inset Formula $K(s',s)$
\end_inset

.
 The 
\begin_inset Formula $Legal$
\end_inset

 case relies on the fact that 
\begin_inset Formula $\PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

, while the 
\begin_inset Formula $View$
\end_inset

 case relies on the fact that 
\begin_inset Formula $s\leq_{\PbU}s'\rightarrow View(s)=View(s')$
\end_inset

.
 For the 
\emph on
only-if
\emph default
 direction we show how to construct an 
\begin_inset Formula $s'$
\end_inset

 satisfying the 
\begin_inset Formula $\exists s'$
\end_inset

 parts of equations (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

).
\end_layout

\begin_layout Standard
Using this new formulation, an agent's knowledge is completely decoupled
 from the global notion of actions, instead depending only on the local
 information that it has observed.
 It remains to specify precisely what the 
\noun on
Observations
\noun default
 sort contains, and how the 
\begin_inset Formula $Obs()$
\end_inset

 function behaves.
 This will be the focus of the next subsection.
\end_layout

\begin_layout Subsection
Axiomatising Observations
\end_layout

\begin_layout Standard
Let us begin by considering again the standard account of knowledge due
 to 
\begin_inset LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

.
 Its basic assumption that 
\begin_inset Quotes eld
\end_inset

all agents are aware of all actions
\begin_inset Quotes erd
\end_inset

 may be rephrased as 
\begin_inset Quotes eld
\end_inset

when an action occurs, all agents will observe that action
\begin_inset Quotes erd
\end_inset

.
 Allowing the 
\noun on
Observations
\noun default
 sort to contain 
\noun on
Action
\noun default
 terms, this assumption is akin to the following axiom for the 
\begin_inset Formula $Obs()$
\end_inset

 function:
\begin_inset Formula \begin{equation}
a\in Obs(agt,c,s)\equiv a\in c\label{eq:ax_obs_std1}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
What about sensing information? We can extend the 
\noun on
Observations
\noun default
 sort to contain 
\begin_inset Formula $Action\#Result$
\end_inset

 pairs and axiomatise like so:
\begin_inset Formula \begin{equation}
a\#r\in Obs(agt,c,s)\equiv a\in c\wedge SR(a,s)=r\wedge actor(a)=agt\label{eq:ax_obs_std2}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Using these definitions, our new account of knowledge will behave identically
 to the standard account:
\end_layout

\begin_layout Theorem
Suppose 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) as definitions of the 
\begin_inset Formula $Obs()$
\end_inset

 function, then for any situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{std}\models K(agt,s',s)\,\,\,\,\mathrm{iff}\,\,\,\,\Dt\cup\Dt_{K}^{obs}\models K(agt,s',s)\]

\end_inset


\end_layout

\begin_layout Proof
Equations (
\begin_inset LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) mean 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

 cannot be empty for 
\begin_inset Formula $c\neq\{\}$
\end_inset

, so 
\begin_inset Formula $s=s'$
\end_inset

 iff 
\begin_inset Formula $s\leq_{\PbU(agt)}s'$
\end_inset

.
 Equations (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) then amount to simple transformations of equations (
\begin_inset LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

,
\begin_inset LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

) respectively, meaning that 
\begin_inset Formula $K$
\end_inset

 behaves the same under both theories.
\end_layout

\begin_layout Standard
We now discuss one straightforward way to generalise this for partial observabil
ity of actions.
 A new action description predicate 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 is used to indicate that agent 
\begin_inset Formula $agt$
\end_inset

 would observe action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 If 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 is false, then that action will be hidden.
 We can then formulate the 
\begin_inset Formula $Obs()$
\end_inset

 function according to:
\begin_inset Formula \[
a\in Obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
There is also a subtle limitation in the standard handling of sensing actions:
 only the agent performing a sensing action can be aware of its result.
 Such a restriction is common but certainly not universal.
 For example, if an agent waiting for a train activates a speaker to determine
 when it will arrive, the result of this sensing action would provide informatio
n to any other agent within earshot.
 To generalise the formalism, an analogous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 is used to indicate when sensing information is available to an agent.
 We then include bare action terms in an agent's observations when it observes
 the action but not its result, and 
\emph on

\begin_inset Formula $Action\#Result$
\end_inset


\emph default
 terms when it also senses the result:
\begin_inset Formula \begin{gather*}
a\in Obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\\
a\#r\in Obs(agt,c,s)\equiv a\in c\wedge SR(a,s)=r\wedge CanObs(agt,a,s)\wedge CanSense(agt,a,s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We feel that this formulation provides a good balance between simplicity
 and expressiveness; it allows the observability of actions to vary according
 to the state of the world, but provides agents with a complete description
 of each action that they are capable of observing.
 In Section 
\begin_inset LatexCommand ref
reference "sub:An-Illustrative-Example"

\end_inset

 we show how to use this formalism to model a domain in which agents can
 only observe actions performed in the same room as them.
 To show the flexibility of the observation-based approach, Section 
\begin_inset LatexCommand ref
reference "sub:Observing-Effects"

\end_inset

 outlines a more powerful axiomatisation of observations in which agents
 may know that some action has occurred without necessarily knowing precisely
 what the action was.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The final aspect of our new account of knowledge is to extend the techniques
 for effective reasoning in the situation calculus to handle the modified
 formalism.
 The appearance of 
\begin_inset Formula $\leq_{\PbU(agt)}$
\end_inset

 in equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) means that our new successor state axiom universally quantifies over situation
s, so standard regression techniques cannot be used.
 We must appeal to the persistence condition meta-operator to transform
 this quantification into a uniform formula, so that regression can be applied.
\end_layout

\begin_layout Standard
We propose the following as the regression rule for 
\begin_inset Formula $\Knows$
\end_inset

 under our formalism:
\begin_inset Formula \begin{align}
\Reg(\Knows(agt,\phi,do(c,s))\isdef\,\, & \exists o:\, Obs(agt,c,s)=o\nonumber \\
 & \wedge\,\left[o=\{\}\,\rightarrow\,\Knows(agt,\phi,s)\right]\nonumber \\
 & \wedge\,\left[o\neq\{\}\,\rightarrow\,\Knows(agt,\forall c':\, Obs(agt,c')=o\right.\nonumber \\
 & \,\,\,\,\,\,\,\,\,\,\,\wedge Poss(c')\rightarrow\left.\Reg(\Pst(\phi,\PbU(agt)),c'),s)\right]\label{eqn:R_do_c_s}\end{align}

\end_inset

 
\end_layout

\begin_layout Standard
Note the similarity to the standard regression rule for knowledge in equation
 
\begin_inset LatexCommand eqref
reference "eq:reg_k_std"

\end_inset

.
 New in our version are: the replacement of the 
\begin_inset Formula $\mathbf{res}$
\end_inset

 macro with a flexible definition of what the agent has observed; explicit
 handling of the case when the agent makes no observations; and use of the
 persistence condition to account for arbitrarily-long sequences of hidden
 actions.
\end_layout

\begin_layout Standard
As required for a regression rule, equation 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 reduces a knowledge query at 
\begin_inset Formula $do(c,s)$
\end_inset

 to a knowledge query at 
\begin_inset Formula $s$
\end_inset

.
 It is also intuitively appealing: to know that 
\begin_inset Formula $\phi$
\end_inset

 holds, the agent must know that in all situations that agree with its observati
ons, 
\begin_inset Formula $\phi$
\end_inset

 cannot become false without it making an observation - this is the meaning
 of 
\begin_inset Formula $\Pst(\phi,\PbU(agt))$
\end_inset

 in the above.
\end_layout

\begin_layout Standard
We must also specify the regression of 
\begin_inset Formula $\Knows$
\end_inset

 in the initial situation, as equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) also uses the 
\begin_inset Formula $\leq_{\PbU(agt)}$
\end_inset

 ordering.
 This clause produces an expression in 
\begin_inset Formula $\KnowsZ$
\end_inset

 at 
\begin_inset Formula $S_{0}$
\end_inset

, meaning that it can be handled by epistemic reasoning about the initial
 situation only:
\begin_inset Formula \begin{equation}
\Reg(\Knows(agt,\phi,S_{0}))\,\isdef\,\KnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\label{eqn:R_s0}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Using these regression rules, we can handle knowledge queries in our formalism
 using standard techniques for effective reasoning in the situation calculus.
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Reg_Knows"

\end_inset

Given a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 and a uniform formula 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\phi[do(c,s)]\equiv\Reg(\phi,c)[s]\]

\end_inset

 
\end_layout

\begin_layout ProofSketch
We need only consider the case of 
\begin_inset Formula $\phi=\Knows(agt,\phi,s)$
\end_inset

.
 In the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, we proceed by expanding the definition for 
\begin_inset Formula $\Knows$
\end_inset

 using our new successor state axiom for 
\begin_inset Formula $K$
\end_inset

, collecting sub-formulae that match the form of the 
\begin_inset Formula $\Knows$
\end_inset

 macro, and using regression and the persistence condition to render the
 resulting knowledge expressions uniform in 
\begin_inset Formula $s$
\end_inset

.
 In the base case, we apply the persistence condition to an expansion of
 
\begin_inset Formula $\Knows$
\end_inset

 at the initial situation to produce the desired result.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
While this reasoning method is suitable for modelling and simulation purposes,
 it would be unreasonable for a situated agent to ask 
\begin_inset Quotes eld
\end_inset

do I know 
\begin_inset Formula $\phi$
\end_inset

 in the current situation?
\begin_inset Quotes erd
\end_inset

 using the situation calculus query 
\begin_inset Formula $\Dt\models\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as it cannot be expected to have the full current situation 
\begin_inset Formula $s$
\end_inset

.
 However, it will have its current view 
\begin_inset Formula $v$
\end_inset

.
 We define knowledge with respect to a view as follows:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,v)\,\isdef\,\forall s:\, View(agt,s)=v\wedge root(s)=S_{0}\rightarrow\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
It is a straightforward consequence of Theorem 
\begin_inset LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 that this form of knowledge is equivalent to knowledge based on a situation
 term having that view and rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
 Modifying the regression rules in equations (
\begin_inset LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

,
\begin_inset LatexCommand ref
reference "eqn:R_s0"

\end_inset

) to handle formulae of this form is actually simpler than for regression
 over situations, as there are no empty observations in a view.
 The result is:
\begin_inset Formula \begin{align*}
\Reg(\mathbf{Knows}(agt,\phi,o\cdot v))\isdef\,\, & \mathbf{Knows}(agt,\forall c:\, Obs(agt,c)=o\\
 & \,\,\,\,\,\,\,\,\wedge Poss(c)\rightarrow\Reg(\Pst(\phi,\PbU(agt)),c),v)\\
\Reg(\mathbf{Knows}(agt,\phi,\epsilon))\isdef\,\, & \KnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Using regression in this way, an agent can reduce the query 
\begin_inset Formula $\Knows(agt,\phi,v)$
\end_inset

 to an equivalent query about its knowledge in the initial situation.
 Agents can thus reason about their own knowledge using only their local
 information.
 Our work makes it possible to include a situation calculus model in the
 implementation of a real-world multi-agent system, even when agents have
 only partial awareness of the actions being performed.
\end_layout

\begin_layout Standard
It is worth re-iterating that our regression rules are no longer straightforward
 syntactic transformations - rather, they involve a fixpoint calculation
 to generate 
\begin_inset Formula $\Pst(\phi,\PbU(agt))$
\end_inset

.
 Can this really be considered an effective reasoning technique? Our previous
 work on the persistence condition meta-operator 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

 discusses the advantages of this approach in detail.
 The primary advantage is that this form of reasoning can be performed at
 all, as the alternative is general second-order theorem proving.
\end_layout

\begin_layout Standard
Of course, the ultimate proof is in the implementation.
 We have implemented a preliminary version of our technique and used it
 to verify the examples found in the following section.
 The code is available as an electronic appendix to this paper.
\end_layout

\begin_layout Subsection
An Illustrative Example
\begin_inset LatexCommand label
name "sub:An-Illustrative-Example"

\end_inset


\end_layout

\begin_layout Standard
Consider again the example domain of the party invitation.
 The fluents of interest are the location of the party (the function 
\begin_inset Formula $loc$
\end_inset

) and whether each agent is in the room (the predicate 
\begin_inset Formula $InRoom$
\end_inset

).
 The action 
\begin_inset Formula $read$
\end_inset

 reads the invitation and returns the location of the party, while the non-sensi
ng actions 
\begin_inset Formula $enter$
\end_inset

 and 
\begin_inset Formula $leave$
\end_inset

 cause the agents to move in/out of the room.
 The 
\begin_inset Formula $read$
\end_inset

 action is only observed by agents who are in the room.
 This domain can be summarised by the following axioms:
\begin_inset Formula \begin{gather*}
loc(S_{0})=C\\
loc(do(c,s))=l\equiv loc(s)=l\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
InRoom(Ann,S_{0})\equiv InRoom(Bob,S_{0})\equiv true\\
InRoom(agt,do(c,s))\equiv enter(agt)\in c\,\vee\, InRoom(agt,s)\wedge leave(agt)\notin c\\
Poss(enter(agt),s)\equiv\neg InRoom(agt,s)\\
Poss(leave(agt),s)\equiv InRoom(agt,s)\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
Poss(read(agt),s)\equiv InRoom(agt,s)\\
SR(read(agt),s)=r\equiv r=loc(s)\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
\forall agt:\,\forall l:\,\neg\KnowsZ(agt,loc=l,S_{0})\\
\forall agt:\,\KnowsZ(agt,InRoom(Ann)\wedge InRoom(Bob),S_{0})\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
CanObs(agt,leave(agt'),s)\equiv CanObs(agt,enter(agt'),s)\equiv true\\
CanObs(agt,read(agt'),s)\equiv InRoom(agt',s)\\
CanSense(agt,read(agt'),s)\equiv agt=agt'\\
CanSense(agt,leave(agt'),s)\equiv CanSense(agt,enter(agt'),s)\equiv false\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The following are examples of knowledge queries that can be posed in our
 formalism, a brief explanation of their outcome, and a demonstration of
 how they can be answered using our new regression rules.
 Each has been verified by the preliminary implementation of our reasoning
 engine.
\newpage

\end_layout

\begin_layout Example
Initially, Ann doesn't know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\neg\exists l:\,\mathbf{Knows}(Ann,loc=l,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
It is given that 
\begin_inset Formula $\neg\exists l:\,\KnowsZ(Ann,loc=l,S_{0})$
\end_inset

, and the only way for Ann to learn such information is by performing a
 
\begin_inset Formula $read$
\end_inset

 action.
 Since such an action will always produce an observation, she cannot have
 learnt the party's location as a result of hidden actions and the example
 is entailed.
 Formally:
\begin_inset Formula \begin{align*}
\Reg(\neg\exists l:\,\mathbf{Knows}(Ann,loc=l,S_{0}))\,\Rightarrow\,\,\,\, & \neg\exists l:\,\KnowsZ(Ann,\Pst(loc=l,PbU(Ann)),S_{0})\\
\Pst(loc=l,PbU(Ann))\,\Rightarrow\,\,\,\, & loc=l\end{align*}

\end_inset


\end_layout

\begin_layout Standard
So the query reduces to:
\begin_inset Formula \[
\neg\exists l:\,\KnowsZ(Ann,loc=l,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Which is entailed by the domain.
\newline

\newline

\end_layout

\begin_layout Example
After reading the invitation, Bob will know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\Knows(Bob,loc=C,do(\{read(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
The sensing results of the 
\begin_inset Formula $read$
\end_inset

 action inform Bob of the location of the party.
 Since this location cannot change after any sequence of hidden actions,
 he can be sure of the party's location.
 Formally, using the fact that 
\begin_inset Formula $Obs(Bob,\{read(Bob)\},s)=\{read(Bob)\#loc(s)\}$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Reg(\Knows(Bob,loc=C,do(\{read(Bob)\},S_{0})))\,\Rightarrow\\
\exists o:\, Obs(Bob,\{read(Bob)\},S_{0})=o\,\wedge\,\\
\Knows(Bob,\forall c':\, Poss(c')\wedge Obs(Bob,c')=o\rightarrow\Reg(\Pst(loc=C,PbU(Bob)),c'),S_{0})\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\Reg(\Pst(loc=C,PbU(Bob)),c')\Rightarrow loc=c$
\end_inset

 and 
\begin_inset Formula $loc(S_{0})=C$
\end_inset

, this simplifies to:
\begin_inset Formula \[
\Knows(Bob,\forall c':\, Poss(c')\wedge Obs(Bob,c')=\{read(Bob)\#C\}\rightarrow loc=C,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Since the only possible value of 
\begin_inset Formula $c'$
\end_inset

 is 
\begin_inset Formula $\{read(Bob)\}$
\end_inset

, we can insert the definitions of 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Obs$
\end_inset

 to obtain:
\begin_inset Formula \[
\Knows(Bob,InRoom(Bob)\wedge loc=C\,\rightarrow\, loc=C,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
This tautology is clearly entailed by the domain.
\newline

\newpage

\end_layout

\begin_layout Example
Initially, Bob knows that Ann doesn't know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\mathbf{Knows}(Bob,\neg\exists l:\,\Knows(Ann,loc=l),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Ann could learn the location of the party by performing the 
\begin_inset Formula $read$
\end_inset

 action, but since Bob is in the room he would observe this action taking
 place.
 Since he has not observed it, he can conclude that Ann does not know the
 location of the party.
 Formally:
\begin_inset Formula \begin{multline*}
\Reg(\mathbf{Knows}(Bob,\neg\exists l:\,\Knows(Ann,loc=l),S_{0}))\,\Rightarrow\\
\KnowsZ(Bob,\Pst(\neg\exists l:\,\Knows(Ann,loc=l),PbU(Bob)),S_{0})\end{multline*}

\end_inset


\begin_inset Formula \begin{multline*}
\Pst(\neg\exists l:\,\Knows(Ann,loc=l),PbU(Bob))\,\Rightarrow\\
\neg\exists l:\,\Knows(Ann,loc=l)\wedge\left(InRoom(Bob)\,\vee\,\neg InRoom(Ann)\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
So the query reduces to:
\begin_inset Formula \[
\KnowsZ(Bob,\neg\exists l:\,\Knows(Ann,loc=l)\wedge\left(InRoom(Bob)\,\vee\,\neg InRoom(Ann)\right),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Which is entailed by the domain.
\newline

\newline

\end_layout

\begin_layout Example
After leaving, Bob won't know that Ann doesn't know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\mathbf{\neg Knows}(Bob,\neg\exists l:\,\Knows(Ann,loc=l),do(\{leave(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
Once Bob leaves the room, he would be unable to observe Ann reading the
 invitation.
 He must therefore consider it possible that she has read it, and may know
 the location of the party.
 Formally, we can use 
\begin_inset Formula $Obs(Bob,\{leave(Bob)\})=\{leave(Bob)\}$
\end_inset

 to regress the outer expression as follows:
\begin_inset Formula \begin{multline*}
\Reg(\neg\Knows(Bob,\phi,do(\{leave(Bob)\},S_{0})))\,\Rightarrow\\
\neg\Knows(Bob,InRoom(Bob)\rightarrow\Reg(\Pst(\phi,PbU(Bob)),\{leave(Bob)\}),S_{0})\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
For the inner expression, we have from the previous example:
\begin_inset Formula \begin{multline*}
\Pst(\neg\exists l:\,\Knows(Ann,loc=l),PbU(Bob))\,\Rightarrow\\
\neg\exists l:\,\Knows(Ann,loc=l)\wedge\left(InRoom(Bob)\,\vee\,\neg InRoom(Ann)\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
This expression is key: for Bob to know
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\neg\exists l:\Knows(Ann,loc=l)$
\end_inset

,
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 he must also know either that he is in the room (and will thus observe
 the 
\begin_inset Formula $read(Ann)$
\end_inset

 action if it occurs) or that Ann is not in the room (so the 
\begin_inset Formula $read(Ann)$
\end_inset

 action will not be possible).
 Otherwise, Ann could learn the location of the party without him making
 any further observations.
\end_layout

\begin_layout Standard
When we regress over the action 
\begin_inset Formula $\{leave(Bob)\}$
\end_inset

 then 
\begin_inset Formula $InRoom(Bob)$
\end_inset

 is made false:
\begin_inset Formula \begin{multline*}
\Reg(\Pst(\neg\exists l:\,\Knows(Ann,loc=l),PbU(Bob)),\{leave(Bob)\})\,\Rightarrow\\
\neg\exists l:\,\Knows(Ann,loc=l)\wedge\left(false\,\vee\,\neg InRoom(Ann)\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
And the entire expression can be simplified to:
\begin_inset Formula \[
\neg\Knows(Bob,InRoom(Bob)\rightarrow\neg\exists l:\,\Knows(Ann,loc=l)\wedge\neg InRoom(Ann),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Since Ann is known to be in the room, this expression will be entailed by
 the domain.
\end_layout

\begin_layout Subsection
Observing the Effects of Actions
\begin_inset LatexCommand label
name "sub:Observing-Effects"

\end_inset


\end_layout

\begin_layout Standard
In many domains it would be infeasible for an agent to observe a particular
 action occurring, but it may observe some of the effects of that action.
 For example, suppose that an agent monitors the state of a light in its
 environment, such that it notices it changing from dark to light.
 While it knows that 
\emph on
some
\emph default
 action must have occurred to produce that effect, it may not be sure precisely
 what action took place (e.g.
 precisely 
\emph on
who
\emph default
 turned on the light).
\end_layout

\begin_layout Standard
This can be modelled by further extending the 
\noun on
Observations
\noun default
 sort.
 Suppose that the observation term 
\begin_inset Formula $f_{\phi}$
\end_inset

 indicates that a particular property of the world 
\begin_inset Formula $\phi$
\end_inset

 has changed from false to true and (for simplicity) that this information
 would be available to all agents.
 The following could be used to include this information in an agent's observati
ons:
\begin_inset Formula \[
f_{\phi}\in Obs(agt,c,s)\equiv\neg\phi[s]\wedge\Reg(\phi,c)\]

\end_inset

 
\end_layout

\begin_layout Standard
Note that since 
\begin_inset Formula $Obs()$
\end_inset

 is an action description predicate, we must use regression to ensure that
 the right-hand side of this definition is uniform in 
\begin_inset Formula $s$
\end_inset

.
 Expanding on the example of the light, we might have an axiom like this:
\begin_inset Formula \[
lightCameOn\in Obs(agt,c,s)\equiv\neg lightIsOn(s)\wedge\exists agt':\, turnLightOn(agt')\in c\]

\end_inset


\end_layout

\begin_layout Standard
When the light is switched on, each agent's observation set will contain
 
\begin_inset Formula $lightCameOn$
\end_inset

, and they will know that this change has occurred without necessarily knowing
 the specific action responsible for the change.
 That this powerful new ability is a straightforward extension of our approach
 highlights the flexibility and robustness of the observation-based semantics.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
In this section, we have first developed a principled axiomatisation of
 the observability of actions, using the notion of observations and views
 as analogues of actions and situations that are localised to an individual
 agent.
 This terminology has been deliberately chosen to match similar concepts
 in other formalisations of knowledge, such as the well-known treatise of
 
\begin_inset LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

.
 By reifying these concepts as terms in the logic, we are able to give a
 succinct definition of the dynamics of the knowledge fluent and prove that
 its behaviour matches our intuitive expectations.
\end_layout

\begin_layout Standard
As an example of why this is important, consider one of the few existing
 formulations of knowledge in the situation calculus that allows for hidden
 actions, that of 
\begin_inset LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

.
 Their successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent is as follows:
\begin_inset Formula \begin{align*}
K(agt,s'',do(a,s))\equiv\,\,\, & \exists s':\, K(agt,s',s)\\
 & \wedge\,(actor(a)\neq agt\,\rightarrow\, s'\leq_{actor(a)\neq agt}s''))\\
 & \wedge\,(actor(a)=agt\,\rightarrow\,\exists s^{*}:\,\left[s'\leq_{actor(a)=agt}s^{*}\wedge\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\left.s''=do(a,s^{*})\wedge Poss(a,s^{*})\wedge sr(a,s)=sr(a,s^{*}))\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Standard
In this case agents are only aware of the actions that they themselves perform,
 and they consider possible an arbitrary sequence of hidden actions preceding
 each action of their own.
 However, this formulation has a subtle problem: an agent's knowledge can
 change in response to actions performed by others.
 Suppose that 
\begin_inset Formula $agt$
\end_inset

 has just performed action 
\begin_inset Formula $a_{1}$
\end_inset

, so the world is in situation 
\begin_inset Formula $do(a_{1},s)$
\end_inset

.
 Another agent then performs the action 
\begin_inset Formula $a_{2}$
\end_inset

, leaving the world in situation 
\begin_inset Formula $do(a_{2},do(a_{1},s))$
\end_inset

.
 Since it is not aware of the occurrence of 
\begin_inset Formula $a_{2}$
\end_inset

, the knowledge of 
\begin_inset Formula $agt$
\end_inset

 should be unchanged between these two situations.
 This is not the case under the formulation of 
\begin_inset LatexCommand citeauthor
key "Lesperance99sitcalc_approach"

\end_inset

.
 By explicitly formalising the notion of a view, our framework avoids such
 problems.
\end_layout

\begin_layout Standard
A further advantage of our explicit axiomatisation of observations is in
 establishing properties of the knowledge relation.
 A major theorem of 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 states that if the 
\begin_inset Formula $K$
\end_inset

-relation is reflexive, symmetric or transitive at the initial situation,
 then its has that property at every situation.
 In our formulation these are all simple corollaries of Theorem 
\begin_inset LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 and the reflexive, symmetric and transitive nature of the equality symbol.
\end_layout

\begin_layout Standard
We have demonstrated that our formalism is expressive enough to capture
 the standard account of knowledge based on public actions, as well as more
 complex formulations where the observability of actions depends on the
 state of the world.
 We have also demonstrated that despite allowing for arbitrarily-long sequences
 of hidden actions, our formalism still permits automated reasoning for
 handling knowledge queries, including a preliminary implementation of such
 a reasoning system.
\end_layout

\begin_layout Standard
Of course, the effectiveness of automated reasoning is now highly dependent
 on the effectiveness of calculating the persistence condition.
 Since this is a fixpoint calculation, it can be computationally expensive
 and even undecidable in very complex domains.
 But by factoring out the necessary inductive reasoning into a separate
 operator, it can now be studied and improved in isolation.
 We have already identified several classes of basic action theory in which
 the persistence condition can be calculated quite effectively, and our
 investigations in this area are ongoing; see the reference for details
 
\begin_inset LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
\end_layout

\begin_layout Standard
Our new observation-based semantics thus provides a powerful account of
 knowledge suitable both for reasoning 
\emph on
about
\emph default
, and for reasoning 
\emph on
in
\emph default
, asynchronous multi-agent domains.
\end_layout

\begin_layout Section
Complex Epistemic Modalities
\begin_inset LatexCommand label
name "sec:Complex-Epistemic-Modalities"

\end_inset


\end_layout

\begin_layout Standard
So far we have constructed a powerful new account of 
\emph on
individual 
\emph default
knowledge in rich multi-agent domains.
 To be truly useful in a multi-agent setting, our formalism must also support
 reasoning about group-level knowledge and, in particular, about common
 knowledge.
 The primary motivation for this section is a formal treatment of common
 knowledge within our framework, but as we shall see, this requires significant
 technical machinery capable of handling much more general epistemic modalities.
\end_layout

\begin_layout Subsection
Group-Level Epistemic Modalities
\end_layout

\begin_layout Standard
We briefly review the various group-level epistemic modalities commonly
 found in the literature; an excellent overview and discussion can be found
 in the work of 
\begin_inset LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

.
 Let 
\begin_inset Formula $G$
\end_inset

 be a finite group of agents.
 The basic group-level modality is 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

, which is defined as:
\begin_inset Formula \[
\EKnows(G,\phi,s)\isdef\,\forall agt\in G:\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $G$
\end_inset

 is a finite set, this can be written equivalently as a finite conjunction:
\begin_inset Formula \[
\mathbf{EKnows}(G,\phi,s)\,\isdef\,\bigwedge_{agt\in G}\,\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
To assert more complete knowledge by members of the group, one can say 
\begin_inset Quotes eld
\end_inset

everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 by nesting 
\begin_inset Formula $\mathbf{EKnows}$
\end_inset

 operators.
 In general:
\begin_inset Formula \begin{gather*}
\mathbf{EKnows}^{1}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\phi,s)\\
\mathbf{EKnows}^{n}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\mathbf{EKnows}^{n-1}(G,\phi),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The higher the value of 
\begin_inset Formula $n$
\end_inset

, the stronger an assertion is made about the knowledge of the group.
 The strongest group-level modality is 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Intuitively this indicates that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, and so on ad infinitum.
 Formally, it can be defined as the infinite conjunction:
\begin_inset Formula \[
\mathbf{CKnows}(G,\phi,s)\,\isdef\,\bigwedge_{n\in\mathbb{N}}\mathbf{EKnows}^{n}(G,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Equivalently, it can be defined as a fixpoint or transitive closure of the
 
\begin_inset Formula $\EKnows$
\end_inset

 relation.
 Common knowledge is an extremely powerful form of knowledge that has deep
 implications for coordinated group behaviour.
 For example, in the famous 
\begin_inset Quotes eld
\end_inset

Coordinated Attack
\begin_inset Quotes erd
\end_inset

 problem, the proof that the generals cannot coordinate an attack depends
 heavily on their inability to obtain common knowledge 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
\end_layout

\begin_layout Subsection
Reasoning about Common Knowledge
\end_layout

\begin_layout Standard
Existing treatments of common knowledge in the situation calculus and related
 literature specify it as the transitive closure of 
\begin_inset Formula $\EKnows$
\end_inset

 using an explicit second-order axiom 
\begin_inset LatexCommand citep
key "davis05fo_ma_theory,ghaderi07sc_joint_ability"

\end_inset

.
 While logically sound, this approach forgoes the use of regression as an
 effective reasoning technique.
 Indeed, reasoning in such formalisms requires a second-order theorem prover.
\end_layout

\begin_layout Standard
This difficulty in effectively handling common knowledge can be attributed
 to a famous expressivity result from the related field of dynamic epistemic
 logic:
\end_layout

\begin_layout Quote
Epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone 
\begin_inset LatexCommand citep
key "baltag98pa_ck"

\end_inset


\end_layout

\begin_layout Standard
In our terminology: given a formula 
\begin_inset Formula $\CKnows(G,\phi,do(c,s))$
\end_inset

, it is impossible in general to find an equivalent formula 
\begin_inset Formula $\CKnows(G,\psi,s)$
\end_inset

.
 It is thus impossible to formulate a regression rule for common knowledge
 using only the 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\CKnows$
\end_inset

 operators.
\end_layout

\begin_layout Standard
Given the deep similarities between the situation calculus and dynamic epistemic
 logic 
\begin_inset LatexCommand citep
key "vanbentham07ml_sitcalc"

\end_inset

, we can be confident that this expressivity limitation also holds in the
 situation calculus.
 To see why, consider again the successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent, which has the simplified general form:
\begin_inset Formula \[
K(do(c',s'),do(c,s))\,\equiv\, K(s',s)\wedge\Phi_{K}(c',s')\]

\end_inset


\end_layout

\begin_layout Standard
We could construct an analogous fluent 
\begin_inset Formula $E$
\end_inset

 that captures the 
\begin_inset Formula $\EKnows$
\end_inset

 relation, with a successor state axiom of the general form:
\begin_inset Formula \[
E(do(c',s'),do(c,s))\,\equiv\, E(s',s)\wedge\Phi_{E}(c',s')\]

\end_inset


\end_layout

\begin_layout Standard
Now consider constructing such a fluent for the 
\begin_inset Formula $\EKnows^{2}$
\end_inset

 relation.
 The general form for its successor state axiom would be:
\begin_inset Formula \begin{align*}
E^{2}(do(c',s'),do(c,s)) & \equiv\exists c'',s'':\, E(do(c'',s''),do(c,s))\wedge E(do(c',s'),do(c'',s''))\\
 & \Rightarrow\exists c'',s'':\, E(s'',s)\wedge E(s',s'')\wedge\Phi_{E}(c',s')\wedge\Phi_{E}(c'',s'')\\
 & \Rightarrow\exists c'',s'':\, E^{2}(s',s)\wedge\Phi_{E}(c',s')\wedge\Phi_{E}(c'',s'')\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This successor state axiom must make assertions not only about 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, but also about the hypothesised intermediate situation 
\begin_inset Formula $s''$
\end_inset

.
 Extending this reasoning, a successor state axiom for common knowledge
 would be required make assertions not only about 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, but all of the intermediate situations in the transitive closure.
 The macro 
\begin_inset Formula $\CKnows$
\end_inset

 can only make assertions about the final situation reached in the transitive
 closure, not about the path leading to it.
 It is thus not expressive enough to formulate a proper regression rule.
\newline

\end_layout

\begin_layout Standard
To overcome this expressiveness limitation, we follow the recent promising
 work of 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

, who use two important new ideas to produce a regression rule for common
 knowledge in their logic LCC:
\end_layout

\begin_layout Itemize
form more expressive epistemic modalities using the syntax of dynamic logic,
 interpreted over the epistemic frame of the agents
\end_layout

\begin_layout Itemize
apply regression within the modality as well as to the enclosed formula
\end_layout

\begin_layout Standard
We apply these ideas to perform epistemic reasoning in the situation calculus,
 allowing common knowledge to be handled using regression.
 While the development naturally parallels that of LCC, the much richer
 ontology of the situation calculus means there are also substantial differences.
 In particular:
\end_layout

\begin_layout Itemize
LCC is 
\emph on
propositional
\emph default
: actions do not take arguments, there are finitely many actions, and no
 quantification is required.
\end_layout

\begin_layout Itemize
LCC is 
\emph on
synchronous
\emph default
:
\emph on
 
\emph default
reasoning is performed by regressing one action at a time, without the 
\begin_inset Quotes eld
\end_inset

all possible futures
\begin_inset Quotes erd
\end_inset

 approach needed to handle hidden actions.
\end_layout

\begin_layout Standard
By contrast, our formalism must capture first-order preconditions and effects,
 quantifying-in and de-dicto/de-re, and arbitrary sets of concurrent actions,
 while incorporating our new technique for handling hidden actions and remaining
 compatible with other extensions to the situation calculus.
\end_layout

\begin_layout Standard
The remainder of this section proceeds as follows.
 In Section 
\begin_inset LatexCommand ref
reference "sub:Epistemic-Paths"

\end_inset

 we define a variant of first-order dynamic logic for use as an epistemic
 path language, which is encoded in the situation calculus using the macro
 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

.
 This macro is analogous to the fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 from the previous section, but expresses more complex epistemic relationships
 between situations.
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sub:Synchronous-Epistemic-Fluent"

\end_inset

 develops a 
\emph on
synchronous
\emph default
 account of complex epistemic modalities.
 The macro 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 expresses knowledge using an epistemic path 
\begin_inset Formula $\pi$
\end_inset

 under the assumption that there have been no hidden actions.
 We develop a regression rule using a new operator 
\begin_inset Formula $\Trn$
\end_inset

 to perform regression inside the epistemic path, transforming 
\begin_inset Formula $\PKnowsZ(\pi,\phi,do(c,s))$
\end_inset

 into an equivalent expression 
\begin_inset Formula $\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)$
\end_inset

.
\end_layout

\begin_layout Standard
Section 
\begin_inset LatexCommand ref
reference "sub:Introducing-Hidden-Actions"

\end_inset

 introduces hidden actions by explicitly representing them with an empty
 action set.
 We simulate agents reasoning about arbitrarily-long sequences of hidden
 actions by inserting arbitrarily many empty action terms between each real
 action in a situation, and show how a fixpoint construction can reason
 about such modified situations.
 Section 
\begin_inset LatexCommand ref
reference "sub:The-Link-with-IK"

\end_inset

 then relates this fixpoint construction back to the results of Section
 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 by showing that in the case of a single agent, it precisely matches the
 fixpoint generated by the persistence condition operator in equation 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

.
 
\end_layout

\begin_layout Standard
The end result is a powerful account of complex epistemic modalities constructed
 almost entirely in the meta-level reasoning machinery of the situation
 calculus.
 We need only a single new successor state axiom, given below.
\end_layout

\begin_layout Subsection
Synchronous Knowledge
\begin_inset LatexCommand label
name "sub:Syncrhonous-Knowledge"

\end_inset


\end_layout

\begin_layout Standard
To begin, we must define the 
\emph on
synchronous 
\emph default
knowledge of an individual agent in an arbitrary situation 
\begin_inset Formula $s$
\end_inset

.
 This is the agent's knowledge when it assumes that no hidden actions have
 occurred, and so it is not required to do any 
\begin_inset Quotes eld
\end_inset

all possible futures
\begin_inset Quotes erd
\end_inset

 style reasoning.
 We extend the fluent 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 which is already used to represent synchronous knowledge in the initial
 situation.
 The axiom set 
\begin_inset Formula $\Dt_{K}^{obs}$
\end_inset

 gains the following successor state axiom for 
\begin_inset Formula $K_{0}$
\end_inset

:
\begin_inset Formula \begin{align}
K_{0}(agt,s'',do(c,s))\,\equiv\,\, & \exists s',c':\,\left(s''=do(c',s')\wedge Poss(c',s')\,\,\vee\,\, s''=s'\wedge c'=\{\}\right)\nonumber \\
 & \,\,\,\,\,\wedge Obs(agt,c,s)=Obs(agt,c',s')\wedge K_{0}(agt,s',s)\label{eq:K0_ssa}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Given synchronicity, this axiom is a simple modification of the standard
 successor state axiom for knowledge from equation 
\begin_inset LatexCommand eqref
reference "eq:k_ssa_standard"

\end_inset

.
 The only complication is in handling the empty action 
\begin_inset Formula $\{\}$
\end_inset

.
 When 
\series bold

\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset


\series default
 then 
\begin_inset Formula $c'$
\end_inset

 is allowed to be 
\begin_inset Formula $\{\}$
\end_inset

, and the agent considers it possible that no actions were actually performed
 (i.e.
 
\begin_inset Formula $s''=s'$
\end_inset

).
 Thus the number of actions in 
\begin_inset Formula $s$
\end_inset

 puts an upper bound on the number of actions that the agent thinks might
 have occurred.
 
\end_layout

\begin_layout Standard
Beginning with the assumption of synchronicity allows us to focus first
 on increasing the expressiveness of the epistemic language.
 Once this have been achieved, we will generalise the formalism to asynchronous
 domains.
\end_layout

\begin_layout Subsection
Epistemic Paths
\begin_inset LatexCommand label
name "sub:Epistemic-Paths"

\end_inset


\end_layout

\begin_layout Standard
In this section, we adopt the language of dynamic logic to express complex
 epistemic modalities.
 To deal gracefully with the many first-order aspects of the situation calculus
 we use a variant of 
\emph on
first-order dynamic logic,
\emph default
 adapted from the dynamic term-modal logic of 
\begin_inset LatexCommand citet
key "kooi07dyn_termmodal_logic"

\end_inset

 but with some simplifications.
\end_layout

\begin_layout Standard
First, we must specify the syntax of our epistemic path language.
 We will use 
\begin_inset Formula $\pi$
\end_inset

 to denote an arbitrary epistemic path expression.
 
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path Let 
\begin_inset Formula $agt$
\end_inset

 be an 
\noun on
Agent 
\noun default
term, 
\begin_inset Formula $\phi$
\end_inset

 a uniform formula and 
\begin_inset Formula $x$
\end_inset

 a variable name, then the epistemic path terms 
\begin_inset Formula $\pi$
\end_inset

 are the smallest set matching the following structural rules:
\begin_inset Formula \[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
The test (
\begin_inset Formula $?$
\end_inset

), sequence (
\begin_inset Formula $;$
\end_inset

), choice (
\begin_inset Formula $\cup$
\end_inset

) and transitive closure (
\begin_inset Formula $^{*}$
\end_inset

) operators are standard in dynamic logic, although test formulae may now
 contain variables that must be interpreted.
 The operator 
\begin_inset Formula $\exists x$
\end_inset

 allows the value of a variable to change during path traversal, by non-determin
istically re-binding 
\begin_inset Formula $x$
\end_inset

 to some value.
\end_layout

\begin_layout Standard
The semantics of this epistemic path language are defined at the meta-level
 as a series of macro expansions.
 The full details of this development can be found in Appendix 
\begin_inset LatexCommand ref
reference "sec:Encoding-Dynamic-Logic"

\end_inset

, and would complicate the presentation here.
 Instead, we give a simplified presentation that treats variable bindings
 as concrete terms in the logic.
 Formulae of first-order dynamic logic are interpreted relative to both
 a 
\begin_inset Quotes eld
\end_inset

current world
\begin_inset Quotes erd
\end_inset

 and a 
\begin_inset Quotes eld
\end_inset

current variable binding
\begin_inset Quotes erd
\end_inset

 
\begin_inset LatexCommand citep
key "kooi07dyn_termmodal_logic"

\end_inset

.
 Variable bindings are represented below by a first-order substitution 
\begin_inset Formula $\mu$
\end_inset

, with 
\begin_inset Formula $\mu(\phi)$
\end_inset

 applying the substitution to the variables in 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\mu[x/z]$
\end_inset

 setting the value of variable 
\begin_inset Formula $x$
\end_inset

 to the term 
\begin_inset Formula $z$
\end_inset

.
 The semantics operate over pairs 
\begin_inset Formula $(\mu,s)$
\end_inset

.
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path\InsetSpace ~
Semantics 
\begin_inset LatexCommand label
name "def:KDo"

\end_inset

A situation 
\begin_inset Formula $s'$
\end_inset

 is reachable from situation 
\begin_inset Formula $s$
\end_inset

 via epistemic path 
\begin_inset Formula $\pi$
\end_inset

, denoted 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

, according to the following definitions.
 These semantics are encoded using macro expansion as detailed in Appendix
 
\begin_inset LatexCommand ref
reference "sec:Encoding-Dynamic-Logic"

\end_inset

.
\begin_inset Formula \[
\KDo(\pi,s,s')\,\,\equiv\,\,\exists\mu,\mu':\,\KTrans(\pi,\mu,s,\mu',s')\]

\end_inset


\begin_inset Formula \begin{gather*}
\KTrans(agt,\mu,s,\mu',s')\,\equiv\,\mu'=\mu\,\wedge\, K_{0}(agt,s',s)\\
\KTrans(?\phi,\mu,s,\mu',s')\,\equiv\, s'=s\,\wedge\,\mu'=\mu\,\wedge\,\mu(\phi)[s]\\
\KTrans(\pi_{1};\pi_{2},\mu,s,\mu',s')\,\equiv\,\exists\mu'',s'':\,\KTrans(\pi_{1},\mu,s,\mu'',s'')\,\wedge\,\KTrans(\pi_{2},\mu'',s'',\mu',s')\\
\KTrans(\pi_{1}\cup\pi_{2},\mu,s,\mu',s')\,\equiv\,\KTrans(\pi_{1},\mu,s,\mu',s')\,\vee\,\KTrans(\pi_{2},\mu,s,\mu',s')\\
\KTrans(\exists x,\mu,s,\mu',s')\,\equiv\,\exists z:\, s'=s\,\wedge\,\mu'=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu,s,\mu',s')\rightarrow\KTrans(\pi^{*},\mu,s,\mu',s')\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Where we use the following abbreviations (standing for 
\begin_inset Quotes eld
\end_inset

reflexive
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

transitive
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

contains
\begin_inset Quotes erd
\end_inset

 respectively) to specify that 
\begin_inset Formula $\pi^{*}$
\end_inset

 is the reflexive transitive closure of 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{align*}
\mathbf{refl}\isdef & \,\, P(\mu,s,\mu,s)\\
\mathbf{tran\isdef} & \,\,\forall\mu_{1},s_{1},\mu_{2},s_{2}:\, P(\mu_{1},s_{1},\mu,s)\wedge\KTrans(\pi,\mu_{2},s_{2},\mu_{1},s_{1})\,\rightarrow\, P(\mu_{2},s_{2},\mu,s)\\
\mathbf{cont}\isdef & \,\,\forall\mu',s':\,\KTrans(\pi,\mu',s',\mu,s)\,\rightarrow\, P(\mu',s',\mu,s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Let us re-iterate: these are 
\emph on
not
\emph default
 axioms to be included in our basic action theory, but are intended only
 to demonstrate the semantics of the epistemic path language and the macro
 
\begin_inset Formula $\KDo$
\end_inset

.
 Paths do not appear in situation calculus terms, but are handled by macro-expan
sion of 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

 into second-order sentences of the situation calculus.
\end_layout

\begin_layout Subsection
A Synchronous Epistemic Fluent
\begin_inset LatexCommand label
name "sub:Synchronous-Epistemic-Fluent"

\end_inset


\end_layout

\begin_layout Standard
At this point it's worth reviewing again the purpose of this path language.
 Despite utilising the syntax of dynamic logic, it is 
\emph on
not
\emph default
 related to actions in any way.
 Rather it expresses complex 
\emph on
epistemic
\emph default
 paths, and is interpreted over the epistemic frame generated by the agents'
 knowledge relations.
 We will be introducing a new macro 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 (read this as 
\begin_inset Quotes eld
\end_inset

Path-Knows
\begin_inset Quotes erd
\end_inset

) to express knowledge using these epistemic paths.
 To make this clear, here is how some different kinds of knowledge would
 be expressed using the standard account of knowledge, and how we intend
 to express them using epistemic paths:
\begin_inset Formula \begin{align}
\Knows(A,\phi,s) & \,\,\equiv\,\,\PKnows(A,\phi,s)\nonumber \\
\Knows(A,\Knows(B,\phi),s) & \,\,\equiv\,\,\PKnows(A;B,\phi,s)\nonumber \\
\Knows(A,\phi)\wedge\Knows(B,\phi,s) & \,\,\equiv\,\,\PKnows(A\cup B,\phi,s)\nonumber \\
\EKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows(\bigcup_{a\in G}a,\phi,s)\nonumber \\
\CKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)\label{eq:pknows_identities}\end{align}

\end_inset


\end_layout

\begin_layout Standard
In this section, we develop a synchronous version 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 of our path-knowledge operator, building on the synchronous 
\begin_inset Formula $K_{0}$
\end_inset

 relation defined earlier.
 Its definition is a straightforward analogue of the individual-level 
\begin_inset Formula $\Knows$
\end_inset

 macro:
\begin_inset Formula \[
\PKnowsZ(\pi,\phi,s)\isdef\forall s':\,\KDo(\pi,s,s')\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
But this macro expands to a complicated second-order formula in the base
 language of the situation calculus.
 As with the case of the basic 
\begin_inset Formula $\Knows$
\end_inset

 macro, we need to treat 
\begin_inset Formula $\PKnowsZ$
\end_inset

 syntactically as a primitive fluent.
 This means we need a regression rule for such expressions.
 It is here that we incorporate the second key idea from LCC - use of a
 syntactic transform to encode the effects of actions within epistemic paths
 as well as in primitive formulae.
 Mirroring LCC, we introduce the meta-operator 
\begin_inset Formula $\Trn$
\end_inset

 for this purpose.
\end_layout

\begin_layout Standard
Let us consider the required operation of 
\begin_inset Formula $\Trn$
\end_inset

 by analogy with the standard regression operator 
\begin_inset Formula $\Reg$
\end_inset

.
 One can think of regression as a 
\begin_inset Quotes eld
\end_inset

pre-encoding
\begin_inset Quotes erd
\end_inset

 of the effects of an action: 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\begin_inset Formula $do(c,s)$
\end_inset

 if and only if 
\begin_inset Formula $\Reg(\phi,c)$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

.
 The path regressor 
\begin_inset Formula $\Trn$
\end_inset

 needs to lift this idea to epistemic paths as follows: there is a 
\begin_inset Formula $\pi$
\end_inset

-path from 
\begin_inset Formula $do(c,s)$
\end_inset

 to 
\begin_inset Formula $do(c',s')$
\end_inset

 if and only if there is a 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

-path from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
\end_layout

\begin_layout Standard
In order to accomplish this task of pre-encoding the effects of actions,
 the path regressor will need to make various assertions about the action
 that is to be performed in each situation traversed by the path.
 It uses a fresh variable to track this 
\begin_inset Quotes eld
\end_inset

current action
\begin_inset Quotes erd
\end_inset

 in the regressed path.
 The basic operation of 
\begin_inset Formula $\Trn$
\end_inset

 is as follows:
\end_layout

\begin_layout Itemize
introduce a fresh variable 
\begin_inset Formula $x$
\end_inset

 to hold the action to be performed in the current situation
\end_layout

\begin_layout Itemize
at the beginning of the path, bind 
\begin_inset Formula $x$
\end_inset

 to the known action 
\begin_inset Formula $c$
\end_inset


\end_layout

\begin_layout Itemize
at the end of the path, assert that 
\begin_inset Formula $x$
\end_inset

 is the known action 
\begin_inset Formula $c'$
\end_inset

 
\end_layout

\begin_layout Itemize
when the path moves to a new situation, select a new action using 
\begin_inset Formula $\exists x$
\end_inset


\end_layout

\begin_layout Standard
This is accomplished with an auxiliary operator 
\begin_inset Formula $\TrnA(\pi,x)$
\end_inset

, which translates 
\begin_inset Formula $\pi$
\end_inset

 under the assumption that variable 
\begin_inset Formula $x$
\end_inset

 contains the action to be performed in the current situation.
 
\end_layout

\begin_layout DefinitionLbld
Epistemic\InsetSpace ~
Path\InsetSpace ~
Regressor
\begin_inset LatexCommand label
name "def:EpistemicPathRegression"

\end_inset

 The epistemic path regressor 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

 operates according to the definitions below, where 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are fresh variables not appearing in 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{align*}
\Trn(\pi,c,c')\,\isdef\,\, & \exists x\,;\,?x=c\,;\,\TrnA(\pi,x)\,;\,?x=c'\\
\\\TrnA(agt,x)\,\isdef\,\, & \exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\\
\TrnA(?\phi,x)\isdef\,\, & ?\Reg(\phi,x)\\
\TrnA(\exists y,x)\isdef\,\, & \exists y\\
\begin{array}{c}
\TrnA(\pi_{1};\pi_{2},x)\isdef\,\,\end{array} & \TrnA(\pi_{1},x)\,;\,\TrnA(\pi_{2},x)\\
\TrnA(\pi_{1}\cup\pi_{2},x)\isdef\,\, & \TrnA(\pi_{1},x)\cup\TrnA(\pi_{2},x)\\
\TrnA(\pi^{*},x)\isdef\,\, & \TrnA(\pi,x)^{*}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Most of these clauses are straightforward, but note how the clause for an
 individual agent term encodes the successor-state axiom for 
\begin_inset Formula $K_{0}$
\end_inset

.
 The following theorem states that these definitions behave has desired,
 respecting the semantics of epistemic paths:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Trn-respects-epi-paths"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models\,\KDo(\pi,do(c,s),s'')\,\equiv\\
\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDo(\Trn(\pi,c,c'),s,s')\end{multline*}

\end_inset


\end_layout

\begin_layout ProofSketch
The proof proceeds by cases, covering each path operator in turn.
 The base cases 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $?\phi$
\end_inset

 and 
\begin_inset Formula $\exists y$
\end_inset

 follow from Definition 
\begin_inset LatexCommand ref
reference "def:KDo"

\end_inset

 and the successor state axiom for 
\begin_inset Formula $K_{0}$
\end_inset

 in equation 
\begin_inset LatexCommand eqref
reference "eq:K0_ssa"

\end_inset

.
 The inductive cases are straightforward as 
\begin_inset Formula $\Trn_{a}$
\end_inset

 is simply pushed inside each operator.
\end_layout

\begin_layout Standard
Given that 
\begin_inset Formula $\Trn$
\end_inset

 correctly regresses our epistemic path language, we are free to use it
 to define the regression of a complex epistemic modality.
 We define the regression of a 
\begin_inset Formula $\PKnowsZ$
\end_inset

 expression as follows:
\begin_inset Formula \[
\Reg(\PKnowsZ(\pi,\phi,do(c,s)))\isdef\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Reg_PKnowsZ"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action 
\begin_inset Formula $c$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{gather*}

\end_inset


\end_layout

\begin_layout ProofSketch
The mechanics of this proof mirror that of Theorem 
\begin_inset LatexCommand ref
reference "thm:Reg_Knows"

\end_inset

: we expand the 
\begin_inset Formula $\PKnowsZ$
\end_inset

 macro, apply Theorem 
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 as a successor state axiom for 
\begin_inset Formula $\KDo$
\end_inset

, re-arrange to eliminate existential quantifiers, then collect terms back
 into forms that match 
\begin_inset Formula $\PKnowsZ$
\end_inset


\end_layout

\begin_layout Subsection
Introducing Hidden Actions
\begin_inset LatexCommand label
name "sub:Introducing-Hidden-Actions"

\end_inset


\end_layout

\begin_layout Standard
We now have a powerful account of multi-agent knowledge for 
\emph on
synchronous
\emph default
 domains, but it remains to generalise this to asynchronous domains by incorpora
ting support for arbitrarily-long sequences of hidden actions.
 We continue to operate at the meta-level, developing support for hidden
 actions directly in the rules governing the regression operator.
\end_layout

\begin_layout Standard
The idea is to use the empty action term 
\begin_inset Formula $\{\}$
\end_inset

 to explicitly represent the notion that 
\begin_inset Quotes eld
\end_inset

nothing happens
\begin_inset Quotes erd
\end_inset

.
 We simulate agents reasoning about hypothetical futures in which they make
 no more observations by inserting these empty actions between each action
 in a situation term.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $\mathcal{E}^{n}(s)$
\end_inset

 be 
\begin_inset Formula $s$
\end_inset

 with 
\begin_inset Formula $n$
\end_inset

 empty actions inserted between each action, as follows:
\begin_inset Formula \begin{align*}
\mathcal{E}^{0}(s)\,\isdef\,\, & s\\
\mathcal{E}^{1}(S_{0})\,\isdef\,\, & do(\{\},S_{0})\\
\mathcal{E}^{1}(do(c,s))\,\isdef\,\, & do(\{\},do(c,\mathcal{E}^{1}(s)))\\
\mathcal{E}^{n}(s)\,\isdef\,\, & \mathcal{E}^{1}(\mathcal{E}^{n-1}(s))\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The intuition here is that we want 
\begin_inset Formula $\PKnows(\pi,\phi)$
\end_inset

 to hold if 
\begin_inset Formula $\PKnowsZ(\pi,\phi)$
\end_inset

 holds after allowing for any number of empty actions.
 Formally, we want to use the following infinite conjunction as the definition
 of 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

:
\begin_inset Formula \[
\PKnows(\pi,\phi,s)\isdef\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\]

\end_inset


\end_layout

\begin_layout Standard
Of course we cannot use this definition directly for automated reasoning,
 any more than we can use a infinitary definition of 
\begin_inset Formula $\CKnows$
\end_inset

.
 Instead we will construct a series of regression rules that simulate the
 infinite conjunction.
 This requires the following results: 
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:En_impl_En-1"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

: 
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\PKnowsZ(\pi,\phi,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
By a case analysis on the definition of 
\begin_inset Formula $\Trn$
\end_inset

, we determine that that path 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 always contains the path 
\begin_inset Formula $\pi$
\end_inset

.
 Thus any situations reachable by 
\begin_inset Formula $\pi$
\end_inset

 are also reachable by 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

.
 Since 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 is always in the regression of 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 and 
\begin_inset Formula $\Reg(\phi,\{\})=\phi$
\end_inset

 always, we can conclude that 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 always implies 
\begin_inset Formula $\PKnowsZ(\Trn(\pi,\{\},\{\}),\phi,s)$
\end_inset

, which implies 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 as required.
\end_layout

\begin_layout Theorem
For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, if there is some 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

 such that:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{n+1}(s))\]

\end_inset

Then:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\,\equiv\,\bigwedge_{m\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))\]

\end_inset


\end_layout

\begin_layout Proof
By Theorem 
\begin_inset LatexCommand ref
reference "thm:En_impl_En-1"

\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n+1}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))$
\end_inset

 always.
 So for this hypothesised value of 
\begin_inset Formula $n$
\end_inset

, the implication in the current theorem is in fact an equivalence.
 We then have 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m<n$
\end_inset

, and 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\equiv\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m\geq n$
\end_inset

, which is enough to establish the infinite conjunction as required.
\end_layout

\begin_layout Standard
This pair of results allows us to replace the infinite conjunction with
 a fixpoint calculation, so we will use the following suggestive notation:
\begin_inset Formula \[
\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(s))\isdef\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\]

\end_inset


\end_layout

\begin_layout Standard
We can therefore use the following as our definition of 
\begin_inset Formula $\PKnows$
\end_inset

:
\begin_inset Formula \[
\PKnows(\pi,\phi,s)\,\isdef\,\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(s))\]

\end_inset


\end_layout

\begin_layout Standard
This macro would once again expand into a complicated second-order sentence
 of the situation calculus, encoding both the semantics of the epistemic
 path and the fixpoint definition of 
\begin_inset Formula $\mathcal{E}^{\infty}$
\end_inset

.
 Regression can avoid expanding these macros by performing the fixpoint
 calculation with a special-purpose prover for dynamic logic.
\end_layout

\begin_layout Standard
The definition of 
\begin_inset Formula $\PKnows$
\end_inset

 operates in a very similar way to the regression rule for 
\begin_inset Formula $\Knows$
\end_inset

 from equation 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

, using a fixpoint calculation to account for arbitrarily long sequences
 of hidden actions.
  In the following section we formalism the precise relationship between
 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\PKnows$
\end_inset

.
\end_layout

\begin_layout Subsection
The Link with Individual Knowledge
\begin_inset LatexCommand label
name "sub:The-Link-with-IK"

\end_inset


\end_layout

\begin_layout Standard
The last remaining link is the most important of all: showing that this
 new path-based account of knowledge actually captures the knowledge of
 the agents, according to the semantics of individual knowledge developed
 in Section 
\begin_inset LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

.
 The follows series of theorems establish this important link.
 First, we produce special cases of the regression rule for 
\begin_inset Formula $\PKnows(\pi,\phi)$
\end_inset

 for the case of a single agent:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Pknows_PbU_S0"

\end_inset

For any 
\begin_inset Formula $agt$
\end_inset

 and 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows(agt,\phi,S_{0})\,\equiv\,\PKnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout ProofSketch
By stepping through the regression of 
\begin_inset Formula $\PKnowsZ(agt,\phi,do(\{\},S_{0}))$
\end_inset

 we show that for any 
\begin_inset Formula $n$
\end_inset

, 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{n}(S_{0}))\equiv\PKnowsZ(agt,\Pst^{n}(\phi,\PbU(agt)),S_{0})$
\end_inset

.
 The fixpoint calculation for 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{\infty}(S_{0}))$
\end_inset

 is then clearly the same calculation required to derive 
\begin_inset Formula $\PKnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})$
\end_inset

 and we can equate the two expressions.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Pknows_PbU_do"

\end_inset

For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\left[z=\{\}\,\rightarrow\,\PKnows(agt,\Pst(\phi,\PbU(agt)),s)\right]\\
\wedge\,\left[z\neq\{\}\,\rightarrow\,\PKnows(agt,\forall c':\,\left(Poss(c')\wedge Obs(agt,c')=z\right)\rightarrow\Reg(\Pst(\phi,\PbU(agt)),c),s)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout ProofSketch
Repeating the calculations from lemma 
\begin_inset LatexCommand ref
reference "thm:Pknows_PbU_S0"

\end_inset

 on 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(do(c,s)))$
\end_inset

, and pushing the application of 
\begin_inset Formula $\mathcal{E}^{\infty}$
\end_inset

 past the actions 
\begin_inset Formula $c$
\end_inset

, we obtain the following:
\begin_inset Formula \[
\PKnows(agt,\phi,do(c,s))\,\equiv\,\PKnowsZ(agt,\Pst(\phi,\PbU(agt)),do(c,\mathcal{E}^{\infty}(s)))\]

\end_inset


\end_layout

\begin_layout ProofSketch
Regressing the RHS through the actions 
\begin_inset Formula $c$
\end_inset

, we obtain:
\begin_inset Formula \begin{align*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\, & \forall c':\,\PKnowsZ(\Trn(agt,c,c'),\Reg(\Pst(\phi,\PbU(agt)),c'),\mathcal{E}^{\infty}(s))\\
\equiv\,\, & \forall c':\,\PKnows(\Trn(agt,c,c'),\Reg(\Pst(\phi,\PbU(agt)),c'),s)\end{align*}

\end_inset


\end_layout

\begin_layout ProofSketch
Simplifying 
\begin_inset Formula $\Trn(agt,c,c')$
\end_inset

 and using it to re-arrange the above expression gives the desired result.
\end_layout

\begin_layout Standard
We will also need the following result for individual knowledge:
\end_layout

\begin_layout Theorem
\begin_inset LatexCommand label
name "thm:Knows_impl_KnowsPbU"

\end_inset

For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\equiv\,\Knows(agt,\Pst(\phi,PbU(agt)),s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
By induction on the regression rules for knowledge, and using the following
 property of the persistence condition (
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $\phi$
\end_inset

 persists, then 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 persists
\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula \[
\forall s':\,\Pst(\phi,\alpha)[s]\,\wedge\, s\leq_{\alpha}s'\,\rightarrow\,\Pst(\phi,\alpha)[s']\]

\end_inset


\end_layout

\begin_layout ProofSketch
We consider three cases: 
\begin_inset Formula $s=S_{0}$
\end_inset

, and 
\begin_inset Formula $s=do(c,s)$
\end_inset

 with 
\begin_inset Formula $c$
\end_inset

 both observable and unobservable.
 Each case requires only a simple re-arrangement of the relevant regression
 rule.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Finally, we are in a position to state the major theorem of this section
 - that 
\begin_inset Formula $\PKnows$
\end_inset

 for a single agent is equivalent to the standard 
\begin_inset Formula $\Knows$
\end_inset

 macro.
\end_layout

\begin_layout Theorem
For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Theorem
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\,\equiv\,\,\PKnows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Proof
By induction on the regression rules for each expression.
 For the 
\begin_inset Formula $S_{0}$
\end_inset

 case, we require the following result which is true by the definition of
 
\begin_inset Formula $\KDo$
\end_inset

:
\begin_inset Formula \[
\KnowsZ(agt,\phi,S_{0})\equiv\PKnowsZ(agt,\phi,S_{0})\]

\end_inset

The regression rule for 
\begin_inset Formula $\Knows$
\end_inset

 from equation 
\begin_inset LatexCommand eqref
reference "eqn:R_s0"

\end_inset

 then precisely matches the result of theorem 
\begin_inset LatexCommand ref
reference "thm:Pknows_PbU_S0"

\end_inset

 and we have the required equivalence.
 For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, we can substitute the result of theorem 
\begin_inset LatexCommand ref
reference "thm:Knows_impl_KnowsPbU"

\end_inset

 into the regression rule for 
\begin_inset Formula $\Knows$
\end_inset

 from equation 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 to produce an expression precisely matching the result of theorem 
\begin_inset LatexCommand ref
reference "thm:Pknows_PbU_do"

\end_inset

.
 Using 
\begin_inset Formula $\Knows(agt,\phi,s)\equiv\PKnows(agt,\phi,s)$
\end_inset

 from the inductive hypothesis renders the two equivalent.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
Thus the expressions 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 and 
\begin_inset Formula $\PKnows(agt,\phi,s)$
\end_inset

 are equivalent under our formulation.
 This link is all this is required to validate the additional complex modalities
 shown in equation 
\begin_inset LatexCommand eqref
reference "eq:pknows_identities"

\end_inset

, which we will repeat below for convenience.
\end_layout

\begin_layout Theorem
The following identities hold under the theory of action 
\begin_inset Formula $\Dt\cup\Dt_{K}^{obs}$
\end_inset

:
\begin_inset Formula \begin{align*}
\Knows(A,\phi,s) & \,\,\equiv\,\,\PKnows(A,\phi,s)\\
\Knows(A,\Knows(B,\phi),s) & \,\,\equiv\,\,\PKnows(A;B,\phi,s)\\
\Knows(A,\phi)\wedge\Knows(B,\phi,s) & \,\,\equiv\,\,\PKnows(A\cup B,\phi,s)\\
\EKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows(\bigcup_{a\in G}a,\phi,s)\\
\CKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Each follows from the equivalence of 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 and 
\begin_inset Formula $\PKnows(agt,\phi,s)$
\end_inset

, using the semantics of first-order dynamic logic as defined by 
\begin_inset Formula $\KDo$
\end_inset

.
 For example, in the 
\begin_inset Formula $\CKnows$
\end_inset

 case we argue as follows: By definition, 
\begin_inset Formula $\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)$
\end_inset

 is the transitive closure of the union of 
\begin_inset Formula $\PKnows(a,\phi,s)$
\end_inset

 for 
\begin_inset Formula $a\in G$
\end_inset

.
 Also by definition, 
\begin_inset Formula $\CKnows(G,\phi,s)$
\end_inset

 is the transitive closure of the union of 
\begin_inset Formula $\Knows(a,\phi,s)$
\end_inset

 for 
\begin_inset Formula $a\in G$
\end_inset

.
 Since 
\begin_inset Formula $\PKnows(a,\phi,s)$
\end_inset

 and 
\begin_inset Formula $\Knows(a,\phi,s)$
\end_inset

 are the same relation, their transitive closures are also the same and
 the identity is entailed.
\end_layout

\begin_layout Subsection
Answering the Regressed Query
\end_layout

\begin_layout Standard
We are now in a position to reduce an epistemic query 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 at some future situation to an epistemic query 
\begin_inset Formula $\PKnows(\Trn^{*}(\pi),\Reg^{*}(\phi),S_{0})$
\end_inset

 at the initial situation.
 While this is a significant gain for effective automated reasoning, it
 still remains to answer the regressed query.
 As with individual knowledge, we assume this will be handled by a special-purpo
se theorem prover rather than by expanding the macros.
\end_layout

\begin_layout Standard
However, we should note that validity in first-order dynamic logic is undecidabl
e; in fact it is 
\begin_inset Formula $\Pi_{1}^{1}$
\end_inset

-hard 
\begin_inset LatexCommand citep
key "kooi07dyn_termmodal_logic"

\end_inset

.
 As with previous work in the situation calculus, we must assume that axioms
 about the initial situation are in a restricted form amenable to effective
 reasoning.
 There are several special cases that can simplify answering the regressed
 query.
\end_layout

\begin_layout Standard
A common simplifying assumption is that the potential values of each variable
 can be finitely enumerated.
 In this case it is possible to translate our epistemic paths into propositional
 dynamic logic, which is decidable.
 The only difficulty is the elimination of variable bindings inside an iteration
 operator, which can be handled using a Kleene-style technique similar to
 the 
\begin_inset Formula $\mathcal{K}$
\end_inset

 translator of 
\begin_inset LatexCommand citet
key "vanBenthem06lcc"

\end_inset

.
 We have implemented a reasoning engine based on this technique and used
 it to validate the examples in the following section.
\end_layout

\begin_layout Standard
Alternately, it may be that the initial situation is completely known and
 uncertainty is introduced only due to partial observability of actions.
 In this case the initial epistemic frame contains the lone situation 
\begin_inset Formula $S_{0}$
\end_inset

, and the regressed path can be reduced to a series of tests and variable
 re-bindings.
\end_layout

\begin_layout Standard
We are currently investigating further techniques for answering the regressed
 query in a more effective manner.
\end_layout

\begin_layout Subsection
An Illustrative Example
\end_layout

\begin_layout Standard
With this technical machinery in place, we are now able to reason about
 the group-level epistemic modalities of a team of agents.
 To demonstrate, we revisit our example domain from Subsection 
\begin_inset LatexCommand ref
reference "sub:An-Illustrative-Example"

\end_inset

.
\end_layout

\begin_layout Example
Initially, it is common knowledge that Ann doesn't know where the party
 is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((Ann\cup Bob)^{*},\neg\exists l:\,\Knows(Ann,loc=l),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Example
After Bob reads the invitation, it is not common knowledge that the party
 is at 
\begin_inset Formula $C$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\not\models\,\PKnows((Ann\cup Bob)^{*},loc=C,do(\{read(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Example
After Bob reads the invitation, is is common knowledge that he knows where
 the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((Ann\cup Bob)^{*},\exists x:\PKnows(Bob,loc=x),do(\{read(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
\InsetSpace ~

\end_layout

\begin_layout Example
If Alice also reads the invitation, it becomes common knowledge that the
 party is at C:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((Ann\cup Bob)^{*},loc=C,do(\{read(Ann)\},do(\{read(Bob)\},S_{0})))\]

\end_inset


\end_layout

\begin_layout Subsection
Discussion
\begin_inset LatexCommand label
name "sub:CEM-Discussion"

\end_inset


\end_layout

\begin_layout Standard
In this section we have introduced a technique for representing and reasoning
 about complex epistemic modalities in the situation calculus.
 In order to formulate an effective reasoning procedure, we have had to
 move beyond just 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\CKnows$
\end_inset

 and introduce a powerful epistemic path language based on dynamic logic.
 Mirroring the development of knowledge for individual agents, group-level
 modalities are introduced as macros of the form 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 where 
\begin_inset Formula $\pi$
\end_inset

 is a complex epistemic path.
 To avoid having to expand these macros during reasoning, we have modified
 the regression operator to treat them as primitive fluents.
\end_layout

\begin_layout Standard
Demonstrating the utility of our approach, we have presented an example
 of effective automated reasoning about common knowledge in an asynchronous,
 partially observable domain.
 This powerful new ability is a first for the situation calculus.
\end_layout

\begin_layout Standard
Our development has clear parallels with the development of LCC 
\begin_inset LatexCommand citep
key "vanBenthem06lcc"

\end_inset

.
 We choose the situation calculus for its much richer ontology, e.g.
 preconditions and effects are first order, while actions take arguments
 and may be performed concurrently.
 On one hand, this forces us to use a more powerful dynamic logic for our
 epistemic language and run the risk of undecidability.
 On the other, it actually simplifies some aspects of our presentation.
 We do not need explicit update frames, and the definition of our path regressor
 does not require an auxiliary Kleene-style operator to handle iteration.
 
\end_layout

\begin_layout Standard
In synchronous domains with a finite state-space the situation calculus
 may not offer a gain in expressiveness, but it can certainly provide a
 more succinct axiomatisation.
 Moving beyond such domains, our formalism offers the potential to incorporate
 other rich domain features that have been developed for the situation calculus,
 such as continuous time and actions with duration 
\begin_inset LatexCommand citep
key "reiter96sc_nat_conc"

\end_inset

.
 
\end_layout

\begin_layout Standard
The expressiveness of our epistemic path language means that answering a
 regressed knowledge query can be difficult in the general case.
 However, starting from the expression for common knowledge, the epistemic
 path regressor 
\begin_inset Formula $\Trn$
\end_inset

 will generate only a fragment of the full epistemic language.
 For example, it will not generate nested iteration operators.
 Restricting the domain can weaken this generated fragment, as shown in
 
\begin_inset LatexCommand cite
key "vanBenthem06lcc"

\end_inset

 where a relativised common-knowledge operator is proven sufficient for
 domains in which all actions are publicly observable.
 Identifying restrictions such as this that can simplify reasoning in the
 epistemic language is a promising avenue for future research.
 
\end_layout

\begin_layout Standard
As with our account of individual-level knowledge, hidden actions are handled
 using a fixpoint calculation.
 However, this calculation is no longer based on objective formulae and
 the unique names axioms, but requires reasoning in first-order dynamic
 logic.
 The above considerations must be taken into account not only when answering
 the final regressed query, but also when generating the intermediate fixpoints.
\end_layout

\begin_layout Section
Conclusions
\begin_inset LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Standard
We have now enriched the standard account of knowledge in the situation
 calculus with two important new features: hidden actions, and common knowledge.
 We conclude the paper with a high-level summary of our achievements, and
 discussions of related and future work.
 
\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
In this paper we have enriched the standard account of knowledge in the
 situation calculus with the following technical results:
\end_layout

\begin_layout Itemize
a formal account of 
\emph on
Common Knowledge
\emph default
 and other group-level epistemic modalities, including a regression rule
 for reasoning about common knowledge.
\end_layout

\begin_layout Itemize
support for 
\emph on
Hidden Actions
\emph default
 and actions that are partially observable, including a reasoning technique
 to deal with arbitrarily-long sequences of hidden actions.
\end_layout

\begin_layout Itemize
a solution to the 
\emph on
Frame Problem
\emph default
 for knowledge, built on the successor state axioms for primitive actions,
 maintaining regression as the primary reasoning tool, and allowing agents
 to reason about their own knowledge using only their local information.
\end_layout

\begin_layout Standard
The standard account of knowledge required the common knowledge operator
 
\begin_inset Formula $\CKnows$
\end_inset

 to be introduced via a separate second-order axiom, which precluded the
 use of regression for effective automated reasoning.
 The key limitation here was the expressiveness of the epistemic language,
 since the regression of 
\begin_inset Formula $\CKnows$
\end_inset

 could not be expressed in terms of 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\CKnows$
\end_inset

 alone.
 We have developed a more powerful epistemic language using the 
\begin_inset Formula $\PKnows$
\end_inset

 operator and the language of dynamic logic, that allows common knowledge
 to be reasoned about using standard regression techniques.
 
\end_layout

\begin_layout Standard
The standard account also required that domains be synchronous, so that
 the 
\begin_inset Formula $\Knows$
\end_inset

 operator need not consider arbitrarily-long sequences of hidden actions.
 Handling hidden actions requires a second-order induction axiom to universally
 quantify over situation terms, again precluding the use of regression for
 effective automated reasoning.
 We have shown that this second-order axiom can be avoided during regression,
 by replacing it with a fixpoint calculation performed by the meta-level
 reasoning machinery.
 This fixpoint calculation requires theorem proving based on a very restricted
 set of axioms, offering a significant advantage over generic second-order
 theorem proving.
\end_layout

\begin_layout Standard
Key to achieving both of these results has been a focus on the frame problem
 - not just in soundly capturing the interplay between knowledge and action,
 but in constructing the formalism to be compatible with existing regression
 techniques.
 By capturing the second-order aspects of common knowledge in a series of
 macro definitions, we were able to directly formulate a successor-state
 axiom for 
\begin_inset Formula $\PKnows$
\end_inset

 and let regression treat it like a primitive fluent.
 And by factoring the second-order aspects of dealing with hidden actions
 into a separate fixpoint calculation, we were able to formulate a proper
 regression rule and study the fixpoint calculation in isolation.
 Both have been a significant win for effective automated reasoning.
\end_layout

\begin_layout Standard
The end result is a rich multi-agent theory of knowledge and action, suitable
 for asynchronous, partially-observable domains, in which complex group-level
 epistemic modalities are amenable to effective automated reasoning.
\end_layout

\begin_layout Subsection
Related Work
\begin_inset LatexCommand label
name "sec:Related-Work"

\end_inset


\end_layout

\begin_layout Standard
There has been a great deal of work on multi-agent systems in the situation
 calculus, including: specification of multi-agent systems 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

; theories of coordination 
\begin_inset LatexCommand citep
key "ghaderi07sc_joint_ability"

\end_inset

 and ability 
\begin_inset LatexCommand citep
key "levesque00knowing_how"

\end_inset

; reasoning about the epistemic feasibility of plans 
\begin_inset LatexCommand citep
key "Lesperance01epi_feas_casl"

\end_inset

; analysing multi-player games 
\begin_inset LatexCommand citep
key "delgrande01sitcalc_cleudo"

\end_inset

; and our own work on the cooperative execution of Golog programs 
\begin_inset LatexCommand citep
key "kelly06hlp_dps"

\end_inset

.
 Many of these works explicitly assume that all actions are public, in order
 to use regression to reason about knowledge.
 And they either do not use common knowledge in their formalisms, or use
 an explicit second-order axiom and forgo the use of regression in such
 cases.
 Our richer theory of knowledge could immediately be used to extend and
 generalise formalisms such as these to more complex multi-agent domains.
\end_layout

\begin_layout Standard
While our formalism has explicitly focused on modelling knowledge, there
 has also been substantial work on modelling 
\emph on
belief
\emph default
 in the situation calculus, where agents may be mistaken about the state
 of the world 
\begin_inset LatexCommand citet
key "shapiro00sc_belief"

\end_inset

.
 In such systems there are alternatives to reasoning about arbitrarily-long
 sequences of hidden actions, such as assuming that no hidden actions occur
 until there is evidence to the contrary.
 
\begin_inset LatexCommand citet
key "shapiro04sc_belief_exog"

\end_inset

 show how agents may hypothesise the occurrence of hidden exogenous actions
 when they discover that their beliefs are wrong.
 We note that these belief-based systems are also based on the original
 formulation of epistemic modalities by 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, and are confident that aspects of our approach could be used to enrich
 such systems.
\newline

\end_layout

\begin_layout Standard
Our development clearly owes much to the heritage of dynamic epistemic logics
 in general 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib,baltag98pa_ck"

\end_inset

 and the development of LCC in particular 
\begin_inset LatexCommand citep
key "vanBenthem06lcc"

\end_inset

; discussion and comparison can be found in Section 
\begin_inset LatexCommand ref
reference "sub:CEM-Discussion"

\end_inset

.
 We echo the sentiment of 
\begin_inset LatexCommand citet
key "vanbentham07ml_sitcalc"

\end_inset

 and look forward to continued cross-pollination between these two related
 disciplines.
\end_layout

\begin_layout Standard
One common feature of epistemic logics that is not found in our work is
 the notion of a 
\emph on
protocol
\emph default
 - an explicit restriction on the sequences of actions that are permissible
 in the world.
 Our formalism corresponds to a simple 
\begin_inset Quotes eld
\end_inset

anything goes
\begin_inset Quotes erd
\end_inset

 protocol - the agents assume that if an action is physically possible,
 then it might have occurred.
 This is suitable for adversarial domains but does not necessarily capture
 cooperative domains where, for example, other agents may be trusted not
 to change the world in certain ways behind one's back.
\end_layout

\begin_layout Standard
The approach can be generalised to some extent by replacing the use of 
\begin_inset Formula $Poss(c,s)$
\end_inset

 with a more specific action description predicate, that axiomatises the
 actions that are permissible.
 For example, an agents could assume no interference from other agents and
 consider only hidden actions performed by the environment.
 Or if other mental attitudes are also part of the theory, they may consider
 only those actions that are compatible with each other's goals or desires;
 such a formulation echos the intuition behind motivated action theory 
\begin_inset LatexCommand cite
key "morgenstern90knowledge"

\end_inset

.
\end_layout

\begin_layout Standard
However, such changes can only accommodate 
\emph on
local
\emph default
 protocols, where the permissible actions depend solely on the state of
 the world.
 A more general formalism would allow protocols to be specified as programs,
 perhaps in the Golog language 
\begin_inset LatexCommand citep
key "levesque97golog"

\end_inset

.
 Combining epistemic and dynamic aspects in such flexible ways is known
 to be highly undecidable even in very simple domains 
\begin_inset LatexCommand citep
key "vanBentham06tree_of_knowledge"

\end_inset

 and we leave such considerations for future work.
\end_layout

\begin_layout Subsection
Future Work
\end_layout

\begin_layout Standard
As noted above, there are interesting applications for reasoning about knowledge
 under a protocol, where the protocol may be expressed as some Golog program
 
\begin_inset Formula $\delta$
\end_inset

.
 The desired modality would be something like the following, stating that
 
\begin_inset Quotes eld
\end_inset

it is 
\begin_inset Formula $\pi$
\end_inset

-known that 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 under protocol 
\begin_inset Formula $\delta$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula \[
\mathbf{PDKnows}(\pi,\delta,\phi,s)\]

\end_inset

Our ongoing research program is investigating modalities such as this.
 One challenging aspect is that while knowledge is usually handled by reasoning
 
\emph on
backward
\emph default
 in time using regression, Golog programs are executed by reasoning 
\emph on
forward
\emph default
 in time to find a valid sequence of actions.
 Such a modality would also need to reason about invariants of a Golog program
 in order to handle iterative protocols, and we are aware of no existing
 work in this area.
\end_layout

\begin_layout Standard
A significant short-term focus of our future work is in increasing the tractabil
ity of our reasoning techniques.
 As noted in Section 
\begin_inset LatexCommand ref
reference "sub:CEM-Discussion"

\end_inset

, we are searching for fragments of first-order dynamic logic that are easier
 to reason about while still be expressive enough to represent common knowledge
 in some domains.
 
\end_layout

\begin_layout Standard
Another approach to more tractable reasoning is to approximate knowledge
 in the style of 
\begin_inset LatexCommand citet
key "demolombe00tractable_sc_belief"

\end_inset

.
 Here knowledge is restricted to primitive fluents only, rather than arbitrary
 uniform formulae.
 Knowledge of more complex formulae may be expressed approximately, by splitting
 the 
\begin_inset Formula $\Knows$
\end_inset

 macro until it operates only on primitive fluents, e.g.
 
\begin_inset Formula $\Knows(F_{1}\vee F_{2})\Rightarrow\Knows(F_{1})\vee\Knows(F_{2})$
\end_inset

.
 
\begin_inset LatexCommand citet
key "petrick02knowledge_equivalence"

\end_inset

 have developed a formal correspondence between this account of knowledge
 and the standard possible-worlds model in the case of a single agent.
 Extending the correspondence to multiple agents and hidden actions would
 be a promising avenue of future work.
\newpage

\end_layout

\begin_layout Section
\start_of_appendix
Dynamic Logic via Macro Expansion
\begin_inset LatexCommand label
name "sec:Encoding-Dynamic-Logic"

\end_inset


\end_layout

\begin_layout Standard
This appendix develops an encoding of first-order dynamic logic (hereafter
 denoted 
\begin_inset Quotes eld
\end_inset

FODL
\begin_inset Quotes erd
\end_inset

) into the situation calculus via macro expansion.
 Our encoding is based on embedding FODL into Golog, a programming language
 based on the situation calculus 
\begin_inset LatexCommand citep
key "levesque97golog"

\end_inset

 that has many similarities to dynamic logic.
\end_layout

\begin_layout Standard
This may seem like an unnecessary complication - why not expand FODL directly
 into sentences of the situation calculus? We find the embedding into Golog
 simpler and clearer, and expect many readers familiar with the situation
 calculus will feel likewise.
 As Golog is well-understood, it relieves some our burden of proof in establishi
ng that the embedding works as required.
 Since the semantics of Golog itself it based on macro-expansion, the end-result
 is the the same: sentences of FODL macro-expand into sentences of the situation
 calculus.
 Finally, our modification to Golog so that it is interpreted over epistemic
 frames may further elucidate the intended operation of FODL in this paper.
\end_layout

\begin_layout Standard
First, let us introduce the semantics of Golog.
 In the following, 
\begin_inset Formula $\delta$
\end_inset

 will represent an arbitrary Golog program.
 The semantics are traditionally defined as a macro 
\begin_inset Formula $\mathbf{Do}(\delta,s,s')$
\end_inset

 which stands for 
\begin_inset Quotes eld
\end_inset

it is possible to execute program 
\begin_inset Formula $\delta$
\end_inset

, starting in situation 
\begin_inset Formula $s$
\end_inset

, and ending in situation 
\begin_inset Formula $s'$
\end_inset


\begin_inset Quotes erd
\end_inset

 
\begin_inset LatexCommand citep
key "levesque97golog"

\end_inset

.
 Since we intend to interpret Golog over epistemic frames, we will use the
 macro 
\begin_inset Formula $\EDo$
\end_inset

 to make this distinction clear.
 This requires only one modification to vanilla Golog - the base operators
 are agent terms, rather than actions.
\end_layout

\begin_layout DefinitionLbld
Semantics\InsetSpace ~
of\InsetSpace ~
Epistemic\InsetSpace ~
Golog The semantics of Golog over epistemic frames is
 given by the macro 
\begin_inset Formula $\EDo$
\end_inset

 defined as follows, where 
\begin_inset Formula $P$
\end_inset

 names a predicate symbol:
\begin_inset Formula \[
\delta::=agt\,|\,?\phi\,|\,\delta_{1};\delta_{2}\,|\,\delta_{1}\cup\delta_{2}\,|\,\pi(x)(\delta(x))\,|\,\delta^{*}\,|\,\mathbf{proc}\, P(\vars{x})\,\delta(\vars{x})\,\mathbf{end}\,;\,\delta\,|\, P(\vars{x})\]

\end_inset


\begin_inset Formula \begin{align*}
\EDo(agt,s,s')\,\isdef\,\, & K_{0}(agt,s',s)\\
\EDo(?\phi,s,s')\,\isdef\,\, & s=s'\wedge\phi[s]\\
\EDo(\delta_{1}\,;\,\delta_{2},s,s')\,\isdef\,\, & \exists s'':\,\EDo(\delta_{1},s,s'')\,\wedge\,\EDo(\delta_{2},s'',s')\\
\EDo(\delta_{1}\,\cup\,\delta_{2},s,s')\,\isdef\,\, & \EDo(\delta_{1},s,s')\vee\EDo(\delta_{2},s,s')\\
\EDo(\pi(x)(\delta(x)),s,s')\,\isdef\,\, & \exists x:\,\EDo(\delta(x),s,s')\\
\EDo(\delta^{*},s,s')\,\isdef\,\, & \mathrm{refl.\, trans.\, closure\, of}\,\,\EDo(\delta,s,s')\\
\EDo(P(\vars{x}),s,s')\,\isdef\,\, & P(\vars{x},s,s')\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The final clause identifies a procedure call with arguments 
\begin_inset Formula $\vars{x}$
\end_inset

.
 Defining procedure calls via macro expansion involves a second-order definition
 corresponding to the standard least-fixed-point semantics for recursive
 procedures.
 This operates as follows, taking a list of 
\begin_inset Formula $n$
\end_inset

 procedure definitions followed by a main program invocation:
\begin_inset Formula \begin{multline*}
\EDo(\{\mathbf{proc}\, P_{1}(\vars{v_{1}})\,\delta_{1}\,\mathbf{end}\,;\dots\,;\,\mathbf{proc}\, P_{n}(\vars{v_{n}})\,\delta_{n}\,\mathbf{end}\,;\,\delta_{0}\}\,\isdef\,\\
\forall(P_{1},\dots,P_{n})\left[\bigwedge_{i=1}^{n}\forall s_{1},s_{2},\vars{v_{i}}:\,\EDo(\delta_{i},s_{1},s_{2})\,\rightarrow\,\EDo(P_{i}(\vars{v}_{i}),s_{1},s_{2})\right]\\
\rightarrow\,\,\EDo(\delta_{0},s,s')\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Clearly Golog is a very powerful language, so the question must be asked:
 could we use Golog as our epistemic path language, rather than FODL? Unfortunat
ely not, as Golog has no notion of 
\emph on
state
\emph default
 - while the Golog operator 
\begin_inset Formula $\pi(x)(\delta(x))$
\end_inset

 is similar to the FODL operator 
\begin_inset Formula $\exists x$
\end_inset

, its effect is localised to the contained program 
\begin_inset Formula $\delta(x)$
\end_inset

.
 FODL allows variable assignments to affect the entire remaining program.
\end_layout

\begin_layout Standard
We review the operators and required semantics of FODL for convenience:
\begin_inset Formula \[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end_inset


\begin_inset Formula \[
\KDo(\pi,s,s')\,\,\equiv\,\,\exists\mu'\,\KTrans(\pi,\varepsilon,s,\mu',s')\]

\end_inset


\begin_inset Formula \begin{gather*}
\KTrans(agt,\mu'',s'',\mu,s)\,\equiv\,\mu''=\mu\,\wedge\, K_{0}(agt,s'',s)\\
\KTrans(?\phi,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu\,\wedge\,\mu(\phi)[s]\\
\KTrans(\pi_{1};\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\exists\mu',s':\,\KTrans(\pi_{1},\mu',s',\mu,s)\,\wedge\,\KTrans(\pi_{2},\mu'',s'',\mu',s')\\
\KTrans(\pi_{1}\cup\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\KTrans(\pi_{1},\mu'',s'',\mu,s)\,\vee\,\KTrans(\pi_{2},\mu'',s'',\mu,s)\\
\KTrans(x:=t,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu[x/t]\\
\KTrans(\exists x,\mu'',s'',\mu,s)\,\equiv\,\exists z:\, s''=s\,\wedge\,\mu''=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu'',s'',\mu,s)\rightarrow\KTrans(\pi^{*},\mu'',s'',\mu,s)\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Note that the semantics of FODL explicitly use first-order substitutions
 to manage stateful variables.
 In order to simulate this via macro expansion, we use what is essentially
 a continuation-passing transformation to avoid explicitly mentioning substituti
ons.
\end_layout

\begin_layout Standard
First, note that any epistemic path 
\begin_inset Formula $\pi$
\end_inset

 will be contain only a finite number of FODL variables.
 Without loss of generality, suppose that 
\begin_inset Formula $\pi$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 such variables named 
\begin_inset Formula $x_{1}$
\end_inset

 to 
\begin_inset Formula $x_{n}$
\end_inset

.
 The idea is to translate each component of the path into a Golog procedure
 with 
\begin_inset Formula $n$
\end_inset

 arguments, where the 
\begin_inset Formula $i$
\end_inset

th argument is used to pass in the current value of 
\begin_inset Formula $x_{i}$
\end_inset

.
 After performing the necessary operations to encode the semantics of that
 path component, it calls a continuation procedure containing the next path
 component.
 This translation is based on the macro 
\begin_inset Formula $\KDo_{cps}(\pi,N,C)$
\end_inset

 which is passed the name it should use for the procedure encoding the given
 path component (
\begin_inset Formula $N$
\end_inset

) and the name of the continuation procedure (
\begin_inset Formula $C$
\end_inset

).
\end_layout

\begin_layout DefinitionLbld
Embedding\InsetSpace ~
FODL\InsetSpace ~
into\InsetSpace ~
Golog The embedding of FODL into Golog is given by the
 macros 
\begin_inset Formula $\KDo$
\end_inset

 and 
\begin_inset Formula $\KDo_{cps}$
\end_inset

 defined as follows, where 
\begin_inset Formula $P_{i}$
\end_inset

 are fresh procedure names and 
\begin_inset Formula $\vars{v}$
\end_inset

 are argument vectors of length 
\begin_inset Formula $n$
\end_inset

:
\begin_inset Formula \begin{align*}
\KDo(\pi,s,s')\,\isdef\,\,\  & \EDo(\{\KDo_{cps}(\pi,P,End)\,;\,\mathbf{proc}\, End(\vars{v})\,?\top\,\mathbf{end}\,;\,\pi(\vars{v})(P(\vars{v}))\},s,s')\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{align*}
\KDo_{cps}(agt,N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\, agt\,;\, C(\vars{v})\,\mathbf{end}\\
\KDo_{cps}(?\phi(\vars{x}),N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,?\phi(\vars{v})\,;\, C(\vars{v})\,\ \mathbf{end}\\
\KDo_{cps}(\exists x_{i},N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,\pi(x)(C(\vars{v}[v_{i}/x]))\,\mathbf{end}\\
\KDo_{cps}(\pi_{1};\pi_{2},N,C)\,\isdef\,\, & \KDo_{cps}(\pi_{1},N,P)\,;\,\KDo_{cps}(\pi_{2},P,C)\\
\KDo_{cps}(\pi_{1}\cup\pi_{2},N,C)\,\isdef\,\, & \KDo_{cps}(\pi_{1},P_{1},C)\,;\,\KDo_{cps}(\pi_{2},P_{2},C)\,;\,\mathbf{proc}\, N(\vars{v})\, P_{1}(\vars{v})\cup P_{2}(\vars{v})\,\mathbf{end}\\
\KDo_{cps}(\pi^{*},N,C)\,\isdef\,\, & \KDo_{cps}(\pi,P,N)\,;\,\mathbf{proc}\, N(\vars{v})\, C(\vars{v})\cup P(\vars{v})\,\mathbf{end}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This translation generates one procedure for each operator in the path,
 plus the procedure 
\begin_inset Formula $End$
\end_inset

 used to successfully terminate execution.
 Most of these definitions are straightforward translations of equivalent
 operators in FODL to Golog.
 One interesting case is 
\begin_inset Formula $\exists x_{i}$
\end_inset

, which calls the continuation procedure with a fresh variable in position
 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
The most complex case is 
\begin_inset Formula $\pi^{*}$
\end_inset

, which simulates iteration using a pair of mutually recursive procedures
 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $N$
\end_inset

.
 Procedure 
\begin_inset Formula $N$
\end_inset

 can either terminate immediately (calling the continuation 
\begin_inset Formula $C$
\end_inset

) or call 
\begin_inset Formula $P$
\end_inset

.
 A call to 
\begin_inset Formula $P$
\end_inset

 executes one iteration of 
\begin_inset Formula $\pi$
\end_inset

 before continuing with another invocation of 
\begin_inset Formula $N$
\end_inset

.
 The possible executions for 
\begin_inset Formula $\pi^{*}$
\end_inset

 are thus 
\begin_inset Formula $nil$
\end_inset

, 
\begin_inset Formula $\pi$
\end_inset

, 
\begin_inset Formula $\pi;\pi$
\end_inset

, etc as required by the semantics of FODL.
\end_layout

\begin_layout Standard
It should be clear that the expansion of each operator satisfies the relevant
 identity from Definition 
\begin_inset LatexCommand ref
reference "def:KDo"

\end_inset

, and thus the encoding acts as required.
\end_layout

\begin_layout Section
Complete Proofs
\begin_inset LatexCommand label
name "sec:Complete-Proofs"

\end_inset


\end_layout

\begin_layout Standard
This appendix contains complete proofs for various lemmas and theorems throughou
t the paper, along with some additional lemmas.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, Legal(s)\wedge s\leq_{\PbU(agt)}s'\,\rightarrow\, Legal(s')\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, since 
\begin_inset Formula $\PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Legal$
\end_inset

 is equivalent to 
\begin_inset Formula $\leq_{Poss}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:pbu-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, s\leq_{\PbU(agt)}s'\,\rightarrow\, View(agt,s')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, by induction on the definition of 
\begin_inset Formula $View$
\end_inset

 from equation (
\begin_inset LatexCommand ref
reference "eq:view_defn"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-root"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, K(agt,s'',s)\,\rightarrow\, K(agt,root(s''),root(s))\]

\end_inset


\end_layout

\begin_layout Proof
Trivial in the base case of 
\begin_inset Formula $Init(s)$
\end_inset

.
 For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, suppose that we have 
\begin_inset Formula $K(agt,s'',do(c,s))$
\end_inset

.
 Then by equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) there is some 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $s'\sqsubseteq s''$
\end_inset

 and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 Then 
\begin_inset Formula $root(s'')$
\end_inset

 = 
\begin_inset Formula $root(s')$
\end_inset

, and 
\begin_inset Formula $K(root(s'),root(s))$
\end_inset

 by the inductive hypothesis, giving the required result.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, K(agt,s'',s)\,\rightarrow\, Legal(s'')\]

\end_inset


\end_layout

\begin_layout Proof
All 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 are initial and therefore legal.
 So using equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) in the base case, there must be a legal 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $s'\leq_{\PbU(agt)}s''$
\end_inset

, making 
\begin_inset Formula $s''$
\end_inset

 legal by lemma 
\begin_inset LatexCommand ref
reference "lem:pbu-implies-legal"

\end_inset

.
 For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) ensures that 
\begin_inset Formula $do(c',s')\leq_{\PbU(agt)}s''$
\end_inset

 for some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $c'$
\end_inset

 satisfying 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 and 
\begin_inset Formula $Poss(c',s')$
\end_inset

.
 So 
\begin_inset Formula $s'$
\end_inset

 is legal by the inductive hypothesis, making 
\begin_inset Formula $s''$
\end_inset

 legal as required.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\newpage

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:K-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, K(agt,s'',s)\,\rightarrow View(agt,s'')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the base case of 
\begin_inset Formula $Init(s)$
\end_inset

, using equation 
\begin_inset LatexCommand eqref
reference "eqn:new_k_s0"

\end_inset

, 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 implies that there must be an 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $Init(s')$
\end_inset

 and 
\begin_inset Formula $s'\leq_{\PbU(agt)}s''$
\end_inset

.
 Therefore 
\begin_inset Formula $View(s'')$
\end_inset

 = 
\begin_inset Formula $View(s')$
\end_inset

 = 
\begin_inset Formula $\epsilon$
\end_inset

 = 
\begin_inset Formula $View(s)$
\end_inset

 as required.
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, suppose 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

.
 Then we have 
\begin_inset Formula $View(agt,do(c,s))$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
= 
\begin_inset Formula $View(agt,s)$
\end_inset

, while equation 
\begin_inset LatexCommand eqref
reference "eqn:new_k_ssa"

\end_inset

 gives us 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

, which yields 
\begin_inset Formula $View(agt,s'')$
\end_inset

 = 
\begin_inset Formula $View(agt,s)$
\end_inset

 by the inductive hypothesis.
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $Obs(agt,c,s)\neq\{\}$
\end_inset

, then equation 
\begin_inset LatexCommand eqref
reference "eqn:new_k_ssa"

\end_inset

 gives us 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $c'$
\end_inset

 such that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $do(c',s')\leq_{\PbU(agt)}s''$
\end_inset

, 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

 = 
\begin_inset Formula $Obs(agt,c',s')$
\end_inset

, and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 By the inductive hypothesis 
\begin_inset Formula $View(agt,s')=View(agt,s)$
\end_inset

, and we have the following: 
\begin_inset Formula $View(agt,s'')$
\end_inset

 = 
\begin_inset Formula $View(agt,do(c',s'))$
\end_inset

 = 
\begin_inset Formula $Obs(agt,c,s)\cdot View(agt,s')$
\end_inset

 = 
\begin_inset Formula $View(agt,do(c,s))$
\end_inset

 as required.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 For any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge View(agt,s'')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the 
\emph on
if
\emph default
 direction, we simply combine lemmas 
\begin_inset LatexCommand ref
reference "lem:K-implies-root"

\end_inset

, 
\begin_inset LatexCommand ref
reference "lem:K-implies-legal"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "lem:K-implies-view"

\end_inset

.
 For the 
\emph on
only-if
\emph default
 base case of 
\begin_inset Formula $Init(s)$
\end_inset

, the 
\begin_inset Formula $\exists s'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) is trivially satisfied by 
\begin_inset Formula $root(s'')$
\end_inset

 and the equivalence holds as required.
\end_layout

\begin_layout Proof
For the 
\emph on
only-if
\emph default
 inductive case with 
\begin_inset Formula $do(c,s)$
\end_inset

, we have two sub-cases to consider.
 Suppose 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

: then 
\begin_inset Formula $View(agt,s'')$
\end_inset

 = 
\begin_inset Formula $View(agt,do(c,s))$
\end_inset

 = 
\begin_inset Formula $View(agt,s)$
\end_inset

 and 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 holds by the inductive hypothesis, satisfying the equivalence in equation
 (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

).
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $Obs(agt,c,s)\neq\{\}$
\end_inset

: then we have:
\begin_inset Formula \[
View(agt,do(c,s))=Obs(agt,c,s)\cdot View(agt,s)=View(agt,s'')\]

\end_inset

For this to be the case, and since 
\begin_inset Formula $s''$
\end_inset

 is legal, there must be some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $c'$
\end_inset

 satisfying 
\begin_inset Formula $Obs(agt,c',s')$
\end_inset

 = 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

, 
\begin_inset Formula $View(agt,s')$
\end_inset

 = 
\begin_inset Formula $View(agt,s)$
\end_inset

 and 
\begin_inset Formula $do(c',s')\leq_{\PbU(agt)}s''$
\end_inset

 .
 This is enough to satisfy the 
\begin_inset Formula $\exists s',a'$
\end_inset

 part of equation (
\begin_inset LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) and so the equivalence holds as required.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Reg_Knows"

\end_inset

 Given a basic action theory 
\begin_inset Formula $\Dt\cup\Dt_{K}^{obs}$
\end_inset

 and a uniform formula 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\phi[do(c,s)]\equiv\Reg(\phi,c)[s]\]

\end_inset

 
\end_layout

\begin_layout Proof
We need only consider applications of 
\begin_inset Formula $\Reg$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 has the form 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

, as other regression rules have not been modified.
 We must establish that our new regression rules in equations 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 and 
\begin_inset LatexCommand eqref
reference "eqn:R_s0"

\end_inset

 are equivalences under the theory of action 
\begin_inset Formula $\Dt\cup\Dt_{K}^{obs}$
\end_inset

.
\end_layout

\begin_layout Proof
For notational clarity we define the abbreviation 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s)$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

persists under equivalent observations
\begin_inset Quotes erd
\end_inset

) which states that 
\begin_inset Formula $\phi$
\end_inset

 holds in all legal futures of 
\begin_inset Formula $s$
\end_inset

 compatible with observations 
\begin_inset Formula $o$
\end_inset

:
\begin_inset Formula \begin{multline*}
\mathbf{PEO}(agt,\phi,o,s)\,\isdef\,\\
\forall c':\, Obs(agt,c',s)=o\wedge Poss(c',s)\rightarrow\left[\forall s':\, do(c',s)\leq_{\PbU(agt)}s'\rightarrow\,\phi[s']\right]\end{multline*}

\end_inset

 Expanding the definition of the 
\begin_inset Formula $\Knows$
\end_inset

 macro at 
\begin_inset Formula $do(c,s)$
\end_inset

, and applying the successor state axiom from equation 
\begin_inset LatexCommand eqref
reference "eqn:new_k_ssa"

\end_inset

 to the 
\begin_inset Formula $K(agt,s'',do(c,s))$
\end_inset

 term, we can produce the following:
\begin_inset Formula \begin{align*}
\Knows(agt,\phi,do(c,s))\equiv\, & \forall s'':\, K(agt,s'',do(c,s))\,\rightarrow\,\phi[s'']\\
\equiv\, & \exists o\,.\, Obs(agt,c,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\forall s':\, K(agt,s',s)\rightarrow\phi[s']\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\forall s':\, K(agt,s',s)\rightarrow\mathbf{PEO}(agt,\phi,o,s')\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Proof
Noting that both conjuncts contain sub-formulae matching the form of the
 
\begin_inset Formula $\Knows$
\end_inset

 macro, it can be substituted back in to give:
\begin_inset Formula \begin{align*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\, & \exists o\,.\, Obs(agt,c,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\mathbf{Knows}(agt,\mathbf{PEO}(agt,\phi,o,s'),s)\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Proof
For 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s')$
\end_inset

 to legitimately appear inside the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro it must be uniform in the situation variable 
\begin_inset Formula $s'$
\end_inset

.
 Applying the persistence condition and regressing to make the expression
 uniform, we develop the following equivalence:
\begin_inset Formula \[
\mathbf{PEO}(agt,\phi,o,s)\equiv\forall c':\, Obs(agt,c',s)=o\wedge Poss(c',s)\rightarrow\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,\PbU(agt)),c')\]

\end_inset

 
\end_layout

\begin_layout Proof
Suppressing the situation term in this uniform formula gives the regression
 rule from equation 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 as required.
\end_layout

\begin_layout Proof
For 
\begin_inset Formula $S_{0}$
\end_inset

, a straightforward transformation of equations 
\begin_inset LatexCommand eqref
reference "eqn:knows_def"

\end_inset

 and 
\begin_inset LatexCommand eqref
reference "eqn:new_k_s0"

\end_inset

 gives:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\left[\forall s'\,.\, s\leq_{\PbU(agt)}s'\rightarrow\phi[s']\right]\]

\end_inset

 Applying the persistence condition operator, this can easily be re-written
 as:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\Pst(\phi,\PbU(agt))[s]\]

\end_inset


\end_layout

\begin_layout Proof
This matches the form of the definition for 
\begin_inset Formula $\KnowsZ$
\end_inset

, which we can substitute in to give:
\begin_inset Formula \[
\Knows(agt,\phi,S_{0})\equiv\KnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Proof
This is the regression rule from equation 
\begin_inset LatexCommand eqref
reference "eqn:R_s0"

\end_inset

 as required.
 Our modified regression rules are thus equivalences under the theory 
\begin_inset Formula $\Dt\cup\Dt_{K}^{obs}$
\end_inset

, and the theorem holds.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\newpage

\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:TrnA_works"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models\,\KDo(\pi,do(c,s),s'')\,\equiv\,\exists\mu,\mu',c',s':\\
\mu(x)=c\wedge\mu'(x)=c'\wedge\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDo(\Trn_{a}(\pi,x),\mu,s,\mu',s')\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Proceed by cases, covering each path operator in turn.
 For the base case of an individual agent, we have:
\begin_inset Formula \begin{align*}
\KDo(\pi,do(c,s),s'')\,\equiv\, & K_{0}(agt,s'',do(c,s))\end{align*}

\end_inset


\begin_inset Formula \[
\TrnA(agt,x)\Rightarrow\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\]

\end_inset

Expanding 
\begin_inset Formula $\KDo(\TrnA(agt,x),\mu,s,\mu',s')$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 thus produces:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula \begin{multline*}
\KDo(\TrnA(agt,x),\mu,s,\mu',s')\equiv\exists z:\, Obs(agt,\mu(x),s)=z\,\wedge\,\exists s'':\, K_{0}(agt,s'',s)\,\wedge\\
\left(Poss(\mu'(x),s'')\vee\mu'(x)=\{\}\right)\,\wedge\, Obs(agt,\mu'(x),s'')=z\,\wedge\, s''=s'\end{multline*}

\end_inset

Note that 
\begin_inset Formula $\mu$
\end_inset

 and 
\begin_inset Formula $\mu'$
\end_inset

 are never applied to a variable other than 
\begin_inset Formula $x$
\end_inset

.
 When we substitute this into the RHS of the hypothesis, 
\begin_inset Formula $\mu(x)$
\end_inset

 and 
\begin_inset Formula $\mu'(x)$
\end_inset

 are asserted to be 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $c'$
\end_inset

 respectively, so they can be simplified away to give:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models K(agt,s'',do(c,s))\equiv\exists c',s':\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\\
\wedge K_{0}(agt,s,s')\,\wedge\,\left(Poss(c',s')\vee c'=\{\}\right)\wedge\, Obs(agt,c,s)=Obs(agt,c',s')\end{multline*}

\end_inset

This is the successor state axiom for 
\begin_inset Formula $K_{0}$
\end_inset

, which is trivially entailed by the domain.
\newline

\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $?\phi$
\end_inset

 case, we have:
\begin_inset Formula \[
\KDo(?\phi,do(c,s),s'')\equiv\phi[do(c,s)]\wedge s''=do(c,s)\]

\end_inset


\begin_inset Formula \[
\TrnA(?\phi,x)\Rightarrow?\Reg(\phi,x)\]

\end_inset


\end_layout

\begin_layout Proof
Giving:
\begin_inset Formula \[
\KDo(\TrnA(?\phi,x),\mu,s,\mu',s')\equiv\Reg(\phi,x)[s]\wedge s=s'\wedge\mu=\mu'\]

\end_inset

Substituting into the RHS of the hypothesis, this asserts that 
\begin_inset Formula $c=c'$
\end_inset

 and hence 
\begin_inset Formula $s''=do(c,s)$
\end_inset

, so the hypothesis is clearly entailed.
\newline

\end_layout

\begin_layout Proof
The case for 
\begin_inset Formula $\exists y$
\end_inset

 is trivial as 
\begin_inset Formula $\KDo(\exists y,s,s')\equiv s=s'$
\end_inset

.
\newline

\end_layout

\begin_layout Proof
The inductive cases are straightforward as 
\begin_inset Formula $\Trn_{a}$
\end_inset

 is simply pushed inside each operator.
 We will take the 
\begin_inset Formula $\pi^{*}$
\end_inset

 case as an example.
 The inductive hypothesis gives us:
\begin_inset Formula \begin{multline*}
\KDo(\pi,do(c,s),s'')\,\equiv\exists\mu,\mu',c',s':\\
\mu(x)=c\wedge\mu'(x)=c'\wedge\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDo(\Trn_{a}(\pi,x),\mu,s,\mu,'s')\end{multline*}

\end_inset

We can apply 
\begin_inset Formula $RTC$
\end_inset

 to both sides of this equivalence, along with two rearrangements: the LHS
 is expanded to put 
\begin_inset Formula $\exists\mu,\mu''$
\end_inset

 at its front, and the rigid tests on the RHS are taken outside the 
\begin_inset Formula $RTC$
\end_inset

 operation.
 The result is:
\begin_inset Formula \begin{multline}
\exists\mu,\mu'':\, RTC[\KDo(\pi,\mu,do(c,s),\mu'',s'')]\,\equiv\\
\exists\mu,\mu',c',s':\,\mu(x)=c\wedge\mu'(x)=c'\wedge s''=do(c',s')\wedge RTC[\KDo(\Trn_{a}(\pi,x),\mu,s,\mu,'s')]\label{eq:rtc-inductive-hyp}\end{multline}

\end_inset

Using the definitions of 
\begin_inset Formula $\KDo$
\end_inset

 and 
\begin_inset Formula $\TrnA$
\end_inset

 we have:
\begin_inset Formula \[
\KDo(\pi^{*},do(c,s),s'')\equiv\exists\mu,\mu'':\, RTC[\KTrans(\pi,\mu,do(c,s),\mu'',s'')]\]

\end_inset


\begin_inset Formula \[
\KDo(\TrnA(\pi^{*},x),\mu,s,\mu',s')\equiv RTC[\KDo(\TrnA(\pi,x),\mu,s,\mu',s')]\]

\end_inset

Substituting these into the 
\begin_inset Formula $RTC$
\end_inset

 of the inductive hypothesis from equation 
\begin_inset LatexCommand eqref
reference "eq:rtc-inductive-hyp"

\end_inset

 completes the proof.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models\,\KDo(\pi,do(c,s),s'')\,\equiv\\
\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDo(\Trn(\pi,c,c'),s,s')\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Recall the rule for 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

:
\begin_inset Formula \[
\Trn(\pi,c,c')\Rightarrow\exists x\,;\,?x=c\,;\,\TrnA(\pi,x)\,;\,?x=c'\]

\end_inset

Expanding 
\begin_inset Formula $\KDo$
\end_inset

 for this rule:
\begin_inset Formula \[
\KDo(\Trn(\pi,c,c'),s,s')\equiv\exists\mu,\mu':\,\mu(x)=c\,\wedge\mu'(x)=c'\wedge\KDo(\TrnA(\pi,x),\mu,s,\mu',s')\]

\end_inset

We can thus substitute 
\begin_inset Formula $\KDo(\Trn(\pi,c,c'),s,s')$
\end_inset

 into the RHS of Lemma 
\begin_inset LatexCommand ref
reference "lem:TrnA_works"

\end_inset

 to get the required result.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Reg_PKnowsZ"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action 
\begin_inset Formula $c$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
This mechanics of this proof mirror that of Theorem 
\begin_inset LatexCommand ref
reference "thm:Reg_Knows"

\end_inset

: we expand the 
\begin_inset Formula $\PKnowsZ$
\end_inset

 macro, apply Theorem 
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 as a successor state axiom for 
\begin_inset Formula $\KDo$
\end_inset

, re-arrange to eliminate existential quantifiers, then collect terms back
 into forms that match 
\begin_inset Formula $\PKnowsZ$
\end_inset

.
 We begin with the following:
\begin_inset Formula \begin{align*}
\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\, & \forall s'':\,\KDo(\pi,do(c,s),s'')\,\rightarrow\,\phi[s'']\\
\equiv\,\, & \forall s'':\,\left[\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\left.\wedge\KDo(\Trn(\pi,c,c'),s,s')\right]\rightarrow\,\phi[s'']\\
\equiv\,\, & \forall s'',c',s':\,\left[\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\left.\wedge\KDo(\Trn(\pi,c,c'),s,s')\right]\rightarrow\,\phi[s'']\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Case-splitting on the disjunction, we see that:
\begin_inset Formula \begin{gather*}
s''=do(c',s')\,\rightarrow\,\left(\phi[s'']\equiv\Reg(\phi,c')[s']\right)\end{gather*}

\end_inset


\begin_inset Formula \[
s''=s'\wedge c'=\{\}\,\rightarrow\,\left(\phi[s'']\equiv\Reg(\phi,c')[s']\right)\]

\end_inset


\end_layout

\begin_layout Proof
This allows us to remove the variable 
\begin_inset Formula $s''$
\end_inset

 from the consequent of the implication, making it redundant in the antecedent
 and allowing us to eliminate it entirely.
 Folding the quantification over 
\begin_inset Formula $s'$
\end_inset

 back into the 
\begin_inset Formula $\PKnowsZ$
\end_inset

 macro completes the proof:
\begin_inset Formula \begin{align*}
\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\, & \forall s'',c',s':\,\left[\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\left.\wedge\KDo(\Trn(\pi,c,c'),s,s')\right]\rightarrow\,\Reg(\phi,c')[s']\\
\equiv\,\, & \forall c',s':\,\KDo(\Trn(\pi,c,c'),s,s')\,\rightarrow\,\Reg(\phi,c')[s']\\
\equiv\,\, & \forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset LatexCommand label
name "lem:KDo_E1_impl_KDo"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\KDo(\Trn(\pi,\{\},\{\}),s,s')\,\rightarrow\,\KDo(\pi,s,s')\]

\end_inset


\end_layout

\begin_layout Proof
By a case analysis on the epistemic path operators.
 For the base case of an individual agent, we have:
\begin_inset Formula \begin{align*}
\Trn(agt,\{\},\{\})\,=\, & \exists x\,;\,?x=\{\}\,;\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\\
 & \,\,\,\,\,\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,\,?Obs(agt,x_{a})=z\,;\,?x=\{\}\\
=\, & \exists z\,;\,?z=\{\}\,;\, agt\,;\,?Poss(\{\})\vee\{\}=\{\}\,;\,?z=\{\}\\
=\, & agt\end{align*}

\end_inset


\end_layout

\begin_layout Proof
So the hypothesis is clearly entailed.
 For the 
\begin_inset Formula $?\phi$
\end_inset

 case:
\begin_inset Formula \begin{align*}
\Trn(?\phi,\{\},\{\})= & \exists x\,;\,?x=\{\}\,;\,?\Reg(\phi,x)\,;\,?x=\{\}\\
= & ?\Reg(\phi,\{\})\\
= & ?\phi\end{align*}

\end_inset


\end_layout

\begin_layout Proof
So the hypothesis is clearly entailed.
 For the 
\begin_inset Formula $\exists z$
\end_inset

 case:
\begin_inset Formula \begin{align*}
\Trn(\exists z,\{\},\{\})= & \exists x\,;\,?x=\{\}\,;\,\exists z\,;\,?x=\{\}\\
= & \exists z\end{align*}

\end_inset


\end_layout

\begin_layout Proof
So the hypothesis is clearly entailed.
 The inductive cases are then straightforward, by choosing 
\begin_inset Formula $x=\{\}$
\end_inset

 uniformly whenever 
\begin_inset Formula $\exists x$
\end_inset

 is encountered in the translated path.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\newpage

\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:En_impl_En-1"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

: 
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\PKnowsZ(\pi,\phi,s)\]

\end_inset


\end_layout

\begin_layout Proof
Expanding the macros, we have:
\begin_inset Formula \[
\left(\forall s'':\,\KDo(\pi,do(\{\},s),s'')\rightarrow\phi[s'']\right)\,\,\rightarrow\,\,\left(\forall s':\,\KDo(\pi,s,s')\rightarrow\phi[s']\right)\]

\end_inset


\end_layout

\begin_layout Proof
Using equation 
\begin_inset LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 on the LHS gives:
\begin_inset Formula \begin{multline*}
\left(\forall s'':\,\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\right.\\
\left.\wedge\KDo(\Trn(\pi,\{\},c'),s,s')\rightarrow\phi[s'']\right)\,\,\rightarrow\,\,\left(\forall s':\,\KDo(\pi,s,s')\rightarrow\phi[s']\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
This implication must hold individually for each disjunct in the antecedent.
 We can thus break out the 
\begin_inset Formula $c'=\{\}$
\end_inset

 case to obtain:
\begin_inset Formula \begin{multline*}
\left(\forall s'':\,\exists c',s':\, s''=s'\wedge c'=\{\}\wedge\KDo(\Trn(\pi,\{\},c'),s,s')\rightarrow\phi[s'']\right)\,\,\rightarrow\\
\left(\forall s':\,\KDo(\pi,s,s')\rightarrow\phi[s']\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Simplifying away the variables 
\begin_inset Formula $s''$
\end_inset

 and 
\begin_inset Formula $c'$
\end_inset

 gives:
\begin_inset Formula \[
\left(\forall s':\,\KDo(\Trn(\pi,\{\},\{\}),s,s')\rightarrow\phi[s']\right)\,\,\rightarrow\,\,\left(\forall s':\,\KDo(\pi,s,s')\rightarrow\phi[s']\right)\]

\end_inset


\end_layout

\begin_layout Proof
This implication is a trivial consequence of lemma 
\begin_inset LatexCommand ref
reference "lem:KDo_E1_impl_KDo"

\end_inset

, so the theorem holds.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Pknows_PbU_S0"

\end_inset

 For any 
\begin_inset Formula $agt$
\end_inset

 and 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows(agt,\phi,S_{0})\,\equiv\,\PKnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Proof
Recall the definition of 
\begin_inset Formula $\PKnows$
\end_inset

:
\begin_inset Formula \[
\PKnows(agt,\phi,S_{0})\,\isdef\,\PKnowsZ(agt,\phi,\mathcal{E}^{\infty}(S_{0}))\]

\end_inset

Begin by considering the sequence of calculations required to calculate
 the regression of 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(S_{0}))$
\end_inset

.
 First, we perform some simplification on 
\begin_inset Formula $\Trn(agt,\{\},c')$
\end_inset

:
\begin_inset Formula \begin{align*}
\Trn(agt,\{\},c')=\,\,\, & \exists x\,;\,?x=\{\}\,;\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\\
 & \,\,\,\,\,\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,\,?Obs(agt,x)=z\,;\,?x=c'\\
=\,\,\, & \exists z\,;\,?Obs(agt,\{\})=z\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?Obs(agt,c')=z\\
=\,\,\, & agt\,;\,?Obs(agt,c')=\{\}\wedge\left(Poss(c')\vee c'=\{\}\right)\\
=\,\,\, & agt\,;\,?\left(\PbU(agt,c')\vee c'=\{\}\right)\end{align*}

\end_inset

 Now we can use this in the regression of 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(S_{0}))$
\end_inset

, as follows: 
\begin_inset Formula \begin{align*}
\PKnowsZ(agt,\phi,\mathcal{E}^{1}(S_{0}))\equiv\,\, & \Reg(\PKnows_{0}(agt,\phi,do(\{\},S_{0})))\\
\equiv\,\, & \forall c':\,\PKnowsZ(\Trn(agt,\{\},c'),\Reg(\phi,c'),S_{0})\\
\equiv\,\, & \forall c':\,\PKnowsZ(agt\,;\,?\left(\PbU(agt,c')\vee c'=\{\}\right),\Reg(\phi,c'),S_{0})\\
\equiv\,\, & \PKnowsZ(agt,\forall c':\,\left(\PbU(agt,c')\vee c'=\{\}\right)\rightarrow\Reg(\phi,c'),S_{0})\\
\equiv\,\, & \PKnowsZ(agt,\phi\,\wedge\,\forall c':\, PbU(agt,c')\rightarrow\Reg(\phi,c'),S_{0})\\
\equiv\,\, & \PKnowsZ(agt,\Pst^{1}(\phi,\PbU(agt)),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Using the same construction, we can show that in general:
\begin_inset Formula \begin{align*}
\PKnowsZ(agt,\phi,\mathcal{E}^{n}(S_{0}))\equiv\,\, & \PKnowsZ(agt,\Pst^{1}(\phi,\PbU(agt)),\mathcal{E}^{n-1}(S_{0}))\\
\equiv\,\, & \PKnowsZ(agt,\Pst^{n}(\phi,\PbU(agt)),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Clearly the fixpoint calculation used to find 
\begin_inset Formula $\PKnowsZ$
\end_inset

 at 
\begin_inset Formula $\mathcal{E}^{\infty}$
\end_inset

 is the same as the fixpoint calculation used to find 
\begin_inset Formula $\Pst(\phi,\PbU(agt))$
\end_inset

.
 Therefore, we have the required:
\begin_inset Formula \[
\PKnows(agt,\phi,S_{0})\,\equiv\,\PKnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Pknows_PbU_do"

\end_inset

 For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\left[z=\{\}\,\rightarrow\,\PKnows(agt,\Pst(\phi,\PbU(agt)),s)\right]\\
\wedge\,\left[z\neq\{\}\,\rightarrow\,\PKnows(agt,\forall c':\,\left(Poss(c')\wedge Obs(agt,c')=z\right)\rightarrow\Reg(\Pst(\phi,\PbU(agt)),c),s)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Repeating the calculations from Theorem 
\begin_inset LatexCommand ref
reference "thm:Pknows_PbU_S0"

\end_inset

 on 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{\infty}(do(c,s)))$
\end_inset

, and pushing the application of 
\begin_inset Formula $\mathcal{E}^{\infty}$
\end_inset

 past the actions 
\begin_inset Formula $c$
\end_inset

, we obtain the following:
\begin_inset Formula \[
\PKnows(agt,\phi,do(c,s))\,\equiv\,\PKnowsZ(agt,\Pst(\phi,\PbU(agt)),do(c,\mathcal{E}^{\infty}(s)))\]

\end_inset


\end_layout

\begin_layout Proof
Regressing the RHS over the actions 
\begin_inset Formula $c$
\end_inset

, we obtain:
\begin_inset Formula \begin{align*}
\PKnows(agt,\phi,do(c,s))\,\equiv & \forall c':\,\PKnowsZ(\Trn(agt,c,c'),\Reg(\Pst(\phi,\PbU(agt)),c'),\mathcal{E}^{\infty}(s))\\
\equiv & \forall c':\,\PKnows(\Trn(agt,c,c'),\Reg(\Pst(\phi,\PbU(agt)),c'),s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Now, let us expand and re-arrange 
\begin_inset Formula $\Trn(agt,c,c')$
\end_inset

:
\begin_inset Formula \begin{align*}
\Trn(agt,c,c')=\,\,\, & \exists x\,;\,?x=c\,;\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\\
 & \,\,\,\,\,\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,\,?Obs(agt,x_{a})=z\,;\,?x=c'\\
=\,\,\, & \exists z\,;\,?Obs(agt,c)=z\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?Obs(agt,c')=z\\
=\,\, & \exists z\,;\,?Obs(agt,c)=z\,;\\
 & \,\,\,\,\,\,\left(z=\{\}\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?Obs(agt,c')=\{\}\right)\\
 & \,\,\,\cup\left(z\neq\{\}\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?Obs(agt,c')=z\right)\\
=\,\, & \exists z\,;\,?Obs(agt,c)=z\,;\,\left(z=\{\}\,;\, agt\,;\,?c'=\{\}\right)\\
 & \,\,\,\cup\left(z=\{\}\,;\, agt\,;\,?PbU(agt,c')\right)\\
 & \,\,\,\cup\left(z\neq\{\}\,;\, agt\,;\,?Poss(c')\wedge Obs(agt,c')=z\right)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Substituting this back into the RHS, we can bring the leading tests outside
 the macro and split the 
\begin_inset Formula $\cup$
\end_inset

 into a conjunction to give:
\begin_inset Formula \begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\forall c':\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\PKnows(\left(?z=\{\};\, agt\right),\Reg(\Pst(\phi,\PbU(agt)),\{\}),s)\\
\wedge\,\PKnows(\left(?z=\{\};agt;?PbU(agt,c')\right),\Reg(\Pst(\phi,\PbU(agt)),c'),s)\\
\wedge\,\PKnows(\left(?z\neq\{\};agt;?Poss(c')\wedge Obs(agt,c')=z\right),\Reg(\Pst(\phi,\PbU(agt)),c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Extracting the remaining tests from these paths, removing regression over
 the empty action, and pushing the quantification over 
\begin_inset Formula $c'$
\end_inset

 into its narrowest scope, we get:
\begin_inset Formula \begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\left[z=\{\}\rightarrow\PKnows(agt,\Pst(\phi,\PbU(agt)),s)\right]\\
\wedge\,\left[z=\{\}\rightarrow\PKnows(agt,\forall c':\, PbU(agt,c')\,\rightarrow\,\Reg(\Pst(\phi,\PbU(agt)),c'),s)\right]\\
\wedge\,\left[z\neq\{\}\rightarrow\PKnows(agt,\forall c':\left(Poss(c')\wedge Obs(agt,c')=z\right)\rightarrow\Reg(\Pst(\phi,\PbU(agt)),c'),s)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
To complete the proof, we need the following property of the persistence
 condition, which follows directly from its definition:
\begin_inset Formula \[
\Dt\,\models\,\left(\forall c:\,\alpha(c,s)\rightarrow\Reg(\Pst(\phi,\alpha),c)[s]\right)\,\equiv\,\Pst(\phi,\alpha)[s]\]

\end_inset


\end_layout

\begin_layout Proof
Using this we see that the two 
\begin_inset Formula $z=\{\}$
\end_inset

 clauses are equivalent, and we can drop the more complicated one to get
 the theorem as required.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset LatexCommand ref
reference "thm:Knows_impl_KnowsPbU"

\end_inset

 For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\equiv\,\Knows(agt,\Pst(\phi,PbU(agt)),s)\]

\end_inset


\end_layout

\begin_layout Proof
By induction on the regression rules for knowledge, and using the following
 properties of the persistence condition:
\begin_inset Formula \[
\forall s':\,\Pst(\phi,\alpha)[s]\,\wedge\, s\leq_{\alpha}s'\,\rightarrow\,\Pst(\phi,\alpha)[s']\]

\end_inset


\begin_inset Formula \[
\Pst(\Pst(\phi,\alpha),\alpha)[s]\,\equiv\,\Pst(\phi,\alpha)[s]\]

\end_inset


\end_layout

\begin_layout Proof
For 
\begin_inset Formula $s=S_{0}$
\end_inset

 the regression rule in equation 
\begin_inset LatexCommand eqref
reference "eqn:R_s0"

\end_inset

 gives us the following equivalence:
\begin_inset Formula \begin{align*}
\Knows(agt,\phi,S_{0})\equiv & \KnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})\\
\equiv & \forall s':\, K_{0}(agt,s',S_{0})\,\rightarrow\,\Pst(\phi,PbU(agt))[s']\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Which, by the above properties of 
\begin_inset Formula $\Pst$
\end_inset

, yields:
\begin_inset Formula \[
\Knows(agt,\phi,S_{0})\equiv\forall s',s'':\, K_{0}(agt,s',S_{0})\wedge s'\leq_{PbU(agt)}s''\,\rightarrow\,\Pst(\phi,PbU(agt))[s'']\]

\end_inset


\end_layout

\begin_layout Proof
This matches the form of the 
\begin_inset Formula $\Knows$
\end_inset

 macro, and can be restructured to give the required:
\begin_inset Formula \[
\Knows(agt,\phi,S_{0})\,\equiv\,\Knows(agt,\Pst(\phi,PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(c,s)$
\end_inset

 the inductive hypothesis gives us:
\begin_inset Formula \[
\Knows(agt,\phi,s)\equiv\Knows(agt,\Pst(\phi,PbU(agt)),s)\]

\end_inset


\end_layout

\begin_layout Proof
We have two sub-cases to consider.
 If 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

 then the regression rule in equation 
\begin_inset LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 gives us:
\begin_inset Formula \[
\Knows(agt,\phi,do(c,s))\equiv\Knows(agt,\phi,s)\]

\end_inset


\begin_inset Formula \[
\Knows(agt,\Pst(\phi,PbU(agt)),do(c,s))\equiv\Knows(agt,\Pst(\phi,PbU(agt)),s)\]

\end_inset


\end_layout

\begin_layout Proof
These can be directly equated using the inductive hypothesis, so the theorem
 holds in this case.
 Alternately, if 
\begin_inset Formula $Obs(agt,c,s)\neq\{\}$
\end_inset

 then the regression rule gives us:
\begin_inset Formula \begin{multline*}
\Knows(agt,\phi,do(c,s))\equiv\exists o:\, Obs(agt,c,s)=o\,\wedge\\
\Knows(agt,\forall c':\, Poss(c')\wedge Obs(agt,c')=o\,\rightarrow\,\Reg(\Pst(\phi,PbU(agt)),c'),s)\end{multline*}

\end_inset


\begin_inset Formula \begin{multline*}
\Knows(agt,\Pst(\phi,PbU(agt)),do(c,s))\equiv\exists o:\, Obs(agt,c,s)=o\,\wedge\\
\Knows(agt,\forall c':\, Poss(c')\wedge Obs(agt,c')=o\,\rightarrow\,\Reg(\Pst(\Pst(\phi,PbU(agt)),PbU(agt)),c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Simplifying the second equation using the properties of 
\begin_inset Formula $\Pst$
\end_inset

 gives:
\begin_inset Formula \begin{multline*}
\Knows(agt,\Pst(\phi,PbU(agt)),do(c,s))\equiv\exists o:\, Obs(agt,c,s)=o\,\wedge\\
\Knows(agt,\forall c':\, Poss(c')\wedge Obs(agt,c')=o\,\rightarrow\,\Reg(\Pst(\phi,PbU(agt)),c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Which matches the equivalence for 
\begin_inset Formula $\Knows(agt,\phi,do(c,s))$
\end_inset

, so the theorem holds.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "theapa"
bibfiles "../../../library/references"

\end_inset


\end_layout

\end_body
\end_document
