#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass jair
\begin_preamble

\usepackage{verbatim}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{color}
\usepackage{tikz}

\jairheading{0}{0000}{0-0}{0/0}{0/0}
\ShortHeadings{Common Knowledge, Hidden Actions, and the Frame Problem}{R. F. Kelly \& A. R. Pearce}
\firstpageno{1}

 \renewenvironment{proofsketch}{\begin{proof}[Proof Sketch]}{ For the complete proof, see Appendix \ref{sec:Complete-Proofs}. \end{proof}}

% Shortcut for formatting program snippets
\newcommand{\programinput}[1]{
  \begin{center}
  \framebox[0.85\textwidth]{
    \begin{minipage}[1\totalheight]{0.75\textwidth}{
      \footnotesize
      \verbatiminput{#1}
    }\end{minipage}
  }
  \end{center}
}
\end_preamble
\options jair,twoside,11pt,theapa,letterpaper
\language british
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Cooperative Task Execution in the Situation Calculus
\end_layout

\begin_layout Author
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Ryan F.
 Kelly 
\backslash
email rfk@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
name Adrian R.
 Pearce 
\backslash
email adrian@csse.unimelb.edu.au
\end_layout

\end_inset


\newline

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
addr Department of Computer Science and Software Engineering
\backslash

\backslash

\end_layout

\begin_layout Standard

The University of Melbourne
\backslash

\backslash

\end_layout

\begin_layout Standard

Victoria, 3010, Australia
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We investigate cooperative task execution in the situation calculus.
 It is a great paper, everyone should read it.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isdef}{\stackrel{\mbox{\tiny def}}{=}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Dt}{\mathcal{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Reg}{\mathcal{R}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\vars}[1]{\bar{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Do}{\mathbf{Do}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Lsit}{\mathcal{L}_{sitcalc}}
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus, along with the programming language Golog that is
 built upon it, has proven a powerful formalism for reasoning about dynamic
 worlds and specifying the behaviour of autonomous agents.
 It combines a rich language for expressing domain features with techniques
 for effective reasoning and a straightforward implementation using logic
 programming.
 But while powerful, applications of the situation calculus in multi-agent
 domains have typically suffered a serious limitation.
\end_layout

\begin_layout Standard
When multi-agent domains are considered, they are almost invariant assumed
 to be 
\emph on
syncrhonous
\emph default
; that is, each agent is assumed to know precisely how many actions have
 been performed in the world.
 This assumption allows the agents to reason about their world using techniques
 developed for the single-agent setting.
\end_layout

\begin_layout Standard
The fundamental unit of reasoning in the situation calculus, and the output
 of the Golog execution planning process, is the 
\emph on
situation
\emph default
: a complete, ordered history of all actions that are to be performed.
 Having to execute a totally-ordered sequence of actions is far from ideal
 in a multi-agent setting, as it requires constant synchronisation between
 the agents.
 While this may be acceptable for systems that are already restricted to
 synchronous domains, it does not take advantage of the concurrency inherent
 in a multi-agent team.
 In asynchronous domains the required synchronisation of actions may be
 impossible to achieve, and a partially-ordered representation must be used
 instead.
 But there have been no formal accounts of such a representation in the
 existing situation calculus literature.
\end_layout

\begin_layout Standard
To overcome these limitations we develop a new multi-agent variant of Golog,
 with which a team of agents can plan the cooperative execution of a shared
 task.
 The language, dubbed 
\emph on
MIndiGolog
\emph default
, is implemented on the Mozart programming platform, using its powerful
 distributed logic programming capabilities to share the planning workload
 between all members of the team.
 
\end_layout

\begin_layout Standard
For asyncrhonous domains, we provide a partially-ordered representation
 of the actions to be performed by a team of agents, that ensures synchronisatio
n is always possible based on the local information available to each agent.
 
\end_layout

\begin_layout Subsection*
Motivating Example: The Cooking Agents
\end_layout

\begin_layout Standard
Cathy is hosting a dinner party.
 A brilliant engineer but a mediocre cook, she has built a team of robotic
 chefs to help her prepare the meal, and must now program them to carry
 out their duties.
 She needs a powerful formalism with which the agents can plan their actions,
 and a programming language flexible enough to specify the major steps in
 each recipe while leaving the precise details of execution for the agents
 to plan amongst themselves.
 Moreover, she wants to specify the tasks to be performed as a single shared
 program, and have the agents automatically distribute the work amongst
 themselves in such a way that they can operate independently where possible
 and synchronise their actions only when necessary.
\newline

\end_layout

\begin_layout Standard
The situation calculus offers a compelling approach for this example domain:
 each recipe can be represented as a Golog program, and the agents can cooperate
 to plan and perform the concurrent execution of these shared programs.
 However, existing Golog implementations generate raw situation terms as
 the output of their planning process.
 These are fully-ordered sequences of the actions to be performed, requiring
 constant synchronisation if the agents are to execute them cooperatively.
\end_layout

\begin_layout Standard
In synchronous domains this is not a problem, as the agents will always
 know how many steps of execution have already been performed, and thus
 what actions should be performed next.
 But it is still desirable to take advantage of the natural concurrency
 present when planning for a team of agents.
 The Golog planning process must be modified to reason about and allow such
 concurrency.
\end_layout

\begin_layout Standard
In asynchronous domains, an agent may not necessarily know how far execution
 has progressed, and may thus be unsure when or if to perform its next action.
 The planning process should account for this by only calling for agents
 to perform an action if they will know, based on their local information,
 that the action should be performed.
 But the situation calculus currently has no means of representing this
 kind of partially-ordered action structure, or of determining whether it
 is executable.
\end_layout

\begin_layout Standard
Rather than demand that Cathy equip her robots with a global synchronisation
 mechanism of some kind, we will extend the situation calculus and the semantics
 of Golog execution planning to better handle concurrency and inter-agent
 synchronisation in asynchronous, partially-observable domains.
\end_layout

\begin_layout Standard
The paper proceeds as follows....TODO
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Subsection
The Multi-Agent Situation Calculus
\begin_inset LatexCommand label
name "sec:The-Multi-Agent-Situation"

\end_inset


\end_layout

\begin_layout Standard
Our work utilises the situation calculus 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 with multiple agents 
\begin_inset LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

 and concurrent actions 
\begin_inset LatexCommand citep
key "reiter96sc_nat_conc"

\end_inset

.
 A brief overview is presented below.
 Readers familiar with the situation calculus should note the following:
 our generalisation of the 
\begin_inset Formula $Poss$
\end_inset

 fluent to action description predicates; and our use of the single-step
 variant of the regression operator;
\end_layout

\begin_layout Subsubsection
Notation and Axioms
\begin_inset LatexCommand label
name "sub:Notation-and-Axioms"

\end_inset


\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change, with the initiating agent indicated by
 their first argument; 
\noun on
Concurrent
\noun default
 terms are sets of actions that occur simultaneously; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Concurrent\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\emph on
Fluents
\emph default
 are predicates or functions that represent properties of the world that
 may change between situations; they take a situation term as their final
 argument.
\end_layout

\begin_layout Standard
Throughout the paper we will present examples from a simple multi-agent
 domain, in which two agents Ann and Bob are attending a party.
 The location of the party (the fluent 
\begin_inset Formula $loc(s)$
\end_inset

) is either 
\begin_inset Formula $C$
\end_inset

 or 
\begin_inset Formula $D$
\end_inset

 but they do not know which, and they have just received an invitation telling
 them the location of the party.
 Each agent may read the invitation (the action 
\begin_inset Formula $read$
\end_inset

) and leave/enter the room (the actions 
\begin_inset Formula $leave$
\end_inset

 and 
\begin_inset Formula $enter$
\end_inset

) at any time.
 Some example formulae from this domain are: 
\begin_inset Quotes eld
\end_inset

Ann is in the room initially
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

Bob is not in the room after leaving it
\begin_inset Quotes erd
\end_inset

.
 Written formally:
\begin_inset Formula \begin{gather*}
InRoom(Ann,S_{0})\\
\neg InRoom(Bob,do(leave(Bob),S_{0}))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The dynamics of a particular domain are captured by a set of sentences called
 a 
\emph on
basic action theory
\emph default
.
 Queries about the behaviour of the world are posed as logical entailment
 queries relative to this theory.
\end_layout

\begin_layout DefinitionLbld
Basic\InsetSpace ~
Action\InsetSpace ~
Theory A basic action theory, denoted 
\begin_inset Formula $\Dt$
\end_inset

, is a set of situation calculus sentences (of the specific syntactic form
 outlined below) describing a particular dynamic world.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); unique names axioms for actions (
\begin_inset Formula $\Dt_{una}$
\end_inset

); action description axioms defining preconditions etc for each action
 (
\begin_inset Formula $\Dt_{ad}$
\end_inset

); successor state axioms describing how primitive fluents change between
 situations (
\begin_inset Formula $\Dt_{ssa}$
\end_inset

); and axioms describing the value of primitive fluents in the initial situation
 (
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{una}\cup\Dt_{ad}\cup\Dt_{ssa}\cup\Dt_{S_{0}}\]

\end_inset


\end_layout

\begin_layout Standard
These axioms must satisfy some simple consistency criteria to constitute
 a valid domain description 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 We assume an arbitrary, but fixed, basic action theory.
\end_layout

\begin_layout Standard
The 
\emph on
uniform formulae
\emph default
 can be thought of as properties of the state of the world.
 They are basically logical combinations of fluents referring to a common
 situation term.
 For the moment we restrict ourselves to 
\emph on
objective
\emph default
 uniform formulae; the complete definition includes statements about knowledge
 and will be introduced in the next section.
\end_layout

\begin_layout DefinitionLbld
Objective\InsetSpace ~
Uniform\InsetSpace ~
Formulae Let 
\begin_inset Formula $s$
\end_inset

 be a fixed situation term, 
\begin_inset Formula $F$
\end_inset

 an arbitrary fluent, 
\begin_inset Formula $\vars{x}$
\end_inset

 a vector of terms mentioning no situation term other than 
\begin_inset Formula $s$
\end_inset

, and 
\begin_inset Formula $y$
\end_inset

 a variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the objective formulae uniform in 
\begin_inset Formula $s$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists y:\phi\,|\,\forall y:\phi\]

\end_inset


\end_layout

\begin_layout Standard
The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout this paper to refer to an arbitrary uniform formula.
 Since they represent properties of the world, it is often useful to evaluate
 uniform formulae at several different situation terms.
 We will frequently suppress the situation term in 
\begin_inset Formula $\phi$
\end_inset

 to simplify the presentation.
 The notation 
\begin_inset Formula $\phi[s']$
\end_inset

 represents a uniform formula with the particular situation 
\begin_inset Formula $s'$
\end_inset

 inserted into all its fluents, while 
\begin_inset Formula $\phi^{-1}$
\end_inset

 represents a uniform formula with the situation argument removed from all
 its fluents.
\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{una}$
\end_inset

 restricts action terms to a finite number of action types, and ensures
 that actions with different types or different arguments are in fact different.
 The function 
\begin_inset Formula $actor(a)$
\end_inset

 gives the agent performing an action, which is always the action's first
 argument.
\newline

\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 contains one 
\emph on
successor state axiom
\emph default
 for each primitive fluent in the domain, providing a monotonic solution
 to the frame problem for that fluent.
 These axioms have the following general form
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow standard naming conventions for the situation calculus: lower-case
 roman names indicate variables, and free variables are implicitly universally
 quantified at the outermost scope
\end_layout

\end_inset

: 
\begin_inset Formula \[
F(\vars{x},do(c,s))\equiv\Phi_{F}^{+}(\vars{x},c,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi_{F}^{+}$
\end_inset

 and 
\begin_inset Formula $\Phi_{F}^{-}$
\end_inset

 are formulae uniform in 
\begin_inset Formula $s$
\end_inset

.
 This may be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after performing 
\begin_inset Formula $c$
\end_inset

 if 
\begin_inset Formula $c$
\end_inset

 made it true, or it was previously true and 
\begin_inset Formula $c$
\end_inset

 did not make it false
\begin_inset Quotes erd
\end_inset

.
\newline

\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 generalises the standard 
\emph on
action precondition axioms
\emph default
 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 to define fluents describing various aspects of the performance of an action,
 which we call 
\emph on
action description predicates
\emph default
.
 The predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 is the canonical example, indicating whether it is possible to perform
 an action in a given situation.
 For example, it is only possible for an agent to leave the room if they
 are actually in it:
\begin_inset Formula \[
Poss(leave(agt),s)\equiv InRoom(agt,s)\]

\end_inset


\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains one axiom of the form 
\begin_inset Formula $Poss(A(\vars{x}),s)\equiv\Phi_{Poss}^{A}(\vars{x},s)$
\end_inset

 for each type of action 
\begin_inset Formula $A$
\end_inset

.
 These are combined into a generalised 
\begin_inset Formula $Poss$
\end_inset

 axiom for sets of concurrent actions, which in its simplest form is just:
\begin_inset Formula \[
Poss(c,s)\equiv c\neq\{\}\,\wedge\,\forall a\in c:\, Poss(a,s)\]

\end_inset

Note that it is never possible to perform an empty set of actions.
 In more complex domains actions may interact, so that they cannot be performed
 concurrently even if possible individually.
 We assume that 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains an appropriate axiomatisation of such interaction; 
\begin_inset LatexCommand citet
key "pinto94temporal"

\end_inset

 provides a full discussion of this issue;
\end_layout

\begin_layout Standard
In principle any number of predicates and functions can be defined in this
 way, and we will use the meta-variable 
\begin_inset Formula $\alpha$
\end_inset

 to represent an arbitrary action description predicate.
 Forthcoming examples include the sensing-result function 
\begin_inset Formula $SR(a,s)$
\end_inset

 of Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Sensing"

\end_inset

 and the observability predicate 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 of Section 
\begin_inset LatexCommand ref
reference "sub:Knowledge-and-Observation"

\end_inset

.
\end_layout

\begin_layout Standard
We assume that these definitions are finitely enumerable and well-founded,
 allowing them to be expanded down to primitive fluents even when they refer
 to an action variable.
 For example, we assume that 
\begin_inset Formula $Poss(a,s)$
\end_inset

 can be replaced by an enumeration over action types such as the following:
\begin_inset Formula \[
Poss(a,s)\equiv\,\, a=A_{1}(\vars{x}_{1})\wedge\Phi_{Poss}^{A_{1}}(\vars{x}_{1},s)\,\vee\,\dots\,\vee a=A_{n}(\vars{x}_{n})\wedge\Phi_{Poss}^{A_{n}}(\vars{x}_{n},s)\]

\end_inset


\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 ensure that situations form a branching-time account of the world state.
 There are initial situations identified by the predicate 
\begin_inset Formula $Init(s)$
\end_inset

, and a distinguished initial situation 
\begin_inset Formula $S_{0}$
\end_inset

 called the 
\emph on
actual 
\emph default
initial situation.
 Other initial situations are used to represent the agents' epistemic uncertaint
y, and will be discussed in the following section.
 Situations in general form a tree structure with an initial situation at
 the root and 
\begin_inset Formula $do(c,s)$
\end_inset

 constructing the successor situation resulting when the actions 
\begin_inset Formula $c$
\end_inset

 are performed in 
\begin_inset Formula $s$
\end_inset

.
 We abbreviate the performance of several successive actions by writing:
\begin_inset Formula \[
do([c_{1},\dots,c_{n}],s)\,\isdef\, do(c_{n},do(\dots,do(c_{1},s)))\]

\end_inset


\end_layout

\begin_layout Standard
The relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 indicates that 
\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset

 and is defined as follows:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg(s'\sqsubset s)\\
s\sqsubset do(c,s')\equiv s\sqsubseteq s'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 There is also a second-order induction axiom asserting that all situations
 must be constructed in this way, which is needed to prove statements that
 universally quantify over situations
\end_layout

\begin_layout Standard
This notation for 
\begin_inset Quotes eld
\end_inset

in the future of
\begin_inset Quotes erd
\end_inset

 can be extended to consider only those futures in which all actions satisfy
 a particular action description predicate.
 We include a relation 
\begin_inset Formula $<_{\alpha}$
\end_inset

 for each action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, with the following definitions:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg\left(s'<_{\alpha}s\right)\\
s<_{\alpha}do(c,s')\equiv s\leq_{\alpha}s'\wedge\alpha(c,s')\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
legal situations
\emph default
 are those in which every action was possible to perform in the preceding
 situation.
 These are of fundamental importance, as they are the only situations that
 could be reached in the real world.
 The 
\emph on
root
\emph default
 of a situation is the initial situation from which it was constructed:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\, root(s)=s\\
root(do(c,s))=root(s)\\
Legal(s)\,\equiv\, root(s)\leq_{Poss}s\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The set 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 describes the actual state of the world before any actions are performed.
 It is a collection of sentences of the form 
\begin_inset Formula $\phi[S_{0}]$
\end_inset

 stating what holds in the actual initial situation.
 It also defines the initial knowledge of each agent, as described in the
 next section.
\end_layout

\begin_layout Subsubsection
Reasoning and Regression
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 These are generally based on syntactic manipulation of a query into a form
 that is more amenable to reasoning -- for example, because it can be proven
 without using some of the axioms from 
\begin_inset Formula $\Dt$
\end_inset

.
\end_layout

\begin_layout Standard
In the general case, answering a query about a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 is a theorem-proving task in second-order logic (denoted SOL) due to the
 induction axiom included in the foundational axioms.
 This is clearly problematic for effective automated reasoning, but fortunately
 there exist particular syntactic forms for which some of the axioms in
 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 In particular, queries about the initial situation can be answered using
 only first-order logic (FOL) and a limited set of axioms:
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\phi[S_{0}]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{una}\models_{FOL}\phi[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Since the axioms 
\begin_inset Formula $\Dt_{S_{0}}\cup\Dt_{una}$
\end_inset

 often satisfy the closed-world assumption, provers such as Prolog can be
 employed to handle this type of query quite effectively.
 Effective reasoning depends on transforming queries into more easily-handled
 forms such as this.
 
\newline

\end_layout

\begin_layout Standard
The principle tool for effective reasoning in the situation calculus is
 the regression meta-operator 
\begin_inset Formula $\Reg_{\Dt}$
\end_inset

 
\begin_inset LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

, a syntactic manipulation that can transform a formula uniform in 
\begin_inset Formula $do(c,s)$
\end_inset

 into an equivalent formula that is uniform in 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\phi[do(c,s)]\equiv\Reg_{\Dt}(\phi[do(c,s)])[s]\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\Dt$
\end_inset

 is fixed, we drop the subscript and simply write 
\begin_inset Formula $\Reg$
\end_inset

 for regression.
 Its operation is defined by a set of 
\emph on
regression rules
\emph default
 such as those shown below:
\begin_inset Formula \begin{align*}
\Reg(\phi_{1}\wedge\phi_{2})\isdef & \,\,\,\Reg(\phi_{1})\wedge\Reg(\phi_{2})\\
\Reg(Poss(a,s))\isdef & \,\,\, a=A{}_{1}(\vars{x}_{1})\wedge\Reg(\Phi_{Poss}^{A_{1}}(\vars{x}_{1},s))\,\vee\,\dots\,\vee\, a=A_{n}(\vars{x}_{n})\wedge\Reg(\Phi_{Poss}^{A_{n}}(\vars{x}_{n},s))\\
\Reg(F(\vars{x},do(c,s)))\isdef & \,\,\,\Phi_{F}^{+}(\vars{x},c,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},c,s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Each application of the regression operator replaces action description
 predicates with their definitions from 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and primitive fluents with their successor state axioms from 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

, 
\begin_inset Quotes eld
\end_inset

unwinding
\begin_inset Quotes erd
\end_inset

 a single action from each situation term in the query.
\end_layout

\begin_layout Standard
Repeated applications of this operator, denoted by 
\begin_inset Formula $\Reg^{*}$
\end_inset

, can transform a query about some future situation into a query about the
 initial situation only, which is much easier to answer.
 The axioms 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 are essentially 
\begin_inset Quotes eld
\end_inset

compiled into
\begin_inset Quotes erd
\end_inset

 the query.
 The trade-off is that the length of the regressed query may be exponential
 in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice 
\begin_inset LatexCommand citep
key "levesque97golog,pirri99contributions_sitcalc"

\end_inset

.
\end_layout

\begin_layout Standard
When dealing with situation-suppressed uniform formulae, we will use a two-argum
ent operator 
\begin_inset Formula $\Reg(\phi,c)$
\end_inset

 to indicate the regression of 
\begin_inset Formula $\phi$
\end_inset

 over the action 
\begin_inset Formula $c$
\end_inset

.
 It should be read as a shorthand for 
\begin_inset Formula $\Reg(\phi[do(c,s)])^{-1}$
\end_inset

 using the situation-suppression operator from Section 
\begin_inset LatexCommand ref
reference "sub:Notation-and-Axioms"

\end_inset

.
\end_layout

\begin_layout Subsection
Golog
\end_layout

\begin_layout Standard
Golog is a declarative agent programming language that is the standard approach
 to specifying complex behaviours in the situation calculus 
\begin_inset LatexCommand citep
key "levesque97golog"

\end_inset

.
 Testimony to its success are its wide range of applications and many extensions
 to provide additional functionality 
\begin_inset LatexCommand citep
key "giacomo00congolog,giacomo99indigolog,Ferrein2005readylog"

\end_inset

.
 For simplicity, we use the general name 
\begin_inset Quotes eld
\end_inset

Golog
\begin_inset Quotes erd
\end_inset

 to refer to the standard family of languages based on this technique, including
 ConGolog 
\begin_inset LatexCommand citep
key "giacomo00congolog"

\end_inset

 and IndiGolog 
\begin_inset LatexCommand citep
key "giacomo99indigolog"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Notation
\end_layout

\begin_layout Standard
To program an agent using Golog one specifies a situation calculus theory
 of action, and a program consisting of actions from the theory connected
 by programming constructs such as if-then-else, while loops, and nondeterminist
ic choice.
 Table 
\begin_inset LatexCommand ref
reference "tbl:Background:Golog-Operators"

\end_inset

 lists the standard operators available in various incarnations of the language.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Operator 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Meaning
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $Nil$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
The empty program
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $a$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute action 
\begin_inset Formula $a$
\end_inset

 in the world
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\phi?$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Proceed if condition 
\begin_inset Formula $\phi$
\end_inset

 is true
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1};\delta_{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta_{1}$
\end_inset

followed by 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}|\delta_{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute either 
\begin_inset Formula $\delta_{1}$
\end_inset

 or 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\pi(x,\delta(x))$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nondet.
 select arguments for 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta*$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 zero or more times
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Exec.
 
\begin_inset Formula $\delta_{1}$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 holds, 
\begin_inset Formula $\delta_{2}$
\end_inset

 otherwise
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{while\,}\phi\mathbf{\, do}\,\delta$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 while 
\begin_inset Formula $\phi$
\end_inset

 holds
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Procedure definition
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Concurrent execution
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}\ll\delta_{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Prioritised concurrency
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta^{||}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Concurrent iteration
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\Sigma(\delta)$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Plan execution offline
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Operators used in Golog and its descendants 
\begin_inset LatexCommand label
name "tbl:Background:Golog-Operators"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Readers familiar with dynamic logic will recognise some of these operators,
 but others are unique to first-order formalisms such as Golog.
 Many Golog operators are nondeterministic and may be executed in several
 different ways.
 It is the task of the agent to plan a deterministic instantiation of the
 program, a sequence of actions that can legally be performed in the world.
 Such a sequence is called a 
\emph on
legal execution
\emph default
 of the program.
\end_layout

\begin_layout Standard
To get a feel for how these operators can be used, consider some example
 programs.
 Figure 
\begin_inset LatexCommand ref
reference "fig:Background:Golog:Washing-Dishes"

\end_inset

 shows a simple program for Jim to wash the dishes.
 It makes use of the nondeterministic 
\begin_inset Quotes eld
\end_inset

pick
\begin_inset Quotes erd
\end_inset

 operator to select and clean a dish that needs washing, and does so in
 a loop until no dirty dishes remain.
 The legal executions of this program are sequences of 
\begin_inset Formula $clean(Jim,d)$
\end_inset

 actions, one for each dirty dish in the domain, performed in any order.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "85col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{flalign*}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
mathbf
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

while
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

\InsetSpace \thinspace{}

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
exists
\end_layout

\end_inset

 d:\InsetSpace \thinspace{}
 Dirty(d)\InsetSpace \thinspace{}

\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
mathbf
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

do
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\newline
 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
pi
\end_layout

\end_inset

(d,\InsetSpace \thinspace{}
 clean(Jim,d))
\newline
 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
mathbf
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

end
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{flalign*}
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A Golog program for washing the dishes
\begin_inset LatexCommand label
name "fig:Background:Golog:Washing-Dishes"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:Background:Golog:MakeSalad"

\end_inset

 shows a program that we will return to in subsequent chapters, giving instructi
ons for how to prepare a simple salad.
 The procedure 
\begin_inset Formula $ChopTypeInto$
\end_inset

 (not shown) directs the specified agent to acquire an ingredient of the
 specified type, chop it, and place it into the indicated bowl.
 The procedure 
\begin_inset Formula $MakeSalad$
\end_inset

 nondeterministically selects an agent to do this for a lettuce, a carrot,
 and a tomato.
 Note the nondeterminism in this program: the agent assigned to handling
 each ingredient is not specified (
\begin_inset Formula $\pi$
\end_inset

 construct), nor is the order in which they should be processed (
\begin_inset Formula $||$
\end_inset

 construct).
 There is thus considerable scope for cooperation between agents to effectively
 carry out this task.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "85col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset Formula \begin{gather*}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt,ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt,ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt,ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt,\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
endTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right])\,\,\mathbf{end}\end{gather*}

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A Golog program for making a salad
\begin_inset LatexCommand label
name "fig:Background:Golog:MakeSalad"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Semantics
\end_layout

\begin_layout Standard
The original semantics of Golog were defined using macro-expansion 
\begin_inset LatexCommand citep
key "levesque97golog"

\end_inset

.
 The macro 
\begin_inset Formula $\Do(\delta,s,s')$
\end_inset

 was defined to be true if program 
\begin_inset Formula $\delta$
\end_inset

 could be successfully executed in situation 
\begin_inset Formula $s$
\end_inset

, leaving the world in situation 
\begin_inset Formula $s'$
\end_inset

.
 However, these semantics could not support the concurrent execution of
 two programs and were modified with the introduction of ConGolog 
\begin_inset LatexCommand citep
key "giacomo00congolog"

\end_inset

 to use two predicates 
\begin_inset Formula $Trans(\delta,s,\delta',s')$
\end_inset

 and 
\begin_inset Formula $Final(\delta,s)$
\end_inset

 which are capable of representing single steps of execution of the program.
\end_layout

\begin_layout Standard
The predicate 
\begin_inset Formula $Trans(\delta,s,\delta',s')$
\end_inset

 holds when executing a step of program 
\begin_inset Formula $\delta$
\end_inset

 can cause the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to situation 
\begin_inset Formula $s'$
\end_inset

, after which 
\begin_inset Formula $\delta'$
\end_inset

 remains to be executed.
 It thus characterises single steps of computation.
 The predicate 
\begin_inset Formula $Final(\delta,s)$
\end_inset

 holds when program 
\begin_inset Formula $\delta$
\end_inset

 may legally terminate its execution in situation 
\begin_inset Formula $s$
\end_inset

.
 We base our work on the semantics of IndiGolog 
\begin_inset LatexCommand citep
key "giacomo99indigolog"

\end_inset

, which builds on ConGolog 
\begin_inset LatexCommand citep
key "giacomo00congolog"

\end_inset

 and is the most feature-full of the standard Golog variants.
 The full semantics are available in the references, but we present some
 illustrative examples below.
\end_layout

\begin_layout Standard
The transition rule for a program consisting of a single action is straightforwa
rd -- it transitions by performing the action, provided it is possible in
 the current situation.
 Such a program may not terminate its execution since the action remains
 to be performed:
\begin_inset Formula \begin{alignat*}{1}
Trans(a,s,\delta',s')\,\equiv\, & \, Poss(a,s)\wedge\delta'=Nil\wedge s'=do(a,s)\\
Final(a,s)\,\equiv\, & \,\bot\end{alignat*}

\end_inset


\end_layout

\begin_layout Standard
The transition rule for a test operator proceeds only if the test is true,
 leaving the situation unchanged, and likewise cannot terminate execution
 until the test has been satisfied:
\begin_inset Formula \begin{alignat*}{1}
Trans(?\phi,s,\delta',s')\,\equiv\, & \,\phi[s]\wedge\delta'=Nil\wedge s'=s\\
Final(?\phi,s)\,\equiv\, & \,\bot\end{alignat*}

\end_inset


\end_layout

\begin_layout Standard
Now consider a simple nondeterministic operator, the 
\begin_inset Quotes eld
\end_inset

choice
\begin_inset Quotes erd
\end_inset

 construct that executes one of two alternate programs:
\begin_inset Formula \begin{alignat*}{1}
Trans(\delta_{1}|\delta_{2},s,\delta',s')\,\equiv\, & \, Trans(\delta_{1},s,\delta',s')\,\vee\, Trans(\delta_{2},s,\delta',s')\\
Final(\delta_{1}|\delta_{2},s)\,\equiv\, & \, Final(\delta_{1},s)\,\vee\, Final(\delta_{2},s)\end{alignat*}

\end_inset


\end_layout

\begin_layout Standard
It is possible for this operator to transition in two different ways - by
 executing a step of execution from the first program, or a step of execution
 from the second program.
 Slightly more complicated, but of fundamental important in the next chapter,
 is the semantics of the concurrency operator:
\begin_inset Formula \begin{alignat*}{1}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\,\equiv\, & \,\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\,\wedge\,\delta'=(\gamma||\delta_{2})\\
 & \,\vee\,\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\,\wedge\,\delta'=(\delta_{1}||\gamma)\\
Final(\delta_{1}||\delta_{2},s)\,\equiv\, & \, Final(\delta_{1},s)\,\wedge\, Final(\delta_{2},s)\end{alignat*}

\end_inset


\end_layout

\begin_layout Standard
This rule specifies the concurrent-execution operator as an 
\emph on
interleaving
\emph default
 of computation steps.
 It states that it is possible to single-step the concurrent execution of
 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

 by performing either a step from 
\begin_inset Formula $\delta_{1}$
\end_inset

 or a step from 
\begin_inset Formula $\delta_{2}$
\end_inset

, with the remainder 
\begin_inset Formula $\gamma$
\end_inset

 left to execute concurrently with the other program
\end_layout

\begin_layout Standard
Clearly there are two notions of concurrency to be considered in the situation
 calculus: the possibility of performing several actions at the same instant
 (
\emph on
true concurrency
\emph default
), and the possibility of interleaving the execution of several programs
 (
\emph on
interleaved concurrency
\emph default
).
 
\begin_inset LatexCommand citet
key "pinto99tcongolog"

\end_inset

 have modified ConGolog to incorporate sets of concurrent actions in an
 attempt to integrate these two forms of concurrency.
 However, their semantics may call for actions to be performed that are
 not possible and can also produce unintuitive program behaviour in some
 cases.
 A key aspect of our work in Chapter 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

 is a robust integration of these two notions of concurrency.
\newline

\end_layout

\begin_layout Standard
We have omitted many details here that are not relevant to this thesis,
 such as the second-order axioms necessary to handle recursive procedure
 definitions.
 We will denote by 
\begin_inset Formula $\Dt_{golog}$
\end_inset

 the standard axioms defining 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 
\begin_inset LatexCommand citep
key "giacomo00congolog,giacomo99indigolog"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Execution Planning
\begin_inset LatexCommand label
name "sec:Background:Golog-Exec-Planning"

\end_inset


\end_layout

\begin_layout Standard
Planning an execution of a Golog program 
\begin_inset Formula $\delta$
\end_inset

 can be reduced to a theorem proving task as shown in equation (
\begin_inset LatexCommand ref
reference "eqn:Background:golog_execution"

\end_inset

).
 Here 
\begin_inset Formula $Trans^{*}$
\end_inset

 indicates the standard second-order definition for the reflexive transitive
 closure of 
\begin_inset Formula $Trans$
\end_inset

.
\begin_inset Formula \begin{equation}
\Dt\cup\Dt_{golog}\models\exists s,\delta':\,\left[Trans^{*}(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]\label{eqn:Background:golog_execution}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
A constructive proof of this query would produce an instantiation of 
\begin_inset Formula $s$
\end_inset

, a situation term giving a sequence of actions constituting a legal execution
 of the program.
 These actions are then executed one-by-one in the world.
 Since the program remaining after termination is often not important, the
 macro 
\begin_inset Formula $\Do$
\end_inset

 is re-defined in terms of 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 to specify only the resulting situation:
\begin_inset Formula \[
\Do(\delta,s,s')\isdef\exists\delta':\, Trans^{*}(\delta,s,\delta',s')\wedge Final(\delta',s')\]

\end_inset


\end_layout

\begin_layout Standard
In the original Golog and in ConGolog this forms the entirety of the execution
 planning process, as these variants require a full legal execution to be
 planned before any actions are performed in the world.
 This is referred to as 
\emph on
offline execution
\emph default
.
 The Golog execution algorithm is presented in Algorithm 
\begin_inset LatexCommand ref
reference "alg:golog_exec"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
The Golog/ConGolog Execution Algorithm for program 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:golog_exec"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{algorithmic}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Find a situation 
\begin_inset Formula $s$
\end_inset

 such that:
\begin_inset Formula \[
\Dt\cup\Dt_{golog}\models\exists s:\,\Do(\delta,S_{0},s)\]

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
FOR
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

each action in the resulting situation term
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 execute that action 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
ENDFOR
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{algorithmic}
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By contrast, IndiGolog allows agents to proceed without planning a full
 terminating execution of their program, instead searching for a legal next
 step 
\begin_inset Formula $a$
\end_inset

 in the current situation 
\begin_inset Formula $\sigma$
\end_inset

 such that:
\begin_inset Formula \[
\Dt\cup\Dt_{golog}\,\models\,\exists a,\delta':\, Trans^{*}(\delta,\sigma,\delta',do(a,\sigma))\]

\end_inset


\end_layout

\begin_layout Standard
This next step is then performed immediately, and the process repeats until
 a terminating configuration is reached.
 This is referred to as 
\emph on
online execution
\emph default
.
 The IndiGolog execution algorithm is presented in Algorithm 
\begin_inset LatexCommand ref
reference "alg:indigolog_exec"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
The IndiGolog Execution Algorithm for program 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:indigolog_exec"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{algorithmic}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\sigma\ \Leftarrow\ S_{0}$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
WHILE
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset


\begin_inset Formula $\Dt\cup\Dt_{golog}\not\models Final(\delta,\sigma)$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Find an action 
\begin_inset Formula $a$
\end_inset

 and program 
\begin_inset Formula $\delta'$
\end_inset

 such that: 
\begin_inset Formula \[
\Dt\cup\Dt_{golog}\models Trans^{*}(\delta,\sigma,\delta',do(a,\sigma))\]

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Execute the action 
\begin_inset Formula $a$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\sigma\ \Leftarrow\ do(a,\sigma)$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\delta\ \Leftarrow\ \delta'$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
ENDWHILE
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{algorithmic}
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to incorporate planning into this execution algorithm, IndiGolog
 introduces an explicit 
\begin_inset Quotes eld
\end_inset

search
\begin_inset Quotes erd
\end_inset

 operator 
\begin_inset Formula $\Sigma(\delta)$
\end_inset

, which can only make a transition if the program is guaranteed to eventually
 terminate successfully:
\begin_inset Formula \[
Trans(\Sigma(\delta),s,\delta',s')\equiv\exists s'',\delta'':\, Trans(\delta,s,\delta'',s')\wedge\mathbf{Do}(\delta'',s',s'')\wedge\delta'=\Sigma(\delta'')\]

\end_inset


\end_layout

\begin_layout Standard
This approach gives the programmer powerful control over the amount of non-deter
minism in the program, and the amount of planning required to find a legal
 execution.
 It also allows the programmer to avoid planning over sensing actions, which
 can cause an exponential blowup in planning complexity.
 Sensing actions are simply performed outside the scope of a search operator.
\end_layout

\begin_layout Subsubsection
Multi-Agent Domains
\end_layout

\begin_layout Standard
There are two basic approaches to the use of Golog in a multi-agent setting.
 The first, and most common, is to assign each agent its own individual
 Golog program.
 The behaviour of the overall system is then defined as the concurrent execution
 of the individual agent's programs:
\begin_inset Formula \[
\delta=\delta_{agt1}\,||\,\delta_{agt2}\,||\,\dots\,||\,\delta_{agtN}\]

\end_inset


\end_layout

\begin_layout Standard
This is the approach followed by TeamGolog 
\begin_inset LatexCommand citep
key "farinelli07team_golog"

\end_inset

 and the Cognitive Agents Specification Language 
\begin_inset LatexCommand citep
key "shapiro02casl"

\end_inset

, along with earlier work in a similar vein 
\begin_inset LatexCommand citep
key "lesperance99modeling"

\end_inset

.
 In such a setting, the agents do not necessarily cooperate or coordinate
 their actions, and it is assumed that any legal execution of the combined
 agent programs is a possible evolution of the entire system.
\end_layout

\begin_layout Standard
The second approach, and the one we follow here, is to have all agents cooperate
 to plan and perform the joint execution of a single, shared program.
 This program would typically be the concurrent execution of several shared
 tasks:
\begin_inset Formula \[
\delta=\delta_{task1}\,||\,\delta_{task2}\,||\,\dots\,||\,\delta_{taskN}\]

\end_inset


\end_layout

\begin_layout Standard
This is the approach taken by the Golog variant 
\begin_inset Quotes eld
\end_inset

ReadyLog
\begin_inset Quotes erd
\end_inset

 developed by 
\begin_inset LatexCommand citet
key "Ferrein2005readylog"

\end_inset

 to control the behaviour of a RoboCup soccer team.
\end_layout

\begin_layout Standard
The one-program-per-agent approach can be considered a special case of the
 shared-task approach, one which does not require coordination or cooperation
 between team members.
 So while we focus exclusively on the cooperative execution of a shared
 task in this and subsequent chapters, the techniques we develop are likely
 to have application in the case of multiple individual control programs
 as well.
\end_layout

\begin_layout Standard
While 
\begin_inset LatexCommand citeauthor
key "Ferrein2005readylog"

\end_inset

 focus on decision-theoretic planning rather than the rich domain extensions
 we consider below, the execution algorithm they have developed for ReadyLog
 provides an excellent introduction to the cooperative execution of Golog
 programs.
 It is presented in Algorithm 
\begin_inset LatexCommand ref
reference "alg:readylog_exec"

\end_inset

.
\end_layout

\begin_layout Standard
The aim of the ReadyLog execution algorithm is to allow agents to coordinate
 their actions without the need for explicit communication.
 Each agent is given their own individual copy of the shared program, and
 they each independently execute the IndiGolog planning process to determine
 the next step of execution.
 When an agent finds a next step where the action is to be performed by
 the agent itself, it executes the action immediately.
 When the next action is to be performed by another agent, it waits for
 its teammate to execute the action before proceeding to the next step.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
The ReadyLog Execution Algorithm for program 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:readylog_exec"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\sigma\ \Leftarrow\ S_{0}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
WHILE
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset


\begin_inset Formula $\Dt\cup\Dt_{golog}\not\models Final(\delta,s)$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Find an action 
\begin_inset Formula $a$
\end_inset

 and program 
\begin_inset Formula $\delta'$
\end_inset

 such that:
\begin_inset Formula \[
\Dt\cup\Dt_{golog}\models Trans^{*}(\delta,\sigma,\delta',do(a,\sigma))\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
IF
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

the action is to be performed by me
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Execute the action 
\begin_inset Formula $a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
ELSE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Wait for the action to be executed
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
ENDIF
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\sigma\ \Leftarrow\ do(a,\sigma)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\delta\ \Leftarrow\ \delta'$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
ENDWHILE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{algorithmic}
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Coordination arises in this setting by ensuring that the agents use identical
 theorem provers (in the case of 
\begin_inset LatexCommand citep
key "Ferrein2005readylog"

\end_inset

, identical Prolog interpreters) to determine each program step, which will
 generate candidate solutions in the same order for each agent.
 So although each agent plans the program execution steps independently,
 they are guaranteed to plan the 
\emph on
same
\emph default
 execution steps and their actions will therefore be coordinated without
 needing to communicate.
\end_layout

\begin_layout Standard
However, the semantics of ReadyLog remain largely single-agent and do not
 address concerns such as the possibility of performing actions concurrently,
 sharing the computational workload of planning, or predicting the behaviour
 of team members and the environment in the face of many concurrently-executing
 tasks.
\end_layout

\begin_layout Subsubsection
Extensions
\end_layout

\begin_layout Standard
There have been a wide range of Golog extensions developed which we will
 not consider in this thesis.
 Among them have been extensions to include decision-theoretic 
\begin_inset LatexCommand citep
key "boutilier00dtgolog"

\end_inset

 and game-theoretic aspects 
\begin_inset LatexCommand citep
key "finzi03gtgolog,finzi05pogtgolog"

\end_inset

, additional control operators such as partially-ordered sequences of actions
 
\begin_inset LatexCommand citep
key "son00htn_golog"

\end_inset

 and hierarchical task networks 
\begin_inset LatexCommand citep
key "Gabaldon02htn_in_golog,Son04golog+htn+time"

\end_inset

, synchronisation between the individual programs of a team of agents 
\begin_inset LatexCommand citep
key "farinelli07team_golog"

\end_inset

, and accounting for continuous change and event triggering 
\begin_inset LatexCommand citep
key "grosskreutz00ccgolog"

\end_inset

.
\end_layout

\begin_layout Standard
While we will not consider these Gologs in any detail, we do note that each
 has been a relatively straightforward matter of extending the underlying
 situation calculus theory and/or the semantics of the Golog operators,
 and as a result there has been rich cross-pollination between these different
 works.
 We therefore hope that our work may in turn be combined with some of these
 extensions to provide an even richer formalism.
\end_layout

\begin_layout Subsection
Mozart/Oz
\begin_inset LatexCommand label
name "sec:Background:Mozart/Oz"

\end_inset


\end_layout

\begin_layout Standard
One of the main advantages of the situation calculus and Golog are their
 straightforward implementation as a logic program.
 As the dominant implementation of the logic programming paradigm, Prolog
 is typically used for such implementations.
 In this thesis we use Mozart, a multi-paradigm programming system with
 some unique features that are particularly suited to our work.
\end_layout

\begin_layout Standard
The Mozart system 
\begin_inset LatexCommand citep
key "vanroy99mozart"

\end_inset

 is an implementation of the Oz programming language 
\begin_inset LatexCommand citep
key "vanRoyHaridi04ctm"

\end_inset

 with strong support for logic programming and distributed computing.
 While a full explanation of its features is well outside the scope of this
 thesis, we provide a short introduction to the subset of its features we
 will be using -- in particular, doing Prolog-style logic programming in
 Oz.
 Familiarity with logic programming in the style of Prolog is assumed.
\end_layout

\begin_layout Standard
Terms, variables and unification in Oz work similarly to Prolog, although
 arguments in compound terms are separated by whitespace rather than a comma.
 Predicates are implemented as ordinary procedures, so all clauses for a
 predicate must be contained in a single procedure.
 Figure 
\begin_inset LatexCommand ref
reference "fig:Background:Naive-List-Reverse"

\end_inset

 shows an Oz implementation of a classic Prolog example predicate, naive
 list reverse.
\end_layout

\begin_layout Standard
Some things to note about this example include:
\end_layout

\begin_layout Itemize
The syntax for procedure definition is 
\begin_inset Formula $\mathbf{proc}\,\{Name\, Arg\,\dots\,\}\,\, Body\,\,\mathbf{end}$
\end_inset

 
\end_layout

\begin_layout Itemize
The syntax for procedure calls is 
\begin_inset Formula $\{Name\, Arg\,\dots\,\}$
\end_inset

 
\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $\mathbf{case}$
\end_inset

 statement is used to pattern-match the contents of a variable 
\end_layout

\begin_layout Itemize
Local variables must be explicitly introduced using the keyword 
\begin_inset Formula $\mathbf{in}$
\end_inset

 
\end_layout

\begin_layout Itemize
Mozart separates functionality into modules, such as 
\begin_inset Formula $List$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/oz-examples/Reverse.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Naive List Reverse implemented in Mozart/Oz
\begin_inset LatexCommand label
name "fig:Background:Naive-List-Reverse"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Procedures in Oz are deterministic by default, and there is no default search
 strategy for exploring different alternatives.
 Instead, Oz provides independent facilities for creating choicepoints and
 for exploring procedures that contain choicepoints.
 The result is a much more flexible, although sometimes syntactically more
 cumbersome, approach to logic programming 
\begin_inset LatexCommand citep
key "lpinoz99"

\end_inset

.
\end_layout

\begin_layout Standard
The creation of choice points is explicit in Oz, and performed using the
 
\begin_inset Formula $\mathbf{choice}$
\end_inset

 keyword.
 To demonstrate, consider another classic Prolog example: the nondeterministic
 list member predicate shown in Figure 
\begin_inset LatexCommand ref
reference "fig:Background:Nondet-Member"

\end_inset

.
 In the case of the empty list, 
\begin_inset Formula $Member$
\end_inset

 simply fails.
 For a non-empty list, 
\begin_inset Formula $Member$
\end_inset

 explicitly creates a 
\emph on
choice point
\emph default
 with two options -- either bind 
\begin_inset Formula $E$
\end_inset

 to the head of the list, or bind 
\begin_inset Formula $E$
\end_inset

 to a member of the tail of the list.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/oz-examples/Member.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Nondeterministic List Member implemented in Mozart/Oz
\begin_inset LatexCommand label
name "fig:Background:Nondet-Member"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is at this point that the use of Mozart for logic programming differs
 most from Prolog.
 If the 
\begin_inset Formula $Member$
\end_inset

 procedure is invoked directly, it will suspend its execution when the 
\begin_inset Formula $\mathbf{choice}$
\end_inset

 statement is reached.
 To resolve the nondeterminism, one must execute the procedure inside an
 explicit 
\emph on
search
\emph default
 
\emph on
object
\emph default
.
 These objects are responsible for exploring the various choicepoints until
 a non-failing computation is achieved.
 They operate by executing the procedure in a separate 
\emph on
computation space
\emph default
 through which the state of the underlying computation can be managed 
\begin_inset LatexCommand citep
key "schulte00constraint_services"

\end_inset

.
\end_layout

\begin_layout Standard
As a demonstration, Figure 
\begin_inset LatexCommand ref
reference "fig:Background:All-Pairs"

\end_inset

 uses the 
\begin_inset Formula $Member$
\end_inset

 procedure to define a procedure 
\begin_inset Formula $Pairs$
\end_inset

, which nondeterministically selects a pair of elements from a pair of lists.
 The procedure 
\begin_inset Formula $AllPairs$
\end_inset

 then uses the builtin 
\begin_inset Formula $Search.base.all$
\end_inset

 object to find all solutions from this procedure, returning a list of all
 possible pairs from the two lists.
 By encapsulating the calls to nondeterministic procedures inside a search
 object, 
\begin_inset Formula $AllPairs$
\end_inset

 will not expose any choicepoints to code that calls it.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/oz-examples/Pairs.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Finding all pairs in Mozart/Oz
\begin_inset LatexCommand label
name "fig:Background:All-Pairs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also of note in Figure 
\begin_inset LatexCommand ref
reference "fig:Background:All-Pairs"

\end_inset

 is the use of a 
\emph on
closure
\emph default
 over the procedure 
\begin_inset Formula $Pair$
\end_inset

 to create the one-argument procedure 
\begin_inset Formula $FindP$
\end_inset

.
 Search objects work with a one-argument procedure, which is expected to
 bind its argument to a result.
 The dollar symbol is used to translate a statement (in this case the 
\begin_inset Formula $\mathbf{proc}$
\end_inset

 definition) into an expression.
 The value that would be bound to the dollar symbol by the statement becomes
 the return value of the expression, so 
\begin_inset Formula $FindP=proc\,\{\$\, P\}$
\end_inset

 is equivalent to 
\begin_inset Formula $proc\,\{FindP\, P\}$
\end_inset

.
\end_layout

\begin_layout Standard
The power of this decoupled approach to nondeterminism and search becomes
 apparent when defining new search strategies, which can then be used to
 evaluate any procedure.
 For example, it is straightforward to implement breadth-first or iterative-deep
ening strategies to replace the standard depth-first traversal of the 
\begin_inset Formula $Search.base$
\end_inset

 object 
\begin_inset LatexCommand citep
key "schulte00constraint_services"

\end_inset

.
\end_layout

\begin_layout Standard
Coupled with Mozart's strong support for distributed computing, these programmab
le search strategies offer a unique opportunity -- it becomes possible to
 implement a parallel search object which can automatically distribute work
 between several networked machines.
 Moreover, this parallel search can be applied without modification to any
 nondeterministic procedure.
 Mozart comes with a built-in 
\begin_inset Formula $ParallelSearch$
\end_inset

 object, which is described in detail in 
\begin_inset LatexCommand citep
key "schulte00oz_parallel"

\end_inset

 and which is our main motivation for the use of Oz in this thesis.
\end_layout

\begin_layout Standard
To demonstrate the power of the approach, consider Figure 
\begin_inset LatexCommand ref
reference "fig:Background:Parallel-All-Pairs"

\end_inset

, which describes a parallel-search version of the 
\begin_inset Formula $AllPairs$
\end_inset

 procedure.
 In this instance we define 
\begin_inset Formula $FindP$
\end_inset

 as a 
\emph on
functor
\emph default
, an Oz abstraction for code that is portable between machines.
 This functor imports the module 
\begin_inset Formula $MyList$
\end_inset

 containing the procedures we defined earlier, and exports a one-argument
 procedure 
\begin_inset Formula $Script$
\end_inset

 which will be executed by the parallel search object.
 The parallel search object 
\begin_inset Formula $Seacher$
\end_inset

 launches one instance of Mozart on the machine 
\begin_inset Quotes eld
\end_inset

mango
\begin_inset Quotes erd
\end_inset

 and two instances on the machine 
\begin_inset Quotes eld
\end_inset

rambutan
\begin_inset Quotes erd
\end_inset

, then is asked to enumerate all solutions for 
\begin_inset Formula $FindP$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/oz-examples/PPairs.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Finding all pairs in parallel in Mozart/Oz
\begin_inset LatexCommand label
name "fig:Background:Parallel-All-Pairs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Chapter 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

 we will use this parallel search object to automatically share the workload
 of planning a Golog execution amongst a team of cooperating agents.
\end_layout

\begin_layout Standard
As a multi-paradigm programming language with significant research history,
 there is much more to Oz than we have described here.
 However, these brief examples should be sufficient for a reader well-versed
 in Prolog to understand the Oz code used throughout this thesis.
 For more information and further examples, consult the general Oz tutorial
 
\begin_inset LatexCommand citep
key "haridi99oz_tutorial"

\end_inset

 or the specialised tutorial on logic programming in Oz 
\begin_inset LatexCommand citep
key "lpinoz99"

\end_inset

, which are both available online.
\end_layout

\begin_layout Section
MIndiGolog
\end_layout

\begin_layout Standard
This chapter develops a Golog variant specifically designed for cooperative
 execution in multi-agent domains.
 Motivated by the 
\begin_inset Quotes eld
\end_inset

cooking agents
\begin_inset Quotes erd
\end_inset

 example domain, we want to allow a team of agents to cooperatively plan
 and perform the execution of a shared Golog program.
 As this chapter will demonstrate, the existing features of the situation
 calculus go a long way towards achieving this goal, but are ultimately
 limited to execution in synchronous domains.
\end_layout

\begin_layout Standard
Key among these is true concurrency of actions, which is combined with the
 standard interleaved concurrency of ConGolog to give a flexible account
 of concurrent execution.
 We name the resulting language 
\begin_inset Quotes eld
\end_inset

MIndiGolog
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Quotes eld
\end_inset

Multi-Agent IndiGolog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In addition to these new Golog semantics, we develop an innovative implementatio
n of our language using the distributed logic programming features of the
 Mozart platform.
 Utilising the parallel search facility as described in Section 
\begin_inset LatexCommand ref
reference "sec:Background:Mozart/Oz"

\end_inset

, the agents can transparently share the workload of planning a program
 execution.
 The ability to utilise off-the-shelf techniques such as parallel search
 highlights a significant advantage of building our system on the situation
 calculus: it has a straightforward encoding as a logic program.
\end_layout

\begin_layout Standard
Concluding the chapter is a discussion of the limitations of this first
 incarnation of MIndiGolog, which derive from the effective reasoning procedures
 of the situation calculus.
 Specifically, it can only operate in fully-observable, synchronous domains.
 Subsequent chapters of this thesis develop new extensions to the situation
 calculus that work towards overcoming this limitation.
\end_layout

\begin_layout Standard
The semantics of MIndiGolog that we develop in this chapter follow a similar
 approach to ReadyLog, but we focus on incorporating rich domain features
 such as concurrency and continuous time.
 While these features have been added to Golog individually in existing
 works 
\begin_inset LatexCommand citep
key "Reiter98seq_temp_golog,pinto99tcongolog,pirri00planning_nat_acts,reiter01kia"

\end_inset

, our work is the first to provide a combined integration.
 We also rectify some subtle problems with the semantics presented in existing
 work, to provide a more robust combination of rich domain features.
\newline

\end_layout

\begin_layout Standard
There are, of course, a variety of other systems and formalisms that could
 be used to model and implement domains such as our 
\begin_inset Quotes eld
\end_inset

cooking agents
\begin_inset Quotes erd
\end_inset

 example.
 A popular choice is to represent tasks using a variant of the Hierarchical
 Task Networks formalism, which has been employed in systems such as STEAM
 
\begin_inset LatexCommand citep
key "tambe97flexible_teamwork"

\end_inset

, SharedPlans 
\begin_inset LatexCommand citep
key "grosz96sharedplans"

\end_inset

, and TAEMS 
\begin_inset LatexCommand citep
key "decker95designing_coordination"

\end_inset

.
\end_layout

\begin_layout Standard
The potential advantages of Golog over HTN-based approaches are discussed
 in 
\begin_inset LatexCommand citep
key "son00htn_golog"

\end_inset

, where HTN-like constructs are added as operators to the Golog language.
 They identify the following advantages: powerful control over and composition
 of nondeterministic operators; a more natural representation of many tasks
 thanks to common programming constructs; and a more sophisticated logic
 of action.
 This chapter will add to the list: the ability to utilise off-the-shelf
 techniques for distributed logic programming to automatically share the
 execution planning workload.
\end_layout

\begin_layout Standard
The purpose of this chapter, though, is not to propose the MIndiGolog approach
 as the ultimate solution for programming cooperative behaviour.
 Rather, it serves to highlight the 
\emph on
potential
\emph default
 of the situation calculus and Golog for both modelling and implementing
 rich multi-agent systems.
\end_layout

\begin_layout Subsection
Motivation
\begin_inset LatexCommand label
name "sec:MIndiGolog:Motivation"

\end_inset


\end_layout

\begin_layout Standard
Recall the 
\begin_inset Quotes eld
\end_inset

cooking agents
\begin_inset Quotes erd
\end_inset

 example domain from Chapter 
\begin_inset LatexCommand ref
reference "ch:intro"

\end_inset

 -- several agents inhabit a kitchen along with various ingredients and
 utensils, and they must cooperate to prepare a meal.
 A full definition of this domain is given in Appendix 
\begin_inset LatexCommand ref
reference "ch:cookingagents"

\end_inset

, but the specific details are not important for the purposes of this this
 chapter.
\end_layout

\begin_layout Standard
Specifying tasks for the cooking agents requires an interesting combination
 of features.
 There is much procedural knowledge about recipes that should be encoded
 as precisely as possible, while at the same time there are a lot of details
 of precisely who performs which steps, or precisely when they are performed,
 that should not be explicitly specified by the programmer.
\end_layout

\begin_layout Standard
The Golog family of languages provide a compelling formalism for specifying
 tasks in this domain, as the controlled nondeterminism they provide can
 be used to elide certain details from the program while keeping its procedural
 nature intact.
 Consider how we might specify the task of making a simple salad, shown
 in Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:MakeSalad"

\end_inset

.
 Using the high-level nondeterministic operators of Golog, this program
 says, in essence, 
\begin_inset Quotes eld
\end_inset

somebody chop a lettuce, somebody chop a carrot, and somebody chop a tomato.
 Then, somebody mix them together
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !t
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "85col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset Formula \begin{gather*}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt,ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt,ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt,ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt,\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
endTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right])\,\,\mathbf{end}\end{gather*}

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A Golog program for making a salad
\begin_inset LatexCommand label
name "fig:MIndiGolog:MakeSalad"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !t
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "85col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset Formula \begin{gather*}
\mathbf{proc}\, ChopTypeInto(agt,type,dest)\\
\left[\pi(board,\, IsType(board,Board)?\,;\right.\\
\pi(obj,\, IsType(obj,type)?\,;\,\,\,\\
acquire(agt,board)\,;\\
acquire(agt,obj)\,;\\
placeIn(agt,obj,board)\,;\\
beginTask(agt,chop(board))\,;\\
endTask(agt,chop(board))\,;\\
acquire(agt,dest)\,;\\
transfer(agt,board,dest)\,;\\
release(agt,board)\,;\\
\left.\, release(agt,dest)))\right]\,\,\mathbf{end}\end{gather*}

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A Golog program for chopping an ingredient
\begin_inset LatexCommand label
name "fig:MIndiGolog:ChopTypeInto"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the explicit concurrency operators allow the three ingredients
 to be chopped independently, while the nondeterministic 
\begin_inset Quotes eld
\end_inset

pick
\begin_inset Quotes erd
\end_inset

 operators allow any available agent to perform each sub-task.
 Expanding on this example, the procedure 
\begin_inset Formula $ChopTypeInto$
\end_inset

 could be specified as shown in Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:ChopTypeInto"

\end_inset

.
 Here the agent must select and acquire an object of the specified type,
 as well as an available chopping board.
 He then places the object on the board, chops it, and transfers it to the
 destination container.
\end_layout

\begin_layout Standard
Notice that the programs do no specify which agent is to perform which task
 -- in fact they make no assertions at all about the particular agents operating
 in the world.
 A library of procedures such as this can be combined very flexibly to specify
 the behaviour of the cooking agents, and the resulting program could be
 given to any team of agents for execution.
 The agents can prepare several dishes concurrently:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "85col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Standard
\begin_inset Formula \[
MakeSalad()\,||\, MakePasta()\,||\, MakeCake()\]

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\newline

\end_layout

\begin_layout Standard
They can even plan to have different dishes ready at different times:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "85col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\left(\left[MakeSalad()\,||\, MakePasta()\right]\,;\,?(time<7:30)\right)\\
||\,\left(MakeCake()\,;\,?(8:15<time<8:30)\right)\end{multline*}

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\newline

\end_layout

\begin_layout Standard
A legal execution of these programs must select appropriate ingredients
 and utensils, and ensure that are acquired in an appropriate order, so
 that it can proceed to completion without the agent's actions interfering
 with each other or coming into conflict over shared resources.
 Following the ReadyLog execution algorithm, each agent plans to avoid such
 conflict by virtue of finding a legal execution.
\end_layout

\begin_layout Standard
In short, the situation calculus and Golog provide an extremely powerful
 formalism for specifying cooperative agent behaviour in domains such as
 this.
\end_layout

\begin_layout Standard
However, executing these kinds of program using a standard Golog variant
 is far from ideal in a multi-agent setting.
 To illustrate this we have executed the 
\begin_inset Formula $MakeSalad$
\end_inset

 program using the standard semantics of IndiGolog 
\begin_inset LatexCommand citep
key "giacomo99indigolog"

\end_inset

, augmented with an explicit temporal component in the style of 
\begin_inset LatexCommand citep
key "Reiter98seq_temp_golog"

\end_inset

.
 The resulting execution is shown in Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:MakeSalad-in-IndiGolog"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "95col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\align center

\size footnotesize
\begin_inset Include \verbatiminput{listings/mindigolog/output-MakeSalad-I.txt}
preview false

\end_inset


\size default
 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Execution of 
\begin_inset Formula $MakeSalad$
\end_inset

 program using IndiGolog semantics
\begin_inset LatexCommand label
name "fig:MIndiGolog:MakeSalad-in-IndiGolog"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this domain there are three agents 
\begin_inset Formula $Joe$
\end_inset

, 
\begin_inset Formula $Jon$
\end_inset

 and 
\begin_inset Formula $Jim$
\end_inset

.
 While the resulting execution is legal, it is suboptimal in several ways.
 The most obvious problem is that it does not take advantage of the concurrency
 inherent in a team of agents.
 Only a single agent acts at any one time, while the other agents are idle.
 Ideally the execution planner should exploit 
\emph on
true concurrency
\emph default
 where possible, by calling for multiple actions to be performed at each
 timestep.
\end_layout

\begin_layout Standard
The remainder of this chapter is dedicated to developing a robustly multi-agent
 Golog semantics to overcome these issues, as well as an implementation
 that can highlight the benefits of this approach.
\end_layout

\begin_layout Subsection
Semantics of MIndiGolog
\begin_inset LatexCommand label
name "sec:MIndiGolog:Semantics"

\end_inset


\end_layout

\begin_layout Standard
We use the extensions to the situation calculus discussed in Chapter 
\begin_inset LatexCommand ref
reference "ch:background"

\end_inset

 to model concurrent actions (Section 
\begin_inset LatexCommand ref
reference "sec:Background:Concurrent-Actions"

\end_inset

) and explicit time (Section 
\begin_inset LatexCommand ref
reference "sec:Background:Time"

\end_inset

).
 The arguments to 
\begin_inset Formula $do$
\end_inset

 will therefore be 
\noun on
Concurrent
\noun default
 action sets rather than individual action terms.
\end_layout

\begin_layout Standard
To take advantage of true concurrency, we must first allow sets of concurrent
 actions to appear in a MIndiGolog execution.
 The modified 
\begin_inset Formula $Trans$
\end_inset

 clause for primitive actions shown in equation 
\begin_inset LatexCommand ref
reference "eq:MIndiGolog:temp_trans_a"

\end_inset

 already ensures that sets of concurrent actions are performed rather than
 raw action terms.
\end_layout

\begin_layout Standard
However, this is clearly not enough to truly exploit the potential for concurren
cy in a multi-agent team.
 As noted by 
\begin_inset LatexCommand citet
key "pinto99tcongolog"

\end_inset

, the concurrency operator should be modified to accept a concurrent transition
 from both programs.
 The concurrency semantics they propose for their variant 
\begin_inset Quotes eld
\end_inset

TConGolog
\begin_inset Quotes erd
\end_inset

 are shown below:
\begin_inset Formula \begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\:\,\,\,\,\,\,\,\,\,\shoveright{\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2}:\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},s))}\\
\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
The first two lines are the standard rules for the concurrency operator,
 encoding the interleaving of steps from programs 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

.
 The remaining lines permit the concurrent execution of a transition from
 both programs.
 While this modification will take advantage of the true concurrency of
 actions present in multi-agent domains, it introduces several complications
 that 
\begin_inset LatexCommand citep
key "pinto99tcongolog"

\end_inset

 does not address.
\end_layout

\begin_layout Standard
First, precondition interaction means that 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 may not be possible even if the individual actions are.
 The transition clause must ensure that the combination of the two sets
 of actions is possible.
 Another issue arises when two programs can legitimately be transitioned
 by executing the same action.
 Consider the following programs which add ingredients to a bowl:
\begin_inset Formula \begin{gather*}
\delta_{1}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Sugar,Bowl)\\
\delta_{2}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Egg,Bowl)\end{gather*}

\end_inset

 Executing 
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset

 should result in the bowl containing two units of flour, one unit of sugar
 and an egg.
 However, an individual transition for both programs is 
\begin_inset Formula $c_{1}=c_{2}=\{placeIn(Jim,Flour,Bowl)\}$
\end_inset

.
 Naively executing 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 to transition both programs would result in only one unit of flour being
 added.
\end_layout

\begin_layout Standard
Alternately, consider two programs waiting for a timer to ring:
\begin_inset Formula \begin{gather*}
\delta_{1}=ringTimer\,;\, acquire(Jim,Bowl)\\
\delta_{2}=ringTimer\,;\, acquire(Joe,Board)\end{gather*}

\end_inset

 Both programs should be allowed to proceed using the same 
\begin_inset Formula $ringTimer$
\end_inset

 occurrence, because it is an environmental effect rather than a purposeful
 agent-initiated action.
\end_layout

\begin_layout Standard
In simple cases like these, it is easy for the programmer to see the potential
 for such undesirable interaction and adjust their programs accordingly.
 But in more complex cases with liberal use of nondeterminism, it may not
 be possible to predict what actions can potentially be executed concurrently.
 To avoid unintuitive (and potentially dangerous) behaviour, concurrent
 execution must not be allowed to transition both programs using the same
 
\emph on
agent-initiated
\emph default
 action.
 Exogenous actions can safely transition two concurrent programs.
\end_layout

\begin_layout Standard
Taking these factors into account, we develop the improved transition rule
 for concurrency in equation (
\begin_inset LatexCommand ref
reference "eqn:trans_conc_new"

\end_inset

).
 The first two lines are the original interleaved concurrency clause from
 ConGolog, while the remainder characterises the above considerations to
 take advantage of true concurrency.
\begin_inset Formula \begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\shoveright{\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t:\, Trans(\delta_{1},s,\gamma_{1},do(c_{1}\#t,s))\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2}\#t,s))}\\
\shoveright{\wedge Legal((c_{1}\cup c_{2})\#t,s)\wedge\forall a:\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Natural(a)\right]}\\
\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do((c_{1}\cup c_{2})\#t,s)\label{eqn:trans_conc_new}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
There are two other Golog operators that relate to concurrency: the prioritised
 concurrency operator 
\begin_inset Formula $\delta_{1}\ll\delta_{2}$
\end_inset

, and the concurrent iteration operator 
\begin_inset Formula $\delta^{||}$
\end_inset

.
 MIndiGolog leaves both of these operators unmodified.
 For the concurrent iteration operator this is clearly the right thing to
 do, since its standard semantics are defined in terms of the base concurrency
 operator and will automatically inherit our new ability to take advantage
 of true concurrency.
\end_layout

\begin_layout Standard
For the prioritised concurrency operator, we note that it is mainly used
 to implement interrupt-handling by blocking the execution of the higher-priorit
y program until a test condition is satisfied, at which point the lower-priority
 program is blocked until the interrupt handler is complete.
 It makes no sense to allow concurrent execution of both programs in this
 case, which would destroy these blocking semantics.
\end_layout

\begin_layout Standard
Let us denote by 
\begin_inset Formula $\Dt_{mgolog}$
\end_inset

 the standard Golog axioms 
\begin_inset Formula $\Dt_{golog}$
\end_inset

, modified according to equations 
\begin_inset LatexCommand eqref
reference "eqn:trans_conc_new"

\end_inset

, 
\begin_inset LatexCommand eqref
reference "eqn:trans_prim_new"

\end_inset

 and 
\begin_inset LatexCommand eqref
reference "eqn:trans_cond_new"

\end_inset

.
 All legal executions of a MIndiGolog program derived from such a theory
 of action produce legal situations.
\end_layout

\begin_layout Theorem
The semantics of MIndiGolog entail: 
\begin_inset Formula \[
\Dt\cup\Dt_{mgolog}\models\forall s',\delta,\delta':\, Trans^{*}(\delta,S_{0},\delta',s')\rightarrow Legal(s')\]

\end_inset

 Thus, all legal executions of a MIndiGolog program produce legal situations.
 
\end_layout

\begin_layout ProofSketch
By induction on situation terms.
 For the base case, 
\begin_inset Formula $S_{0}$
\end_inset

 is always legal by definition.
 Lemma 
\begin_inset LatexCommand ref
reference "lem:MIndiGolog:trans_legal"

\end_inset

 immediately provides legality for the inductive case by the transitivity
 of 
\begin_inset Formula $Trans^{*}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The MIndiGolog semantics are thus a powerful but robust extension to the
 standard semantics of the Golog language family.
 Our integration of concurrent actions allows the language to more accurately
 reflect the concurrency present in multi-agent teams while ensuring actions
 are performed in a definite order if they are not legal to perform concurrently.
\end_layout

\begin_layout Subsection
Implementation
\begin_inset LatexCommand label
name "sec:MIndiGolog:Implementation"

\end_inset


\end_layout

\begin_layout Standard
With these new semantics in place, it is now possible to build a multi-agent
 execution planning system utilising MIndiGolog to specify the tasks to
 be performed.
 We have followed the style of 
\begin_inset LatexCommand citep
key "giacomo99indigolog,giacomo00congolog"

\end_inset

 to build an interpreter for our language in Oz on the Mozart programming
 platform 
\begin_inset LatexCommand citep
key "vanroy03mozart_logic"

\end_inset

.
 We summarise our implementation below; details on obtaining the full source
 code are available in Appendix 
\begin_inset LatexCommand ref
reference "ch:implementation"

\end_inset

.
\end_layout

\begin_layout Standard
Programs and actions are represented in Oz as record terms in a similar
 way to Prolog data terms.
 For example, the program:
\begin_inset Formula \[
\pi(agt,\left[acquire(agt,Bowl1);acquire(agt,Lettuce1)\right])\]

\end_inset


\end_layout

\begin_layout Standard
is represented as follows:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-ex-prog.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Quotes eld
\end_inset

do
\begin_inset Quotes erd
\end_inset

 is a reserved keyword in Oz, we represent situation terms as records of
 the form 
\begin_inset Formula $res(C\,\, T\,\, S)$
\end_inset

.
 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 have a straightforward encoding as Oz procedures, using the 
\series bold
case
\series default
 statement to encode each individual clause using pattern matching, and
 the 
\series bold
choice
\series default
 statement to explicitly introduce choice points.
 The following are a selection of the operators as they appear in our implementa
tion:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-trans.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-final.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The calls to 
\begin_inset Formula $Sitcalc.holds$
\end_inset

 etc here perform standard regression-based theorem proving in the style
 of Prolog-based Golog implementations 
\begin_inset LatexCommand citep
key "levesque97golog,giacomo00congolog"

\end_inset

.
 Of particular interest is our implementation of the concurrency operator,
 reflecting the new semantics from equation 
\begin_inset LatexCommand eqref
reference "eqn:trans_conc_new"

\end_inset

.
 First, we introduce a procedure 
\emph on
Step
\emph default
 which calculates a series of transitions to produce a single next action:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-step.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then we can encode the semantics of concurrency using the following case:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-trans-conc.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first option presented by the choicepoint is the case for true concurrency
 of actions, while the two other choices represent interleaved concurrency.
 By putting the true-concurrency case first, a depth-first search will try
 to find a concurrent step before looking for a step from only one of the
 programs.
 Using 
\begin_inset Formula $Step$
\end_inset

 instead of 
\begin_inset Formula $Trans$
\end_inset

 allows this search to consume empty transitions of each program, such as
 test conditions, to find a valid concurrent step.
 This is valid since the empty transitions consumed by 
\begin_inset Formula $Step$
\end_inset

 are also generated by the interleaved concurrency cases.
\end_layout

\begin_layout Standard
These simple implementation details are enough to ensure a high degree of
 concurrency in the generated executions, as we shall demonstrate in the
 next section.
\end_layout

\begin_layout Standard
A procedure 
\begin_inset Formula $Do(\delta,s,s')\equiv Trans^{*}(\delta,s,\delta',s')\wedge Final(\delta',s')$
\end_inset

 is defined that determines a complete legal execution 
\begin_inset Formula $Sp$
\end_inset

 for a given program 
\begin_inset Formula $D$
\end_inset

.
 As discussed in Section 
\begin_inset LatexCommand ref
reference "sec:Background:Golog-Exec-Planning"

\end_inset

, this is used to define the semantics of the search operator.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-do.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our implementation of the search operator avoids recalculating the complete
 legal execution by translating it into a direct list of actions to be performed.
 More sophisticated implementations can further instrument this case to
 perform failure detection and re-planning 
\begin_inset LatexCommand citep
key "Lesperance00improved_indigolog"

\end_inset

, but we do not include these techniques in our work.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-trans-search1.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using this implementation, a team of agents can plan and perform the execution
 of a shared MIndiGolog program by following the ReadyLog execution algorithm
 from Algorithm 
\begin_inset LatexCommand ref
reference "alg:readylog_exec"

\end_inset

.
 First we define procedures to detect program termination and to plan a
 next program step, which use built-in search object to resolve choicepoints:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-control.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The main control loop is then implemented in the procedure 
\begin_inset Formula $Run$
\end_inset

 as shown below.
 As in ReadyLog, each agent individually executes this control loop.
 When the next step contains an action that is to be performed be the agent,
 they execute it at the indicated time.
 Otherwise, they wait for the actions to be executed by their teammates
 before proceeding to the next iteration.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-run.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !b
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "95col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\align center

\size footnotesize
\begin_inset Include \verbatiminput{listings/mindigolog/output-MakeSalad-M.txt}
preview false

\end_inset


\size default
 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Execution of 
\begin_inset Formula $MakeSalad$
\end_inset

 program using MIndiGolog semantics
\begin_inset LatexCommand label
name "fig:MIndiGolog:MakeSalad-in-MIndiGolog"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The effect of our new semantics can be seen in Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:MakeSalad-in-MIndiGolog"

\end_inset

.
 This shows the execution generated by our implementation for the 
\begin_inset Formula $MakeSalad$
\end_inset

 program from Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:MakeSalad"

\end_inset

, using the new semantics of MIndiGolog in a domain with three agents.
 Note the execution of several actions at each timestep, demonstrating the
 integration of true concurrency into the language.
 Since there are three agents but only two chopping boards, in this execution
 
\begin_inset Formula $Jon$
\end_inset

 must wait until a board becomes available at time 12 before he can begin
 processing his ingredient.
 This execution is clearly more suited to a multi-agent domain than that
 produced by the standard IndiGolog semantics.
\end_layout

\begin_layout Subsection
Distributed Execution Planning
\begin_inset LatexCommand label
name "sec:MIndiGolog:Distributed-Planning"

\end_inset


\end_layout

\begin_layout Standard
One powerful feature of Mozart is the ability to use several networked computers
 to search for solutions to a logic program in parallel.
 Since the task of planning a MIndiGolog execution is encoded as a logic
 program, this immediately allows a team of agents to distribute the execution
 planning workload.
\end_layout

\begin_layout Standard
There are non-trivial computational and communication overheads involved
 in such a search, so it must be used judiciously.
 We argue that parts of the program appearing outside the scope of a search
 operator are intended for on-line execution, and so will tend to require
 little deliberation by the agent.
 By contrast, program components enclosed in a search operator are intended
 to require significant planning to generate a legal execution.
 We therefore modify the search operator to perform distributed execution
 planning, but leave the rest of the code intact.
\end_layout

\begin_layout Standard
To coordinate the parallel search, we designate one agent to be the 
\emph on
team leader
\emph default
, who will be responsible for managing the search process; the choice of
 agent is arbitrary and is simply a coordination device.
 The code below shows our implementation of the search operator using parallel
 search.
 If the executing agent is the team leader, it executes the procedure 
\begin_inset Formula $ParallelDo$
\end_inset

 and, when a plan is found, sends the details to the other members of the
 team.
 Subordinate team members simply wait for the plan to be received before
 continuing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-trans-search2.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that this modification is completely transparent to the rest of the
 implementation.
 While some details of sending messages are not shown, the core implementation
 of the ParallelDo procedure is shown below.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/mindigolog/goloz-paralleldo.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This code packages up the task to be performed as a 
\emph on
functor
\emph default
, a portable piece of code that can be shared across the network by all
 team members.
 Input terms are serialised to a textual representation since variables
 cannot be exported in functor definitions.
 It is then a simple matter of creating a new 
\begin_inset Formula $ParallelSearch$
\end_inset

 object that spans all team members, and asking it for a solution to the
 functor.
 When this code is executed by the team leader, it will utilise the computationa
l resources of all team members to plan the execution of the enclosed MIndiGolog
 program.
\end_layout

\begin_layout Standard
As a brief demonstration of the advantages provided by this technique, consider
 the suggestively-named program 
\begin_inset Quotes eld
\end_inset

HardToPlan
\begin_inset Quotes erd
\end_inset

 shown in Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:HardToPlan"

\end_inset

.
 This program asks the agents to nondeterministically select and acquire
 objects of a variety of types, and then tests whether certain specific
 objects have been acquired.
 It has been constructed so that a single bad choice in the early stages
 of execution planning - for example, having 
\begin_inset Formula $Joe$
\end_inset

 acquire 
\begin_inset Formula $Carrot1$
\end_inset

 instead of 
\begin_inset Formula $Carrot3$
\end_inset

 - can invalidate all choices subsequently made.
 Planning a legal execution of this program thus requires a significant
 amount of backtracking and should benefit greatly from parallelisation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !t
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "85col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset Formula \begin{gather*}
\mathbf{proc}\, HardToPlan()\\
\left[AcquireType(Joe,Carrot)\,;\right.\\
AcquireType(Jon,Sugar)\,;\\
AcquireType(Jim,Lettuce)\,;\\
AcquireType(Joe,Flour)\,;\\
AcquireType(Jon,Flour)\,;\\
HasObject(Jon,Carrot3)?\,;\\
HasObject(Joe,Flour5)?\,;\\
\left.\, HasObject(Jon,Sugar4)?\right]\,\,\mathbf{end}\\
\\\mathbf{proc}\, AcquireType(Agt,Type)\\
\pi(obj,\, IsType(obj,Type)?\,;\\
\left.\, acquire(Agt,obj)))\right]\,\,\mathbf{end}\end{gather*}

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A Golog program for which execution planning is difficult
\begin_inset LatexCommand label
name "fig:MIndiGolog:HardToPlan"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We used our MIndiGolog implementation to execute 
\begin_inset Formula $\Sigma(HardToPlan)$
\end_inset

 in two different ways: using parallel search as described above, and having
 the team leader search for a legal execution on its own.
 The program for team leader 
\begin_inset Formula $Jon$
\end_inset

 was executed on an AMD Althon 64 3000+, while the subordinate team members
 
\begin_inset Formula $Jim$
\end_inset

 and 
\begin_inset Formula $Joe$
\end_inset

 each executed on one core an Intel Core2 Duo 1.8 GHz.
 Three test runs were performed for both parallel and individual search.
 The times required to find a legal execution are shown in Table 
\begin_inset LatexCommand ref
reference "tab:MIndiGolog:Execution-planning-times"

\end_inset

 along with the speedup factor achieved by using parallel search.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement !t
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Individual Search
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Parallel Search
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Ratio Indiv/Para
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Run 1
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
29.30 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13.67 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2.14
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Run 2
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
29.21 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11.25 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2.59
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Run 3
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
29.08 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
11.61 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2.50
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Average
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
29.19 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
12.17 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2.39
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Execution planning times for 
\begin_inset Formula $HardToPlan$
\end_inset

, in seconds
\begin_inset LatexCommand label
name "tab:MIndiGolog:Execution-planning-times"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
These results shown an impressive decrease in execution planning time with
 the use of parallel search - close to a factor of three speedup using the
 computational resources of three agents.
 Of course, on programs where execution planning is less difficult this
 advantage will be reduced, but on difficult problems it can clearly provide
 a significant benefit.
\end_layout

\begin_layout Standard
The ability to implement this distributed execution planning with so little
 code, and in a way that is completely transparent to the rest of the implementa
tion, highlights one of the major advantages of using the situation calculus
 and Golog -- the ability to encode both the domain and the execution planning
 problem as a simple logic program, which is then amenable to off-the-shelf
 techniques for distributed logic programming.
\end_layout

\begin_layout Subsection
Discussion
\begin_inset LatexCommand label
name "sec:MIndiGolog:Discussion"

\end_inset


\end_layout

\begin_layout Standard
Our work in this chapter has integrated several important extensions to
 the situation calculus and Golog to better model the dynamics of multi-agent
 teams.
 Specifically, MIndiGolog combines true and interleaved concurrency, an
 explicit account of time, and seamless integration of natural actions.
 As we have shown by comparison to IndiGolog, it defines legal executions
 of Golog programs that are much more suitable for cooperative execution
 by a multi-agent team.
\end_layout

\begin_layout Standard
We have also demonstrated an innovative implementation of MIndiGolog using
 Mozart/Oz instead of Prolog.
 Since the situation calculus and Golog have a straightforward encoding
 as a logic program, the off-the-shelf techniques for distributed logic
 programming provided by the Mozart platform can be used to transparently
 share the execution planning workload between team members.
\end_layout

\begin_layout Standard
The approach presented in this chapter is by no means a complete account
 of cooperative execution in multi-agent domains.
 It pre-supposes the existence of a fixed team of agents and their mutual
 commitment to executing a pre-specified shared task.
 Our implementation therefore focuses entirely on planning and performing
 the execution of such a task, without explicit mental attitudes such as
 cooperation or commitment.
 However, this technique could easily form a component of a larger multi-agent
 system based on the situation calculus, such as 
\begin_inset LatexCommand citep
key "shapiro02casl,lesperance05ecasl"

\end_inset

.
\end_layout

\begin_layout Standard
The purpose of this chapter is not to propose the MIndiGolog approach as
 the ultimate solution for programming cooperative behaviour.
 Rather, it serves to highlight the 
\emph on
potential
\emph default
 of the situation calculus and Golog for both modelling and implementing
 rich multi-agent systems.
 Unfortunately, this potential has traditionally been limited by some restrictio
ns on the effective reasoning procedures of the situation calculus, and
 our implementation of MIndiGolog has inherited those limitations.
\end_layout

\begin_layout Standard
Most fundamentally, the output of our execution planning process assumes
 that the domain is synchronous and that all actions are publicly observable.
 This assumption is necessary to allow reasoning using standard regression
 techniques, as it means the agents do not need to consider arbitrarily-long
 sequences of hidden actions.
 It also means that simple situation terms suffice as the output of the
 planning process; agents have all the information they need to coordinate
 the performance of concurrent actions, and to ensure that actions are performed
 in the correct order.
 For example, the execution in Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:MakeSalad-in-MIndiGolog"

\end_inset

 calls for 
\begin_inset Formula $Jim$
\end_inset

 to release 
\begin_inset Formula $Bowl1$
\end_inset

 and then for 
\begin_inset Formula $Joe$
\end_inset

 to acquire it in the next timestep, implicitly assuming that the two agents
 are able to coordinate and synchronise these actions.
\end_layout

\begin_layout Standard
Consider, by contrast, an asynchronous domain in which some actions are
 not public.
 If 
\begin_inset Formula $Joe$
\end_inset

 is not be able to observe the occurrence of 
\begin_inset Formula $Jim$
\end_inset

 releasing the bowl, he would not know when to proceed with acquiring it
 and execution of the plan would fail.
 To be sure that the plans produced by our system can be executed in the
 real world, we must assume that the agents execute their actions in lock-step
 and always know the current state of execution -- in other words, that
 there is some form of constant synchronisation between the agents.
\end_layout

\begin_layout Standard
Another limitation is that MIndiGolog does only 
\emph on
linear
\emph default
 planning, and has no support for sensing actions.
 In the single-agent case the execution of Golog programs that include sensing
 actions is well understood 
\begin_inset LatexCommand citep
key "giacomo99indigolog,lakemeyer99golog_cats"

\end_inset

, but there is no straightforward way to adapt these techniques to the implicit
 coordination scheme used by MIndiGolog.
 The difficulty arises from the execution algorithm's crucial assumption
 that all agents have access to the same information.
 Introducing sensing actions to MIndiGolog will require more explicit reasoning
 about coordination based on the local information available to each agent.
\end_layout

\begin_layout Standard
Existing situation calculus techniques for reasoning about the local perspective
 of each agent are based on explicit notions of knowledge, as described
 in Section 
\begin_inset LatexCommand ref
reference "sec:Background:Epistemic"

\end_inset

.
 But even these formalisms are limited to synchronous domains, requiring
 agents to always know how many actions have occurred so that standard regressio
n techniques can be applied.
 The situation calculus currently offers no tools to extend the MIndiGolog
 approach into asynchronous domains.
 The remainder of this thesis is devoted to developing the foundations for
 such tools, based on a formal characterisation of the local perspective
 of each agent that explicitly deals with the hidden actions inherent in
 an asynchronous domain.
\end_layout

\begin_layout Standard
While we will revisit the cooking agents again in Chapter 
\begin_inset LatexCommand ref
reference "ch:jointexec"

\end_inset

, our implementation of a new, asynchronous version of MIndiGolog is still
 ongoing.
 At the conclusion of this thesis, we will discuss the challenges remaining
 to be faced in bringing our new techniques for representing and reasoning
 about asynchronous domains together with a practical implementation of
 a system such as MIndiGolog.
\end_layout

\begin_layout Section
Observations and Views
\end_layout

\begin_layout Standard
This chapter develops an explicit formalisation of the local perspective
 of each agent, representing it using concrete terms in the logic, so that
 we can approach reasoning and planning in asynchronous domains in a systematic
 way.
\end_layout

\begin_layout Standard
Existing work on multi-agent domains in the situation calculus has left
 this agent-local perspective largely implicit; for example, it is customary
 to introduce different kinds of sensing or communication actions by directly
 modifying the axioms that define the dynamics of knowledge.
 We choose instead to reify the local perspective of each agent by explicitly
 talking about what it has observed, independent of how this information
 will be used by the rest of the action theory.
\end_layout

\begin_layout Standard
The basic idea is as follows: each occurrence of an action results in an
 agent making a set of 
\emph on
observations
\emph default
.
 Every situation then corresponds to a local 
\emph on
view
\emph default
 for that agent: the sequence of all its observations, excluding cases where
 the set of observations was empty.
 These form agent-local analogues to standard action and situation terms,
 which represent the global state of the world.
 Allowing the set of observations to be empty lets us model truly asynchronous
 domains, in which an agent's local view is not always updated when the
 state of the world is changed.
\end_layout

\begin_layout Standard
By having views as explicit terms in the logic, we are then in a position
 to ensure that agents only reason and act based on their local information.
 Having factored out the precise details of each agent's local view, we
 can develop reasoning techniques and tools that can be applied in a variety
 of different domains, rather than depending on any particular details of
 how actions are perceived by each agent.
\end_layout

\begin_layout Standard
To demonstrate the appeal of this decoupling, we show how a variety of domain
 dynamics can be modelled using our approach.
 The techniques we subsequently develop using this foundation of observations
 and views - our planning formalism using joint executions, our account
 of knowledge with hidden actions, our regression rule for common knowledge
 - can be used unmodified in any of these domains.
\end_layout

\begin_layout Subsection
Background
\begin_inset LatexCommand label
name "sec:Observations:Background"

\end_inset


\end_layout

\begin_layout Standard
In many single-agent applications of the situation calculus, there is no
 need to consider the local perspective of the agent -- since the agent
 has complete knowledge and is the only entity acting in the world, its
 local information is precisely equivalent to the global information captured
 by the current situation term.
\end_layout

\begin_layout Standard
If the agent has incomplete knowledge about the state of the world, it may
 need to perform 
\emph on
sensing actions
\emph default
 to obtain additional information 
\begin_inset LatexCommand citep
key "giacomo99indigolog,scherl03sc_knowledge"

\end_inset

.
 To represent such actions, a new sort 
\noun on
Result 
\noun default
is added to 
\begin_inset Formula $\Lsit$
\end_inset

, along with an action description function 
\begin_inset Formula $SR(a,s)=r$
\end_inset

 that specifies the result returned by each action.
 The agent's local perspective on the world is then given by a 
\emph on
history
\emph default
, a sequence of 
\begin_inset Formula $a\#r$
\end_inset

 pairs giving each action performed and its corresponding sensing result.
\end_layout

\begin_layout Standard
When sensing actions are used in IndiGolog 
\begin_inset LatexCommand citep
key "giacomo99indigolog"

\end_inset

, the agent must plan its execution using this history rather than a raw
 situation term.
 This is accomplished without any modifications to the underlying theory
 of action, by handling the history as a purely meta-level structure and
 modifying the way queries are posed.
\end_layout

\begin_layout Standard
First, a pair of macros are defined to convert a history into proper sentences
 of the situation calculus that capture the information it contains.
 The macro 
\begin_inset Formula $\mathbf{end}$
\end_inset

 gives the situation term corresponding to a history, while the macro 
\begin_inset Formula $\mathbf{Sensed}$
\end_inset

 produces a formula asserting that each action produced the given sensing
 result.
 Let 
\begin_inset Formula $\epsilon$
\end_inset

 be the empty history, then the definitions are:
\begin_inset Formula \begin{alignat*}{1}
\mathbf{end}[\epsilon] & \isdef S_{0}\\
\mathbf{end}[h\cdot(a\#r)] & \isdef do(a,\mathbf{end}[h])\\
\mathbf{Sensed}[\epsilon] & \isdef\top\\
\mathbf{Sensed}[h\cdot(a\#r)] & \isdef\mathbf{Sensed}[h]\wedge SR(a,\mathbf{end}[h])=r\end{alignat*}

\end_inset


\end_layout

\begin_layout Standard
Then, instead of asking whether a query holds at the current situation 
\begin_inset Formula $\sigma$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Dt\,\models\,\phi[\sigma]\]

\end_inset


\end_layout

\begin_layout Standard
The agent asks whether the query holds given its current history 
\begin_inset Formula $h$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\mathbf{Sensed}[h]\,\rightarrow\,\phi[\mathbf{end}[h]]\]

\end_inset


\end_layout

\begin_layout Standard
This approach works well for a single agent, but we are aware of no works
 extending this meta-level handling of histories to the multi-agent case.
\newline

\end_layout

\begin_layout Standard
While the meta-level approach of 
\begin_inset LatexCommand citep
key "giacomo99indigolog"

\end_inset

 allows an agent to reason based on its local perspective, it is cumbersome
 for reasoning 
\emph on
about
\emph default
 that local perspective.
 To determine whether an agent 
\emph on
knows
\emph default
 that a formula holds in a given situation, we must explicitly specify the
 agent's history of sensing results for that situation, which may not be
 available until run-time.
 This meta-level approach is not suitable for rich epistemic reasoning,
 where we may want to reason offline about what the agent (or a group of
 agents) will or will not know after a series actions.
\end_layout

\begin_layout Standard
This kind of reasoning requires an explicit representation of an agent's
 knowledge, as described in Section 
\begin_inset LatexCommand ref
reference "sec:Background:Epistemic"

\end_inset

.
 We will review such epistemic reasoning in more detail in Chapter 
\begin_inset LatexCommand ref
reference "ch:knowledge"

\end_inset

, where we extend existing approaches to handle asynchronous domains based
 on the formalism developed in this chapter.
 For now we briefly discuss its use in axiomatising the local perspective
 of each agent.
\end_layout

\begin_layout Standard
The effect of sensing results on an agent's knowledge is axiomatised in
 
\begin_inset LatexCommand citep
key "scherl03sc_knowledge"

\end_inset

 by directly specifying it in the successor state axiom for the knowledge
 fluent 
\begin_inset Formula $K$
\end_inset

.
 Agents discard situations that do not agree with the obtained sensing result:
\begin_inset Formula \[
K(agt,do(a,s'),do(a,s))\,\equiv\, K(agt,s',s)\wedge Legal(a,s')\wedge SR(a,s')=SR(a,s)\]

\end_inset

 As a variety of richer domains have been modelled on top of this formalism,
 their particular accounts of the local information available to each agent
 have been specified by progressively modifying this successor state axiom.
\end_layout

\begin_layout Standard
For example, when multiple agents are introduced, the successor state axiom
 for 
\begin_inset Formula $K$
\end_inset

 is modified to ensure that an agent knows the results produced by its own
 actions, but not by the actions of others 
\begin_inset LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

.
 When communication actions are introduced, the successor state axiom for
 
\begin_inset Formula $K$
\end_inset

 is modified to ensure that the agent's knowledge is updated to include
 the communicated information 
\begin_inset LatexCommand citep
key "shapiro01casl_feat_inter,shapiro07sc_goal_change"

\end_inset

.
 When concurrent actions and time are introduced, the successor state axiom
 for 
\begin_inset Formula $K$
\end_inset

 is modified to ensure that the agent knows how much time has passed since
 the last action, while not inadvertently learning the real value of the
 current time unless this was already known 
\begin_inset LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

.
\end_layout

\begin_layout Standard
In these works there is no explicit representation of the local perspective
 of each agent -- rather, the information each agent receives from an action
 is specified only in terms of its effect on the agent's knowledge.
 The formalism developed in this chapter will allow us to decouple the dynamics
 of knowledge from the specific details of how each action affects the agent's
 local perspective.
 As we will show in Chapter 
\begin_inset LatexCommand ref
reference "ch:knowledge"

\end_inset

, this can produce a much more general and robust formalism for knowledge.
\end_layout

\begin_layout Standard
The observation-based approach will also allow us to work directly with
 the local information available to each agent without needing to make explicit
 statements about knowledge.
 For example, when planning the cooperative execution of a task, we can
 formulate a reactive plan in which each agent can act based directly on
 its local observations, without having to introspectively reason about
 what it knows.
\newline

\end_layout

\begin_layout Standard
A related approach to ours is the work by 
\begin_inset LatexCommand citet
key "pinto98sc_observations"

\end_inset

 on axiomatising narratives in the situation calculus.
 Here the term 
\begin_inset Quotes eld
\end_inset

observation
\begin_inset Quotes erd
\end_inset

 is used in a more general sense to mean some partial information about
 the state of the world, such as an action occurring or a fluent holding
 at a particular time.
 These are asserted using predicates such as 
\begin_inset Formula $occurs(a,t)$
\end_inset

 and 
\begin_inset Formula $holds(F,t)$
\end_inset

, and situations are defined as 
\emph on
proper
\emph default
 if they respect the asserted 
\begin_inset Formula $occurs$
\end_inset

 and 
\begin_inset Formula $holds$
\end_inset

 facts.
 Although the focus of 
\begin_inset LatexCommand citep
key "pinto98sc_observations"

\end_inset

 is on reasoning from a single omniscient perspective, it could easily be
 extended to reason about the local perspective of multiple agents.
\end_layout

\begin_layout Standard
The crucial difference between 
\begin_inset LatexCommand citep
key "pinto98sc_observations"

\end_inset

 and the approach presented in this chapter is that we provide an explicit
 axiomatisation not just of 
\emph on
observations
\emph default
 but of 
\emph on
observability.

\emph default
 We provide a complete account of what each agent would observe if any particula
r action occurred in any particular state of the world.
 By virtue of not having made particular observations, agents in our formalism
 can conclude that certain actions cannot have occurred.
 By contrast, the use of 
\begin_inset Formula $occurs$
\end_inset

 and 
\begin_inset Formula $holds$
\end_inset

 in 
\begin_inset LatexCommand citep
key "pinto98sc_observations"

\end_inset

 specifies only what 
\emph on
must
\emph default
 have happened, not what 
\emph on
cannot
\emph default
 have happened.
 This distinction will play an important role for effective reasoning for
 our formalism.
\end_layout

\begin_layout Subsection
Definitions
\begin_inset LatexCommand label
name "sec:Observations:Definitions"

\end_inset


\end_layout

\begin_layout Standard
In this section we formally define an explicit representation of the local
 information available to each agent, and do so in a manner that is independent
 of how that information will eventually be used.
 Our approach can be seen as a generalisation of the history-based approach
 of 
\begin_inset LatexCommand citep
key "giacomo99indigolog"

\end_inset

, explicitly representing the information available to each agent.
 However, we encode this information as terms in the logic rather than in
 the meta-level reasoning machinery.
 This allows us to use this explicit local perspective in more general ways.
\end_layout

\begin_layout Standard
We begin by defining the notion of an 
\emph on
observation
\emph default
, which is fundamental to the entire approach
\emph on
.

\emph default
 At the simplest level, this is an internal notification that an agent receives
 when some action has occurred.
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Observations
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] An observation is a notification event received by an agent, making it
 aware of some change in the state of the world.
 When an agent receives such a notification, we say that it 
\begin_inset Quotes eld
\end_inset

observed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

made
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

perceived
\begin_inset Quotes erd
\end_inset

 that observation.
 
\end_layout

\begin_layout Standard
Since 
\begin_inset Quotes eld
\end_inset

observation
\begin_inset Quotes erd
\end_inset

 is quite a loaded term, it is worth re-iterating this point: our observations
 are instantaneous 
\emph on
events
\emph default
 generated internally by each agent in response to actions occurring in
 the world.
 We make no commitment as to how these events are generated, preferring
 a clean delineation between the task of observing change and the dynamics
 of knowledge update based on those observations.
\end_layout

\begin_layout Standard
Since the state of the world may only change in response to some action,
 observations can only be made as a result of some action.
 For simplicity we assume that agents perceive observations instantaneously,
 i.e.
 in the same instant as the actions that cause them, but see Section 
\begin_inset LatexCommand ref
reference "sec:Observations:Delayed"

\end_inset

 for a suggestion on how delayed observations can be modelled.
\end_layout

\begin_layout Standard
To make this idea concrete, let us introduce an additional sort 
\noun on
Observation
\noun default
 to the language 
\begin_inset Formula $\Lsit$
\end_inset

, for the moment without any particular commitment towards what this sort
 will contain.
 We then add an action description function of the following form to 
\begin_inset Formula $\Dt_{ad}$
\end_inset

:
\begin_inset Formula \[
Obs(agt,c,s)=o\]

\end_inset

 This function returns a set of observations, and should be read as 
\begin_inset Quotes eld
\end_inset

when actions 
\begin_inset Formula $c$
\end_inset

 are performed in situation 
\begin_inset Formula $s$
\end_inset

, agent 
\begin_inset Formula $agt$
\end_inset

 will perceive observations 
\begin_inset Formula $o$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Using a set of observations allows an agent to perceive any number of observati
ons in response to an action occurrence -- perhaps several observations,
 perhaps none.
 When 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

 is empty, the agent makes no observations and the actions 
\begin_inset Formula $c$
\end_inset

 are completely hidden.
\end_layout

\begin_layout Standard
The concept of a 
\emph on
view
\emph default
 follows naturally - it is the sequence of all the observations made by
 an agent as the world has evolved.
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Views
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] An agent's view in a given situation 
\begin_inset Formula $\mathrm{s}$
\end_inset

 is the corresponding sequence of observations made by the agent as a result
 of each action in 
\begin_inset Formula $\mathrm{s}$
\end_inset

, excluding those actions for which no observations were made.
 
\begin_inset LatexCommand label
name "defn:Observations:View"

\end_inset

 
\end_layout

\begin_layout Standard
We introduce another sort 
\noun on
View
\noun default
 consisting of sequences of sets of observations, with 
\begin_inset Formula $\epsilon$
\end_inset

 being the empty sequence and the functional fluent 
\begin_inset Formula $View$
\end_inset

 giving the history of observations associated with a particular situation.
 Since these definitions will not change from one domain to another, they
 are added to the foundational axioms:
\begin_inset Formula \begin{align}
Init(s)\,\rightarrow & \, View(agt,s)=\epsilon\nonumber \\
Obs(agt,c,s)=\{\}\,\rightarrow & \, View(agt,do(c,s))=View(agt,s)\nonumber \\
Obs(agt,c,s)\neq\{\}\,\rightarrow & \, View(agt,do(c,s))=Obs(agt,c,s)\cdot View(agt,s)\label{eq:view_defn}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Observations and views can be seen as localised analogues of actions and
 situations respectively.
 An action is a global event that causes the state of the world to change,
 while an observation is an internal event that causes an agent's knowledge
 of the state of the world to change.
 Similarly, a situation represents a complete, global history of all the
 actions that have occurred in the world, while a view is an agent's local
 history of all the observations it has made.
 The situation is an omniscient perspective on the world, the view a local
 perspective.
 This distinction will be fundamental to the new techniques we develop throughou
t this thesis.
\end_layout

\begin_layout Standard
To provide a global account of the results returned by each action, we can
 define a 
\emph on
history
\emph default
 in a similar way to IndiGolog, but represented explicitly as a term in
 the language.
 First, we define the 
\emph on
outcome
\emph default
 of an action as a mapping from agents to the observations they made.
 To represent this mapping we use a set of 
\noun on
Agent#Observation
\noun default
 pairs:
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Outcomes
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] The outcome of an action 
\begin_inset Formula $c$
\end_inset

 is the set of 
\begin_inset Formula $agt\#Obs(agt,c)$
\end_inset

 pairs generated by that action:
\begin_inset Formula \[
Out(c,s)=y\,\equiv\,\forall agt,o:\, agt\#o\in y\,\equiv\, Obs(agt,c,s)=o\]

\end_inset


\end_layout

\begin_layout Standard
Then we can build the global history of a situation as a sequence of actions
 paired with their respective outcomes:
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Histories
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] The history of a situation 
\begin_inset Formula $s$
\end_inset

 is the sequence of action#outcome pairs corresponding to each action in
 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\, History(s)=\epsilon\\
History(do(c,s))=h\,\equiv\, h=(c\#Out(c,s))\cdot History(s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We can also introduce an analogous function 
\begin_inset Formula $Sit$
\end_inset

 that translates from a history term back into a raw situation:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather*}
Sit(\epsilon)=S_{0}\\
Sit((c\#y)\cdot h)=do(c,Sit(h))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Histories will be useful for planning the cooperative execution of a shared
 task, when agents must explicitly reason about both the global state of
 the system and the local perspective of each agent.
 To this end, we introduce some suggestive notation for accessing the individual
 observations in an outcome:
\begin_inset Formula \[
Out(c,s)[agt]=o\,\equiv\, agt\#o\in Out(c,s)\]

\end_inset


\end_layout

\begin_layout Standard
To ensure that these definitions operate in an intuitively correct way,
 we also need a simple consistency constraint.
 Just as the empty set of actions is assumed to never be legal, so we should
 assume that it generates no observations -- clearly the agents cannot observe
 anything if no action has taken place.
 Formally, we impose the following consistency requirement on basic actions
 theories containing 
\begin_inset Formula $Obs$
\end_inset

:
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Observation\InsetSpace ~
Causality\InsetSpace ~
Requirement
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] A basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 specifying the 
\begin_inset Formula $Obs$
\end_inset

 function must ensure that agents do not perceive observations that are
 not caused by some action:
\begin_inset Formula \[
\Dt\,\models\,\forall agt,s:\, Obs(agt,\{\},s)=\{\}\]

\end_inset


\end_layout

\begin_layout Standard
The key distinguishing feature of our approach is that the agent's view
 excludes cases where 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

 is empty, so the agent may not have enough information to determine how
 many actions have been performed in the world.
 As discussed in Chapter 
\begin_inset LatexCommand ref
reference "ch:intro"

\end_inset

, this property is fundamental to modelling truly asynchronous domains.
 Mirroring the terminology of 
\begin_inset LatexCommand citep
key "vanBentham06tree_of_knowledge"

\end_inset

, we can explicitly define what it means for a domain to be 
\emph on
synchronous
\emph default
 in the situation calculus.
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Synchronous\InsetSpace ~
Action\InsetSpace ~
Theory
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] A basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 is synchronous if every agent observes something whenever an action occurs:
\begin_inset LatexCommand label
name "def:Synchronous-Action-Theory"

\end_inset


\begin_inset Formula \[
\Dt\,\models\,\forall agt,c,s:\, Legal(c,s)\,\rightarrow\, Obs(agt,c,s)\neq\{\}\]

\end_inset


\end_layout

\begin_layout Standard
As we shall see, such domains make reasoning from the local perspective
 of an agent significantly easier, as they do not need to consider arbitrarily-l
ong sequences of hidden actions.
 Before proceeding with some example definitions of 
\begin_inset Formula $Obs$
\end_inset

, let us briefly foreshadow how observations and views will be used in the
 coming chapters.
\end_layout

\begin_layout Standard
In Chapter 
\begin_inset LatexCommand ref
reference "ch:jointexec"

\end_inset

, we will define a partially-ordered branching action structure to be generated
 as the output of the MIndiGolog execution planning process.
 This structure, called a 
\emph on
joint execution,
\emph default
 represents many possible situations that are legal executions of the program.
 Since agents can only be expected to act based on their local information,
 we will require that if 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 are two situations that could be reached while performing a joint execution,
 and 
\begin_inset Formula $View(agt,s)=View(agt,s')$
\end_inset

, then the agent's next action in both situations must be the same.
 Moreover, if the joint execution requires an agent to execute some action
 
\begin_inset Formula $a_{2}$
\end_inset

 after another action 
\begin_inset Formula $a_{1}$
\end_inset

, we will require that 
\begin_inset Formula $Obs(agt,a_{1},s)$
\end_inset

 is not empty, so that it will have some local observation to trigger the
 performance of 
\begin_inset Formula $a_{2}$
\end_inset

.
 These restrictions ensure that the joint execution can feasibly be carried
 out by the agents.
\end_layout

\begin_layout Standard
In Chapter 
\begin_inset LatexCommand ref
reference "ch:knowledge"

\end_inset

, we formalise the intuition that an agent's knowledge should be based only
 on its local information.
 So if the agent believes that the world might be in situation 
\begin_inset Formula $s$
\end_inset

, then it must also consider possible any other situation 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $View(agt,s)=View(agt,s')$
\end_inset

.
 By decoupling the axiomatisation of knowledge from the specific details
 of how each action affects the agent's local information, we develop a
 very general and robust formalism that can be applied without modification
 in a wide variety of domains.
\end_layout

\begin_layout Subsection
Axiomatising Observations
\begin_inset LatexCommand label
name "sec:Observations:Axiomatising-simple"

\end_inset


\end_layout

\begin_layout Standard
We now show how observations and views can be used to model a variety of
 common domain dynamics from the situation calculus literature.
 We argue that these axiomatisations intuitively capture the 
\begin_inset Quotes eld
\end_inset

correct
\begin_inset Quotes erd
\end_inset

 information in each case, but defer a formal comparison between our approach
 and existing axiomatisations until we have developed our theory of knowledge
 in Chapter 
\begin_inset LatexCommand ref
reference "ch:knowledge"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Public Actions
\end_layout

\begin_layout Standard
By far the most common assumption about the observability of actions is
 that 
\begin_inset Quotes eld
\end_inset

all actions are public
\begin_inset Quotes erd
\end_inset

, which can be rephrased as 
\begin_inset Quotes eld
\end_inset

when an action occurs, all agents will observe that action
\begin_inset Quotes erd
\end_inset

.
 Letting the 
\noun on
Observation 
\noun default
sort contain 
\noun on
Action 
\noun default
terms, this can be captured using the following axiom in the definition
 of 
\begin_inset Formula $Obs$
\end_inset

:
\begin_inset Formula \begin{equation}
a\in Obs(agt,c,s)\,\equiv\, a\in c\label{eq:Observations:ObsStd1}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
When sensing actions are included, it is typically assumed that only the
 performing agent has access to the sensing results.
 This can be modelled by extending the 
\noun on
Observation
\noun default
 sort to contain 
\noun on
Action#Result
\noun default
 pairs, and including the following in the definition for 
\begin_inset Formula $Obs$
\end_inset

:
\begin_inset Formula \begin{equation}
a\#r\in Obs(agt,c,s)\,\equiv\, a\in c\wedge actor(a)=agt\wedge SR(a,s)=r\label{eq:Observations:ObsStd2}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Note that since 
\begin_inset Formula $Obs$
\end_inset

 is an action description function, technically we must specify it using
 a single axiom as described in Section 
\begin_inset LatexCommand ref
reference "sec:Background:SC:Axioms"

\end_inset

.
 For the sake of clarity we specify these two cases independently, and assume
 that the final axiom defining 
\begin_inset Formula $Obs$
\end_inset

 takes the completion of the individual cases in the standard way.
\end_layout

\begin_layout Standard
It should be clear that these definitions capture the intuition behind this
 most common model of action observability.
 When we develop our new axiomatisation of knowledge in Chapter 
\begin_inset LatexCommand ref
reference "ch:knowledge"

\end_inset

, we will demonstrate that these definitions provide an equivalent account
 to the standard knowledge axioms of 
\begin_inset LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

.
\end_layout

\begin_layout Standard
This approach clearly leads to synchronous domains, since an agent's set
 of observations can only be empty if the set of actions is also empty,
 and the empty action set is never legal to perform.
\end_layout

\begin_layout Subsubsection
Private Actions
\end_layout

\begin_layout Standard
Another common model for action observability is to assume that 
\begin_inset Quotes eld
\end_inset

all actions are private
\begin_inset Quotes erd
\end_inset

, which can be rephrased as 
\begin_inset Quotes eld
\end_inset

when an action occurs, only the performing agent will observe it
\begin_inset Quotes erd
\end_inset

.
 This can be modelled by simply dropping the public-observability axiom
 from equation 
\begin_inset LatexCommand ref
reference "eq:Observations:ObsStd1"

\end_inset

, leaving the following definition of 
\begin_inset Formula $Obs$
\end_inset

:
\begin_inset Formula \[
a\#r\in Obs(agt,c,s)\,\equiv\, a\in c\wedge actor(a)=agt\wedge SR(a,s)=r\]

\end_inset


\end_layout

\begin_layout Standard
As noted in 
\begin_inset LatexCommand citep
key "Lesperance99sitcalc_approach"

\end_inset

, this approach means that agents need to consider arbitrarily-long sequences
 of hidden actions which may or may not have occurred, and thus forego regressio
n as an effective reasoning technique.
 By explicitly formalising this situation, we will be in a position provide
 the first formal account of effective reasoning in such asynchronous domains.
\end_layout

\begin_layout Subsubsection
Speech Acts
\end_layout

\begin_layout Standard
Communication in the situation calculus is traditionally modelled using
 explicit communicative actions or 
\begin_inset Quotes eld
\end_inset

speech acts
\begin_inset Quotes erd
\end_inset

 
\begin_inset LatexCommand citep
key "shapiro01casl_feat_inter,shapiro07sc_goal_change"

\end_inset

.
 These actions are axiomatised as per standard actions, but special-case
 handling is introduced in the axioms for knowledge in order to model their
 communicative effects.
\end_layout

\begin_layout Standard
Instantaneous communication is modelled using actions such as 
\begin_inset Formula $inform$
\end_inset

, where 
\begin_inset Formula $inform(agt_{s},agt_{r},\phi)$
\end_inset

 means the sender 
\begin_inset Formula $agt_{s}$
\end_inset

 informs the receiver 
\begin_inset Formula $agt_{r}$
\end_inset

 of the truth of some formula 
\begin_inset Formula $\phi$
\end_inset

.
 If we assert that only truthful speech acts are allowed, and all actions
 are publicly observable, then this requires no further axiomatisation:
\begin_inset Formula \[
Poss(inform(agt_{s},agt_{r},\phi),s)\,\equiv\,\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $inform$
\end_inset

 action will be included in each agent's observations whenever it occurs,
 from which the agent can conclude that it was possible and thus that the
 contained formula holds in the world.
\end_layout

\begin_layout Standard
However, this simple approach can lead to third-party agents being aware
 of what was communicated, which is often not desirable.
 In 
\begin_inset LatexCommand citep
key "shapiro01casl_feat_inter"

\end_inset

 encrypted speech acts are introduced to overcome this limitation, ensuring
 that only the intended recipient of a message is able to access its contents
 by performing a special 
\emph on
decrypt
\emph default
 action.
 While it would be straightforward to copy this approach in our formalism,
 the problem it was introduced to solve no longer exists; we can directly
 limit the accessibility of the message contents to the receiving agent
 without introducing another action:
\begin_inset Formula \begin{gather*}
inform(s,r)\in Obs(agt,c,s)\,\equiv\,\exists m:\, inform(s,r,m)\in c\\
inform(s,r,m)\in Obs(agt,c,s)\,\equiv\, inform(s,r,m)\in c\wedge\left(agt=r\vee agt=s\right)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Here all agents will observe that the communication occurred, but only the
 sender and recipient can access the contents of the message.
\end_layout

\begin_layout Standard
Non-instantaneous communication can be modelled using a message queue for
 each agent with separate 
\begin_inset Formula $send$
\end_inset

 and 
\begin_inset Formula $check$
\end_inset

 actions 
\begin_inset LatexCommand citep
key "Lesperance99sitcalc_approach"

\end_inset

.
 The 
\begin_inset Formula $send$
\end_inset

 action adds a message to the queue, while the 
\begin_inset Formula $check$
\end_inset

 action returns the details of pending messages as its sensing result.
 Since this approach uses the standard sensing-result machinery, it requires
 no special axiomatisation in our framework.
\end_layout

\begin_layout Subsection
New Axiomatisations
\begin_inset LatexCommand label
name "sec:Observations:Axiomatising-extended"

\end_inset


\end_layout

\begin_layout Standard
From the above examples, it should be clear that our formalism can capture
 the information available to each agent under a variety of domain dynamics
 already modelled in the situation calculus.
 We now demonstrate some new axiomatisations of domains that have not previously
 been explored in the situation calculus.
\end_layout

\begin_layout Subsubsection
Explicit Observability Axioms
\begin_inset LatexCommand label
name "sec:Observations:CanObs"

\end_inset


\end_layout

\begin_layout Standard
Our approach offers a straightforward way to explore the middle ground between
 the two extremes of 
\begin_inset Quotes eld
\end_inset

public actions
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

private actions
\begin_inset Quotes erd
\end_inset

 discussed in the previous section.
 To axiomatise general 
\emph on
partial observability
\emph default
 of actions, we introduce a new action description predicate 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 that defines the conditions under which agent 
\begin_inset Formula $agt$
\end_inset

 would observe action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 If 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 is false, then that action will be hidden.
 We can then define 
\begin_inset Formula $Obs$
\end_inset

 as follows:
\begin_inset Formula \[
a\in Obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
This permits a great deal of flexibility in the axiomatisation.
 Consider a domain in which the agents inhabit several different rooms,
 and are aware of all the actions performed in the same room as themselves:
\begin_inset Formula \[
CanObs(agt,a,s)\equiv InSameRoom(agt,actor(a),s)\]

\end_inset


\end_layout

\begin_layout Standard
It is also possible to allow partial observability of sensing results using
 an analo\SpecialChar \-
gous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 and the following definition of 
\begin_inset Formula $Obs$
\end_inset

:
\begin_inset Formula \begin{multline*}
a\in Obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\\
\shoveleft{a\#r\in Obs(agt,c,s)\equiv a\in c\wedge SR(a,s)=r}\\
\wedge CanObs(agt,a,s)\wedge CanSense(agt,a,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
For example, consider an agent waiting for a train who activates a speaker
 to determine when it will arrive.
 The results of this sensing action would provide information to any other
 agent within earshot:
\begin_inset Formula \[
CanSense(agt,activateSpeaker(agt_{2}),s)\equiv CloseToSpeaker(agt)\]

\end_inset


\end_layout

\begin_layout Standard
We feel that this formulation provides a good balance between simplicity
 and expressiveness; it allows the observability of actions to vary according
 to the state of the world, but provides agents with a complete description
 of each action that they are capable of observing.
\end_layout

\begin_layout Subsubsection
Observability Interaction
\end_layout

\begin_layout Standard
Reasoning about observability of concurrent actions raises the potential
 for 
\emph on
observability interaction
\emph default
, in which some actions produce different observations when they are performed
 concurrently with another action.
 Like the precondition interaction problem for 
\begin_inset Formula $Poss$
\end_inset

 discussed in Section 
\begin_inset LatexCommand ref
reference "sec:Background:Concurrent-Actions"

\end_inset

, we assume that the axiom defining 
\begin_inset Formula $Obs$
\end_inset

 contains the appropriate logic to handle such interaction.
 A simple axiomatisation might have actions being 
\begin_inset Quotes eld
\end_inset

masked
\begin_inset Quotes erd
\end_inset

 by the co-occurrence of another action, and would appear like so:
\begin_inset Formula \[
a\in Obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\wedge\neg\exists a'\in c:\, Masks(a',a,s)\]

\end_inset


\end_layout

\begin_layout Standard
The important point is that, given an explicit account of the local perspective
 of each agent, such interaction can be axiomatised independently of the
 rest of the action theory.
\end_layout

\begin_layout Subsubsection
Observing the Effects of Actions
\end_layout

\begin_layout Standard
In many domains it would be infeasible for an agent to observe all of the
 details of a particular action when it occurs, but it may observe some
 of the effects of that action.
 For example, suppose that an agent monitors the state of a light in its
 environment, such that it notices it changing from dark to light.
 While it knows that 
\emph on
some
\emph default
 action must have occurred to produce that effect, it may not be sure precisely
 what action took place (e.g.
 precisely 
\emph on
who
\emph default
 turned on the light).
 This can be modelled by further extending the 
\noun on
Observation
\noun default
 sort to contain a special 
\begin_inset Quotes eld
\end_inset

effect observation
\begin_inset Quotes erd
\end_inset

 term 
\begin_inset Formula $lightCameOn$
\end_inset

, and axiomatising like so:
\begin_inset Formula \[
lightCameOn\in Obs(agt,c,s)\equiv\neg lightIsOn(s)\wedge\exists agt':\, turnLightOn(agt')\in c\]

\end_inset


\end_layout

\begin_layout Standard
When the light is switched on, each agent's observation set will contain
 the term 
\begin_inset Formula $lightCameOn$
\end_inset

, and they will be able to deduce that this change has occurred without
 necessarily knowing the specific action responsible for the change.
 This is similar to the 
\begin_inset Quotes eld
\end_inset

fluent change
\begin_inset Quotes erd
\end_inset

 actions proposed by 
\begin_inset LatexCommand citet
key "degiacomo98execution_monitoring"

\end_inset

, but embedded in the theory itself rather than generated by the agent when
 it discovers that it must update its beliefs.
\end_layout

\begin_layout Subsubsection
Delayed Communication
\begin_inset LatexCommand label
name "sec:Observations:Delayed"

\end_inset


\end_layout

\begin_layout Standard
Delayed communication can be modelled using separate 
\begin_inset Formula $send$
\end_inset

 and 
\begin_inset Formula $recv$
\end_inset

 actions.
 However, unlike the use of explicit communication channels discussed on
 the previous section, we do not want the receiving agent to have to poll
 the message queue.
 Rather, the 
\begin_inset Formula $recv$
\end_inset

 action should occur automatically some time after the 
\begin_inset Formula $send$
\end_inset

 action.
\end_layout

\begin_layout Standard
This is easily modelled by making 
\begin_inset Formula $recv$
\end_inset

 a natural action.
 The 
\begin_inset Formula $send/recv$
\end_inset

 pair can then be axiomatised mirroring the standard account of long-running
 tasks in the situation calculus.
 A fluent 
\begin_inset Formula $PendMsg(s,r,m,t)$
\end_inset

 indicates that some message is pending and will be delivered at time 
\begin_inset Formula $t$
\end_inset

.
 We have:
\begin_inset Formula \begin{gather*}
natural(recv(agt_{s},agt_{r},m))\\
send(agt_{s},agt_{r},m)\in Obs(agt,c,s)\equiv send(agt_{s},agt_{r},m)\in c\wedge agt=agt_{s}\\
recv(agt_{s},agt_{r},m)\in Obs(agt,c,s)\equiv recv(agt_{s},agt_{r},m)\in c\wedge agt=agt_{r}\\
Poss(recv(agt_{s},agt_{r},m)\#t,s)\equiv PendMsg(agt_{s},agt_{r},m,t,s)\end{gather*}

\end_inset

 
\begin_inset Formula \begin{multline*}
PendMsg(s,r,m,t_{m},do(c\#t,s))\,\equiv send(s,r,m)\in c\wedge t_{m}=t+delay(s,r,m,s)\\
\vee PendMsg(s,s,m,t_{m},s)\wedge\left(recv(s,r,m)\not\in c\vee t\neq t_{m}\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Formula $send$
\end_inset

 action thus causes the message to become pending, with its delivery time
 determined by the functional fluent 
\begin_inset Formula $delay$
\end_inset

.
 Once the delay time has elapsed, the natural action 
\begin_inset Formula $recv$
\end_inset

 will be triggered and the message delivered.
 The 
\begin_inset Formula $send$
\end_inset

 and 
\begin_inset Formula $recv$
\end_inset

 messages are observed only by the sender and receiver respectively.
\end_layout

\begin_layout Standard
If the agents have incomplete information about the 
\begin_inset Formula $delay$
\end_inset

 function, this can easily model domains in which the message delay is unpredict
able or even unbounded, giving asynchronous communication in the style of
 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
\end_layout

\begin_layout Subsection
Reasoning from Observations
\begin_inset LatexCommand label
name "sec:Observations:Reasoning"

\end_inset


\end_layout

\begin_layout Standard
With these definitions in place, we can now give a principled account of
 what it means for an agent to reason using its local information.
 Recall that in the single-agent setting of IndiGolog 
\begin_inset LatexCommand citep
key "giacomo99indigolog"

\end_inset

 a pair of macros is used to construct a query of the following form given
 the agent's current history 
\begin_inset Formula $h$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\mathbf{Sensed}[h]\,\rightarrow\,\phi[\mathbf{end}[h]]\]

\end_inset


\end_layout

\begin_layout Standard
This depends crucially on the assumption that all actions are publicly observabl
e, so that the macro 
\begin_inset Formula $\mathbf{end}$
\end_inset

 can construct the precise situation term corresponding to a given history.
 The resulting query is in a form that can be answered effectively using
 the standard regression operator.
\end_layout

\begin_layout Standard
We can pose a similar query using the definition of a global history in
 our framework.
 First, define a history to be legal if it contains the correct sensing
 results for a legal situation:
\begin_inset Formula \[
Legal(h)\,\isdef\, Legal(Sit(h))\wedge History(Sit(h))=h\]

\end_inset

 Then an appropriate query using the current history 
\begin_inset Formula $h$
\end_inset

 would be:
\begin_inset Formula \[
\Dt\,\models\, Legal(h)\,\rightarrow\,\phi[Sit(h)]\]

\end_inset


\end_layout

\begin_layout Standard
Since these are no longer macros, but are now actual functions in the logic,
 this query is not immediately amenable to standard regression techniques.
 However, since a history can always be converted into a unique corresponding
 situation term, we can easily provide special-purpose regression rules
 as follows: 
\begin_inset Formula \begin{gather*}
\Reg(\phi[Sit(\epsilon)])\,\isdef\,\phi[S_{0}]\\
\Reg(\phi[Sit((c\#y)\cdot h)])\,\isdef\,\Reg(\phi,c)[Sit(h)]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
These rules mirror the definition of 
\begin_inset Formula $\mathbf{end}$
\end_inset

 and preserve equivalence given the definition of the 
\begin_inset Formula $History$
\end_inset

 function.
 Since 
\begin_inset Formula $Legal$
\end_inset

 and 
\begin_inset Formula $History$
\end_inset

 are ordinary fluents they can be handled by standard regression rules.
 Agents can therefore use such a query to do regression-based reasoning
 about some hypothetical future state of the world, for example for the
 purposes of planning.
\end_layout

\begin_layout Standard
As we shall see in the coming chapters, for offline planning we can permit
 the agents to reason using the hypothetical global history rather than
 their local observations.
 For richer epistemic reasoning about the current state of the world, we
 will require a technique capable of performing inductive reasoning.
\end_layout

\begin_layout Subsection
Discussion
\begin_inset LatexCommand label
name "sec:Observations:Discussion"

\end_inset


\end_layout

\begin_layout Standard
In this chapter we have constructed an explicit representation of the local
 perspective of each agent, in terms of 
\emph on
observations
\emph default
 and 
\emph on
views
\emph default
.
 This terminology has been deliberately chosen to mirror that used in other
 formalisms where representing this local perspective is the norm, such
 as 
\begin_inset LatexCommand citep
key "parikh85dist_knowledge,halpern90knowledge_distrib"

\end_inset

.
 As the examples in Sections 
\begin_inset LatexCommand ref
reference "sec:Observations:Axiomatising-simple"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "sec:Observations:Axiomatising-extended"

\end_inset

 have demonstrated, this approach is able to capture a very wide variety
 of domain dynamics in a flexible way.
\end_layout

\begin_layout Standard
Some of our axioms in Sections 
\begin_inset LatexCommand ref
reference "sec:Observations:Axiomatising-simple"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "sec:Observations:Axiomatising-extended"

\end_inset

 may seem rather ad-hoc, but we claim they are no more or less ad-hoc than
 the many adjustments made to the axioms defining the knowledge fluent 
\begin_inset Formula $K$
\end_inset

 to accommodate different kinds of information-producing action 
\begin_inset LatexCommand citep
key "shapiro98specifying_ma_systems,Lesperance99sitcalc_approach,shapiro01casl_feat_inter,Petrick06thesis,shapiro07sc_goal_change"

\end_inset

.
 The difference is that these adjustments can now be made separately from
 the rest of the theory, rather than in the fundamental axiom for reasoning
 about knowledge.
 This makes our formalism significantly more elaboration tolerant, a point
 we will return to in Chapter 
\begin_inset LatexCommand ref
reference "ch:knowledge"

\end_inset

.
 It also means that for certain applications, we can reason about an agent's
 local view without the overhead of performing explicit epistemic reasoning.
\end_layout

\begin_layout Standard
Of course, we also pay a price for this extra expressive power: representational
 complexity.
 The theory of action must contain an explicit axiomatisation of the 
\noun on
Observation
\noun default
 sort and of our new 
\begin_inset Formula $Obs$
\end_inset

 function.
 There is something of a tradition in the situation calculus of doing as
 much as possible at the meta-level, adding to the theory itself only when
 necessary 
\begin_inset LatexCommand citep
key "levesque97golog"

\end_inset

.
 As we will demonstrate in the remainder of this thesis, the advantages
 provided by our explicit representation of each agent's local perspective
 more than compensate for the added complexity it introduces to the theory
 of action.
\end_layout

\begin_layout Standard
From the perspective of the rest of the thesis, the key contribution of
 this chapter is to provide a uniform representation formalism.
 The domain-specific observability dynamics can now be specified independently
 from the rest of the theory.
 By 
\begin_inset Quotes eld
\end_inset

factoring out
\begin_inset Quotes erd
\end_inset

 the details in this way, we are in a position to construct formalisms and
 reasoning techniques that do not make any assumptions about action observabilit
y.
 In particular, we can explicitly represent and reason about asynchronous
 domains.
\end_layout

\begin_layout Section
Joint Executions
\end_layout

\begin_layout Standard
This chapter constructs a new representation for the actions to be performed
 by a team of agents during the cooperative execution of a shared task.
 Dubbed 
\emph on
joint executions
\emph default
, they are partially-ordered branching sequences of events.
 Joint executions allow independent actions to be performed independently,
 while using each agent's local view to ensure that synchronisation is always
 possible when required.
\end_layout

\begin_layout Standard
The output of the standard Golog execution planning process is a raw situation
 term; a complete, ordered sequence of all actions that are to be performed.
 This is suboptimal for generating and representing plans in an asynchronous
 multi-agent setting in three ways:
\end_layout

\begin_layout Itemize
it does not permit branching to utilise information obtained at run-time
 
\end_layout

\begin_layout Itemize
it enforces a strict execution order on actions that are potentially independent
, requiring inter-agent synchronisation when it is not actually necessary
 
\end_layout

\begin_layout Itemize
it requires a strict execution order on actions that may be unobservable,
 demanding inter-agent synchronisation that is not actually feasible 
\end_layout

\begin_layout Standard
As we have demonstrated in Chapter 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

, restricting the domain to be synchronous and completely known lets the
 agents make effective use of raw situation terms for planning.
 In asynchronous domains with incomplete knowledge they are no longer sufficient
, and the Golog execution planner is required to generate a much richer
 representation of the actions to be performed.
\end_layout

\begin_layout Standard
To build such a representation, we take inspiration from a model of concurrent
 computation known as 
\emph on
prime event
\emph default
 
\emph on
structures
\emph default
, which are partially-ordered branching sequences of events 
\begin_inset LatexCommand citep
key "npw79event_structures"

\end_inset

.
 A 
\emph on
joint execution
\emph default
 is defined as a particular kind of prime event structure that is rich enough
 to capture the concurrent execution of independent actions and can branch
 on the results of sensing actions.
 We use our explicit account of an agent's local view to identify joint
 executions that can feasibly be executed based on the local information
 available to each agent at runtime.
\end_layout

\begin_layout Standard
Joint executions are formalised in a way that translates well into an implementa
tion.
 They can be built up one action at a time in much the same way as ordinary
 situation terms.
 If the theory of action meets some simple restrictions, joint executions
 can also be reasoned about using standard regression techniques.
 We demonstrate an implementation that performs offline execution planning
 for an asynchronous, partially observable domain, and discuss the challenges
 faced when attempting a cooperative online execution in such domains.
\end_layout

\begin_layout Standard
Joint executions thus allow us to represent the actions that a team of agents
 are to perform in service of some shared task, without requiring constant
 synchronisation between the agents, and without assuming that agents know
 all the actions that have been performed, while utilising existing reasoning
 methods and planning machinery.
 This is a significant increase in power over existing approaches to planning
 for multi-agent teams in the situation calculus.
\end_layout

\begin_layout Standard
The chapter proceeds as follows: after some more detailed background information
 in Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Background"

\end_inset

, we formally define and axiomatise joint executions in Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:JEs"

\end_inset

.
 Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Planning"

\end_inset

 then characterises the Golog execution planning problem in terms of joint
 executions rather than raw situation terms, and Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Reasonable"

\end_inset

 identifies a restricted kind of joint execution that can be reasoned about
 effectively using standard regression techniques.
 In Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Implementation"

\end_inset

 we present an overview of our new MIndiGolog execution planner that generates
 joint executions, and show some examples of its output.
 Finally, Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Discussion"

\end_inset

 concludes with some general discussion and an outline of our ongoing work
 in this area.
\end_layout

\begin_layout Subsection
Background
\begin_inset LatexCommand label
name "sec:JointExec:Background"

\end_inset


\end_layout

\begin_layout Standard
The above discussion highlights three important properties of a plan representat
ion formalism intended for use in asynchronous multi-agent domains: it must
 be 
\emph on
partially-ordered
\emph default
 to allow agents to operate independently, 
\emph on
branching
\emph default
 to allow information to be collected at run-time, and 
\emph on
feasible to execute
\emph default
 based on the local information available to each agent.
 While each of these aspects have been studied in isolation in the situation
 calculus, our work is the first to combine them into a single formalism
 that is suitable for asynchronous multi-agent domains.
\end_layout

\begin_layout Subsubsection
Partial Ordering
\end_layout

\begin_layout Standard
There has been little work on partial-order planning in the situation calculus,
 most likely because the use of situations heavily biases the reasoning
 machinery towards totally-ordered sequences of actions.
 While 
\begin_inset LatexCommand citet
key "son00htn_golog"

\end_inset

 allow the programmer to specify a partial order on actions by adding operators
 to the Golog language, the actual plans produced by their system are still
 ordinary situation terms.
 One exception is 
\begin_inset LatexCommand citep
key "plaisted97sc_aspect"

\end_inset

, which extends the situation calculus with explicit 
\begin_inset Quotes eld
\end_inset

aspects
\begin_inset Quotes erd
\end_inset

 and allows partial ordering between actions that affect different aspects
 of the world state.
 By contrast, we seek to leverage the existing meta-theory of the standard
 situation calculus.
\end_layout

\begin_layout Standard
Partial-order planning is the mainstay of the closely-related 
\emph on
event calculus
\emph default
 formalism 
\begin_inset LatexCommand citep
key "kowalski86event_calculus"

\end_inset

.
 In this formalism, actions are represented as occurring at specific times,
 rather than in a specific order as in the situation calculus.
 Constraints placed on the relative occurrence times of actions then determine
 a partial ordering.
 
\begin_inset LatexCommand citet
key "Shanahan97ec_planning"

\end_inset

 has shown that abductive theorem proving in the event calculate generates
 partially-ordered plans, and the mechanics of the theorem prover naturally
 mirror various concepts from the goal-based partial-order planning literature,
 such as conflicts, threats and links 
\begin_inset LatexCommand citep
key "peot92conditional_nonlinear"

\end_inset

.
\end_layout

\begin_layout Standard
The close similarities between the situation and event calculi are well
 understood, as are the advantages of the event calculus when working with
 partially-ordered action sequences 
\begin_inset LatexCommand citep
key "belleghem97sitcalc_evtcalc"

\end_inset

.
 Indeed, it is possible to implement a Golog interpreter on top of the event
 calculus, and the execution plans it generates are partially-ordered sets
 of actions 
\begin_inset LatexCommand citep
key "pereira04ec_golog"

\end_inset

.
 Perhaps we should simply adopt a formalism such as the event calculus that
 is naturally partially-ordered, rather than trying to construct a partially-ord
ered representation on top of the naturally sequential situation calculus?
\end_layout

\begin_layout Standard
Having a partial-order representation is important, but it is not the complete
 picture.
 While we don't want the agents to have to synchronise their actions unnecessari
ly, we also need to ensure the converse: that when an explicit ordering
 between actions is 
\emph on
necessary
\emph default
, the required synchronisation is actually 
\emph on
feasible
\emph default
 based on the local information available to each agent.
 It is not clear how techniques such as 
\begin_inset LatexCommand citep
key "pereira04ec_golog"

\end_inset

 would extend to the asynchronous multi-agent case.
\end_layout

\begin_layout Standard
By taking advantage of our explicit account of the local information available
 to each agent, the formalism developed in this chapter enables these dual
 requirements - that some actions don't need to be ordered, while other
 actions cannot be ordered - to be captured in an elegant way.
 Moreover, we do not need to step outside the bounds of existing situation
 calculus theory, and can utilise existing regression techniques for effective
 automated reasoning.
\end_layout

\begin_layout Subsubsection
Branching
\end_layout

\begin_layout Standard
Several single-agent formalisms based on the situation calculus have introduced
 some form of branching into the structures returned by the planner, including
 the conditional action trees of of sGolog 
\begin_inset LatexCommand citep
key "lakemeyer99golog_cats"

\end_inset

 and the branching IndiGolog plans of 
\begin_inset LatexCommand citep
key "giacomo04sem_delib_indigolog"

\end_inset

.
 These structures typically branch based on the truth or falsehood of test
 conditions included in the program.
 For example, the structural definition of conditional action trees in 
\begin_inset LatexCommand citep
key "lakemeyer99golog_cats"

\end_inset

 includes the following branching case:
\begin_inset Formula \[
c=[\phi,c_{1},c_{2}]\]

\end_inset


\end_layout

\begin_layout Standard
This instructs the agent to execute the sub-tree 
\begin_inset Formula $c_{1}$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 is true and the sub-tree 
\begin_inset Formula $c_{2}$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 is false.
 An alternate approach, exemplified by the 
\begin_inset Quotes eld
\end_inset

robot programs
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset LatexCommand citet
key "levesque98what_robots_can_do"

\end_inset

, is to have the plan branch directly on the results returned by actions
 rather than on a test condition.
 Branching on the binary result of a sensing action is represented in this
 formalism by the following structure:
\begin_inset Formula \[
branch(action,\delta_{1},\delta_{2})\]

\end_inset


\end_layout

\begin_layout Standard
Here the agent continues execution with program 
\begin_inset Formula $\delta_{1}$
\end_inset

 if the action returns true, and with 
\begin_inset Formula $\delta_{2}$
\end_inset

 if the action returns false.
 Plans that branch directly on the results of actions are typically longer,
 but easier for the agent to execute reactively since it does not need to
 introspect its knowledge base to decide a test condition.
\end_layout

\begin_layout Subsubsection
Feasibility
\begin_inset LatexCommand label
name "sec:JointExec:BG:Feasibility"

\end_inset


\end_layout

\begin_layout Standard
To allow an agent to execute a plan that depends on information collected
 at run-time, it is not sufficient to simply introduce branching into the
 plan representation formalism.
 One must also ensure that, at execution time, the agent will always 
\emph on
know
\emph default
 which branch of the plan to take.
 For example, suppose this simple branching plan will provably achieve a
 goal:
\begin_inset Formula \[
\mathbf{if}\,\,\phi\,\,\mathbf{then}\,\, action_{1}\,\,\mathbf{else\,}\, action_{2}\]

\end_inset


\end_layout

\begin_layout Standard
The agent can only execute this program if it knows whether or not 
\begin_inset Formula $\phi$
\end_inset

 holds; otherwise, although one of the branches is guaranteed to achieve
 the goal, the agent does not know which branch to take.
 Feasibility is typically guaranteed by including sensing actions to ensure
 that the test conditions become known when needed:
\begin_inset Formula \[
sense_{\phi}\,\,;\,\mathbf{if\,}\,\phi\,\,\mathbf{then}\,\, action_{1}\,\,\mathbf{else\,}\, action_{2}\]

\end_inset


\end_layout

\begin_layout Standard
This requirement that an agent 
\begin_inset Quotes eld
\end_inset

knows how
\begin_inset Quotes erd
\end_inset

 to execute a plan is formalised by various notions of 
\emph on
epistemic feasibility
\emph default
, including those of 
\begin_inset LatexCommand citep
key "levesque98what_robots_can_do,levesque00knowing_how,Lesperance01epi_feas_casl,giacomo04sem_delib_indigolog,baier06programs_that_sense"

\end_inset

.
\end_layout

\begin_layout Standard
One approach to ensuring feasibility, embodied by 
\begin_inset LatexCommand citep
key "levesque00knowing_how,giacomo04sem_delib_indigolog,baier06programs_that_sense"

\end_inset

, is to represent plans by arbitrary programs formulated in a control language
 such as Golog.
 One then semantically characterises the class of epistemically feasible
 programs, using direct assertions about the knowledge of each agent at
 each stage of execution.
 While this allows for potentially very rich, very succinct plans, it is
 not clear how to systematically generate an epistemically feasible plan
 using such a general characterisation.
\end_layout

\begin_layout Standard
Another approach, advocated by 
\begin_inset LatexCommand citep
key "levesque96what_is_planning,levesque98what_robots_can_do"

\end_inset

 and used in the implementation section of 
\begin_inset LatexCommand citep
key "giacomo04sem_delib_indigolog"

\end_inset

, is to restrict the structure of plans so that they are always epistemically
 feasible.
 For example, the 
\begin_inset Quotes eld
\end_inset

robot programs
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset LatexCommand citep
key "levesque98what_robots_can_do"

\end_inset

 are restricted to simple operators such as sequencing, branching and looping:
\begin_inset Formula \begin{gather*}
action\\
seq(\delta_{1},\delta_{2})\\
branch(action,\delta_{1},\delta_{2})\\
loop(branch(action,\delta,exit))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
These programs do not contain test conditions, but rather branch and loop
 directly according to the sensing results returned from each action.
 There is therefore no potential for confusion when executing such programs;
 they are essentially equivalent to a kind of finite automaton that can
 be executed reactively.
 Nevertheless, 
\begin_inset LatexCommand citet
key "levesque98what_robots_can_do"

\end_inset

 show that these programs are universal, in the sense that any achievable
 goal can be achieved by suitable a robot program.
 We are not aware of any work extending this approach to represent programs
 intended for cooperative execution by a team of agents.
\end_layout

\begin_layout Standard
These existing notions of epistemic feasibility can be broadly characterised
 as 
\emph on
knowing what
\emph default
.
 At each stage of execution, each agent must know what its next action is.
 In synchronous domains with public actions, as typically studied in the
 situation calculus, this is sufficient to ensure the feasibility of executing
 a plan.
\end_layout

\begin_layout Standard
In asynchronous domains it is not enough for an agent to know 
\emph on
what
\emph default
 its next action is; it must also know 
\emph on
when
\emph default
 that action should be performed.
 For example, suppose that the following simple plan provably achieves a
 goal:
\begin_inset Formula \[
action_{1}(agt_{1})\,;\, action_{2}(agt_{2})\]

\end_inset


\end_layout

\begin_layout Standard
In a synchronous domain this plan can be executed directly.
 But suppose the domain is asynchronous, and 
\begin_inset Formula $agt_{2}$
\end_inset

 is unable to observe the occurrence of 
\begin_inset Formula $action_{1}$
\end_inset

.
 Since 
\begin_inset Formula $agt_{2}$
\end_inset

 has no way of knowing whether or not 
\begin_inset Formula $action_{1}$
\end_inset

 has been performed yet, it will not know when to perform 
\begin_inset Formula $action_{2}$
\end_inset

 and the plan cannot be executed.
\end_layout

\begin_layout Standard
In this chapter we ensure plan feasibility by restricting the structure
 used to represent plans, in an approach similar to 
\begin_inset LatexCommand citep
key "levesque98what_robots_can_do"

\end_inset

 but without looping constructs.
 We use the explicit account of an agent's local view developed in the previous
 chapter to ensure that each agent will always have enough information to
 determine what action to perform next, and when to perform it.
\end_layout

\begin_layout Subsubsection
Event Structures
\end_layout

\begin_layout Standard
To tackle cooperative execution in a multi-agent setting, we have adopted
 a model of concurrent computation known as 
\emph on
event structures
\emph default
 
\begin_inset LatexCommand citep
key "npw79event_structures"

\end_inset

.
 The particular variant we are interested in are 
\emph on
prime event structures
\emph default
, which are defined as follows.
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Prime\InsetSpace ~
Event\InsetSpace ~
Structure
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] A prime event structure is a four-tuple 
\begin_inset Formula $(\mathcal{V},\gamma,\prec,\oplus)$
\end_inset

 where: 
\begin_inset Formula $\mathcal{V}$
\end_inset

 is a set of events; 
\begin_inset Formula $\gamma$
\end_inset

 is a function assigning a label to each event; 
\begin_inset Formula $\prec$
\end_inset

 is the precedence relation, a strict partial order on events; 
\begin_inset Formula $\oplus$
\end_inset

 is the conflict relation, a binary symmetric relation indicating events
 that are mutually exclusive.
 
\end_layout

\begin_layout Standard
The labels assigned by 
\begin_inset Formula $\gamma$
\end_inset

 give the action associated with each event.
 By using a labelling scheme rather than identifying events directly with
 actions, multiple events can result in the same action being performed.
 The precedence relation restricts the order in which events can occur,
 so that if 
\begin_inset Formula $e1\prec e2$
\end_inset

 then 
\begin_inset Formula $e1$
\end_inset

 must occur before 
\begin_inset Formula $e2$
\end_inset

.
 The conflict relation allows the structure to represent branching, by having
 the occurrence of some events preclude the occurrence of others.
\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:example-pes"

\end_inset

 shows a simple example of a prime event structure.
 The arrows represent the precedence relation, so in this diagram we have
 
\begin_inset Formula $e1\prec e3\prec e7$
\end_inset

, but 
\begin_inset Formula $e3\not\prec e4$
\end_inset

.
 The conflict relation is represented using a dotted line, so we have 
\begin_inset Formula $e2\oplus e3$
\end_inset

 and only one of these two events is permitted to occur.
 Conflict is also inherited through the precedence relation, so 
\begin_inset Formula $e6\oplus e7$
\end_inset

 in this diagram.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "97col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\align center

\family sans
\series bold
\size tiny
\begin_inset Graphics
	filename /storage/pgrad/writings/thesis/listings/jointexec/example_pes.eps
	scale 35

\end_inset


\family default
\series default

\begin_inset ERT
status collapsed

\begin_layout Standard

{}
\end_layout

\end_inset


\size default
 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
An example Prime Event Structure.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:example-pes"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As it can be cumbersome to specify 
\begin_inset Formula $\prec$
\end_inset

 and 
\begin_inset Formula $\oplus$
\end_inset

 in their entirety, we will instead specify only the direct 
\emph on
enablers
\emph default
 and 
\emph on
alternatives
\emph default
 for each event, denoted by 
\begin_inset Formula $ens(i)$
\end_inset

 and 
\begin_inset Formula $alts(i)$
\end_inset

 respectively.
 Construction of 
\begin_inset Formula $(\prec,\oplus)$
\end_inset

 from 
\begin_inset Formula $(ens,alts)$
\end_inset

 is a straightforward transitive closure.
 Indeed, it only the enablers and alternatives that are represented explicitly
 in Figure 
\begin_inset LatexCommand ref
reference "fig:example-pes"

\end_inset

, by arrows and dotted lines respectively.
\end_layout

\begin_layout Standard
A 
\emph on
configuration
\emph default
 is a sequence of events consistent with 
\begin_inset Formula $\prec$
\end_inset

 in which no pair of events conflict.
 Each configuration represents a potential partial run of execution of the
 system.
 Event structures thus form a directed acyclic graph of the events that
 could occur during execution of the system.
 As shown in 
\begin_inset LatexCommand citep
key "pratt91modeling_conc_with_geom"

\end_inset

, these structures are a canonical representation of a variety of formalisms
 for representing concurrent execution, and it is straightforward to execute
 them in a purely reactive fashion.
\end_layout

\begin_layout Subsection
Joint Executions
\begin_inset LatexCommand label
name "sec:JointExec:JEs"

\end_inset


\end_layout

\begin_layout Standard
This section defines 
\emph on
joint execution
\emph default
s as a restricted kind of prime event structure suitable for representing
 the actions of a team of agents in an asynchronous domain.
 We begin with a high-level intuitive description to motivate these structures,
 and then formally define them using a set of axioms to be included in the
 theory of action 
\begin_inset Formula $\Dt$
\end_inset

.
 Since we intend for agents to synthesise joint executions as the output
 of a planning process, they must exist as concrete terms in the logic.
\end_layout

\begin_layout Subsubsection
Motivation
\end_layout

\begin_layout Standard
To make things more concrete, consider again the 
\begin_inset Quotes eld
\end_inset

cooking agents
\begin_inset Quotes erd
\end_inset

 example domain from Chapter 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

 and the 
\begin_inset Formula $MakeSalad$
\end_inset

 program shown in Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:MakeSalad"

\end_inset

.
 In a completely-known, synchronous domain, the execution found for this
 program by our MIndiGolog interpreter was a linear sequence of concurrent
 actions as shown in Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:MakeSalad-in-MIndiGolog"

\end_inset

 on page 
\begin_inset LatexCommand pageref
reference "fig:MIndiGolog:MakeSalad-in-MIndiGolog"

\end_inset

.
\end_layout

\begin_layout Standard
Let us now suppose that the cooking agents domain is asynchronous, and all
 actions other than 
\begin_inset Formula $release$
\end_inset

 and 
\begin_inset Formula $acquire$
\end_inset

 are private.
 The execution found by a MIndiGolog interpreter for such a domain cannot
 assume that the agents perform their actions in lock-step.
 Rather, it should allow the agents to process their respective ingredients
 independently, synchronising their actions only on the 
\begin_inset Formula $release$
\end_inset

/
\begin_inset Formula $acquire$
\end_inset

 sequence necessary to gain control of shared utensils.
\end_layout

\begin_layout Standard
An appropriate partially-ordered representation of the actions to be performed
 for 
\begin_inset Formula $MakeSalad$
\end_inset

 would then look something like the structure shown in Figure 
\begin_inset LatexCommand ref
reference "fig:JE:MakeSalad1"

\end_inset

.
 For simplicity, we do not consider time or natural actions in this chapter,
 and have collapsed the 
\begin_inset Quotes eld
\end_inset

mix
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

chop
\begin_inset Quotes erd
\end_inset

 tasks into primitive actions.
 Without expanding on the details at this stage, it should be clear that
 this structure captures the same basic workflow as the synchronous execution
 of 
\begin_inset Formula $MakeSalad$
\end_inset

 from Chapter 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

, but without imposing a strict ordering between the independent actions
 of different agents.
\end_layout

\begin_layout Standard
Indeed, Figure 
\begin_inset LatexCommand ref
reference "fig:JE:MakeSalad1"

\end_inset

 is the joint execution produced for the 
\begin_inset Formula $MakeSalad$
\end_inset

 program by our new execution planner detailed in Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Implementation"

\end_inset

, although with certain details suppressed for brevity.
 It may be helpful to keep this structure in mind as we develop the formal
 definitions contained in this section.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !h
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "97col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\align center

\family sans
\series bold
\size tiny
\begin_inset Graphics
	filename /storage/pgrad/writings/thesis/listings/jointexec/salad1_plan.eps
	scale 25

\end_inset


\family default
\series default

\begin_inset ERT
status collapsed

\begin_layout Standard

{}
\end_layout

\end_inset


\size default
 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Joint Execution for the 
\begin_inset Formula $MakeSalad$
\end_inset

 Program
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:JE:MakeSalad1"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Intuitions
\end_layout

\begin_layout Standard
We define a joint execution as a special kind of prime event structure as
 follows:
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Joint\InsetSpace ~
Execution
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] A joint execution is a tuple 
\begin_inset Formula $(\mathcal{A},\mathcal{O},ens,alts,\gamma,<)$
\end_inset

 where: action events 
\begin_inset Formula $\mathcal{A}$
\end_inset

 represent actions to be performed; outcome events 
\begin_inset Formula $\mathcal{O}$
\end_inset

 represent possible outcomes of actions; 
\begin_inset Formula $(\mathcal{A}\cup\mathcal{O},ens,alts,\gamma)$
\end_inset

 forms a prime event structure with precedence relation 
\begin_inset Formula $\prec$
\end_inset

; 
\begin_inset Formula $<$
\end_inset

 is a total order on events that is consistent with 
\begin_inset Formula $\prec$
\end_inset

.
 
\end_layout

\begin_layout Standard
A joint execution contains two disjoint sets of events: 
\emph on
action
\emph default
 events 
\begin_inset Formula $\mathcal{A}$
\end_inset

 representing the actions to be performed, and 
\emph on
outcome
\emph default
 events 
\begin_inset Formula $\mathcal{O}$
\end_inset

 representing the possible outcomes of each action.
 For each action event 
\begin_inset Formula $i\in\mathcal{A}$
\end_inset

, its enablers 
\begin_inset Formula $ens(i)$
\end_inset

 is a set of outcome events, its alternatives 
\begin_inset Formula $alts(i)$
\end_inset

 is empty, and its label 
\begin_inset Formula $\gamma(i)$
\end_inset

 is the action to be performed.
 For each outcome event 
\begin_inset Formula $i\in\mathcal{O}$
\end_inset

, 
\begin_inset Formula $ens(i)$
\end_inset

 is a single action event for which it is a possible outcome, 
\begin_inset Formula $alts(i)$
\end_inset

 is the set of all other outcome events 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $ens(j)=ens(i)$
\end_inset

, and 
\begin_inset Formula $\gamma(i)$
\end_inset

 is an outcome as produced by the 
\begin_inset Formula $Out({a},s)$
\end_inset

 function for the action 
\begin_inset Formula $\gamma(ens(i))$
\end_inset

.
\end_layout

\begin_layout Standard
Each action event thus represents a single action to be performed, which
 enables several alternative outcome events corresponding to the potential
 results returned by that action; since the action can only produce one
 actual outcome when it is executed, the enabled outcome events are all
 mutually conflicting.
 Each of these outcome events can then enable further action events, and
 so forth.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !b
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "97col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\family sans
\series bold
\size tiny
\begin_inset Graphics
	filename /storage/pgrad/writings/thesis/listings/jointexec/example_je.eps
	scale 35

\end_inset


\family default
\series default

\begin_inset ERT
status collapsed

\begin_layout Standard

{}
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A simple joint execution.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:example-je"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A simple example of a joint execution is shown in Figure 
\begin_inset LatexCommand ref
reference "fig:example-je"

\end_inset

, again using the 
\begin_inset Quotes eld
\end_inset

cooking agents
\begin_inset Quotes erd
\end_inset

 example domain.
 Here elliptical nodes are action events and box nodes are the resulting
 outcome events.
 The action 
\begin_inset Formula $checkFor$
\end_inset

 senses the presence of a type of ingredient, returning either 
\begin_inset Formula $T$
\end_inset

 or 
\begin_inset Formula $F$
\end_inset

, and thus producing two conflicting outcome events.
 In this example the agent 
\begin_inset Formula $Jim$
\end_inset

 senses for the availability of eggs, and if this returns true he acquires
 one; otherwise, he acquires a tomato.
 Meanwhile agent 
\begin_inset Formula $Joe$
\end_inset

 acquires a lettuce, independent of the actions 
\begin_inset Formula $Jim$
\end_inset

 is performing.
\end_layout

\begin_layout Standard
Since we are explicitly considering concurrent actions, there are many different
 possible ways that the events in this structure could translate into action
 occurrences.
 The independent actions 
\begin_inset Formula $checkFor(Jim,Egg)$
\end_inset

 and 
\begin_inset Formula $acquire(Joe,Lettuce1)$
\end_inset

 could be performed in either order, or even concurrently.
\end_layout

\begin_layout Standard
These structures are clearly much richer than ordinary situation terms,
 as they permit branching and partial-ordering between actions.
 Still, they correspond to sets of ordinary situation terms in a straightforward
 way.
 Recall that a 
\emph on
configuration
\emph default
 is a partial run of execution of a prime event structure.
 Clearly any configuration ending in an outcome event corresponds to a unique
 situation term and also a unique history term, as it is a sequence of alternati
ng actions and their outcomes.
\end_layout

\begin_layout Standard
We will call a set of unordered, non-conflicting outcome events a 
\emph on
branch
\emph default
.
 A branch identifies a set of partial runs of the joint execution.
 In Figure 
\begin_inset LatexCommand ref
reference "fig:example-je"

\end_inset

, the sets 
\begin_inset Formula $\{O3\}$
\end_inset

, 
\begin_inset Formula $\{O1,O3\}$
\end_inset

 and 
\begin_inset Formula $\{O5,O3\}$
\end_inset

 are examples of branches.
 A 
\emph on
leaf
\emph default
 is a special case of a branch, where every event is either in the leaf,
 conflicts with something in the leaf, or precedes something in the leaf;
 it thus represents potential 
\emph on
terminating
\emph default
 runs of the joint execution execution.
 In Figure 
\begin_inset LatexCommand ref
reference "fig:example-je"

\end_inset

 there are two leaves, 
\begin_inset Formula $\{O3,O4\}$
\end_inset

 and 
\begin_inset Formula $\{O3,O5\}$
\end_inset

, generated by the two alternate outcomes of the 
\begin_inset Formula $checkFor$
\end_inset

 action.
\end_layout

\begin_layout Standard
A 
\emph on
history
\emph default
 of a branch is a history term (as defined in Chapter 
\begin_inset LatexCommand ref
reference "ch:observations"

\end_inset

) that can be generated by performing actions and observing outcomes from
 the joint execution until all events in the branch have occurred.
 By these definitions, the set of histories of all leaves gives every possible
 history that could be produced by performing the joint execution through
 to a terminating configuration.
\end_layout

\begin_layout Standard
A joint execution has one additional component over a standard prime event
 structure: a 
\emph on
total
\emph default
 order on events 
\begin_inset Formula $<$
\end_inset

 that is consistent with the partial order 
\begin_inset Formula $\prec$
\end_inset

 induced by the enabling relation.
 We call this the 
\emph on
canonical ordering
\emph default
, and it allows any branch to be unambiguously translated into a single
 
\emph on
canonical history
\emph default
.
 When we come to use joint executions for planning, we will use the canonical
 history to avoid having to reason about all the (potentially exponentially-many
) histories of each leaf.
 The canonical ordering is essentially arbitrary; in practice it is determined
 by the order of insertion of events into the structure.
\end_layout

\begin_layout Subsubsection
Structural Axioms
\end_layout

\begin_layout Standard
We introduce new sorts 
\noun on
Event 
\noun default
and 
\noun on
JointExec
\noun default
 to 
\begin_inset Formula $\Lsit$
\end_inset

, and will collect the axioms defining joint executions in a separate axiom
 set 
\begin_inset Formula $\Dt_{je}$
\end_inset

.
 Events are opaque identifiers with which a joint execution associates a
 label, a set of enablers, and a set of alternatives.
 In practice we identify events with the integers, although our definitions
 require only a total ordering relation over events.
 Labels are either 
\noun on
Action
\noun default
 or 
\noun on
Outcome
\noun default
 terms.
 A joint execution is then a term containing:
\end_layout

\begin_layout Itemize
a set of 
\emph on
events
\emph default
, which are opaque ids having total order 
\begin_inset Formula $<$
\end_inset

 
\end_layout

\begin_layout Itemize
a mapping from each event to a 
\emph on
label
\emph default
, which is either an action or an outcome 
\end_layout

\begin_layout Itemize
a mapping from each event to its 
\emph on
enablers
\emph default
, a set of lower-numbered events 
\end_layout

\begin_layout Itemize
a mapping from each event to its 
\emph on
alternatives
\emph default
, a set of events 
\end_layout

\begin_layout Standard
We will use the function 
\begin_inset Formula $jexec$
\end_inset

 as a constructor for joint execution terms, specifying each of the four
 features above as an argument, and using sets of 
\begin_inset Formula $key\#value$
\end_inset

 pairs to represent a mapping as in the previous chapter.
\end_layout

\begin_layout Standard
First, we require a unique names axiom to specify that a joint execution
 is uniquely defined by its four components, and a domain closure axiom
 to specify that all joint executions are constructed in this way.
 Assuming the variables are restricted to appropriate sorts by 
\begin_inset Formula $\Lsit$
\end_inset

, the following axioms suffice:
\begin_inset Formula \begin{gather*}
\forall ex:\,\exists es,ls,ns,as:\,\, ex=jexec(es,ls,ns,as)\\
\\jexec(es,ls,ns,as)=jexec(es',ls',ns',as')\,\equiv\,\,\,\,\,\,\,\,\\
\,\,\,\,\,\,\,\, es=es'\wedge ls=ls'\wedge ns=ns'\wedge as=as'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We introduce four functions to access the components of a joint execution:
\begin_inset Formula \begin{gather*}
events(ex)=es\,\equiv\exists ls,ns,as:\, ex=jexec(es,ls,ns,as)\\
lblmap(ex)=ls\,\equiv\exists es,ns,as:\, ex=jexec(es,ls,ns,as)\\
ensmap(ex)=ns\,\equiv\exists es,ls,as:\, ex=jexec(es,ls,ns,as)\\
altsmap(ex)=as\,\equiv\exists es,ls,ns:\, ex=jexec(es,ls,ns,as)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We also define the following shortcut accessors to get the value from each
 mapping for a particular event 
\begin_inset Formula $i$
\end_inset

:
\begin_inset Formula \begin{gather*}
lbl(ex,i,l)\equiv i\#l\in lblmap(ex)\\
ens(ex,i,ns)\equiv i\#ns\in ensmap(ex)\\
alts(ex,i,as)\equiv i\#as\in altsmap(ex)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
For notational convenience we will often write these as functions, e.g.
 
\begin_inset Formula $ens(ex,i)=ns$
\end_inset

 rather than 
\begin_inset Formula $ens(ex,i,ns)$
\end_inset

, but this should be understood as an abbreviation since not every joint
 execution will contain every event.
\end_layout

\begin_layout Standard
We must also define the 
\emph on
precedes
\emph default
 and 
\emph on
conflicts
\emph default
 relations in terms of enablers and alternatives.
 These will be written as binary infix operators 
\begin_inset Formula $\prec_{ex}$
\end_inset

 and 
\begin_inset Formula $\oplus_{ex}$
\end_inset

 respectively.
 Since they are transitive closures they require a second-order axiomatisation.
 First, the precedence relation is defined as a simple transitive closure
 over enablers:
\begin_inset Formula \begin{multline*}
\forall P,ex,i,j:\left[\left(i\in ens(ex,j)\,\rightarrow P(i,j)\right)\wedge\left(\forall k:P(i,k)\wedge k\in ens(ex,j)\rightarrow P(i,j)\right)\right]\\
\rightarrow\left(P(i,j)\rightarrow i\prec_{ex}j\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Then we can define the conflict relation by specifying that 
\begin_inset Formula $i\oplus_{ex}j$
\end_inset

 if they are alternatives to each other, or they have conflicting predecessors:
\begin_inset Formula \begin{multline*}
\forall P,ex,i,j:\,\left[\left(i\in alts(ex,j)\,\rightarrow P(i,j)\right)\right.\\
\left.\wedge\,\left(\forall i',j':\, P(i',j')\wedge i'\preceq_{ex}i\wedge j'\preceq_{ex}j\,\rightarrow\, P(i,j)\right)\right]\\
\rightarrow\left(P(i,j)\rightarrow i\oplus_{ex}j\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Next we need axioms defining our terminology of 
\emph on
branches
\emph default
 and 
\emph on
leaves
\emph default
.
 A branch is a set of unordered non-conflicting outcome events:
\begin_inset Formula \begin{multline*}
Branch(ex,br)\,\equiv\,\forall i,j\in br:\, IsOutcome(lbl(ex,i))\wedge IsOutcome(lbl(ex,j))\\
\wedge\,\neg(i\oplus_{ex}j)\,\wedge\, i\not\prec_{ex}j\,\wedge\, j\not\prec_{ex}\, j\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
leaf
\emph default
 is defined as a special case of a branch, so that every event in the joint
 execution is either in the leaf, precedes something in the leaf, or conflicts
 with something in the leaf:
\begin_inset Formula \begin{multline*}
Leaf(ex,lf)\,\equiv\, Branch(ex,lf)\\
\wedge\forall i\in events(ex):\, i\in lf\,\equiv\,\neg(\exists i'\in lf:\,\, i\oplus_{ex}i'\,\vee\, i\prec_{ex}i')\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Finally, we say a joint execution is 
\emph on
proper
\emph default
 if it respects the basic structural intuitions we discussed in the previous
 section.
 Every event must be proper according to its type, and events cannot be
 enabled by higher-numbered events:
\begin_inset Formula \begin{gather*}
Proper(ex)\,\equiv\,\forall i\in events(ex):\, ProperAct(ex,i)\vee ProperOut(ex,i)\\
\wedge\forall i,j:\,\left(i\in events(ex)\wedge j\in ens(ex,i)\,\rightarrow\, j<i\right)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Note that this does not result in a loss of expressivity, since we we want
 event 
\begin_inset Formula $i$
\end_inset

 to precede event 
\begin_inset Formula $j$
\end_inset

, then 
\begin_inset Formula $j$
\end_inset

 cannot also precede 
\begin_inset Formula $i$
\end_inset

 and we simply give 
\begin_inset Formula $j$
\end_inset

 the higher event number.
 This restriction will play an important role in Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Reasonable"

\end_inset

.
\end_layout

\begin_layout Standard
An action event is proper if it has no alternatives, enables at least one
 outcome event, and is enabled by a branch.
 Restricting the enablers to be a branch ensures that they do not contain
 any redundant or conflicting information.
\begin_inset Formula \begin{gather*}
ProperAct(ex,i)\,\equiv\, IsAction(lbl(ex,i))\\
\wedge Branch(ex,ens(ex,i))\wedge alts(ex,i)=\{\}\wedge\exists j:\, ens(ex,j)=\{i\}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
An outcome event is proper if it is enabled by a unique action event, and
 has as its alternatives the set of all other events enabled by that action.
\begin_inset Formula \begin{gather*}
ProperOut(ex,i)\,\equiv\, IsOutcome(lbl(ex,i))\\
\wedge\exists j:\, ens(ex,i)=\{j\}\wedge IsAction(lbl(ex,j))\\
\wedge\forall k:\,\left(k\in alts(ex,i)\,\equiv\, ens(ex,k)=\{j\}\wedge k\neq i\right)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
These definitions enforce the basic structure of a joint execution according
 to the intuitions discussed in the previous section, but do not constrain
 it to be something that could actually be performed in the world -- for
 example, outcomes can be enabled by actions that will never actually produce
 that outcome.
 Like situation terms, we focus first on getting the appropriate structure,
 and then specify additional conditions that joint executions must satisfy
 in order to be legal in the real world.
\end_layout

\begin_layout Subsubsection
Performing Events
\end_layout

\begin_layout Standard
We introduce a predicate 
\begin_inset Formula $Perform$
\end_inset

 that axiomatises how events from a joint execution can be performed.
 Since we explicitly consider concurrent actions, this predicate selects
 a 
\emph on
set
\emph default
 of action events to be performed: 
\begin_inset Formula \begin{gather*}
Perform(ex,es_{a},es_{o},ex')\equiv\,\,\,\,\, es_{a}\neq\{\}\wedge es_{o}\neq\{\}\\
\wedge\,\forall i:\,\left(i\in es_{a}\,\rightarrow\, IsAction(lbl(ex,i))\wedge ens(ex,i)=\{\}\right)\\
\wedge\,\forall i:\,\left(i\in es_{o}\,\rightarrow\exists j:\, ens(ex,i)=\{j\}\wedge j\in es_{a}\right)\\
\wedge\,\forall i:\,\left(i\in es_{a}\,\rightarrow\,\exists j:\, j\in es_{o}\wedge ens(ex,j)=\{i\}\right)\\
\wedge\,\forall i,j:\,\left(i\in es_{o}\wedge j\in es_{o}\,\rightarrow\,\neg(i\oplus_{ex}j)\right)\\
\wedge\,\forall i:\,\left(i\in events(ex')\,\equiv\, i\not\in es_{a}\wedge i\not\in es_{o}\wedge\neg\exists j:\,(j\in es_{o}\wedge i\oplus_{je}j)\wedge\right)\\
\wedge\,\forall i,lb:\,\left(i\#lb\in lblmap(ex')\equiv\, lbl(ex,i)=lb\wedge i\in events(ex')\right)\\
\wedge\,\forall i,as:\,\left(i\#as\in altsmap(ex')\equiv alts(ex,i)=as\wedge i\in events(ex')\right)\\
\wedge\,\forall i,ns:\,\left(i\#ns\in ensmap(ex')\equiv(ens(ex,i)-es_{o})=ns\wedge i\in events(ex')\right)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The first four lines of this definition select 
\begin_inset Formula $es_{a}$
\end_inset

 and 
\begin_inset Formula $es_{o}$
\end_inset

 as sets of action and outcome events respectively.
 The events in 
\begin_inset Formula $es_{a}$
\end_inset

 are any subset of the action events in the joint execution that have no
 enablers, and are therefore possible to perform.
 The set 
\begin_inset Formula $es_{o}$
\end_inset

 contains one outcome event enabled by each event in 
\begin_inset Formula $es_{a}$
\end_inset

.
\end_layout

\begin_layout Standard
The remaining four lines specify how the events remaining in the joint execution
 are updated: events that conflict with the performed events are removed,
 and the performed events are removed from all lists of enablers.
\end_layout

\begin_layout Standard
As an example, consider again the simple joint execution shown in Figure
 
\begin_inset LatexCommand ref
reference "fig:example-je"

\end_inset

.
 The possible values of 
\begin_inset Formula $es_{a}\#es_{o}$
\end_inset

 generated by 
\begin_inset Formula $Perform$
\end_inset

 for this joint execution are:
\begin_inset Formula \begin{gather*}
\{A1\}\#\{O1\}\\
\{A1\}\#\{O2\}\\
\{A2\}\#\{O3\}\\
\{A1,A2\}\#\{O1,O3\}\\
\{A1,A2\}\#\{O2,O3\}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
These correspond to all potential next steps of execution of this structure.
 The 
\begin_inset Formula $Perform$
\end_inset

 predicate is clearly quite non-deterministic, permitting any subset of
 the enabled events to be performed; the different choices it can make correspon
d to different potential orderings of events when performing the joint execution.
\end_layout

\begin_layout Subsubsection
Histories
\end_layout

\begin_layout Standard
Every branch identifies a family of potential partial runs of the execution,
 which are given by the branch's 
\emph on
histories
\emph default
.
 The predicate 
\begin_inset Formula $History$
\end_inset

 constructs a branch history by recursively performing events that do not
 conflict with the branch, until all events in the branch have been performed.
 This predicate depends on 
\begin_inset Formula $Perform$
\end_inset

 to identify an enabled set of action events 
\begin_inset Formula $es_{a}$
\end_inset

 and outcome events 
\begin_inset Formula $es_{o}$
\end_inset

, the labels of which are translated into action and outcome terms 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 respectively.
 
\begin_inset Formula \begin{gather*}
History(ex,br,h)\equiv\,\,\,\, b=\{\}\wedge h=\epsilon\\
\vee\,\left(\exists ex',h',br',es_{a},es_{o},c,y:\, Perform(ex,es_{a},es_{o},ex')\right.\\
\wedge\,\forall i,j:\,\left(i\in br\wedge j\in(es_{a}\cup es_{o})\,\rightarrow\,\neg(i\oplus_{ex}j)\right)\\
\wedge\,\forall a:\,\left(a\in c\,\equiv\,\exists i:\, i\in es_{a}\wedge lbl(ex,i)=a\right)\\
\wedge\,\forall agt,o:\,\left(o\in y[agt]\,\equiv\,\exists i:\, i\in es_{o}\wedge o\in lbl(ex,i)[agt]\right)\\
\forall i:\,\left(i\in br'\,\equiv\, i\in br\wedge i\in events(ex')\right)\\
\left.\wedge\, History(ex',br',h')\,\wedge\, h=h'\cdot(c\#y)\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The second and third lines of this definition select sets 
\begin_inset Formula $es_{a}$
\end_inset

 and 
\begin_inset Formula $es_{o}$
\end_inset

 that do not conflict with the given branch.
 The fourth line constructs the concurrent action 
\begin_inset Formula $c$
\end_inset

 as the union of each action in the set 
\begin_inset Formula $es_{a}$
\end_inset

, while the fifth line constructs the corresponding outcome 
\begin_inset Formula $y$
\end_inset

 as the agent-wise union of the outcomes in the set 
\begin_inset Formula $es_{o}$
\end_inset

.
 Such pairs 
\begin_inset Formula $c\#y$
\end_inset

 are repeatedly selected until every event in the branch is performed.
\end_layout

\begin_layout Standard
Clearly, if there are many unordered events then there are many potential
 histories for a given branch; in fact there may be exponentially-many histories
 in general.
 In Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Reasonable"

\end_inset

 we show how to avoid reasoning about each history individually, which is
 crucial if these structures are to be of practical use.
 Instead, we reason about only the 
\emph on
canonical
\emph default
 
\emph on
history,
\emph default
 the unique history obtained by performing events in the strict order determined
 by the 
\begin_inset Formula $<$
\end_inset

 relation:
\begin_inset Formula \begin{gather*}
CHistory(ex,br,h)\equiv\,\,\,\, b=\{\}\wedge h=\epsilon\\
\vee\,\left(\exists ex',h',br',es_{a},es_{o},c,y:\, Perform(ex,es_{a},es_{o},ex')\right.\\
\wedge\,\exists i:\, es_{a}=\{i\}\wedge\forall j\in events(ex):\, i<j\,\\
\wedge\,\forall i,j:\,\left(i\in br\wedge j\in(es_{a}\cup es_{o})\,\rightarrow\,\neg(i\oplus_{ex}j)\right)\\
\wedge\,\forall a:\,\left(a\in c\,\equiv\,\exists i:\, i\in es_{a}\wedge lbl(ex,i)=a\right)\\
\wedge\,\forall agt,o:\,\left(o\in y[agt]\,\equiv\,\exists i:\, i\in es_{o}\wedge o\in lbl(ex,i)[agt]\right)\\
\forall i:\,\left(i\in br'\,\equiv\, i\in br\wedge i\in events(ex')\right)\\
\left.\wedge\, History(ex',br',h')\,\wedge\, h=h'\cdot(c\#y)\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
For convenience, we also define a predicate 
\begin_inset Formula $Sit$
\end_inset

 that gives the situation terms corresponding to the branch histories:
\begin_inset Formula \[
Sit(ex,br,s)\,\equiv\,\exists h:\, History(ex,br,h)\wedge Sit(h)=s\]

\end_inset


\end_layout

\begin_layout Standard
From these definitions it should be clear that joint executions constitute
 a plan of action that can be executed reactively in the world.
 It is simply a matter of picking some subset of the enabled actions, executing
 them and obtaining the corresponding outcomes, then rolling the joint execution
 forward according to the 
\begin_inset Formula $Perform$
\end_inset

 predicate.
 The set of histories of all leaves of a joint execution gives every possible
 situation that could be reached by performing it in the world.
\end_layout

\begin_layout Standard
Of course, this simple account of performing a joint execution assumes public
 observability of all actions and outcomes.
 For a team of agents to be able to feasibly execute it based only on their
 local information, we must enforce some additional restrictions on the
 structure of a joint execution.
\end_layout

\begin_layout Subsubsection
Feasible Joint Executions
\end_layout

\begin_layout Standard
Since we intend for joint executions to be performed reactively by a team
 of agents in an asynchronous environment, we must formalise the relationship
 between the global histories of a joint execution and each agent's local
 view of those histories.
 First, we define the 
\begin_inset Formula $View$
\end_inset

 function over a history in the obvious way:
\begin_inset Formula \begin{gather*}
View(agt,\epsilon)=\epsilon\\
y[agt]=\{\}\,\rightarrow\, View(agt,(c\#y)\cdot h)=View(agt,h)\\
y[agt]\neq\{\}\,\rightarrow\, View(agt,(c\#y)\cdot h)=y[agt]\cdot View(agt,h)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
A branch can 
\emph on
generate a view
\emph default
 if one of its histories corresponds to that view:
\begin_inset Formula \[
GeneratesView(ex,br,agt,v)\,\equiv\,\exists h:\, History(ex,br,h)\,\wedge\, View(agt,h)=v\]

\end_inset

 Let 
\begin_inset Formula $actor(ex,i)$
\end_inset

 be the agent responsible for performing an action event 
\begin_inset Formula $i$
\end_inset

.
 Then that event is 
\emph on
enabled by a view
\emph default
 if there is a history of its enablers that can generate that view for the
 performing agent:
\begin_inset Formula \begin{multline*}
EnabledByView(ex,i,agt,v)\equiv\\
actor(ex,i)=agt\,\wedge\, GeneratesView(ex,ens(ex,i),agt,v)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Since an agent's view does not have complete information, 
\begin_inset Formula $EnabledByView$
\end_inset

 identifies events that the agent 
\emph on
might
\emph default
 be required to perform based on its local information.
 It is not sufficient to precisely identify a particular branch, and therefore
 cannot be used to determine for certain whether any particular event should
 be performed.
\end_layout

\begin_layout Standard
To ensure the feasibility of performing a joint execution based on each
 agent's local information, we must assert two additional structural restriction
s to ensure each agent can always determine the action it is to perform.
\end_layout

\begin_layout Standard
The first restriction corresponds to the idea of 
\emph on
knowing when
\emph default
 to perform an action.
 If an action event 
\begin_inset Formula $i$
\end_inset

 is enabled by an outcome event 
\begin_inset Formula $j$
\end_inset

, then 
\begin_inset Formula $j$
\end_inset

 must not be hidden from the agent performing 
\begin_inset Formula $i$
\end_inset

.
 Otherwise, it has no way of enforcing the required ordering between the
 two events.
 This requirement is formalised by:
\begin_inset Formula \begin{multline*}
KnowsWhen(ex)\,\isdef\,\\
\forall i,j\in events(ex):\, IsAction(lbl(ex,i))\,\wedge j\in ens(ex,i)\\
\rightarrow\, lbl(ex,i)[actor(ex,i)]\neq\{\}\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:not-knows-when"

\end_inset

 shows an example of a joint execution that does not meet this requirement.
 This plan calls for 
\begin_inset Formula $Jim$
\end_inset

 to place an egg in the bowl, and then for 
\begin_inset Formula $Joe$
\end_inset

 to mix the bowl's contents.
 However, since 
\begin_inset Formula $Joe$
\end_inset

 cannot observe the occurrence of 
\begin_inset Formula $Jim$
\end_inset

's action, he cannot enforce the ordering between these two events.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "97col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\family sans
\series bold
\size tiny
\begin_inset Graphics
	filename /storage/pgrad/writings/thesis/listings/jointexec/unfeas_je2.eps
	scale 35

\end_inset


\family default
\series default

\begin_inset ERT
status collapsed

\begin_layout Standard

{}
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A joint execution that violates the 
\begin_inset Formula $KnowsWhen$
\end_inset

 restriction
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:not-knows-when"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement !t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "97col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\family sans
\series bold
\size tiny
\begin_inset Graphics
	filename /storage/pgrad/writings/thesis/listings/jointexec/unfeas_je.eps
	scale 35

\end_inset


\family default
\series default

\begin_inset ERT
status collapsed

\begin_layout Standard

{}
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A joint execution that violates the 
\begin_inset Formula $KnowsWhat$
\end_inset

 restriction
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:not-knows-what"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second restriction corresponds to the idea of 
\emph on
knowing what
\emph default
 action to perform.
 For any given view 
\begin_inset Formula $v$
\end_inset

, there may be multiple branches with a history that could generate that
 view, and the agent has no means of knowing precisely branch has been performed
 in the world.
 We require that if an event is enabled by a view, then 
\emph on
all
\emph default
 branches that could generate that view enable a similar event:
\begin_inset Formula \begin{multline*}
KnowsWhat(ex)\,\isdef\,\\
\forall agt,v,i,br:\,\, EnabledByView(ex,i,agt,v)\,\wedge GeneratesView(ex,br,agt,v)\,\rightarrow\\
\exists j:\, ens(ex,j)=br\,\wedge\, lbl(ex,i)=lbl(ex,j)\end{multline*}

\end_inset

 While the agent may not know precisely which 
\emph on
event
\emph default
 is enabled, its local information is enough to determine the specific 
\emph on
action
\emph default
 that it is to perform.
 Figure 
\begin_inset LatexCommand ref
reference "fig:not-knows-what"

\end_inset

 shows an example of a joint execution that does not meet this requirement.
 This plan calls for 
\begin_inset Formula $Jim$
\end_inset

 to check for the availability of eggs, then for 
\begin_inset Formula $Joe$
\end_inset

 to acquire an appropriate ingredient depending on whether they are available.
 But since 
\begin_inset Formula $Joe$
\end_inset

 cannot distinguish between outcome events 
\begin_inset Formula $O1$
\end_inset

 and 
\begin_inset Formula $O2$
\end_inset

 after he observes 
\begin_inset Formula $checkFor(egg)$
\end_inset

, he doesn't know what action to perform and the plan cannot be executed.
\end_layout

\begin_layout Standard
We say a joint execution is 
\emph on
feasible
\emph default
 if it meets both of these restrictions:
\begin_inset Formula \[
Feasible(ex)\,\isdef\, KnowsWhat(ex)\wedge KnowsWhen(ex)\]

\end_inset


\end_layout

\begin_layout Subsubsection
Legal Joint Executions
\end_layout

\begin_layout Standard
So far, we have not restricted joint executions to correspond to any sort
 of 
\emph on
legal
\emph default
 run of execution.
 A joint execution may have action events enabling outcome events that they
 would never produce under the given theory of action.
 It may call for actions to be performed in situations where they are not
 legal, or allow actions to be performed concurrently that could be in conflict.
\end_layout

\begin_layout Standard
To avoid such undesirable cases, we identify 
\emph on
legal
\emph default
 joint executions as ones that are constrained enough to be performed in
 the real word.
 We will say that a particular leaf of a joint execution is legal if every
 history of that leaf is legal:
\begin_inset Formula \[
Legal(ex,lf)\,\isdef\,\forall h:\, History(ex,lf,h)\,\rightarrow\, Legal(h)\]

\end_inset


\end_layout

\begin_layout Standard
This ensures that the leaf is constrained enough to prevent precondition
 interaction between independent action events, that its outcome events
 are correct for their corresponding actions, etc.
 However, the agents will generally not have enough information to determine
 whether a particular leaf is legal, since this would imply that they already
 know what sensing results will occur.
 We call an entire joint execution legal if is proper and contains a legal
 leaf:
\begin_inset Formula \[
Legal(ex)\,\isdef\, Proper(ex)\,\wedge\,\exists lf:\, Leaf(ex,lf)\wedge Legal(ex,lf)\]

\end_inset


\end_layout

\begin_layout Standard
This definition does not require that we establish 
\emph on
which
\emph default
 leaf is legal, only that we are able to prove that 
\emph on
some
\emph default
 leaf must be legal.
 In practise this would be done by enumerating the possible outcomes of
 each action.
 Since the leaves of a joint execution represent all its possible terminating
 configurations, this requirement means that a legal joint execution can
 legally be performed to completion in the world.
\end_layout

\begin_layout Standard
The definition is also 
\emph on
permissive
\emph default
, in that there may be leaves of the joint execution that are provably never
 be legal.
 Since the outcomes along these leaves will not occur in reality, the agents
 will never follow them at execution time.
 This permissiveness will therefore not affect an agent's ability to carry
 out the plan in practice.
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
This section has formally defined a 
\emph on
joint execution
\emph default
, a partially-ordered branching action structure that we claim is particularly
 well suited for representing the actions to be performed by a team of agents
 in service of a shared task.
 The partially-ordered nature of joint executions allows them to explicitly
 account for inter-agent synchronisation of actions in the face of partial
 observability, while their branching nature allows them to account for
 incomplete information that must be augmented with runtime sensing results.
\end_layout

\begin_layout Standard
In asynchronous domains, where raw situation terms cannot feasibly be executed
 in the world, joint executions are an ideal alternative as a plan representatio
n structure for use by the Golog execution planning process.
 In the next section we identify precisely what such a planning process
 would entail.
\end_layout

\begin_layout Subsection
Planning with Joint Executions
\begin_inset LatexCommand label
name "sec:JointExec:Planning"

\end_inset


\end_layout

\begin_layout Standard
With the above definitions and axioms in place, we are now in a position
 to plan the cooperative execution of a shared Golog program using joint
 executions rather than raw situation terms.
 For the moment we focus on 
\emph on
offline
\emph default
 execution planning, in the style of the original Golog and ConGolog.
 Recall that the semantics of execution planning in Golog involve finding
 a situation term 
\begin_inset Formula $s$
\end_inset

 satisfying:
\begin_inset Formula \[
\Dt\cup\Dt_{golog}\,\models\,\exists s:\,\Do(\delta,S_{0},s)\]

\end_inset


\end_layout

\begin_layout Standard
Before extending this query to search for a joint execution, notice an important
 consequence of our definitions: two events can occur in either order if
 and only if they can also occur concurrently.
 Since the standard Golog/ConGolog semantics do not permit true concurrency,
 they would force all events to be ordered and we would gain no benefit
 from using joint executions.
 We must therefore adopt the concurrency semantics of MIndiGolog from Chapter
 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

, which permit true concurrency of actions.
\end_layout

\begin_layout Standard
The execution planning problem then reduces to the task of finding a 
\emph on
legal
\emph default
, 
\emph on
feasible
\emph default
 joint execution such that for every leaf, if that leaf is legal, then it
 constitutes a legal execution of the program:
\begin_inset Formula \begin{multline}
\Dt\cup\Dt_{mgolog}\cup\Dt_{je}\models\exists ex:\, Legal(ex)\wedge Feasible(ex)\wedge\\
\forall lf:\, Leaf(ex,lf)\wedge Legal(ex,lf)\,\rightarrow\,\left[\forall s:\, Sit(ex,lf,s)\rightarrow\Do(\delta,S_{0},s)\right]\label{eq:JE-Plan-Defn}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
This query neatly captures dual soundness and completeness requirements.
 For soundness, it requires that for every leaf of the joint execution,
 
\emph on
if
\emph default
 that leaf is legal then it will be a legal execution of the program 
\begin_inset Formula $\delta$
\end_inset

.
 For completeness, it requires that there must in fact be 
\emph on
some
\emph default
 leaf that is legal, so the joint execution can actually be performed in
 the world.
 The joint execution must contain enough branching to account for any incomplete
 knowledge the agents have about the state of the world.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Offline Execution Algorithm using Joint Executions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:je_offline_exec"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $v\,\Leftarrow\,\epsilon$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Find a joint execution 
\begin_inset Formula $ex$
\end_inset

 such that:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{mgolog}\cup\Dt_{je}\models\exists ex:\, Legal(ex)\wedge Feasible(ex)\wedge\\
\forall lf:\, Leaf(ex,lf)\wedge Legal(ex,lf)\,\rightarrow\,\left[\forall s:\, Sit(ex,lf,s)\rightarrow\Do(\delta,S_{0},s)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
WHILE
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset


\begin_inset Formula $ex$
\end_inset

 contains action events to be performed by me
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Find an action 
\begin_inset Formula $a$
\end_inset

 such that
\begin_inset Formula \[
\Dt\cup\Dt_{mgolog}\cup\Dt_{je}\models\exists i:\, EnabledByView(ex,i,agt,v)\wedge lbl(ex,i)=a\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
IF
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

there is such an action
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Execute action 
\begin_inset Formula $a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
ENDIF
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Wait for a new observation 
\begin_inset Formula $o$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $v\,\Leftarrow\, o\cdot v$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
ENDWHILE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{algorithmic}
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Algorithm 
\begin_inset LatexCommand ref
reference "alg:je_offline_exec"

\end_inset

 presents a simple modification of the Golog offline planning algorithm
 that can be used by each agent to plan the execution of a shared program
 
\begin_inset Formula $\delta$
\end_inset

 and then perform it in the world.
 A restricted version of this algorithm is used by our implementation that
 will be described in Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Implementation"

\end_inset

.
\end_layout

\begin_layout Standard
Since this algorithm is to be executed independently by each agent in the
 team, it must identify actions to perform using only the agent's local
 view.
 We restrict the joint execution to be feasible so that the 
\begin_inset Formula $EnabledByView$
\end_inset

 query is sufficient to identify what action to perform next.
 If we did not have this restriction, Algorithm 
\begin_inset LatexCommand ref
reference "alg:je_offline_exec"

\end_inset

 would not be correct.
\end_layout

\begin_layout Standard
If we turn our attention to 
\emph on
online
\emph default
 execution in the style of IndiGolog, things are not so straightforward.
 Although we have not presented the axioms for doing so, it is simple enough
 to extend the leaves of a joint execution one action at a time in the style
 of the IndiGolog execution algorithm presented in Algorithm 
\begin_inset LatexCommand ref
reference "alg:indigolog_exec"

\end_inset

.
 The difficulty comes in trying to coordinate this process across multiple
 agents when they have differing knowledge about the state of the world.
\end_layout

\begin_layout Standard
To demonstrate the issues involved, consider the hypothetical, 
\series bold
\emph on
incorrect
\series default
\emph default
 online execution algorithm presented in Algorithm 
\begin_inset LatexCommand ref
reference "alg:je_online_exec_invalid"

\end_inset

, which mirrors the ReadyLog execution algorithm used by our first MIndiGolog
 implementation.
 Since joint executions are a branching structure, the agent must extend
 each leaf of the joint execution with a new step of execution of the program;
 if any leaf cannot be extended then execution will potentially fail.
 To avoid this the agent discards leaves that it knows are not legal before
 planning the next step of execution.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Hypothetical (Incorrect) Online Execution Algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "alg:je_online_exec_invalid"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $v\,\Leftarrow\,\epsilon$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $ex\,\Leftarrow\, jexec(\{\},\{\},\{\},\{\})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
WHILE
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset


\begin_inset Formula $\delta$
\end_inset

 is not final according to my current view 
\begin_inset Formula $v$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Discard any leaves of 
\begin_inset Formula $ex$
\end_inset

 incompatible with 
\begin_inset Formula $v$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Extend each leaf of 
\begin_inset Formula $ex$
\end_inset

 with a legal step of 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Find an action in 
\begin_inset Formula $ex$
\end_inset

 that is enabled by 
\begin_inset Formula $v$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
IF
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

there is such an action
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Execute that action
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
ENDIF
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 Wait for a new observation 
\begin_inset Formula $o$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $v\,\Leftarrow\, o\cdot v$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
ENDWHILE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{algorithmic}
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, the implicit coordination scheme used by ReadyLog and MIndiGolog
 depends on all agents generating the same 
\begin_inset Quotes eld
\end_inset

next step
\begin_inset Quotes erd
\end_inset

 at every iteration.
 It is therefore incorrect for the agent to discard leaves based only on
 its local information -- it must retain any leaves that its teammates could
 still consider possible, in order to guarantee that they generate the same
 plan.
 Worse, it must also consider that its teammates will retain leaves that
 they think 
\emph on
it
\emph default
 could still consider possible, and so-on ad infinitum.
\end_layout

\begin_layout Standard
The difficulty here is the well-known correspondence between coordination
 and common knowledge 
\begin_inset LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
 In order to extend this execution algorithm to the case of incomplete informati
on, the agents must plan based on what is 
\emph on
commonly known
\emph default
 at each step of execution, rather than based on their own individual view.
 Unfortunately the situation calculus currently offers no tools for reasoning
 about common knowledge, not even in synchronous domains.
\end_layout

\begin_layout Standard
Coordinating the online execution of a shared Golog program in asynchronous
 domains thus requires more explicit reasoning about the knowledge of each
 agent, and the common knowledge of the team.
 In the coming chapters of this thesis we will explore the foundations for
 such reasoning, but we are yet to incorporate it into our implementation.
 Our joint-execution based MIndiGolog planner is therefore currently limited
 to offline execution planning.
\end_layout

\begin_layout Subsection
Reasonable Joint Executions
\begin_inset LatexCommand label
name "sec:JointExec:Reasonable"

\end_inset


\end_layout

\begin_layout Standard
While joint executions can clearly provide a powerful formal account of
 execution planning for asynchronous multi-agent domains, in their current
 form they are not suitable for an effective implementation.
 The difficulty arises from the definition of 
\begin_inset Formula $History(ex,br,h)$
\end_inset

, which due to the partial ordering on events can generate an exponentially-larg
e number of possible histories.
 To verify that a joint execution is legal, the planner needs to examine
 each of these histories individually.
\end_layout

\begin_layout Standard
To overcome this difficulty and produce an effective implementation, we
 identify a restricted class of joint executions in which all possible histories
 of a branch are provably equivalent.
 Such executions can be reasoned about using the canonical ordering over
 events, rather than having to enumerate each possible distinct history.
\end_layout

\begin_layout Subsubsection
Independent Actions
\end_layout

\begin_layout Standard
To construct families of situation terms that are all equivalent, we need
 a way to identify 
\emph on
independent actions.

\emph default
 Intuitively, we want independent actions to be able to be performed in
 either order, or even concurrently, without affecting what holds in the
 resulting situation, or the preconditions or outcomes of each action.
 This section formally identifies the conditions that independent actions
 must satisfy.
\end_layout

\begin_layout Standard
For simplicity, we identify actions that are independent regardless of the
 situation they are performed in.
 Let us assume that the theory of action 
\begin_inset Formula $\Dt$
\end_inset

 is equipped with a rigid predicate 
\begin_inset Formula $indep(a,a')$
\end_inset

 identifying actions that are independent.
 We identify sets of mutually-independent actions with this simple definition:
\begin_inset Formula \[
mIndep(c)\isdef\forall a,a':\, a\in c\wedge a'\in c\,\rightarrow\, indep(a,a')\]

\end_inset

 We then restrict the theory of action to satisfy the following conditions:
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Independent\InsetSpace ~
Actions
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] A theory of action 
\begin_inset Formula $\Dt$
\end_inset

 correctly specifies independent actions when it contains a rigid predicate
 
\begin_inset Formula $indep(a,a')$
\end_inset

 and entails the following, where 
\begin_inset Formula $\mathcal{F}$
\end_inset

 is a meta-variable ranging over fluents:
\begin_inset LatexCommand label
name "def:Independent-Actions"

\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Dt\,\models\, indep(a,a')\equiv indep(a',a)$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Dt\,\models\, Legal(\{a\},s)\equiv Legal(\{a\},do(\{a'\},s))$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Dt\,\models\, Out(\{a\},s)=Out(\{a\},do(\{a'\},s))$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Dt\,\models\,\mathcal{F}(do(\{a\},do(\{a'\},s)))\equiv\mathcal{F}(do(\{a'\},do(\{a\},s)))$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Dt\,\models\, mIndep(c)\,\rightarrow\,\left(Legal(c,s)\equiv\,\forall a\in c:\, Legal(\{a\},s)\right)$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Dt\,\models\, mIndep(c)\,\rightarrow\,\left(o\in Out(c,s)[agt]\equiv\exists a\in c:\, o\in Out(\{a\},s)[agt]\right)$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Dt\,\models\, mIndep(c)\,\rightarrow\,\forall a\in c:\left(\,\mathcal{F}(do(c,s))\equiv\mathcal{F}(do(\{a\},do(c-\{a\},s)))\right)$
\end_inset

 
\end_layout

\begin_layout Standard
The first restriction simply ensures that independence is symmetrical.
 The next three restrictions ensure that independent actions do not interfere
 with each other's preconditions, outcomes or effects.
 The final three restrictions ensure that there is no interference between
 preconditions, outcomes or effects when independent actions are performed
 concurrently.
\end_layout

\begin_layout Standard
The following theorems are direct consequences of correctly specifying independe
nt actions; indeed, they are the motivation for the restrictions in Definition
 
\begin_inset LatexCommand ref
reference "def:Independent-Actions"

\end_inset

.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $h$
\end_inset

 and 
\begin_inset Formula $h'$
\end_inset

 be two histories of the same length, containing the same action#outcome
 pairs, and differing only by transposition of 
\begin_inset Formula $(\{a\}\#y)$
\end_inset

 and 
\begin_inset Formula $(\{a'\}\#y')$
\end_inset

.
 If 
\begin_inset Formula $indep(a,a')$
\end_inset

 holds, then 
\begin_inset Formula $h$
\end_inset

 is legal if and only if 
\begin_inset Formula $h'$
\end_inset

 is legal.
\begin_inset LatexCommand label
name "thm:Indep-Trans-Equiv"

\end_inset

 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $h_{p}$
\end_inset

 be the common prefix of these histories and 
\begin_inset Formula $h_{s}$
\end_inset

 the common suffix:
\begin_inset Formula \begin{gather*}
h\,=\, h_{s}\cdot(\{a\}\#y)\cdot(\{a'\}\#y')\cdot h_{p}\\
h'\,=\, h_{s}\cdot(\{a'\}\#y')\cdot(\{a\}\#y)\cdot h_{p}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
By restrictions 2 and 3 from Definition 
\begin_inset LatexCommand ref
reference "def:Independent-Actions"

\end_inset

, we have:
\begin_inset Formula \begin{gather*}
Legal(\{a\},Sit(h_{p}))\,\equiv\, Legal(\{a\},Sit((\{a'\}\#y')\cdot h_{p}))\\
Out(\{a\},Sit(h_{p}))\,=\, Out(\{a\},Sit((\{a'\}\#y')\cdot h_{p}))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
And vice-versa.
 If 
\begin_inset Formula $h_{s}$
\end_inset

 is empty, this is sufficient to establish 
\begin_inset Formula $Legal(h)$
\end_inset

 iff 
\begin_inset Formula $Legal(h')$
\end_inset

 as desired.
 Alternately, suppose 
\begin_inset Formula $h_{s}$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 items, then we can apply regression 
\begin_inset Formula $n$
\end_inset

 times to state the legality of the 
\begin_inset Formula $h_{s}$
\end_inset

 component as a uniform formula evaluated at 
\begin_inset Formula $Sit((\{a\}\#y)\cdot(\{a'\}\#y')\cdot h_{p})$
\end_inset

.
 By restriction 4, whether this formula holds will be unaffected by the
 order of 
\begin_inset Formula $\{a\}$
\end_inset

 and 
\begin_inset Formula $\{a'\}$
\end_inset

 and we have the equivalence as desired.
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $h$
\end_inset

 and 
\begin_inset Formula $h'$
\end_inset

 be two histories that differ only by the concurrent execution of adjacent
 mutually-independent actions, and the corresponding agent-wise union of
 their outcomes.
 Then 
\begin_inset Formula $h$
\end_inset

 is legal iff 
\begin_inset Formula $h'$
\end_inset

 is legal.
\begin_inset LatexCommand label
name "thm:Indep-Conc-Equiv"

\end_inset

 
\end_layout

\begin_layout Standard
Assume that the histories differ by concurrent execution of a single action.
 Let 
\begin_inset Formula $h_{p}$
\end_inset

 be the common prefix of these histories and 
\begin_inset Formula $h_{s}$
\end_inset

 the common suffix:
\begin_inset Formula \begin{gather*}
h\,=\, h_{s}\cdot(\{a\}\#y)\cdot(\{c\}\#y')\cdot h_{p}\\
h'\,=\, h_{s}\cdot(c\cup\{a\}\#y'')\cdot h_{p}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Furthermore, we're given that:
\begin_inset Formula \begin{gather*}
agt\#o\in y''\,\equiv\, o\in y[agt]\vee\, o\in y'[agt]\\
mIndep(c\cup\{a\})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
By mutual independence, and restrictions 2 and 5, we have: 
\begin_inset Formula \begin{gather*}
Legal(\{a\},Sit((\{c\}\#y')\cdot h_{p}))\,\equiv\, Legal(\{a\},Sit(h_{p}))\\
Legal(c\cup\{a\},Sit(h_{p}))\,\equiv\, Legal(\{a\},Sit(h_{p}))\wedge\forall a'\in c:\, Legal(\{a'\},Sit(h_{p}))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Similarly for outcomes, using restrictions 3 and 6:
\begin_inset Formula \begin{gather*}
Out(\{a\},Sit((\{c\}\#y')\cdot h_{p}))\,=\, Out(\{a\},Sit(h_{p}))\\
o\in Out(c\cup\{a\},Sit(h_{p}))[agt]\,\equiv o\in\left(Out(\{a\},Sit(h_{p}))\cup Out(c,Sit(h_{p}))\right)[agt]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
This is sufficient to establish 
\begin_inset Formula $Legal(h)$
\end_inset

 iff 
\begin_inset Formula $Legal(h')$
\end_inset

 if 
\begin_inset Formula $h_{s}$
\end_inset

 is empty.
 Alternately, suppose 
\begin_inset Formula $h_{s}$
\end_inset

 contains 
\begin_inset Formula $n$
\end_inset

 items, then we can apply regression 
\begin_inset Formula $n$
\end_inset

 times to state the legality of the 
\begin_inset Formula $h_{s}$
\end_inset

 component as a uniform formula evaluated at 
\begin_inset Formula $Sit((c\cup\{a\}\#y'')\cdot h_{p})$
\end_inset

.
 By restriction 7, whether this formula holds will be unaffected if 
\begin_inset Formula $\{a\}$
\end_inset

 is executed separately, and we have the equivalence as desired.
\end_layout

\begin_layout Standard
If the histories differ by concurrent execution of more than a single action,
 we can simply unfold them into a sequence of histories differing by only
 one action, with each being legal iff its adjacent history is legal.
 
\end_layout

\begin_layout Standard
Note that we make no attempt to derive action independence from the theory
 of action, but simply assume an appropriate predicate 
\begin_inset Formula $indep(a,a')$
\end_inset

 is available for the purposes of planning.
 This predicate need not identify 
\emph on
all
\emph default
 independent actions, although the more actions that can be identified as
 independent, the better for our implementation.
\end_layout

\begin_layout Subsubsection
Reasonability
\end_layout

\begin_layout Standard
We can now define a 
\emph on
reasonabl
\emph default
e joint execution as one in which every pair of action events is either
 ordered, in conflict, or independent:
\end_layout

\begin_layout Standard
[
\begin_inset ERT
status collapsed

\begin_layout Standard

{
\end_layout

\end_inset

Reasonable\InsetSpace ~
Joint\InsetSpace ~
Execution
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

] A joint execution is reasonable if it satisfies the following restriction:
\begin_inset Formula \begin{multline*}
\Dt\,\models\,\forall i,j\in events(ex):\, IsAction(lbl(ex,i))\wedge IsAction(lbl(ex,j))\\
\rightarrow\, i\prec_{ex}j\,\vee\, j\prec_{ex}i\,\vee\, i\oplus_{ex}j\,\vee\, indep(lbl(ex,i),lbl(ex,j))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
We call such executions 
\begin_inset Quotes eld
\end_inset

reasonable
\begin_inset Quotes erd
\end_inset

 because a planner can reason about then effectively, using the unique canonical
 history of each leaf rather than enumerating every individual history.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $ex$
\end_inset

 be a reasonable joint execution, then:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{je}\,\models\,\forall lf:\, Leaf(ex,lf)\,\rightarrow\,\\
\left[Legal(ex,lf)\,\equiv\,\exists h:\, CHistory(ex,lf,h)\,\wedge\, Legal(h)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
By definition, a leaf is legal if every possible history of that leaf is
 legal, so the 
\emph on
if
\emph default
 direction is trivial.
 For the 
\emph on
only-if
\emph default
 direction, assume that the canonical history of the leaf if legal.
 The histories of a leaf can differ only by the ordering or concurrent execution
 of unordered action events, and all unordered action events in a reasonable
 execution are independent.
 Therefore every history of the leaf differs from the canonical history
 by transposition or concurrent execution of independent action events.
 So if the canonical history is legal, by Theorems 
\begin_inset LatexCommand ref
reference "thm:Indep-Trans-Equiv"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "thm:Indep-Conc-Equiv"

\end_inset

 we have legality of every history and hence legality of the leaf as required.
 
\end_layout

\begin_layout Standard
This result is key to our implementation of a MIndiGolog execution planner
 based on joint executions - by restricting its search to reasonable executions,
 it can verify the legality of each leaf by querying the legality of the
 canonical leaf history, which can be done using standard regression techniques.
\end_layout

\begin_layout Standard
We thus trade completeness for efficiency in our implementation.
 There can certainly be non-reasonable joint executions that are valid plans
 of execution according to equation 
\begin_inset LatexCommand eqref
reference "eq:JE-Plan-Defn"

\end_inset

, but it is computationally too expensive to search for them in practice.
\end_layout

\begin_layout Subsection
Implementation
\begin_inset LatexCommand label
name "sec:JointExec:Implementation"

\end_inset


\end_layout

\begin_layout Standard
We have modified our MIndiGolog execution planner from Chapter 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

 to perform offline execution planning and generate a joint execution rather
 than a raw situation term.
 For details on obtaining the full source code see Appendix 
\begin_inset LatexCommand ref
reference "ch:implementation"

\end_inset

; for the full axiomatisation of observability in our example domain see
 Appendix 
\begin_inset LatexCommand ref
reference "ch:cookingagents"

\end_inset

.
\end_layout

\begin_layout Standard
As mentioned in Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:JEs"

\end_inset

, Figure 
\begin_inset LatexCommand ref
reference "fig:JE:MakeSalad1"

\end_inset

 shows the output of our planner when run on the 
\begin_inset Formula $MakeSalad$
\end_inset

 program from Chapter 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

.
 Since all actions in this execution have a single outcome, the outcome
 events have been suppressed for brevity.
\end_layout

\begin_layout Standard
In the cooking agents domain, actions are independent if they deal with
 different objects.
 As seen in Figure 
\begin_inset LatexCommand ref
reference "fig:JE:MakeSalad1"

\end_inset

, the use of a partial order structure facilitates independent execution
 between the agents, with each processing a different ingredient and only
 synchronising on the availability of the required resources.
 This execution provides the maximum potential for concurrency given the
 resource constraints of the domain, and is clearly a significant improvement
 over totally ordered sequences of actions as produced by the earlier MIndiGolog
 planner.
\end_layout

\begin_layout Standard
However, the simple 
\begin_inset Formula $MakeSalad$
\end_inset

 program does not demonstrate a key feature of joint executions: branching.
 Consider instead the program 
\begin_inset Formula $MakeSalad2$
\end_inset

 shown in Figure 
\begin_inset LatexCommand ref
reference "fig:MIndiGolog:MakeSalad2"

\end_inset

.
 In this case the agents are unsure whether there are any eggs available,
 so the sensing action 
\begin_inset Formula $checkFor$
\end_inset

 is required.
 If there are eggs then they should make an egg salad, otherwise they should
 make the standard vegetable salad.
 Note that since lettuce appears in both dishes, they are permitted to begin
 processing that ingredient before checking for the eggs.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
width "85col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset Formula \begin{gather*}
\mathbf{proc}\, MakeSalad2(dest)\\
\left[\,\,\,\pi(agt,ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\left.ChopEggOrVeg(dest)\,\,\,\,\right]\,;\\
\pi(agt,\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
endTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right])\,\,\mathbf{end}\\
\\\\\mathbf{proc}\, ChopEggOrVeg(dest)\\
\pi(agt,\, checkFor(agt,Egg))\,;\\
\mathbf{if}\\
\exists e:\, IsType(e,Egg)\wedge\neg Used(e)\\
\mathbf{then}\\
\left[\pi(agt,ChopTypeInto(agt,Egg,dest))\,||\right.\\
\left.\pi(agt,ChopTypeInto(agt,Cheese,dest))\right]\\
\mathbf{else}\\
\left[\pi(agt,ChopTypeInto(agt,Carrot,dest))\,||\right.\\
\left.\pi(agt,ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\mathbf{endif}\,\,\mathbf{end}\end{gather*}

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A Golog program for making Egg or Veg Salad
\begin_inset LatexCommand label
name "fig:MIndiGolog:MakeSalad2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The joint execution found by our implementation for 
\begin_inset Formula $MakeSalad2$
\end_inset

 is shown in Figure 
\begin_inset LatexCommand ref
reference "fig:JE:MakeSalad2-Exec"

\end_inset

.
 The event nodes in this diagram are colour-coded into three groups: white
 nodes can occur independently of the sensing results from 
\begin_inset Formula $checkFor$
\end_inset

; light-grey nodes can only occur if 
\begin_inset Formula $checkFor$
\end_inset

 returns false; dark-grey nodes can only occur if 
\begin_inset Formula $checkFor$
\end_inset

 returns true.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "97col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\align center

\family sans
\series bold
\size tiny
\begin_inset Graphics
	filename /storage/pgrad/writings/thesis/listings/jointexec/salad2_plan.eps
	scale 25

\end_inset


\family default
\series default

\begin_inset ERT
status collapsed

\begin_layout Standard

{}
\end_layout

\end_inset


\size default
 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Joint Execution for the 
\begin_inset Formula $MakeSalad2$
\end_inset

 program
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "fig:JE:MakeSalad2-Exec"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We see from this joint execution that 
\begin_inset Formula $Joe$
\end_inset

 can indeed prepare the lettuce without needing to know whether eggs are
 available.
 
\begin_inset Formula $Jim$
\end_inset

 is assigned to check for the eggs, and acquires either an egg or a tomato
 depending on the outcome of his sensing action.
 Importantly, 
\begin_inset Formula $Jon$
\end_inset

 has to wait until 
\begin_inset Formula $Jim$
\end_inset

 acquires his ingredient before he knows whether to process the cheese,
 or the carrot.
 This is due to him being unable to directly observe the outcome of the
 
\begin_inset Formula $checkFor$
\end_inset

 action.
\end_layout

\begin_layout Standard
Again, there is a significant amount of independence between agents in this
 execution.
 They do not need to be able to observe the private processing actions such
 as 
\begin_inset Formula $chop$
\end_inset

 and 
\begin_inset Formula $mix$
\end_inset

, and only need to synchronise their actions when they come to 
\begin_inset Formula $release$
\end_inset

/
\begin_inset Formula $acquire$
\end_inset

 the shared resources.
 By basing branching and synchronisation directly on the observations made
 by each agent, joint executions allow us to capture this kind of rich branching
 and partial-order structure while ensuring that the agents can still feasibly
 execute the plan based solely on their local information.
\end_layout

\begin_layout Standard
In the following sections we highlight some key aspects of our implementation.
\end_layout

\begin_layout Subsubsection
Program Steps
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $Trans$
\end_inset

 predicate of MIndiGolog is modified to generate 
\emph on
steps
\emph default
 instead of constructing a new situation term.
 These are records that describe not only the next action to perform, but
 also meta-data about that action's role in the overall program.
 Step records have the following attributes.
\end_layout

\begin_layout Itemize
action: the action performed in that step, or 
\begin_inset Formula $nil$
\end_inset

 if it is an internal program transition 
\end_layout

\begin_layout Itemize
test: an additional fluent formula that must hold immediately before performing
 the step 
\end_layout

\begin_layout Itemize
thread: a sequence of 'l' and 'r' characters indicating the concurrent thread
 in which the step is performed 
\end_layout

\begin_layout Itemize
outcome: the outcome of performing the action.
 
\end_layout

\begin_layout Standard
Step records track the necessary information to determine whether the program
 allows any given pair of actions to be performed independently.
 A sequence of steps can be used as a history term in the obvious way, taking
 only the actions and outcomes.
\end_layout

\begin_layout Standard
The thread-naming scheme used here is similar to that of 
\begin_inset LatexCommand citep
key "fritz08congolog_sin_trans"

\end_inset

.
 Each time 
\begin_inset Formula $Trans$
\end_inset

 chooses to execute a step from the left-hand side of a concurrency operator
 it appends an 
\begin_inset Quotes eld
\end_inset

l
\begin_inset Quotes erd
\end_inset

 to the thread name, and each time it chooses the right-hand side it appends
 an 
\begin_inset Quotes eld
\end_inset

r
\begin_inset Quotes erd
\end_inset

.
 If one step's thread name is a prefix of another step's thread name, then
 those two steps must be performed in the order they are generated; if not,
 they are steps from different threads and can potentially be performed
 concurrently.
\end_layout

\begin_layout Standard
The procedure implementing 
\begin_inset Formula $Trans$
\end_inset

 takes a program and a history as input, returning a new step of execution
 along with the remainder of the program to be executed.
 The code below is representative of this procedure:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/jointexec/Trans.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In particular, note that the evaluation of test conditions calls 
\begin_inset Formula $Sitcalc.holds$
\end_inset

 passing it the input history.
 This procedure performs standard regression-based reasoning using a 
\begin_inset Quotes eld
\end_inset

just-in-time history
\begin_inset Quotes erd
\end_inset

 assumption to handle sensing results, in the same manner as standard IndiGolog
 
\begin_inset LatexCommand citep
key "giacomo99indigolog"

\end_inset

.
 The planner ensures that this is the canonical history of the leaf that
 is being planned for, so we can be sure that the test will hold in all
 possible histories of the leaf if it holds in the given history.
\end_layout

\begin_layout Standard
We say that two steps are 
\emph on
ordered
\emph default
 if any of the following holds: their action terms are not independent;
 one's thread is a prefix of the other; one's action falsifies the test
 condition associated with the other.
 When building a joint execution, ordered steps are forced to be executed
 in the order they were generated by the planner, while unordered steps
 may be performed independently and potentially concurrently.
\end_layout

\begin_layout Standard
Note that we no longer require a separate clause to handle true concurrency
 in the 
\begin_inset Formula $conc(D1\, D2)$
\end_inset

 case, unlike the MIndiGolog implementation from Chapter 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

.
 Rather, the potential for truly concurrent execution is captured in the
 partial ordering of the joint execution itself, which allows independent
 actions to be performed concurrently while forcing non-independent actions
 to occur in a particular order.
\end_layout

\begin_layout Subsubsection
Building Joint Executions
\end_layout

\begin_layout Standard
Our implementation builds up joint executions by inserting one action at
 a time, in much the same way that the standard Golog planning loop builds
 up situation terms.
 The procedure 
\begin_inset Formula $Insert$
\end_inset

 is called with the step object whose action is to be inserted, the leaf
 for which it is a new program step, and a function 
\begin_inset Formula $MustPrec$
\end_inset

 that will be used to determine the action's enablers.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/jointexec/JointExec.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The joint execution code enumerates all possible outcomes of the action
 and inserts corresponding outcome events.
 This extends the input leaf by the given action, and if the input leaf
 was legal, then one the new leaves so generated is also guaranteed to be
 legal.
 The updated joint execution is returned along with the new outcome events.
\end_layout

\begin_layout Standard
The call to 
\begin_inset Formula $FixFeasibility$
\end_inset

 ensures that the joint execution remains feasible, by inserting additional
 action events if it discovers branches that have identical views for the
 performing agent.
 Currently this is done using a brute-force search through all possible
 histories, but it is able to eliminate many branches quickly by first checking
 whether they will always contain an incompatible observation.
\end_layout

\begin_layout Standard
When determining the enablers for a new action, the joint execution code
 has potentially many choices, and generates choice points accordingly.
 It processes all existing events on the leaf in turn, first checking if
 they are 
\emph on
orderable
\emph default
 according to the restrictions on feasible joint executions.
 If they are orderable, the function 
\begin_inset Formula $MustPrec$
\end_inset

 is called to determine whether they must be 
\emph on
ordered
\emph default
 according to the semantics of the program.
 If they are orderable, but need not be ordered, a choice point is generated.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/jointexec/FindEnablers.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Planning Loop
\end_layout

\begin_layout Standard
The main execution planning loop operates by extending a joint execution
 one leaf at a time.
 At each iteration, the current state of the plan is represented by the
 joint execution built so far, along with a list of program#history#leaf
 tuples tracking each leaf in the joint execution.
 The history here is the list of program steps performed on that leaf, and
 also gives the canonical leaf history, while the program represents what
 remains to execute on that leaf.
 The planning loop can only terminate when every leaf has a program that
 is final in its canonical history.
\end_layout

\begin_layout Standard
The top-level procedure 
\begin_inset Formula $Plan$
\end_inset

 takes a program as input, and calls 
\begin_inset Formula $MakePlan$
\end_inset

 with an empty joint execution and a single, empty leaf:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/jointexec/Planner.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $MakePlan$
\end_inset

 is a recursive procedure implementing the planning loop.
 Note that it cannot discard leaves or process them in isolation, since
 extending one leaf with an action may cause actions to be added to other
 leaves in order to maintain the feasibility restrictions.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/jointexec/MakePlan.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each iteration of the planning loop proceeds as follows.
 First, it searches for an 
\emph on
open leaf,
\emph default
 one for which a terminating execution of the program has not yet been found.
 If no open leaves are found, planning can terminate.
 Otherwise, the procedure 
\begin_inset Formula $FindTrans1$
\end_inset

 is called to find a new step of execution for that leaf.
 The action is inserted into the joint execution, which returns a list of
 new leaves, one for each possible outcome of the action.
 Each is added to the list of leaves to be processed, and the loop repeats.
\end_layout

\begin_layout Standard
The procedure to find an open leaf must also deal with any new events that
 were inserted into the joint execution to maintain its feasibility invariants.
 The procedure 
\begin_inset Formula $HandleExistingEvents$
\end_inset

 rolls the leaf forward to account for these new events, or fails if an
 event was added that does not form part of a legal program execution.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/jointexec/FindOpenBranch.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of particular interest is the procedure 
\begin_inset Formula $FindTrans1$
\end_inset

, which uses the encapsulated search functionality of Mozart to yield possible
 next steps according to an estimate of their potential for concurrency.
 The procedure 
\begin_inset Formula $LP.yieldOrdered$
\end_inset

 yields the solutions of the given search context, sorted using the procedure
 
\begin_inset Formula $CompareSteps$
\end_inset

.
 This procedure gives preference to steps that can be performed concurrently
 with as many existing actions as possible.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
programinput{
\end_layout

\end_inset

listings/jointexec/FindTrans1.oz
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This use of encapsulated search allows our implementation to find highly
 concurrent executions, such as the one shown in Figure 
\begin_inset LatexCommand ref
reference "fig:JE:MakeSalad2-Exec"

\end_inset

.
\end_layout

\begin_layout Subsection
Discussion
\begin_inset LatexCommand label
name "sec:JointExec:Discussion"

\end_inset


\end_layout

\begin_layout Standard
In this chapter we have defined a 
\emph on
joint execution
\emph default
 as a special kind of prime event structure.
 We contend that such structures are highly suitable for planning the actions
 to be performed by a team of agents in service of some shared task, such
 as executing a shared Golog program.
\end_layout

\begin_layout Standard
On one hand, joint executions are restricted enough to be practical for
 such use.
 By restricting ourselves to 
\emph on
reasonable
\emph default
 joint executions, each leaf can be easily converted into a single history
 term for the purposes of reasoning, and can be extended one action at a
 time.
 This allows us to re-use much of the standard IndiGolog reasoning machinery.
 By ensuring that the joint execution is 
\emph on
feasible
\emph default
, the agent are guaranteed to be able to carry it out in a purely reactive
 fashion using only their local information.
\end_layout

\begin_layout Standard
Joint executions are also significantly more flexible than previous approaches.
 They allow independent actions to be performed without synchronisation,
 in any order.
 The agents need never know precisely what actions have been executed, as
 long as their local observations are sufficient to determine the next action
 to perform.
 Synchronisation is automatically achieved when required by explicitly reasoning
 about what actions each agent can observe, rather than requiring that all
 actions be public.
\end_layout

\begin_layout Standard
To demonstrate the utility of these structures, we have implemented a new
 version of our MIndiGolog interpreter that produces joint executions as
 its output, and shown that the resulting executions can enable significant
 independence among agents when cooperatively executing the plan.
\newline

\end_layout

\begin_layout Standard
An alternate approach to coordinating concurrent execution in Golog-like
 languages is the TeamGolog language developed in 
\begin_inset LatexCommand citep
key "farinelli07team_golog"

\end_inset

, where agents explicitly synchronise through communication and a shared
 state.
 By contrast, our approach constructs synchronisation implicitly by reasoning
 about the actions that can be observed by each agent.
 This has the advantage of requiring no changes to the form or semantics
 of the agents' control program, but the disadvantage that joint execution
 construction may fail if too many actions are unobservable.
 It would be interesting to combine these approaches by automatically incorporat
ing explicit communication when implicit synchronisation is not possible.
\end_layout

\begin_layout Standard
There is, of course, an extensive body of work on partial-order planning
 in the context of goal-based planning.
 Unsurprisingly, the joint execution structure we develop here has deep
 similarities to the structures used in conditional partial-order planners
 such as 
\begin_inset LatexCommand citep
key "peot92conditional_nonlinear"

\end_inset

.
 It is, however, intentionally specific to the situation calculus.
 We make no use of many concepts common in partial-order goal-based planning
 (causal links, threats, conflicts, etc) because we do not deal explicitly
 with goals, but with steps generated by an underlying transition semantics.
 Our approach can be considered roughly equivalent to 
\emph on
deordering
\emph default
 of a totally-ordered plan as described in 
\begin_inset LatexCommand citep
key "backstrom99reordering"

\end_inset

; we plan as if actions are performed in the specific order identified by
 the canonical leaf history, but allow actions to be performed out-of-order
 if they are independent.
\end_layout

\begin_layout Standard
Our use of a restrictive plan representation that branches directly on the
 sensing results returned by actions has strong parallels with the 
\begin_inset Quotes eld
\end_inset

robot programs
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset LatexCommand citep
key "levesque96what_is_planning,levesque98what_robots_can_do"

\end_inset

, but is significantly less expressive.
 In particular, joint executions do not allow looping constructs and thus
 lack the universality of general robot programs.
 It would be interesting to incorporate loops in our structures, but how
 to do so if far from clear in the face of partial observability.
 Indeed, producing iterative plans is still an active area of research even
 in the single-agent case 
\begin_inset LatexCommand citep
key "levesque05planning_with_loops"

\end_inset


\newline

\end_layout

\begin_layout Standard
By explicitly formalising the local perspective of each agent, we have given
 an account of planning with coordination and feasibility guarantees without
 needing to perform explicit epistemic reasoning.
 On the one hand, this means we can implement a practical planning system
 without concern for the computational difficulties involved in epistemic
 reasoning.
 But this has also limited us to purely offline planning, when each agent
 can reasonably be expected to have the same knowledge about the domain.
\end_layout

\begin_layout Standard
As discussed in Section 
\begin_inset LatexCommand ref
reference "sec:JointExec:Planning"

\end_inset

, extending the use of joint executions for online execution in asynchronous
 domains poses a significant challenge, and seems to require explicit reasoning
 about knowledge and common knowledge.
 The remainder of this thesis is devoted to developing the foundations of
 such a reasoning system, by extending the standard account of epistemic
 reasoning in the situation calculus to handle asynchronous domains.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "ch:conclusion"

\end_inset


\end_layout

\begin_layout Standard
This thesis has laid the foundations for cooperative execution in asynchronous
 multi-agent domains in the situation calculus.
 As highlighted by our initial investigations and implementation of the
 multi-agent Golog variant MIndiGolog, the standard reasoning and planning
 machinery of the situation calculus often depends on an assumption of synchroni
city.
 In many cases, this synchronicity is enforced by requiring all actions
 to be publicly observable.
\end_layout

\begin_layout Standard
At the core of our approach to overcoming this limitation is a new, explicit
 representation of the local perspective of each agent.
 By formalising what each agent 
\emph on
observes
\emph default
 when a particular set of actions is performed, and its corresponding local
 
\emph on
view
\emph default
 in each situation, we are able to approach reasoning and planning in a
 principled way without making any assumptions about the dynamics of the
 domain.
 In particular, we can explicitly define and represent asynchronous domains
 as those in which some action occurrences generate no observations; in
 other words, domains in which agents cannot determine how many actions
 have been performed.
\end_layout

\begin_layout Standard
Our first key contribution defines a partially-ordered branching action
 structure to replace raw situation terms as the output of the Golog execution
 planning process.
 Called 
\emph on
joint executions
\emph default
, they represent a set of many possible histories that could constitute
 a legal execution of the program.
 They allow independent actions to be performed independently, while ensuring
 that inter-agent synchronisation is always possible when required.
 By formulating these requirements explicitly in terms of the local view
 available to each agent, we identify joint executions that are feasible
 to perform in the world despite potential asynchronicity in the domain.
\end_layout

\begin_layout Standard
The utility of these structures was demonstrated by implementing an offline
 execution planner that produces joint executions as its output.
 By imposing some simple restrictions on the theory of action, the planner
 is able to reason about joint executions without having to explicitly consider
 the exponentially-many possible histories of such a partially-ordered structure.
 It can thus make use of the standard reasoning machinery of the situation
 calculus developed in existing Golog implementations.
\newline

\end_layout

\begin_layout Section
\start_of_appendix
Extended Proofs
\end_layout

\begin_layout Standard
Extended proofs go here, if we need any.
\end_layout

\begin_layout Section
Axioms for the 
\begin_inset Quotes eld
\end_inset

Cooking Agents
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This appendix provides the axioms for the 
\begin_inset Quotes eld
\end_inset

cooking agents
\begin_inset Quotes erd
\end_inset

 example domain used in Sections 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset

 and 
\begin_inset LatexCommand ref
reference "ch:jointexec"

\end_inset

.
 While the different sections use slightly different variants of the domain,
 the major details are unchanged between chapters.
\end_layout

\begin_layout Subsection*
Synchronous, completely-known
\end_layout

\begin_layout Standard
In this domain there are three agents named 
\begin_inset Formula $Jon$
\end_inset

, 
\begin_inset Formula $Jim$
\end_inset

 and 
\begin_inset Formula $Joe$
\end_inset

:
\begin_inset Formula \[
\forall agt:\,\, agt=Jim\,\vee\, agt=Jon\,\vee\, agt=Joe\]

\end_inset


\end_layout

\begin_layout Standard
There are various types of ingredient and utensil, and types are represented
 explicitly as terms such as 
\begin_inset Formula $Lettuce$
\end_inset

 and 
\begin_inset Formula $Bowl.$
\end_inset

 Individual objects of these types are named e.g.
 
\begin_inset Formula $Lettuce1$
\end_inset

, 
\begin_inset Formula $Bowl2$
\end_inset

: We have a rigid predicate 
\begin_inset Formula $ObjIsType(obj,typ)$
\end_inset

 that relates these two sorts of object.
 It is defined as the completion of the following clauses:
\begin_inset Formula \begin{gather*}
IsType(obj,Bowl)\,\rightarrow\, obj=Bowl1\,\vee\, obj=Bowl2\,\vee\, Bowl3\\
IsType(obj,Board)\,\rightarrow\, obj=Board1\,\vee\, obj=Board2\\
IsType(obj,Egg)\,\rightarrow\, Egg1\\
IsType(obj,Tomato)\,\rightarrow\, obj=Tomato1\,\vee\, obj=Tomato2\,\vee\, obj=Tomato3\\
IsType(obj,Lettuce)\,\rightarrow\, obj=Lettuce1\,\vee\, obj=Lettuce2\\
IsType(obj,Carrot)\,\rightarrow\, obj=Carrot1\,\vee\, obj=Carrot2\,\vee\, obj=Carrot3\\
IsType(obj,Cheese)\,\rightarrow\, obj=Cheese1\,\vee\, obj=Cheese2\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Different object super-types are identified using:
\begin_inset Formula \begin{gather*}
IsContainer(obj)\,\equiv\, IsType(obj,Bowl)\,\vee\, IsType(obj,Board)\\
IsIngredient(obj)\,\equiv\, IsType(obj,Egg)\,\vee\, IsType(obj,Lettuce)\,\vee\,\dots\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The available actions are 
\begin_inset Formula $release$
\end_inset

, 
\begin_inset Formula $acquire$
\end_inset

, 
\begin_inset Formula $placeIn$
\end_inset

, 
\begin_inset Formula $transer$
\end_inset

, 
\begin_inset Formula $mix$
\end_inset

 and 
\begin_inset Formula $chop$
\end_inset

.
 
\end_layout

\begin_layout Standard
We have the following fluents and successor state axioms.
 An ingredient is used if the agent places it in some container:
\begin_inset Formula \begin{multline*}
Used(obj,do(c\#t,s))\,\equiv\, IsIngredient(obj)\\
\wedge\,\left(\exists agt,cnt:placeIn(agt,obj,cnt)\in c\right)\vee\, Used(obj,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
An agent has an object after he acquires it, and ceases to have it when
 it is released or becomes used:
\begin_inset Formula \begin{multline*}
HasObject(agt,obj,do(c\#t,s))\,\equiv\, acquire(agt,obj)\in c\\
\vee HasObject(agt,obj,s)\,\wedge\neg\left(release(agt,obj)\in c\right.\\
\left.\vee IsIngredient(obj)\wedge\exists cnt:\, placeIn(agt,obj,cnt)\in c\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
The contents of a container is simply the set of things that have been placed
 into it.
 For this simple example, we do not represent the 
\emph on
state
\emph default
 of those ingredients, e.g.
 mixed or chopped:
\begin_inset Formula \begin{multline*}
Contents(obj,cnts,do(c\#t,s))\,\equiv\,\left(\exists cnts_{n},cnts_{o}:\,\mathbf{NewConts}(obj,cnts_{n},c,s)\right.\\
\left.\wedge\, Contents(obj,cnts_{o},s)\wedge cnts=cnts_{n}\cup cnts_{o}\right)\\
\vee\,\,\left(cnts=\{\}\wedge\mathbf{LostContents}(obj,c)\right)\\
\vee\,\,\left(Contents(obj,cnts,s)\right.\wedge\\
\left.\neg(\exists cnts_{n},cnts_{o}:\,\mathbf{NewConts}(obj,cnts_{n},c,s)\vee\mathbf{LostContents}(obj,c)\right)\end{multline*}

\end_inset

 
\begin_inset Formula \begin{multline*}
\mathbf{NewConts}(obj,cnts,c,s)\,\equiv\,\exists agt,igr:\, placeIn(agt,igr,obj)\in c\wedge cnts=\{igr\}\\
\vee\,\,\exists agt,obj':\, transfer(agt,obj',obj)\in c\wedge Contents(obj',cbts,s)\end{multline*}

\end_inset

 
\begin_inset Formula \[
\mathbf{LostConts}(obj,c)\,\equiv\,\exists agt,obj':\, transfer(agt,obj,obj')\in c\]

\end_inset


\end_layout

\begin_layout Standard
An agent can be doing a long-running task, with time 
\begin_inset Formula $t_{r}$
\end_inset

 remaining until completion.
 The rigid function 
\begin_inset Formula $duration(tsk)$
\end_inset

 gives the running time of a task:
\begin_inset Formula \begin{multline*}
DoingTask(agt,tsk,t_{r},do(c\#t,s))\,\equiv\,\\
beginTask(agt,tsk)\in c\wedge t_{r}=duration(tsk)\\
\vee\exists t_{r}':\, DoingTask(agt,tsk,t_{r}',s)\wedge t_{r}=t_{r}'-t\wedge endTask(agt,tsk)\not\in c\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
The possibility axioms for individual actions are:
\begin_inset Formula \[
Poss(acquire(agt,obj)\#t,s)\,\equiv\,\neg Used(obj)\,\wedge\,\neg\exists agt':\, HasObject(agt,obj,s)\]

\end_inset

 
\begin_inset Formula \[
Poss(release(agt,obj)\#t,s)\,\equiv\, HasObject(agt,obj,s)\]

\end_inset

 
\begin_inset Formula \[
Poss(placeIn(agt,obj,cnt)\#t,s)\,\equiv\, HasObject(agt,obj,s)\wedge HasObject(agt,cnt,s)\]

\end_inset

 
\begin_inset Formula \begin{multline*}
Poss(transfer(agt,cnt,cont')\#t,s)\,\equiv\\
\, HasObject(agt,cnt,s)\wedge HasObject(agt,cnt',s)\end{multline*}

\end_inset

 
\begin_inset Formula \begin{multline*}
Poss(beginTask(agt,tsk)\#t,s)\,\equiv\,\\
\exists cnt,t:\, tsk=mix(cnt,t)\wedge HasObject(agt,cnt,s)\wedge ObjIsType(cnt,Bowl)\\
\vee\exists cnt:\, tsk=chop(cnt)\wedge HasObject(agt,cnt,s)\wedge ObjIsType(cnt,Board)\end{multline*}

\end_inset

 
\begin_inset Formula \[
Poss(endTask(agt,tsk)\#t,s)\,\equiv\,\exists t_{r}:\, DoingTask(agt,tsk,t_{r},s)\wedge t=start(s)+t_{r}\]

\end_inset


\end_layout

\begin_layout Standard
Concurrent actions are possible if they are all individually possible and
 no pair of action is in conflict:
\begin_inset Formula \[
Poss(c\#t,s)\,\equiv\,\forall a,a'\in c:\, Poss(a\#t,s)\wedge Poss(a'\#t,s)\wedge\neg Conflicts(a,a',s)\]

\end_inset


\end_layout

\begin_layout Standard
Actions conflict if they are performed by the same agent, or are attempts
 to acquire the same resource:
\begin_inset Formula \begin{multline*}
Conflicts(a,a',s)\,\equiv\, actor(a)=actor(a')\\
\vee\,\exists agt,agt',obj:\, a=acquire(agt,obj)\wedge a'=acquire(agt',obj)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Initially all containers are empty, no-one has any objects, and all ingredients
 apart from possibly the egg are not used:
\begin_inset Formula \begin{gather*}
\forall cnt:\, IsContainer(cnt)\,\rightarrow\, Contents(cnt,\{\},S_{0})\\
\forall agt,obj:\,\neg HasObject(agt,obj,S_{0})\\
\forall igr:\, ObjIsType(igr,Egg)\,\vee\,\neg Used(igr,S_{0})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
These axioms suffice for the example domain used in Chapter 
\begin_inset LatexCommand ref
reference "ch:mindigolog"

\end_inset


\end_layout

\begin_layout Subsection*
Asynchronous, with sensing
\end_layout

\begin_layout Standard
For Chapter 
\begin_inset LatexCommand ref
reference "ch:jointexec"

\end_inset

 we drop the temporal component, and collapse the tasks 
\begin_inset Formula $mix$
\end_inset

 and 
\begin_inset Formula $chop$
\end_inset

 into primitive actions:
\begin_inset Formula \[
Poss(mix(agt,cnt),s)\,\equiv\, HasObject(agt,cnt,s)\wedge ObjIsType(cnt,Bowl)\]

\end_inset

 
\begin_inset Formula \[
Poss(chop(agt,cnt),s)\,\equiv\, HasObject(agt,cnt,s)\wedge ObjIsType(cnt,Board)\]

\end_inset


\end_layout

\begin_layout Standard
We introduce a sensing action 
\begin_inset Formula $checkFor(agt,typ)$
\end_inset

 which determines whether all objects of that type are unused:
\begin_inset Formula \[
Poss(checkFor(agt,typ),s)\,\equiv\,\top\]

\end_inset

 
\begin_inset Formula \begin{multline*}
SR(checkFor(agt,typ),s)=r\,\equiv\,\\
\shoveright{r="T"\wedge\forall obj:\, ObjIsType(obj,typ)\rightarrow\neg Used(obj,s)}\\
\vee r="F"\wedge\exists obj:\, ObjIsType(obj,typ)\wedge Used(obj,s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
We adopt the 
\begin_inset Formula $CanObs/CanSense$
\end_inset

 axioms for observability and make all actions private except 
\begin_inset Formula $acquire$
\end_inset

 and 
\begin_inset Formula $release$
\end_inset

:
\begin_inset Formula \begin{multline*}
CanObs(agt,a,s)\,\equiv\, actor(a)=agt\,\vee\,\exists agt',obj:\, a=acquire(agt',obj)\\
\vee\,\exists agt',obj:\, a=release(agt',obj)\end{multline*}

\end_inset

 
\begin_inset Formula \[
CanSense(agt,a,s)\,\equiv\, actor(a)=agt\]

\end_inset


\end_layout

\begin_layout Standard
Finally, we identify independent actions as those that deal with different
 objects, which much be axiomatised by enumerating the each possible case.
 We will not present such an enumeration here.
\end_layout

\begin_layout Standard
These axioms suffice for the example domain in Chapter 
\begin_inset LatexCommand ref
reference "ch:jointexec"

\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "theapa"
bibfiles "/storage/pgrad/library/references"

\end_inset


\end_layout

\end_body
\end_document
