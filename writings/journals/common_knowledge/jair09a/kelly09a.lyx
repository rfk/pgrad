#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass jair
\begin_preamble

\jairheading{0}{0000}{0-0}{0/0}{0/0}
\ShortHeadings{Common Knowledge, Hidden Actions, and the Frame Problem}{R. F. Kelly \& A. R. Pearce}
\firstpageno{1}

 \renewenvironment{proofsketch}{\begin{proof}[Proof Sketch]}{ For the complete proof, see Appendix \ref{sec:Complete-Proofs}. \end{proof}}
\end_preamble
\options jair,twoside,11pt,theapa,letterpaper
\use_default_options false
\language british
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Common Knowledge, Hidden Actions, and the Frame Problem
\end_layout

\begin_layout Author
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
name Ryan F.
 Kelly 
\backslash
email rfk@csse.unimelb.edu.au
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
name Adrian R.
 Pearce 
\backslash
email adrian@csse.unimelb.edu.au
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
addr Department of Computer Science and Software Engineering
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

The University of Melbourne
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Victoria, 3010, Australia
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a powerful new account of multi-agent knowledge in the situation
 calculus and an effective reasoning procedure for knowledge queries.
 Our approach handles partial observability of actions, including actions
 that are completely hidden, by explicitly reifying the observations made
 by each agent as the world evolves.
 It formally treats complex group-level epistemic modalities such as common
 knowledge, which were previously difficult to handle effectively in the
 situation calculus.
 By using the persistence condition meta-operator to augment traditional
 regression techniques, we allow agents to reason about their own knowledge
 using only their internal history of observations, rather than requiring
 a full history of the world.
 The result is a more robust and flexible account of knowledge in the situation
 calculus suitable for asynchronous, partially-observable multi-agent domains.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isdef}{\stackrel{\mbox{\tiny def}}{=}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Dt}{\mathcal{D}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Reg}{\mathcal{R}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Pst}{\mathcal{P}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Trn}{\mathcal{T}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Kln}{\mathcal{K}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\TrnA}{\Trn_{a}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EKnows}{\mathbf{EKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Knows}{\mathbf{Knows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\CKnows}{\mathbf{CKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KnowsZ}{\mathbf{Knows_{0}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PKnowsZ}{\mathbf{PKnows_{0}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PKnows}{\mathbf{PKnows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KTrans}{\mathbf{KDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\KDo}{\mathbf{KDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\EDo}{\mathbf{EDo}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\vars}[1]{\bar{#1}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PbU}{PbU}
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In their landmark paper 
\emph on
Knowledge, Action, and the Frame Problem,
\emph default
 
\begin_inset CommandInset citation
LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 incorporate knowledge-producing actions into the situation calculus 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

, inheriting Reiter's solution to the frame problem 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter91frameprob"

\end_inset

 and so enabling use of the regression operator to reason about the changing
 knowledge of an agent.
 Extensions to multiple agents 
\begin_inset CommandInset citation
LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

 and concurrent actions 
\begin_inset CommandInset citation
LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

 have produced an expressive logic of knowledge, action and change in which
 regression provides an effective reasoning procedure.
 But while powerful, this formalism suffers two major limitations that make
 it unsuitable for modelling complex multi-agent domains.
\end_layout

\begin_layout Standard
First, it lacks a comprehensive treatment of group-level epistemic modalities.
 Simple group-level modalities such as 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 can be finitely expressed in terms of individual-level knowledge, but more
 complex modalities such as 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 cannot be handled in this way.
 Instead, common knowledge is typically introduced via a separate second-order
 axiom 
\begin_inset CommandInset citation
LatexCommand citep
key "davis05fo_ma_theory,ghaderi07sc_joint_ability"

\end_inset

.
 This approach is logically sound, but means regression can no longer be
 used for effective automated reasoning.
 Given the deep connections between common knowledge and coordination, this
 is a serious shortcoming in multi-agent domains.
\end_layout

\begin_layout Standard
Second, it requires that whenever an action occurs, all agents 
\emph on
know
\emph default
 that an action has occurred.
 This demands a level of synchronicity that is unreasonable in many multi-agent
 domains.
 But if the restriction is lifted, each agent's knowledge must account for
 arbitrarily-long sequences of hidden actions 
\begin_inset CommandInset citation
LatexCommand citep
key "Lesperance99sitcalc_approach"

\end_inset

.
 Such a formulation must utilise a second-order induction axiom, again precludin
g the use of regression for effective automated reasoning.
\end_layout

\begin_layout Standard
In this paper we overcome these limitations, extending the standard account
 of knowledge in the situation calculus with the following technical results.
\end_layout

\begin_layout Itemize
A formal account of 
\emph on
Common Knowledge
\emph default
 and other group-level epistemic modalities, including a regression rule
 for reasoning about common knowledge;
\end_layout

\begin_layout Itemize
support for 
\emph on
Hidden Actions
\emph default
 and actions that are partially observable, including a reasoning technique
 to deal with arbitrarily-long sequences of hidden actions; and
\end_layout

\begin_layout Itemize
A solution to the 
\emph on
Frame Problem
\emph default
 for knowledge, built on the successor state axioms for primitive actions,
 maintaining regression as the primary reasoning tool, and allowing agents
 to reason about their own knowledge using only their local information.
\end_layout

\begin_layout Standard
The result is a rich account of knowledge for asynchronous, partially-observable
 domains, in which group-level epistemic modalities are amenable to effective
 automated reasoning.
\end_layout

\begin_layout Standard
There is a large body of work that can immediately benefit from such a formalism
, including: specification and verification of multi-agent systems 
\begin_inset CommandInset citation
LatexCommand citep
key "shapiro02casl"

\end_inset

; theories of coordination 
\begin_inset CommandInset citation
LatexCommand citep
key "ghaderi07sc_joint_ability"

\end_inset

 and ability 
\begin_inset CommandInset citation
LatexCommand citep
key "levesque00knowing_how"

\end_inset

; reasoning about the epistemic feasibility of plans 
\begin_inset CommandInset citation
LatexCommand citep
key "Lesperance01epi_feas_casl"

\end_inset

; analysing multi-player games 
\begin_inset CommandInset citation
LatexCommand citep
key "delgrande01sitcalc_cleudo"

\end_inset

; and our own work on the cooperative execution of Golog programs 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly06hlp_dps"

\end_inset

.
\end_layout

\begin_layout Standard
The paper begins by reviewing the standard account of multi-agent knowledge
 in the situation calculus in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-Multi-Agent-Situation"

\end_inset

.
 Readers familiar with the situation calculus are encouraged to review this
 material, as we extend some of the standard notation in preparation for
 later sections.
 Our new formalism is then developed in two parts.
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 treats the individual knowledge of each agent in the face of hidden actions.
 To decouple knowledge from the specific actions that have occurred, we
 explicitly reify the local 
\emph on
observations
\emph default
 made by each agent, so that every situation corresponds to an agent-local
 
\emph on
view
\emph default
.
 An agent is said to know propsition 
\begin_inset Formula $\phi$
\end_inset

 if and only if 
\begin_inset Formula $\phi$
\end_inset

 is true in all situations matching its current view.
 Our work thus has strong parallels with the classic view-based account
 of knowledge of 
\begin_inset CommandInset citation
LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

, but grounded in the situation calculus and with an emphasis on regression
 for automated reasoning.
\end_layout

\begin_layout Standard
The main challenge we overcome in this section is reasoning about arbitrarily-lo
ng sequences of hidden actions.
 Since universal quantification over situation terms requires a second-order
 induction axiom, such sequences cannot be handled by the standard regression
 operator.
 Using a new meta-operator called the 
\emph on
persistence condition
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

 to augment the regression techniques developed by 
\begin_inset CommandInset citation
LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, we maintain their elegant solution to the frame problem while being able
 to reason about arbitrarily-long sequences of hidden actions.
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Complex-Epistemic-Modalities"

\end_inset

 builds on our account of individual knowledge by introducing complex group-leve
l epistemic modalities.
 The main goal of this section is a formal account of common knowledge with
 a regression rule for effective reasoning, but this poses a significant
 technical challenge -- the regression of common knowlege cannot be expressed
 in terms of common knowledge alone, due to a fundamental expressivity limitatio
n of modal logic:
\end_layout

\begin_layout Quote
epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone
\emph on
 
\begin_inset CommandInset citation
LatexCommand citep
key "baltag98pa_ck"

\end_inset

.
\end_layout

\begin_layout Standard
To overcome this limitation, we take our cue from recent promising work
 in the related field of dynamic epistemic logic, with the main idea due
 to 
\begin_inset CommandInset citation
LatexCommand citet
key "vanBenthem06lcc"

\end_inset

: increase the expressive power of the epistemic language so it is strong
 enough to formulate a proper regression rule.
 They have developed the Logic of Communication and Change (henceforth 
\begin_inset Quotes eld
\end_inset

LCC
\begin_inset Quotes erd
\end_inset

) using the syntax of propositional dynamic logic to form epistemic modalities,
 and have shown that it allows reasoning about common knowledge with techniques
 akin to regression.
 We follow a similar approach in this paper and introduce complex epistemic
 modalities to the situation calculus.
 
\end_layout

\begin_layout Standard
To illustrate the effectiveness of our techniques, we will present a series
 of running examples from the following domain:
\end_layout

\begin_layout Quote
Ann and Bob are attending a party but do not know its location.
 They are both in the dining room when they receive an invitation in the
 mail.
 If Ann reads the invitation, she will know the location of the party.
 But will Bob know that she knows it? What if he temporarily leaves the
 room, meaning Ann is able to read the invitation in secret? And most importantl
y, can they achieve common knowledge of the party's location in order to
 coordinate their travel plans for the evening?
\end_layout

\begin_layout Standard
The potential for hidden actions and the need to reason explicitly about
 common knowledge put this domin beyond the reach of existing situation
 calculus theories, but our approach can handle it quite elegantly.
 This paper thus contributes a rich multi-agent theory of knowledge and
 action in which complex group-level epistemic modalities are amenable to
 effective automated reasoning.
\end_layout

\begin_layout Section
The Multi-Agent Situation Calculus
\begin_inset CommandInset label
LatexCommand label
name "sec:The-Multi-Agent-Situation"

\end_inset


\end_layout

\begin_layout Standard
Our work utilises the situation calculus 
\begin_inset CommandInset citation
LatexCommand citep
key "McCHay69sitcalc,pirri99contributions_sitcalc"

\end_inset

 with multiple agents 
\begin_inset CommandInset citation
LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

 and concurrent actions 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter96sc_nat_conc"

\end_inset

, and we begin from the standard account of knowledge due to 
\begin_inset CommandInset citation
LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

.
 Several conservative extensions to the standard situation calculus meta-theory
 are also employed: the 
\begin_inset Formula $Poss$
\end_inset

 fluent is subsumed by a general class of 
\emph on
action description predicates
\emph default
; the unique names axioms for actions are subsumed by a general 
\emph on
background
\emph default
 
\emph on
theory; 
\emph default
and reasoning is performed using the 
\emph on
single-step regression operator
\emph default
.
 We also review a new reasoning tool called the 
\emph on
persistence condition
\emph default
 operator 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
\end_layout

\begin_layout Standard
There are of course a wide range of related formalisms for reasoning about
 knowledge, action and change, which we do not directly consider in this
 paper.
 We find the notation and meta-theory of the situation calculus particularly
 suitable for expressing our main ideas.
 Moreover, the strong underlying similarities between the major action formalism
s should allow the these ideas to transcend the specifics of the situation
 calculus 
\begin_inset CommandInset citation
LatexCommand citep
key "thielscher06reconcile_sc_fc,thielscher07unifying_action_calculus,vanbentham07ml_sitcalc"

\end_inset

.
\end_layout

\begin_layout Subsection
Notation and Axioms
\begin_inset CommandInset label
LatexCommand label
name "sub:Notation-and-Axioms"

\end_inset


\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 Its has the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change, with the initiating agent indicated by
 their first argument; 
\noun on
Concurrent
\noun default
 terms are sets of actions that occur simultaneously; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Concurrent\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\emph on
Fluents
\emph default
 are predicates or functions that represent properties of the world that
 may change between situations; they take a situation term as their final
 argument.
\end_layout

\begin_layout Standard
We follow standard naming conventions for the situation calculus: lower-case
 roman names indicate variables; upper-case roman names indicate constants;
 greek letters indicate meta-variables and meta-operators; macros are presented
 in bold face; all axioms in 
\begin_inset Formula $\Dt$
\end_inset

 universally close over their free variables.
 The connectives 
\begin_inset Formula $\wedge$
\end_inset

, 
\begin_inset Formula $\neg$
\end_inset

, 
\begin_inset Formula $\exists$
\end_inset

 are taken as primitive, with 
\begin_inset Formula $\vee$
\end_inset

, 
\begin_inset Formula $\rightarrow$
\end_inset

, 
\begin_inset Formula $\equiv$
\end_inset

, 
\begin_inset Formula $\forall$
\end_inset

 defined in the usual manner.
 The name 
\begin_inset Formula $s$
\end_inset

 is used for variables of sort 
\noun on
Situation,
\noun default
 
\begin_inset Formula $a$
\end_inset

 for sort 
\noun on
Action, 
\noun default

\begin_inset Formula $c$
\end_inset

 for sort
\noun on
 Concurrent, 
\noun default

\begin_inset Formula $agt$
\end_inset

 for sort 
\noun on
Agent 
\noun default
and 
\begin_inset Formula $x$
\end_inset

 for sort 
\noun on
Object
\noun default
.
 The notation 
\begin_inset Formula $\vars x$
\end_inset

 indicates a vector of terms of context-appropriate sort and arity.
 
\end_layout

\begin_layout Standard
Some example statements from the 
\begin_inset Quotes eld
\end_inset

party invitation
\begin_inset Quotes erd
\end_inset

 domain are 
\begin_inset Quotes eld
\end_inset

Everyone is in the room initially
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Bob is not in the room after leaving it
\begin_inset Quotes erd
\end_inset

.
 Written formally:
\begin_inset Formula \begin{gather*}
\forall agt:\, InRoom(agt,S_{0})\\
\neg InRoom(Bob,do(leave(Bob),S_{0}))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The dynamics of a particular domain are captured by a set of sentences called
 a 
\emph on
basic action theory
\emph default
.
 Queries about the behaviour of the world are posed as logical entailment
 queries relative to this theory.
\end_layout

\begin_layout DefinitionLbld
Basic
\begin_inset space ~
\end_inset

Action
\begin_inset space ~
\end_inset

Theory A basic action theory, denoted 
\begin_inset Formula $\Dt$
\end_inset

, is a set of situation calculus sentences (of the specific syntactic form
 outlined below) describing a particular dynamic world.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); action description axioms defining various aspects of action performance,
 such as preconditions (
\begin_inset Formula $\Dt_{ad}$
\end_inset

); successor state axioms describing how primitive fluents change between
 situations (
\begin_inset Formula $\Dt_{ssa}$
\end_inset

); axioms describing the value of primitive fluents in the initial situation
 (
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

); and axioms describing the static background facts of the domain (
\begin_inset Formula $\Dt_{bg}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{ad}\cup\Dt_{ssa}\cup\Dt_{S_{0}}\cup\Dt_{bg}\]

\end_inset


\end_layout

\begin_layout Standard
These axioms must satisfy some simple consistency criteria to constitute
 a valid domain description 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 This is a conservative extension of the definition used by 
\begin_inset CommandInset citation
LatexCommand citeauthor
key "pirri99contributions_sitcalc"

\end_inset

, designed to accomodate our forthcoming extensions.
\end_layout

\begin_layout Standard
The 
\emph on
uniform formulae
\emph default
 can be thought of as properties of the state of the world, and are basically
 logical combinations of fluents referring to a common situation term.
 The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used to refer to an arbitrary uniform formula.
 For the moment we restrict ourselves to 
\emph on
objective
\emph default
 uniform formulae; the complete definition includes statements about knowledge
 and will be introduced in the next section.
\end_layout

\begin_layout DefinitionLbld
Uniform
\begin_inset space ~
\end_inset

Terms Let 
\begin_inset Formula $\sigma$
\end_inset

 be a fixed situation term, 
\begin_inset Formula $r$
\end_inset

 an arbitrary rigid function symbol, 
\begin_inset Formula $f$
\end_inset

 an arbitrary fluent function symbol, and 
\begin_inset Formula $x$
\end_inset

 a variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the terms uniform in 
\begin_inset Formula $\sigma$
\end_inset

 are the smallest set of syntactically-valid terms satisfying:
\begin_inset Formula \[
\tau\,::=x\,|\, r(\vars{\tau})\,|\, f(\vars{\tau},\sigma)\]

\end_inset


\end_layout

\begin_deeper
\begin_layout DefinitionLbld
Objective
\begin_inset space ~
\end_inset

Uniform
\begin_inset space ~
\end_inset

Formulae Let 
\begin_inset Formula $\sigma$
\end_inset

 be a fixed situation term, 
\begin_inset Formula $R$
\end_inset

 an arbitrary rigid predicate, 
\begin_inset Formula $F$
\end_inset

 an arbitrary primitive fluent predicate, 
\begin_inset Formula $\tau$
\end_inset

 an arbitrary term uniform in 
\begin_inset Formula $\sigma$
\end_inset

, and 
\begin_inset Formula $x$
\end_inset

 an arbitrary variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the objective formulae uniform in 
\begin_inset Formula $\sigma$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{\tau},\sigma)\,|\, R(\vars{\tau})\,|\,\tau_{1}=\tau_{2}\,|\,\phi_{1}\wedge\phi_{2}\,|\,\neg\phi\,|\,\exists x:\phi\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Since they represent properties of the world, it is often useful to evaluate
 uniform formulae at several different situation terms, and to suppress
 the situation terms in order to simplify the presentation.
 The notation 
\begin_inset Formula $\phi[s']$
\end_inset

 represents a uniform formula in which all fluents have their situation
 argument replaced with the particular situation 
\begin_inset Formula $s'$
\end_inset

, while 
\begin_inset Formula $\phi^{-1}$
\end_inset

 represents a uniform formula with the situation argument removed from all
 its fluents.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 contains all the situation-independent facts about the domain, and must
 include a set of unique names axioms to ensure that action terms with different
 names or different arguments are in fact different.
 The function 
\begin_inset Formula $actor(a)$
\end_inset

 gives the agent performing an action, which is always the action's first
 argument.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 contains one 
\emph on
successor state axiom
\emph default
 for each primitive fluent in the domain, providing a monotonic solution
 to the frame problem for that fluent.
 These axioms have the following general form: 
\begin_inset Formula \[
F(\vars x,do(c,s))\equiv\Phi_{F}^{+}(\vars x,c,s)\,\,\vee\,\, F(\vars x,s)\wedge\neg\Phi_{F}^{-}(\vars x,c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi_{F}^{+}$
\end_inset

 and 
\begin_inset Formula $\Phi_{F}^{-}$
\end_inset

 are formulae uniform in 
\begin_inset Formula $s$
\end_inset

.
 This may be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after performing 
\begin_inset Formula $c$
\end_inset

 if 
\begin_inset Formula $c$
\end_inset

 made it true, or it was previously true and 
\begin_inset Formula $c$
\end_inset

 did not make it false
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 defines fluents that describe various aspects of the performance of an
 action, which we call 
\emph on
action description predicates
\emph default
.
 The precondition predicate 
\begin_inset Formula $Poss(c,s)$
\end_inset

 is the canonical example, indicating whether it is possible to perform
 a set of actions in a given situation.
 In principle there can be any number of predicates or functions defined
 in a similar way -- forthcoming examples include the sensing-result function
 
\begin_inset Formula $SR$
\end_inset

 and the observability predicate 
\begin_inset Formula $CanObs$
\end_inset

.
 The meta-predicate 
\begin_inset Formula $\alpha$
\end_inset

 will denote an arbitrary action description predicate.
 For each such predicate the set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains a single axiom of the following form, where 
\begin_inset Formula $\Pi_{\alpha}$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\alpha(\vars x,c,s)\,\equiv\,\Pi_{\alpha}(\vars x,c,s)\]

\end_inset


\end_layout

\begin_layout Standard
Note that this is a departure from the standard approach of 
\begin_inset CommandInset citation
LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

 where a separate axiom specifies the preconditions for each individual
 action type.
 The single-axiom approach used in this paper embodies a domain-closure
 assumption on the 
\noun on
Action
\noun default
 sort.
 It is necessary when reasoning about formulae that universally quantify
 over actions 
\begin_inset CommandInset citation
LatexCommand citep
key "savelli06sc_quantum_levels,vassos08progression_future_queries"

\end_inset

, and is assumed to contain an appropriate axiomatisation of any interactions
 that may occur between primitive actions when they are performed concurrently
 
\begin_inset CommandInset citation
LatexCommand citep
key "pinto94temporal"

\end_inset

.
\end_layout

\begin_layout Standard
For convenience we will allow action description predicates to be defined
 in terms of other action description predicates; as long as these definitions
 are well-founded they can be expanded out to a definition that uses only
 uniform formulae.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 ensure that situations form a branching-time account of the world state.
 There are 
\emph on
initial situations
\emph default
 identified by the predicate 
\begin_inset Formula $Init(s)$
\end_inset

, and a distinguished initial situation 
\begin_inset Formula $S_{0}$
\end_inset

 called the 
\emph on
actual 
\emph default
initial situation.
 Other initial situations are used to represent the agents' epistemic uncertaint
y, and will be discussed in the following section.
 Situations in general form a tree structure with an initial situation at
 the root and 
\begin_inset Formula $do(c,s)$
\end_inset

 constructing the successor situation resulting when the actions 
\begin_inset Formula $c$
\end_inset

 are performed in 
\begin_inset Formula $s$
\end_inset

; all situations thus produced are distinct:
\begin_inset Formula \[
do(c_{1},s_{1})=do(c_{2},s_{2})\,\rightarrow\, c_{1}=c_{2}\,\wedge\, s_{1}=s_{2}\]

\end_inset


\end_layout

\begin_layout Standard
We abbreviate the performance of several successive actions by writing:
\begin_inset Formula \[
do([c_{1},\dots,c_{n}],s)\,\isdef\, do(c_{n},do(\dots,do(c_{1},s)))\]

\end_inset


\end_layout

\begin_layout Standard
There is also a second-order induction axiom asserting that all situations
 must be constructed in this way, which is needed to prove statements that
 universally quantify over situations 
\begin_inset CommandInset citation
LatexCommand citep
key "Reiter93proving"

\end_inset

:
\begin_inset Formula \[
\forall P:\,\left[P(S_{0})\wedge\forall s,c:\,\left(P(s)\rightarrow P(do(c,s))\right)\right]\,\rightarrow\,\forall s:\, P(s)\]

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
root
\emph default
 of a situation is the initial situation from which it was constructed:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\, root(s)=s\\
root(do(c,s))=root(s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 indicates that 
\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset

 and is defined as follows:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg(s'\sqsubset s)\\
s\sqsubset do(c,s')\equiv s\sqsubseteq s'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 This notation for 
\begin_inset Quotes eld
\end_inset

in the future of
\begin_inset Quotes erd
\end_inset

 can be extended to consider only those futures in which all actions satisfy
 a particular action description predicate.
 We include a relation 
\begin_inset Formula $<_{\alpha}$
\end_inset

 for each action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, with the following definitions:
\begin_inset Formula \begin{gather*}
Init(s)\,\rightarrow\,\neg\left(s'<_{\alpha}s\right)\\
s<_{\alpha}do(c,s')\equiv s\leq_{\alpha}s'\wedge\alpha(c,s')\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
For example, by stating that 
\begin_inset Formula $s<_{Poss}s'$
\end_inset

 we assert that not only is 
\begin_inset Formula $s'$
\end_inset

 in the future of 
\begin_inset Formula $s$
\end_inset

, but that all actions performed between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 were actually possible; this is equivalent to the 
\begin_inset Formula $<$
\end_inset

 operator of 
\begin_inset CommandInset citation
LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

.
 The 
\emph on
legal situations
\emph default
 are those in which every action performed was actually possible:
\begin_inset Formula \begin{gather*}
Legal(s)\,\equiv\, root(s)\leq_{Poss}s\end{gather*}

\end_inset

Note that we suppress the action and situation arguments to the action descripti
on predicate in order to simplify the presentation.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Finally, the axiom set 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 describes the state of the world before any actions are performed.
 It is a collection of sentences uniform in 
\begin_inset Formula $S_{0}$
\end_inset

 stating what holds in the actual initial situation.
 The initial knowledge of each agent is also captured in these axioms, as
 described in the next section.
\end_layout

\begin_layout Subsection
Knowledge and Sensing
\begin_inset CommandInset label
LatexCommand label
name "sub:Knowledge-and-Sensing"

\end_inset


\end_layout

\begin_layout Standard
Epistemic reasoning was first introduced to the situation calculus by 
\begin_inset CommandInset citation
LatexCommand citet
key "moore80know_act"

\end_inset

, and formalised extensively by 
\begin_inset CommandInset citation
LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

 whose paper is now the canonical reference for these techniques.
 Their work has been extended to include concurrent actions 
\begin_inset CommandInset citation
LatexCommand citep
key "scherl03conc_knowledge"

\end_inset

 and multiple agents 
\begin_inset CommandInset citation
LatexCommand citep
key "shapiro98specifying_ma_systems"

\end_inset

.
 
\end_layout

\begin_layout Standard
The semantics of knowledge are based on a reification of the 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 semantics of modal logic, using situation terms rather than abstract worlds.
 A special fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 is used to indicate that 
\begin_inset Quotes eld
\end_inset

in situation 
\begin_inset Formula $s$
\end_inset

, the agent 
\begin_inset Formula $agt$
\end_inset

 considers the alternate situation 
\begin_inset Formula $s'$
\end_inset

 to be possible
\begin_inset Quotes erd
\end_inset

.
 The macro 
\begin_inset Formula $\Knows$
\end_inset

 is then defined as a shorthand for the standard possible-worlds definition
 of knowledge, stating that an agent knows 
\begin_inset Formula $\phi$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 is true in all situations considered possible: 
\begin_inset Formula \begin{equation}
\Knows(agt,\phi,s)\isdef\forall s':\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}

\end_inset

 
\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 define a special fluent 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 that is used to model the initial epistemic uncertainty of the agents,
 with 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 containing sentences of the form 
\begin_inset Formula $\KnowsZ(agt,\phi,S_{0})$
\end_inset

 to specify what is initially known
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The standard account does not require a separate 
\begin_inset Formula $K_{0}$
\end_inset

 fluent, as evidenced by equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:k_s0_standard"

\end_inset

.
 It is required when incorporating hidden actions, so we introduce it now
 to maintain consistency.
 
\end_layout

\end_inset

:
\begin_inset Formula \begin{gather*}
K_{0}(agt,s',s)\,\rightarrow Init(s)\wedge Init(s')\\
\KnowsZ(agt,\phi,s)\isdef\forall s':\, K_{0}(agt,s',s)\rightarrow\phi[s']\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The action description function 
\begin_inset Formula $SR(a,s)$
\end_inset

 specifies the sensing result returned by 
\begin_inset Formula $a$
\end_inset

 when executed in situation 
\begin_inset Formula $s$
\end_inset

.
 For non-sensing actions the value of 
\begin_inset Formula $SR$
\end_inset

 is an arbitrary constant.
 The dynamics of knowledge are then specified by an additional set of axioms.
\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K}^{std}$
\end_inset

 the axioms of the standard account of knowledge due to 
\begin_inset CommandInset citation
LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, as detailed in equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

) below:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
Init(s)\rightarrow\left(K(agt,s',s)\,\equiv\, K_{0}(agt,s',s)\right)\label{eq:k_s0_standard}\end{equation}

\end_inset


\begin_inset Formula \begin{align}
K(agt,s'',do(c,s))\equiv\exists s': & \, s''=do(c,s')\,\wedge K(agt,s',s)\wedge Poss(c,s')\nonumber \\
 & \wedge\,\forall a\in c:\,\left(actor(a)=agt\,\rightarrow\, SR(a,s)=SR(a,s')\right)\label{eq:k_ssa_standard}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:k_s0_standard"

\end_inset

 ensures that the agents begin with their knowledge as specified by 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

.
 Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:k_ssa_standard"

\end_inset

 takes the form of a standard successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent.
 It ensures that 
\begin_inset Formula $s''$
\end_inset

 is considered a possible alternative to 
\begin_inset Formula $do(c,s)$
\end_inset

 when 
\begin_inset Formula $s''$
\end_inset

 is the result of doing the same actions 
\begin_inset Formula $c$
\end_inset

 in a situation 
\begin_inset Formula $s'$
\end_inset

 that is considered a possible alternative to 
\begin_inset Formula $s$
\end_inset

.
 It must furthermore have been possible to perform those actions in 
\begin_inset Formula $s'$
\end_inset

, and the sensing results must match for each action that was carried out
 by the agent in question.
 Thus an agent's knowledge after the occurrence of an action is completely
 determined by the combination of its knowledge before the action, and the
 sensing results from the action.
 
\end_layout

\begin_layout Standard
We can now present the complete definition of a uniform formula, which may
 statements about knowledge:
\end_layout

\begin_layout DefinitionLbld
Uniform
\begin_inset space ~
\end_inset

Formulae Let 
\begin_inset Formula $\sigma$
\end_inset

 be a fixed situation term, 
\begin_inset Formula $\tau$
\end_inset

 an arbitrary term uniform in 
\begin_inset Formula $\sigma$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset

 an arbitrary variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the formulae uniform in 
\begin_inset Formula $\sigma$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{\tau},\sigma)\,|\, R(\vars{\tau})\,|\,\tau_{1}=\tau_{2}\,|\,\phi_{1}\wedge\phi_{2}\,|\,\neg\phi\,|\,\exists x:\phi\,|\,\Knows(agt,\phi,s)\,|\,\KnowsZ(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
While powerful, this knowledge-representation formalism has an important
 limitation: it is fundamentally 
\emph on
synchronous.
 
\emph default
Each agent is assumed to have full knowledge of all actions that have occurred
 - in other words, all actions are public.
 While suitable for some domains, there are clearly many multi-agent domains
 where achieving total awareness of actions would be infeasible.
 A major contribution of this paper is a more flexible formalism for knowledge
 that can be applied to a much wider range of domains.
\end_layout

\begin_layout Subsection
Reasoning and Regression
\end_layout

\begin_layout Standard
One of the attractions of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 These are generally based on syntactic manipulation of a query into a form
 that is more amenable to reasoning -- for example, because it can be proven
 without using some of the axioms from 
\begin_inset Formula $\Dt$
\end_inset

.
\end_layout

\begin_layout Standard
In the general case, answering a query about a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 is a theorem-proving task in second-order logic (denoted SOL) due to the
 induction axiom included in the foundational axioms.
 This is clearly problematic for effective automated reasoning, but fortunately
 there exist particular syntactic forms for which some of the axioms in
 
\begin_inset Formula $\mathcal{D}$
\end_inset

 are not required 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 In particular, queries about the initial situation can be answered using
 only first-order logic (FOL) and a limited set of axioms:
\begin_inset Formula \[
\mathcal{D}\models_{SOL}\phi[S_{0}]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{bg}\models_{FOL}\phi[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
Since the axioms 
\begin_inset Formula $\Dt_{S_{0}}\cup\Dt_{bg}$
\end_inset

 often satisfy the closed-world assumption, provers such as Prolog can be
 employed to handle this type of query quite effectively.
 Effective reasoning depends on transforming queries into more easily-handled
 forms such as this.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The principle tool for effective reasoning in the situation calculus is
 the regression meta-operator 
\begin_inset Formula $\Reg_{\Dt}$
\end_inset

, a syntactic manipulation that encodes the preconditions and effects of
 actions into the query itself, meaning fewer axioms are needed for the
 final reasoning task 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 The idea is to reduce a query about some future situation to a query about
 the current situation only.
\end_layout

\begin_layout Standard
Regression is only defined for a certain class of formulae, the 
\emph on
regressable formulae
\emph default
.
 
\end_layout

\begin_layout DefinitionLbld
Regressable
\begin_inset space ~
\end_inset

Terms Let 
\begin_inset Formula $\sigma$
\end_inset

 be an arbitrary situation term, 
\begin_inset Formula $x$
\end_inset

 an arbitrary variable not of sort situation, 
\begin_inset Formula $r$
\end_inset

 an arbitrary rigid function and 
\begin_inset Formula $f$
\end_inset

 an arbitrary fluent function.
 Then the regressable terms are the smallest set of syntactically-valid
 terms satisfying: 
\begin_inset Formula \[
\nu::=\sigma\,|\, x\,|\, f(\vars{\nu},\sigma)\,|\, r(\vars{\nu})\]

\end_inset


\end_layout

\begin_deeper
\begin_layout DefinitionLbld
Regressable
\begin_inset space ~
\end_inset

Formulae 
\begin_inset CommandInset label
LatexCommand label
name "def:Background:Regressable-Formulae"

\end_inset

Let 
\begin_inset Formula $\sigma$
\end_inset

 be an arbitrary situation term, 
\begin_inset Formula $x$
\end_inset

 an arbitrary variable not of sort situation, 
\begin_inset Formula $\nu$
\end_inset

 an arbitrary regressable term, 
\begin_inset Formula $R$
\end_inset

 an arbitrary rigid predicate, 
\begin_inset Formula $F$
\end_inset

 an arbitrary primitive fluent predicate, and 
\begin_inset Formula $\alpha$
\end_inset

 an arbitrary action description predicate.
 Then the regressable formulae are the smallest set of syntactically-valid
 formulae satisfying: 
\begin_inset Formula \[
\varphi::=F(\vars{\nu},\sigma)\,|\,\alpha(\vars{\nu},c,\sigma)\,|\, R(\vars{\nu})\,|\,\nu_{1}=\nu_{2}\,|\,\neg\varphi\,|\,\varphi_{1}\wedge\varphi_{2}\,|\,\exists x:\,\varphi\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Regressable formulae are more general than uniform formulae.
 In particular, they can contain action description predicates and may mention
 different situation terms.
 They cannot, however, quantify over situation terms or compare situations
 using the 
\begin_inset Formula $\sqsubset$
\end_inset

 predicate.
\end_layout

\begin_layout Standard
The regression operator is then defined using a series of 
\emph on
regression rules
\emph default
 such as those shown below, which mirror the structural definition of regressabl
e formulae.
 
\end_layout

\begin_layout DefinitionLbld
Regression
\begin_inset space ~
\end_inset

Operator Let 
\begin_inset Formula $R$
\end_inset

 be a rigid predicate, 
\begin_inset Formula $\alpha$
\end_inset

 be an action description predicate with axiom 
\begin_inset Formula $\alpha(\vars{\nu},c,s)\equiv\Pi_{\alpha}(c,s)$
\end_inset

 in 
\begin_inset Formula $\Dt_{ad}$
\end_inset

, and 
\begin_inset Formula $F$
\end_inset

 be a primitive fluent with axiom 
\begin_inset Formula $F(\vars x,s)\equiv\Phi_{F}(\vars x,s)$
\end_inset

 in 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

.
 Then the regression of 
\begin_inset Formula $\phi$
\end_inset

, denoted 
\begin_inset Formula $\Reg_{\Dt}(\phi)$
\end_inset

, is defined according to the following structural rules:
\begin_inset Formula \begin{gather*}
\Reg_{\Dt}(\varphi_{1}\wedge\varphi_{2})\,\isdef\,\Reg_{\Dt}(\varphi_{1})\wedge\Reg_{\Dt}(\varphi_{2})\\
\Reg_{\Dt}(\exists x:\,\varphi)\,\isdef\,\exists x:\,\Reg_{\Dt}(\varphi)\\
\Reg_{\Dt}(\neg\varphi)\,\isdef\,\neg\Reg_{\Dt}(\varphi)\\
\Reg_{\Dt}(\alpha(\vars{\nu},a,\sigma))\,\isdef\,\Reg_{\Dt}(\Pi_{\alpha}(\vars{\nu},a,\sigma))\\
\Reg_{\Dt}(F(\vars{\nu},do(a,\sigma)))\,\isdef\,\Phi_{F}(\vars{\nu},a,\sigma)\\
\Reg_{\Dt}(F(\vars{\nu},s))\,\isdef\,\Phi_{F}(\vars{\nu},a,s)\\
\Reg_{\Dt}(F(\vars{\nu},S_{0}))\,\isdef\,\Phi_{F}(\vars{\nu},a,S_{0})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We have omitted some technical details here, such as the handling of functional
 fluents; consult 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 for the details.
 The key point is that each application of the regression operator replaces
 action description predicates with their definitions from 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and primitive fluents with their successor state axioms from 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

, 
\begin_inset Quotes eld
\end_inset

unwinding
\begin_inset Quotes erd
\end_inset

 a single action from each 
\begin_inset Formula $do(a,\sigma)$
\end_inset

 situation term in the query.
 If the situation term is not constructed using 
\begin_inset Formula $do$
\end_inset

, it is left unchanged.
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\Dt$
\end_inset

 is fixed, we will henceforth drop the subscript and simply write 
\begin_inset Formula $\Reg$
\end_inset

 for the regression operator.
 When dealing with situation-suppressed uniform formulae, we will use a
 two-argument operator 
\begin_inset Formula $\Reg(\phi,c)$
\end_inset

 to indicate the regression of 
\begin_inset Formula $\phi$
\end_inset

 over the action 
\begin_inset Formula $c$
\end_inset

.
 It should be read as a shorthand for 
\begin_inset Formula $\Reg(\phi[do(c,s)])^{-1}$
\end_inset

 using the situation-suppression operator from Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Notation-and-Axioms"

\end_inset

.
\end_layout

\begin_layout Standard
Repeated applications of this operator, denoted by 
\begin_inset Formula $\Reg^{*}$
\end_inset

, can transform a query about some future situation into a query about the
 initial situation only, which is much easier to answer.
 The axioms 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 are essentially 
\begin_inset Quotes eld
\end_inset

compiled into
\begin_inset Quotes erd
\end_inset

 the query.
 The trade-off is that the length of the regressed query may be exponential
 in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice 
\begin_inset CommandInset citation
LatexCommand citep
key "levesque97golog,pirri99contributions_sitcalc"

\end_inset

 and there are techniques to avoid exponential growth of the query in some
 cases 
\begin_inset CommandInset citation
LatexCommand citep
key "vandtmarsh07optimal_regression"

\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A key contribution of 
\begin_inset CommandInset citation
LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 was showing how to apply the regression operator to formulae containing
 the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro, allowing it to be treated syntactically as if it were a primitive
 fluent.
 This means that epistemic queries can be approached using standard reasoning
 techniques of the situation calculus.
 Although we have changed the notation somewhat to foreshadow the techniques
 we will develop in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

, their definition operates as follows.
 First, define the 
\emph on
results
\emph default
 of a concurrent action to be the set of 
\begin_inset Formula $action\#result$
\end_inset

 pairs for all primitive actions perform by the agent in question:
\begin_inset Formula \[
\mathbf{res}(agt,c,s)\isdef\{a\#SR(a,s)\,\,|\,\, a\in c\,\wedge\, actor(a)=agt\}\]

\end_inset


\end_layout

\begin_layout Standard
TODO: clean this up, make use of set theory precise.
 This definition is then used to formulate a regression rule as follows:
\begin_inset Formula \begin{multline}
\Reg(\Knows(agt,\phi,do(c,s))\isdef\\
\exists y:\, y=\mathbf{res}(agt,c,s)\,\wedge\Knows(agt,\left[Poss(c)\wedge\mathbf{res}(agt,c)=y\right]\rightarrow\Reg(\phi[do(c,s)]),s)\label{eq:reg_k_std}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
This works by collecting the sensing results from each action performed
 by the agent into the set 
\begin_inset Formula $y$
\end_inset

, then ensuring matching sensing results in every situation considered possible.
 It expresses the knowledge of the agent after a concurrent action in terms
 of what it knew before the action, along with the information returned
 by the action.
 This technique relies heavily on the fact that all actions are public,
 since it requires every agent's knowledge to be updated in response to
 every action.
\end_layout

\begin_layout Standard
Repeated applications of 
\begin_inset Formula $\Reg$
\end_inset

 can thus transform a knowledge query into one that is uniform in the initial
 situation.
 While it would be valid to then expand the 
\begin_inset Formula $\Knows$
\end_inset

 macros and handle the query using first-order logic, in practice the reasoning
 procedure would leave 
\begin_inset Formula $\Knows$
\end_inset

 intact and use a specialised prover based on modal logic.
\end_layout

\begin_layout Standard
It is possible to formulate an alternate successor state axiom for knowledge
 that does not assume all actions are public, such as that of 
\begin_inset CommandInset citation
LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

.
 Such formulations invariably require universal quantification over situation
 terms, to account for arbitrarily-long sequences of hidden actions.
 This is incompatible with regression rules like the above, and these formulatio
ns offer no reasoning procedure other than general second-order theorem
 proving.
 By utilising a new reasoning technique called the 
\emph on
persistence condition
\emph default
 to reason about universal quantification over situation terms, our work
 is the first to provide an account of knowledge with hidden actions while
 maintaining regression in the style presented above as an effective reasoning
 tool.
\end_layout

\begin_layout Standard
TODO: also encrypted speech acts etc
\end_layout

\begin_layout Standard
TODO: accessibility relation properties, and easy breakage.
\end_layout

\begin_layout Subsection
Property Persistence and the Persistence Condition
\begin_inset CommandInset label
LatexCommand label
name "sub:Property-Persistence"

\end_inset


\end_layout

\begin_layout Standard
Queries that universally quantify over situation terms are often in a simple
 syntactic form called 
\emph on
property persistence
\emph default
 queries 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 Such queries assert that a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 holds in a given situation, and will continue to hold as long as all future
 actions satisfy some action description predicate 
\begin_inset Formula $\alpha$
\end_inset

: 
\begin_inset Formula \[
\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
We have developed the 
\emph on
persistence condition
\emph default
 meta-operator 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 to handle such queries more effectively 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 It produces a uniform formula such that:
\begin_inset Formula \[
\Dt\,\models\,\Pst_{\Dt}(\phi,\alpha)[s]\,\equiv\,\forall s':\, s\leq_{\alpha}s'\,\rightarrow\,\phi[s']\]

\end_inset


\end_layout

\begin_layout Standard
As with regression, we will use the simpler notation 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 and leave 
\begin_inset Formula $\Dt$
\end_inset

 implicit.
 Since the persistence condition is used to replace a second-order induction
 axiom, 
\begin_inset Formula $\Pst$
\end_inset

 is actually a fixpoint calculation and it therefore requires some theorem
 proving.
 This is in contrast to the regression operator, which is a purely syntactic
 transformation.
 We briefly describe the operation of 
\begin_inset Formula $\Pst$
\end_inset

 below since we will need some of these details for a later proof; for full
 details consult our previous work 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
\end_layout

\begin_layout Standard
First, the one-step-persistence operator 
\begin_inset Formula $\Pst^{1}$
\end_inset

 is defined to assert that 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and all its immediate successors:
\begin_inset Formula \[
\Pst^{1}(\phi,\alpha)[s]\,\isdef\,\phi[s]\wedge\forall c:\,\alpha(c,s)\rightarrow\Reg(\phi,c)[s]\]

\end_inset


\end_layout

\begin_layout Standard
Repeated application asserts persistence after greater numbers of actions:
\begin_inset Formula \[
\Pst^{n}(\phi,\alpha)\,\isdef\,\Pst^{1}(\Pst^{n-1}(\phi,\alpha),\alpha)\]

\end_inset

 
\end_layout

\begin_layout Standard
Intuitively 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 should be a fixpoint of 
\begin_inset Formula $\Pst^{1}(\phi,\alpha)$
\end_inset

, and indeed it can be shown that:
\begin_inset Formula \[
\mathcal{D}_{bg}\,\models\,\Pst^{n}(\phi,\alpha)\,\rightarrow\,\Pst^{n+1}(\phi,\alpha)\,\,\,\,\,\,\mathrm{iff}\,\,\,\,\,\,\Dt-\Dt_{S_{0}}\,\models\,\Pst^{n}(\phi,\alpha)\,\equiv\,\Pst(\phi,\alpha)\]

\end_inset


\end_layout

\begin_layout Standard
Thus the calculation of 
\begin_inset Formula $\mathcal{P}(\phi,\alpha)$
\end_inset

 replaces a single second-order reasoning task with iterated first-order
 reasoning using only the unique names axioms.
 Our experience has shown this technique to be quite effective in practice
 thanks to the simple form of axioms in 
\begin_inset Formula $\Dt_{una}$
\end_inset

.
 Since 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 produces a uniform formula, it allows queries that universally quantify
 over situation terms to be reduced to a form that is compatible with traditiona
l regression techniques.
\end_layout

\begin_layout Standard
TODO: always exisits, and is a uniform formula
\end_layout

\begin_layout Standard
TODO: decidable for propositional domains, context-free domains
\end_layout

\begin_layout Standard
TODO: reference 
\begin_inset CommandInset citation
LatexCommand citet
key "classen08golog_properties"

\end_inset

 on use of fixpoint calculations
\end_layout

\begin_layout Section
Individual Knowledge with Hidden Actions
\begin_inset CommandInset label
LatexCommand label
name "sec:Obs-Knowledge"

\end_inset


\end_layout

\begin_layout Standard
Existing accounts of knowledge in the situation calculus directly express
 the dynamics of knowledge update in terms of the actions that have occurred
 in the world, as seen in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Knowledge-and-Sensing"

\end_inset

.
 This works well when agents can be assumed to have full knowledge of the
 actions that have been performed, but quickly becomes cumbersome when trying
 to allow for hidden actions.
 In this section we first develop a principled axiomatisation of the 
\emph on
observability
\emph default
 of actions, then build a powerful yet succinct axiomatisation of knowledge
 upon it.
\end_layout

\begin_layout Standard
The basic idea is as follows: each occurrence of an action results in an
 agent making a set of 
\emph on
observations
\emph default
.
 Every situation then corresponds to a local 
\emph on
view
\emph default
 for that agent: the sequence of all its observations, excluding cases where
 the set of observations was empty.
 An agent knows something if it is true in all situations matching its current
 view.
 Decoupling knowledge in this manner makes it easy to express various degrees
 of observability of actions, from public actions through to actions that
 are completely hidden.
 
\end_layout

\begin_layout Standard
To maintain the elegant solution to the frame problem for knowledge developed
 by 
\begin_inset CommandInset citation
LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, the regression rule of knowledge must be modified to account for arbitrarily
 long sequences of hidden actions.
 We present a new regression rule for knowledge that uses the persistence
 condition meta-operator to augment standard regression and perform the
 necessary inductive reasoning.
\end_layout

\begin_layout Standard
The direct coupling between knowledge and action also has undesirable implicatio
ns for situated agents reasoning about their own knowledge.
 As a consequence of using regression to handle knowledge queries, one can
 only reason about knowledge if one has a rooted situation term, as the
 required query is:
\begin_inset Formula \[
\Dt_{S_{0}}\cup\Dt_{una}\,\models\,\Reg^{*}(\Knows(agt,\phi,do([c_{1},\dots,c_{n}],S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
In asynchronous domains with hidden actions, where agents are not necessarily
 aware how many actions have been performed, the agents cannot use this
 formulation to reason about their own knowledge.
 Since knowledge is directly coupled to actions, and hence to situation
 terms, they cannot construct the appropriate query.
\end_layout

\begin_layout Standard
Further demonstrating the power of our approach, we show how the new regression
 rules can be applied using an agent's individual view, rather than requiring
 a full situation term.
 Agents can thus use our techniques to reason about their own knowledge
 using only their local information, making the formalism suitable both
 for reasoning 
\emph on
about
\emph default
, and reasoning 
\emph on
in
\emph default
,
\emph on
 
\emph default
rich multi-agent domains.
\end_layout

\begin_layout Subsection
Extra
\end_layout

\begin_layout Standard
Decoupling knowledge in this manner makes it easy to express various degrees
 of observability of actions, from public actions through to actions that
 are completely hidden.
 This section is a greatly expanded version of our conference paper on the
 same topic, and stands as a significant new account of knowledge in its
 own right 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_know_obs"

\end_inset

.
\end_layout

\begin_layout Standard
The main challenge we overcome in this section is developing regression
 rules that can handle arbitrarily long sequences of hidden actions.
 To ensure its knowledge is valid, an agent must reason about all future
 situations that are compatible with its observations.
 Such universal quantification over situation terms requires a second-order
 induction axiom, which the standard regression operator cannot handle.

\emph on
 
\emph default
In previous work we have developed the persistence condition operator, which
 uses a meta-level fixpoint calculation to deal with universally quantified
 queries 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

.
 Using this operator to augment the regression techniques developed by 
\begin_inset CommandInset citation
LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, we maintain their elegant solution to the frame problem while handling
 arbitrarily long sequences of hidden actions.
\end_layout

\begin_layout Standard
Further demonstrating the power of our approach, we show how the new regression
 rules can be applied using an agent's individual view, rather than requiring
 a full situation term.
 Agents can thus use our techniques to reason about their own knowledge
 using only their local information, making the formalism suitable both
 for reasoning 
\emph on
about
\emph default
, and reasoning 
\emph on
in
\emph default
,
\emph on
 
\emph default
rich multi-agent domains.
\end_layout

\begin_layout Subsection
Observations
\end_layout

\begin_layout Standard
To remove the direct coupling between knowledge and actions, we introduce
 an explicit notion of 
\emph on
observations
\emph default
.
 These are internal notifications that agents receive when an action has
 occurred.
 By expressing knowledge in terms of observations rather than actions, we
 ensure that agents can always reason about their own knowledge based on
 their own internal history of observations.
\end_layout

\begin_layout DefinitionLbld
Observations An observation is a notification event received by an agent,
 making it aware of some change in the state of the world.
 When an agent receives such a notification, we say that it 
\begin_inset Quotes eld
\end_inset

observed
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

made
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

perceived
\begin_inset Quotes erd
\end_inset

 that observation.
\end_layout

\begin_layout Standard
Since the state of the world may only change in response to some action,
 observations can only be made as a result of some action.
 For simplicity we assume that agents perceive observations instantaneously,
 i.e.
 in the same instant as the actions that cause them.
\end_layout

\begin_layout Standard
Since 
\begin_inset Quotes eld
\end_inset

observation
\begin_inset Quotes erd
\end_inset

 is quite a loaded term, it is worth re-iterating this point: observations
 are instantaneous
\emph on
 events
\emph default
 generated internally by each agent in response to actions occurring in
 the world.
 We make no commitment as to how these events are generated, preferring
 a clean delineation between the task of observing change and the dynamics
 of knowledge update based on those observations.
 As with the work of 
\begin_inset CommandInset citation
LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

, we consider change-awareness to be the responsibility of a lower-level
 component of the agent's control software.
\end_layout

\begin_layout Standard
To make this idea concrete, let us introduce an additional sort 
\noun on
Observations
\noun default
 to the language of the situation calculus, for the moment without any particula
r commitment towards what this sort will contain.
 We then add to 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 an axiom for the action description function:
\begin_inset Formula \[
Obs(agt,c,s)=o\]

\end_inset

This function returns a set of observations, and should be read as 
\begin_inset Quotes eld
\end_inset

when actions 
\begin_inset Formula $c$
\end_inset

 are performed in situation 
\begin_inset Formula $s$
\end_inset

, agent 
\begin_inset Formula $agt$
\end_inset

 will perceive 
\begin_inset Formula $o$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Using a set of observations allows an agent to perceive any number of observati
ons in response to an action occurrence - perhaps several observations,
 perhaps none.
 When 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

 is the empty set (denoted 
\begin_inset Formula $\{\}$
\end_inset

) then the agent makes no observations and the actions 
\begin_inset Formula $c$
\end_inset

 are completely hidden.
 
\end_layout

\begin_layout Standard
The concept of a 
\emph on
view
\emph default
 follows naturally - it is the sequence of all the observations made by
 an agent as the world has evolved.
 
\end_layout

\begin_layout DefinitionLbld
Views An agent's view in a given situation 
\begin_inset Formula $\mathrm{s}$
\end_inset

 is the corresponding sequence of observations made by the agent as a result
 of each action in 
\begin_inset Formula $\mathrm{s}$
\end_inset

, excluding those actions for which no observations were made.
\end_layout

\begin_layout Standard
We introduce another sort 
\noun on
Views
\noun default
 consisting of sequences of sets of observations Using 
\begin_inset Formula $\epsilon$
\end_inset

 to represent the empty sequence and 
\begin_inset Formula $\cdot$
\end_inset

 to prepend a new element to a sequence, the functional fluent 
\begin_inset Formula $View$
\end_inset

 is defined as follows to give the history of observations associated with
 a particular situation:
\begin_inset Formula \begin{align}
Init(s)\,\rightarrow & \, View(agt,s)=\epsilon\nonumber \\
Obs(agt,c,s)=\{\}\,\rightarrow & \, View(agt,do(c,s))=View(agt,s)\nonumber \\
Obs(agt,c,s)\neq\{\}\,\rightarrow & \, View(agt,do(c,s))=Obs(agt,c,s)\cdot View(agt,s)\label{eq:view_defn}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Observations and views can be seen as localised analogues of actions and
 situations respectively.
 An action is a global event that causes the state of the world to change,
 while an observation is an internal event that causes an agent's knowledge
 of the state of the world to change.
 Similarly, a situation represents a complete, global history of all the
 actions that have occurred in the world, while a view is an agent's local
 history of all the observations it has made.
 The situation is an omniscient perspective on the world, the view a local
 perspective.
 As we shall see, this distinction is fundamental to developing a truly
 general multi-agent semantics for knowledge.
\end_layout

\begin_layout Subsection
Knowledge and Observation
\begin_inset CommandInset label
LatexCommand label
name "sub:Knowledge-and-Observation"

\end_inset


\end_layout

\begin_layout Standard
It is a basic tenet of epistemic reasoning that an agent's knowledge at
 any particular time must depend solely on its local history: the knowledge
 that it started out with combined with the observations it has made since
 then 
\begin_inset CommandInset citation
LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
 Given an explicit account of the observations made by each agent, the required
 semantics of the 
\begin_inset Formula $K$
\end_inset

 relation are clear: 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 must hold whenever 
\begin_inset Formula $s'$
\end_inset

 is legal, both 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 would result in the same view for the agent, and 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 are rooted at 
\begin_inset Formula $K$
\end_inset

-related initial situations:
\begin_inset Formula \begin{equation}
K(agt,s',s)\equiv K(root(s'),root(s))\wedge Legal(s')\wedge View(agt,s')=View(agt,s)\label{eq:k-desired}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
While a wonderfully succinct definition of how knowledge should behave,
 this formulation cannot be used directly in a basic action theory.
 The dynamics of fluent change must be specified by a successor state axiom,
 so we must formulate a successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent which enforces the above equivalence.
\end_layout

\begin_layout Standard
For notational convenience, let us first introduce an action description
 predicate 
\begin_inset Formula $\PbU$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

possible but unobservable
\begin_inset Quotes erd
\end_inset

) indicating that the actions 
\begin_inset Formula $c$
\end_inset

 are possible in 
\begin_inset Formula $s$
\end_inset

, but no observations will be made by 
\begin_inset Formula $agt$
\end_inset

 if they are performed:
\begin_inset Formula \begin{equation}
\PbU(agt,c,s)\,\equiv\, Poss(c,s)\wedge Obs(agt,c,s)=\{\}\label{eqn:PbU_defn}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
By stating that 
\begin_inset Formula $s\leq_{\PbU(agt)}s'$
\end_inset

 we assert that 
\begin_inset Formula $agt$
\end_inset

 would make no observations were the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
 This means that its view in both situations would be identical, so if it
 considers 
\begin_inset Formula $s$
\end_inset

 possible then it must also consider 
\begin_inset Formula $s'$
\end_inset

 possible.
 Following this intuition, we propose the following successor state axiom
 to capture the desired dynamics of the knowledge fluent:
\begin_inset Formula \begin{align}
K(agt,s'',do(c,s))\equiv & \left[\, Obs(agt,c,s)=\{\}\rightarrow K(agt,s'',s)\,\right]\nonumber \\
\wedge & \left[\, Obs(agt,c,s)\neq\{\}\rightarrow\exists c',s':\, Obs(agt,c',s')=Obs(agt,c,s)\right.\nonumber \\
 & \left.\,\,\,\,\,\,\,\,\wedge\, Poss(c',s')\wedge K(agt,s',s)\wedge do(c',s')\leq_{\PbU(agt)}s''\,\right]\label{eqn:new_k_ssa}\end{align}

\end_inset

 
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $c$
\end_inset

 was totally unobservable, the agent's state of knowledge does not change.
 Otherwise, it considers possible any legal successor to a possible alternate
 situation 
\begin_inset Formula $s'$
\end_inset

 that can be brought about by an action 
\begin_inset Formula $c'$
\end_inset

 yielding identical observations.
 It also considers possible any future of such a situation in which is would
 make no further observations.
 To reiterate: unlike the standard successor state axiom from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:k_ssa_standard"

\end_inset

, our new formalism requires agents to consider any possible future situation
 in which they would make no further observations.
\end_layout

\begin_layout Standard
It remains to specify 
\begin_inset Formula $K$
\end_inset

 in the initial situation.
 The relation 
\begin_inset Formula $K_{0}$
\end_inset

 defines knowledge before 
\emph on
any
\emph default
 actions have occurred, but the agents must consider the possibility that
 some hidden actions have occurred.
 In other words, we must include situations where 
\begin_inset Formula $root(s)\leq_{\PbU(agt)}s$
\end_inset

 in the 
\begin_inset Formula $K$
\end_inset

-relation for initial situations.
 We therefore propose the following axiom:
\begin_inset Formula \begin{gather}
Init(s)\rightarrow\left[K(agt,s'',s)\equiv\exists s'\,.\, K_{0}(agt,s',s)\wedge s'\leq_{\PbU(agt)}s'')\right]\label{eqn:new_k_s0}\end{gather}

\end_inset


\end_layout

\begin_layout Definition
We will denote by 
\begin_inset Formula $\Dt_{K}^{obs}$
\end_inset

 the axioms for our new observation-based semantics for knowledge, as detailed
 in equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:view_defn"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) above.
\end_layout

\begin_layout Standard
These axioms suffice to ensure that knowledge behaves as we require: two
 situations will be related by 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 if and only if they result in identical views for that agent, 
\begin_inset Formula $s'$
\end_inset

 is legal, and their root situations were initially related.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:k_obs_equiv"

\end_inset

 For any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge View(agt,s'')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
For the
\series bold
 
\series default
\emph on
if
\emph default
 direction we establish each of the three conjuncts individually.
 The 
\begin_inset Formula $root$
\end_inset

 case is trivial since equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) always expresses 
\begin_inset Formula $K(s'',do(c,s))$
\end_inset

 in terms of 
\begin_inset Formula $K(s',s)$
\end_inset

.
 The 
\begin_inset Formula $Legal$
\end_inset

 case relies on the fact that 
\begin_inset Formula $\PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

, while the 
\begin_inset Formula $View$
\end_inset

 case relies on the fact that 
\begin_inset Formula $s\leq_{\PbU}s'\rightarrow View(s)=View(s')$
\end_inset

.
 For the 
\emph on
only-if
\emph default
 direction we show how to construct an 
\begin_inset Formula $s'$
\end_inset

 satisfying the 
\begin_inset Formula $\exists s'$
\end_inset

 parts of equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

).
\end_layout

\begin_layout Standard
Using this new formulation, an agent's knowledge is completely decoupled
 from the global notion of actions, instead depending only on the local
 information that it has observed.
 It remains to specify precisely what the 
\noun on
Observations
\noun default
 sort contains, and how the 
\begin_inset Formula $Obs()$
\end_inset

 function behaves.
 This will be the focus of the next subsection.
\end_layout

\begin_layout Subsection
Axiomatising Observations
\end_layout

\begin_layout Standard
Let us begin by considering again the standard account of knowledge due
 to 
\begin_inset CommandInset citation
LatexCommand cite
key "scherl03sc_knowledge"

\end_inset

.
 Its basic assumption that 
\begin_inset Quotes eld
\end_inset

all agents are aware of all actions
\begin_inset Quotes erd
\end_inset

 may be rephrased as 
\begin_inset Quotes eld
\end_inset

when an action occurs, all agents will observe that action
\begin_inset Quotes erd
\end_inset

.
 Allowing the 
\noun on
Observations
\noun default
 sort to contain 
\noun on
Action
\noun default
 terms, this assumption is akin to the following axiom for the 
\begin_inset Formula $Obs()$
\end_inset

 function:
\begin_inset Formula \begin{equation}
a\in Obs(agt,c,s)\equiv a\in c\label{eq:ax_obs_std1}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
What about sensing information? We can extend the 
\noun on
Observations
\noun default
 sort to contain 
\begin_inset Formula $Action\#Result$
\end_inset

 pairs and axiomatise like so:
\begin_inset Formula \begin{equation}
a\#r\in Obs(agt,c,s)\equiv a\in c\wedge SR(a,s)=r\wedge actor(a)=agt\label{eq:ax_obs_std2}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Using these definitions, our new account of knowledge will behave identically
 to the standard account:
\end_layout

\begin_layout Theorem
Suppose 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) as definitions of the 
\begin_inset Formula $Obs()$
\end_inset

 function, then for any situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{std}\models K(agt,s',s)\,\,\,\,\mathrm{iff}\,\,\,\,\Dt\cup\Dt_{K}^{obs}\models K(agt,s',s)\]

\end_inset


\end_layout

\begin_layout Proof
Equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ax_obs_std1"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ax_obs_std2"

\end_inset

) mean 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

 cannot be empty for 
\begin_inset Formula $c\neq\{\}$
\end_inset

, so 
\begin_inset Formula $s=s'$
\end_inset

 iff 
\begin_inset Formula $s\leq_{\PbU(agt)}s'$
\end_inset

.
 Equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) then amount to simple transformations of equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:k_s0_standard"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:k_ssa_standard"

\end_inset

) respectively, meaning that 
\begin_inset Formula $K$
\end_inset

 behaves the same under both theories.
\end_layout

\begin_layout Standard
We now discuss one straightforward way to generalise this for partial observabil
ity of actions.
 A new action description predicate 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 is used to indicate that agent 
\begin_inset Formula $agt$
\end_inset

 would observe action 
\begin_inset Formula $a$
\end_inset

 being performed in situation 
\begin_inset Formula $s$
\end_inset

.
 If 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 is false, then that action will be hidden.
 We can then formulate the 
\begin_inset Formula $Obs()$
\end_inset

 function according to:
\begin_inset Formula \[
a\in Obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
There is also a subtle limitation in the standard handling of sensing actions:
 only the agent performing a sensing action can be aware of its result.
 Such a restriction is common but certainly not universal.
 For example, if an agent waiting for a train activates a speaker to determine
 when it will arrive, the result of this sensing action would provide informatio
n to any other agent within earshot.
 To generalise the formalism, an analogous predicate 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 is used to indicate when sensing information is available to an agent.
 We then include bare action terms in an agent's observations when it observes
 the action but not its result, and 
\emph on

\begin_inset Formula $Action\#Result$
\end_inset


\emph default
 terms when it also senses the result:
\begin_inset Formula \begin{gather*}
a\in Obs(agt,c,s)\equiv a\in c\wedge CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\\
a\#r\in Obs(agt,c,s)\equiv a\in c\wedge SR(a,s)=r\wedge CanObs(agt,a,s)\wedge CanSense(agt,a,s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We feel that this formulation provides a good balance between simplicity
 and expressiveness; it allows the observability of actions to vary according
 to the state of the world, but provides agents with a complete description
 of each action that they are capable of observing.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:An-Illustrative-Example"

\end_inset

 we show how to use this formalism to model a domain in which agents can
 only observe actions performed in the same room as them.
 To show the flexibility of the observation-based approach, Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Observing-Effects"

\end_inset

 outlines a more powerful axiomatisation of observations in which agents
 may know that some action has occurred without necessarily knowing precisely
 what the action was.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The final aspect of our new account of knowledge is to extend the techniques
 for effective reasoning in the situation calculus to handle the modified
 formalism.
 The appearance of 
\begin_inset Formula $\leq_{\PbU(agt)}$
\end_inset

 in equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) means that our new successor state axiom universally quantifies over situation
s, so standard regression techniques cannot be used.
 We must appeal to the persistence condition meta-operator introduced in
 Section  
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Property-Persistence"

\end_inset

 to transform this quantification into a uniform formula, so that regression
 can be applied.
\end_layout

\begin_layout Standard
We propose the following as the regression rule for 
\begin_inset Formula $\Knows$
\end_inset

 under our formalism:
\begin_inset Formula \begin{align}
\Reg(\Knows(agt,\phi,do(c,s))\isdef\,\, & \exists o:\, Obs(agt,c,s)=o\nonumber \\
 & \wedge\,\left[o=\{\}\,\rightarrow\,\Knows(agt,\phi,s)\right]\nonumber \\
 & \wedge\,\left[o\neq\{\}\,\rightarrow\,\Knows(agt,\forall c':\, Obs(agt,c')=o\right.\nonumber \\
 & \,\,\,\,\,\,\,\,\,\,\,\wedge Poss(c')\rightarrow\left.\Reg(\Pst(\phi,\PbU(agt)),c'),s)\right]\label{eqn:R_do_c_s}\end{align}

\end_inset

 
\end_layout

\begin_layout Standard
Note the similarity to the standard regression rule for knowledge in equation
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:reg_k_std"

\end_inset

.
 New in our version are: the replacement of the 
\begin_inset Formula $\mathbf{res}$
\end_inset

 macro with a flexible definition of what the agent has observed; explicit
 handling of the case when the agent makes no observations; and use of the
 persistence condition to account for arbitrarily-long sequences of hidden
 actions.
\end_layout

\begin_layout Standard
As required for a regression rule, equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 reduces a knowledge query at 
\begin_inset Formula $do(c,s)$
\end_inset

 to a knowledge query at 
\begin_inset Formula $s$
\end_inset

.
 It is also intuitively appealing: to know that 
\begin_inset Formula $\phi$
\end_inset

 holds, the agent must know that in all situations that agree with its observati
ons, 
\begin_inset Formula $\phi$
\end_inset

 cannot become false without it making an observation - this is the meaning
 of 
\begin_inset Formula $\Pst(\phi,\PbU(agt))$
\end_inset

 in the above.
\end_layout

\begin_layout Standard
We must also specify the regression of 
\begin_inset Formula $\Knows$
\end_inset

 in the initial situation, as equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) also uses the 
\begin_inset Formula $\leq_{\PbU(agt)}$
\end_inset

 ordering.
 This clause produces an expression in 
\begin_inset Formula $\KnowsZ$
\end_inset

 at 
\begin_inset Formula $S_{0}$
\end_inset

, meaning that it can be handled by epistemic reasoning about the initial
 situation only:
\begin_inset Formula \begin{equation}
\Reg(\Knows(agt,\phi,S_{0}))\,\isdef\,\KnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\label{eqn:R_s0}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Using these regression rules, we can handle knowledge queries in our formalism
 using standard techniques for effective reasoning in the situation calculus.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Reg_Knows"

\end_inset

Given a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 and a uniform formula 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\phi[do(c,s)]\equiv\Reg(\phi,c)[s]\]

\end_inset

 
\end_layout

\begin_layout ProofSketch
We need only consider the case of 
\begin_inset Formula $\phi=\Knows(agt,\phi,s)$
\end_inset

.
 In the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, we proceed by expanding the definition for 
\begin_inset Formula $\Knows$
\end_inset

 using our new successor state axiom for 
\begin_inset Formula $K$
\end_inset

, collecting sub-formulae that match the form of the 
\begin_inset Formula $\Knows$
\end_inset

 macro, and using regression and the persistence condition to render the
 resulting knowledge expressions uniform in 
\begin_inset Formula $s$
\end_inset

.
 In the base case, we apply the persistence condition to an expansion of
 
\begin_inset Formula $\Knows$
\end_inset

 at the initial situation to produce the desired result.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
While this reasoning method is suitable for modelling and simulation purposes,
 it would be unreasonable for a situated agent to ask 
\begin_inset Quotes eld
\end_inset

do I know 
\begin_inset Formula $\phi$
\end_inset

 in the current situation?
\begin_inset Quotes erd
\end_inset

 using the situation calculus query 
\begin_inset Formula $\Dt\models\mathbf{Knows}(agt,\phi,s)$
\end_inset

, as it cannot be expected to have the full current situation 
\begin_inset Formula $s$
\end_inset

.
 However, it will have its current view 
\begin_inset Formula $v$
\end_inset

.
 We define knowledge with respect to a view as follows:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,v)\,\isdef\,\forall s:\, View(agt,s)=v\wedge root(s)=S_{0}\rightarrow\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
It is a straightforward consequence of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 that this form of knowledge is equivalent to knowledge based on a situation
 term having that view and rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
 Modifying the regression rules in equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:R_do_c_s"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:R_s0"

\end_inset

) to handle formulae of this form is actually simpler than for regression
 over situations, as there are no empty observations in a view.
 The result is:
\end_layout

\begin_layout Standard
TODO: use a different macro for this
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{align*}
\Reg(\mathbf{Knows}(agt,\phi,o\cdot v))\isdef\,\, & \mathbf{Knows}(agt,\forall c:\, Obs(agt,c)=o\\
 & \,\,\,\,\,\,\,\,\wedge Poss(c)\rightarrow\Reg(\Pst(\phi,\PbU(agt)),c),v)\\
\Reg(\mathbf{Knows}(agt,\phi,\epsilon))\isdef\,\, & \KnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Using regression in this way, an agent can reduce the query 
\begin_inset Formula $\Knows(agt,\phi,v)$
\end_inset

 to an equivalent query about its knowledge in the initial situation.
 Agents can thus reason about their own knowledge using only their local
 information.
 Our work makes it possible to include a situation calculus model in the
 implementation of a real-world multi-agent system, even when agents have
 only partial awareness of the actions being performed.
\end_layout

\begin_layout Standard
It is worth re-iterating that our regression rules are no longer straightforward
 syntactic transformations - rather, they involve a fixpoint calculation
 to generate 
\begin_inset Formula $\Pst(\phi,\PbU(agt))$
\end_inset

.
 Can this really be considered an effective reasoning technique? Our previous
 work on the persistence condition meta-operator 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

 discusses the advantages of this approach in detail.
 The primary advantage is that this form of reasoning can be performed at
 all, as the alternative is general second-order theorem proving.
\end_layout

\begin_layout Standard
Of course, the ultimate proof is in the implementation.
 We have implemented a preliminary version of our technique and used it
 to verify the examples found in the following section.
 The code is available from the author's website
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Currently at http://www.csse.unimelb.edu.au/~rfk/pknows/
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
An Illustrative Example
\begin_inset CommandInset label
LatexCommand label
name "sub:An-Illustrative-Example"

\end_inset


\end_layout

\begin_layout Standard
TODO: mention which obs axioms
\end_layout

\begin_layout Standard
Consider again the example domain of the party invitation.
 The fluents of interest are the location of the party (the function 
\begin_inset Formula $loc$
\end_inset

) and whether each agent is in the room (the predicate 
\begin_inset Formula $InRoom$
\end_inset

).
 The action 
\begin_inset Formula $read$
\end_inset

 reads the invitation and returns the location of the party, while the non-sensi
ng actions 
\begin_inset Formula $enter$
\end_inset

 and 
\begin_inset Formula $leave$
\end_inset

 cause the agents to move in/out of the room.
 The 
\begin_inset Formula $read$
\end_inset

 action is only observed by agents who are in the room.
 This domain can be summarised by the following axioms:
\begin_inset Formula \begin{gather*}
loc(S_{0})=C\\
loc(do(c,s))=l\equiv loc(s)=l\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
InRoom(Ann,S_{0})\equiv InRoom(Bob,S_{0})\equiv true\\
InRoom(agt,do(c,s))\equiv enter(agt)\in c\,\vee\, InRoom(agt,s)\wedge leave(agt)\notin c\\
Poss(enter(agt),s)\equiv\neg InRoom(agt,s)\\
Poss(leave(agt),s)\equiv InRoom(agt,s)\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
Poss(read(agt),s)\equiv InRoom(agt,s)\\
SR(read(agt),s)=r\equiv r=loc(s)\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
\forall agt,l:\,\neg\KnowsZ(agt,loc=l,S_{0})\\
\forall agt_{1},agt_{2},l:\,\KnowsZ(agt_{1},\neg\KnowsZ(agt_{2},loc=l),S_{0})\\
\forall agt:\,\KnowsZ(agt,InRoom(Ann)\wedge InRoom(Bob),S_{0})\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
CanObs(agt,leave(agt'),s)\equiv CanObs(agt,enter(agt'),s)\equiv true\\
CanSense(agt,leave(agt'),s)\equiv CanSense(agt,enter(agt'),s)\equiv false\\
CanObs(agt,read(agt'),s)\equiv InRoom(agt',s)\\
CanSense(agt,read(agt'),s)\equiv agt=agt'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
The following are examples of knowledge queries that can be posed in our
 formalism, a brief explanation of their outcome, and a demonstration of
 how they can be answered using our new regression rules.
 Each has been verified by the preliminary implementation of our reasoning
 engine.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Example
Initially, Ann doesn't know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\neg\exists l:\,\mathbf{Knows}(Ann,loc=l,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
It is given that 
\begin_inset Formula $\neg\exists l:\,\KnowsZ(Ann,loc=l,S_{0})$
\end_inset

, and the only way for Ann to learn such information is by performing a
 
\begin_inset Formula $read$
\end_inset

 action.
 Since she would always observe such an action, she cannot have learnt the
 party's location as a result of hidden actions and the example is entailed.
 Formally:
\begin_inset Formula \begin{align*}
\Reg(\neg\exists l:\,\mathbf{Knows}(Ann,loc=l,S_{0}))\,\Rightarrow\,\,\,\, & \neg\exists l:\,\KnowsZ(Ann,\Pst(loc=l,PbU(Ann)),S_{0})\\
\Pst(loc=l,PbU(Ann))\,\Rightarrow\,\,\,\, & loc=l\end{align*}

\end_inset


\end_layout

\begin_layout Standard
So the query reduces to:
\begin_inset Formula \[
\neg\exists l:\,\KnowsZ(Ann,loc=l,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
which is entailed by the domain.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Example
After reading the invitation, Bob will know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\Knows(Bob,loc=C,do(\{read(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
The sensing results of the 
\begin_inset Formula $read$
\end_inset

 action inform Bob of the location of the party.
 Since this location cannot change after any sequence of hidden actions,
 he can be sure of the party's location.
 Formally, using the fact that 
\begin_inset Formula $Obs(Bob,\{read(Bob)\},s)=\{read(Bob)\#loc(s)\}$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Reg(\Knows(Bob,loc=C,do(\{read(Bob)\},S_{0})))\,\Rightarrow\\
\exists o:\, Obs(Bob,\{read(Bob)\},S_{0})=o\,\wedge\,\\
\Knows(Bob,\forall c':\, Poss(c')\wedge Obs(Bob,c')=o\rightarrow\Reg(\Pst(loc=C,PbU(Bob)),c'),S_{0})\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\Reg(\Pst(loc=C,PbU(Bob)),c')\Rightarrow loc=c$
\end_inset

 and 
\begin_inset Formula $loc(S_{0})=C$
\end_inset

, this simplifies to:
\begin_inset Formula \[
\Knows(Bob,\forall c':\, Poss(c')\wedge Obs(Bob,c')=\{read(Bob)\#C\}\rightarrow loc=C,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Since the only possible value of 
\begin_inset Formula $c'$
\end_inset

 that satisfies the antecedent is 
\begin_inset Formula $\{read(Bob)\}$
\end_inset

, we can insert the definitions of 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Obs$
\end_inset

 to obtain:
\begin_inset Formula \[
\Knows(Bob,InRoom(Bob)\wedge loc=C\,\rightarrow\, loc=C,S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
This tautology is clearly entailed by the domain.
\begin_inset Newline newline
\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Example
Initially, Bob knows that Ann doesn't know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\mathbf{Knows}(Bob,\neg\exists l:\,\Knows(Ann,loc=l),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Ann could learn the location of the party by performing the 
\begin_inset Formula $read$
\end_inset

 action, but since Bob is in the room he would observe this action taking
 place.
 Since he has not observed it, he can conclude that Ann does not know the
 location of the party.
 Formally:
\begin_inset Formula \begin{multline*}
\Reg(\mathbf{Knows}(Bob,\neg\exists l:\,\Knows(Ann,loc=l),S_{0}))\,\Rightarrow\\
\KnowsZ(Bob,\Pst(\neg\exists l:\,\Knows(Ann,loc=l),PbU(Bob)),S_{0})\end{multline*}

\end_inset


\begin_inset Formula \begin{multline*}
\Pst(\neg\exists l:\,\Knows(Ann,loc=l),PbU(Bob))\,\Rightarrow\\
\neg\exists l:\,\Knows(Ann,loc=l)\wedge\left(InRoom(Bob)\,\vee\,\neg InRoom(Ann)\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
So the query reduces to:
\begin_inset Formula \[
\KnowsZ(Bob,\neg\exists l:\,\Knows(Ann,loc=l)\wedge\left(InRoom(Bob)\,\vee\,\neg InRoom(Ann)\right),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
which is entailed by the domain.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Example
After leaving, Bob won't know that Ann doesn't know where the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\mathbf{\neg Knows}(Bob,\neg\exists l:\,\Knows(Ann,loc=l),do(\{leave(Bob)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
Once Bob leaves the room, he would be unable to observe Ann reading the
 invitation.
 He must therefore consider it possible that she has read it, and may know
 the location of the party.
 Formally, we can use 
\begin_inset Formula $Obs(Bob,\{leave(Bob)\})=\{leave(Bob)\}$
\end_inset

 to regress the outer expression as follows:
\begin_inset Formula \begin{multline*}
\Reg(\neg\Knows(Bob,\phi,do(\{leave(Bob)\},S_{0})))\,\Rightarrow\\
\neg\Knows(Bob,InRoom(Bob)\rightarrow\Reg(\Pst(\phi,PbU(Bob)),\{leave(Bob)\}),S_{0})\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
For the inner expression, we have from the previous example:
\begin_inset Formula \begin{multline*}
\Pst(\neg\exists l:\,\Knows(Ann,loc=l),PbU(Bob))\,\Rightarrow\\
\neg\exists l:\,\Knows(Ann,loc=l)\wedge\left(InRoom(Bob)\,\vee\,\neg InRoom(Ann)\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
This expression is key: for Bob to know
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\begin_inset Formula $\neg\exists l:\Knows(Ann,loc=l)$
\end_inset

,
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
 he must also know either that he is in the room (and will thus observe
 the 
\begin_inset Formula $read(Ann)$
\end_inset

 action if it occurs) or that Ann is not in the room (so the 
\begin_inset Formula $read(Ann)$
\end_inset

 action will not be possible).
 Otherwise, Ann could learn the location of the party without him making
 any further observations.
\end_layout

\begin_layout Standard
When we regress over the action 
\begin_inset Formula $\{leave(Bob)\}$
\end_inset

 then 
\begin_inset Formula $InRoom(Bob)$
\end_inset

 is made false:
\begin_inset Formula \begin{multline*}
\Reg(\Pst(\neg\exists l:\,\Knows(Ann,loc=l),PbU(Bob)),\{leave(Bob)\})\,\Rightarrow\\
\neg\exists l:\,\Knows(Ann,loc=l)\wedge\left(false\,\vee\,\neg InRoom(Ann)\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
And the entire expression can be simplified to:
\begin_inset Formula \[
\neg\Knows(Bob,InRoom(Bob)\rightarrow\neg\exists l:\,\Knows(Ann,loc=l)\wedge\neg InRoom(Ann),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Since Ann is known to be in the room, this expression will be entailed by
 the domain.
\end_layout

\begin_layout Subsection
Approximate Epistemic Reasoning
\end_layout

\begin_layout Standard
From the examples in the previous section, it is clear that agents may need
 to perform significant amounts of reasoning to answer knowledge queries
 about arbitrary formulae.
 This is on top of the already significant task of performing possible-worlds
 reasoning in the initial situation 
\begin_inset CommandInset citation
LatexCommand citep
key "Petrick06thesis"

\end_inset

.
 An interesting approach to making reasoning about knowledge more tractable
 is the formalism of 
\begin_inset CommandInset citation
LatexCommand citet
key "demolombe00tractable_sc_belief"

\end_inset

, in which knowledge is limited to be about fluent literals only.
\end_layout

\begin_layout Standard
The basic idea is to introduce, for each fluent 
\begin_inset Formula $F$
\end_inset

 in the domain, two additional fluents 
\begin_inset Formula $K_{agt}^{+}F$
\end_inset

 and 
\begin_inset Formula $K_{agt}^{-}F$
\end_inset

 to explicitly represent 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $agt$
\end_inset

 knows 
\begin_inset Formula $F$
\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $agt$
\end_inset

 knows 
\begin_inset Formula $\neg F$
\end_inset


\begin_inset Quotes erd
\end_inset

 respectively.
 By formulating ordinary successor state axioms for these fluents, literal-level
 knowledge can be reasoned about using standard regression and does not
 require an explicit possible-worlds 
\begin_inset Formula $K$
\end_inset

-relation.
 However, this approach cannot represent indeterminate disjunctive knowledge
 such as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $agt$
\end_inset

 knows 
\begin_inset Formula $F$
\end_inset

 or 
\begin_inset Formula $G$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset CommandInset citation
LatexCommand citeauthor
key "demolombe00tractable_sc_belief"

\end_inset

 approach has been formally related to the standard 
\begin_inset CommandInset citation
LatexCommand citeauthor
key "scherl03sc_knowledge"

\end_inset

 approach by 
\begin_inset CommandInset citation
LatexCommand citet
key "petrick02knowledge_equivalence"

\end_inset

.
 They show there is an equivalence between the two approaches when an agent's
 knowledge is restricted to be 
\emph on
disjunctive
\emph default
, so that the following holds:
\begin_inset Formula \[
\Knows(agt,\phi_{1}\vee\phi_{2},s)\rightarrow\Knows(agt,\phi_{1},s)\vee\Knows(agt,\phi_{2,}s)\]

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand citep
key "Petrick06thesis"

\end_inset

 this equivalence is extended to cover existential quantification by restricting
 knowledge to also satisfy the following:
\begin_inset Formula \[
\Knows(agt,\exists x:\,\phi(x),s)\rightarrow\exists x:\,\Knows(agt,\phi(x),s)\]

\end_inset

 These disjunctive properties of knowledge are 
\emph on
not
\emph default
 entailed by a general possible-worlds style theory in the tradition of
 
\begin_inset CommandInset citation
LatexCommand citep
key "scherl03sc_knowledge"

\end_inset

, although there are restrictions that can be placed on the theory in order
 to enforce them 
\begin_inset CommandInset citation
LatexCommand citep
key "petrick08cartesian_situations,Petrick06thesis"

\end_inset

.
\end_layout

\begin_layout Standard
While we do not consider maintenance of these disjunctive knowledge properties
 in any detail, we do note that they also permit a sound 
\emph on
approximation
\emph default
 of knowledge that can be reasoned about more tractably than the standard
 possible-worlds account.
 Following the style of 
\begin_inset CommandInset citation
LatexCommand citep
key "petrick02knowledge_equivalence"

\end_inset

 we could provide the following definitions:
\begin_inset Formula \begin{gather*}
\Knows_{A}(agt,\phi_{1}\wedge\phi_{2},s)\isdef\Knows_{A}(agt,\phi_{1},s)\wedge\Knows_{A}(agt,\phi_{2},s)\\
\Knows_{A}(agt,\neg(\phi_{1}\wedge\phi_{2}),s)\isdef\Knows_{A}(agt,\neg\phi_{1},s)\vee\Knows_{A}(agt,\neg\phi_{2},s)\\
\Knows_{A}(agt,\forall x:\,\phi(x),s)\isdef\forall x:\,\Knows_{A}(agt,\phi(x),s)\\
\Knows_{A}(agt,\neg\forall x:\,\phi(x),s)\isdef\exists x:\,\Knows_{A}(agt,\neg\phi(x),s)\\
\Knows_{A}(agt,\neg\neg\phi,s)\isdef\Knows_{A}(agt,\phi,s)\\
\Knows_{A}(agt,F,s)\isdef\Knows(agt,F,s)\\
\Knows_{A}(agt,\neg F,s)\isdef\Knows(agt,\neg F,s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
A knowledge query is split across the logical operators until we are left
 with only knowledge of fluent literals, which is then handled using the
 formalism presented in this chapter.
 If we assume a finite number of fluents, then we can use our regression
 rule for knowledge to 
\emph on
pre-calculate
\emph default
 an explicit successor state axiom for 
\begin_inset Formula $\Knows_{A}(agt,F,s)$
\end_inset

 and 
\begin_inset Formula $\Knows_{A}(agt,\neg F,s)$
\end_inset

, allowing them to be treated as primitive fluents and reasoned about at
 run-time using purely syntactic transformations.
\end_layout

\begin_layout Standard
Unlike the approach of 
\begin_inset CommandInset citation
LatexCommand citep
key "demolombe00tractable_sc_belief"

\end_inset

 in which the knowledge literal fluents must be axiomatised separately from
 the actual fluents they describe, the approach suggested here would allow
 a successor state axiom for literal-level knowledge to be derived from
 the dynamics of the domain.
 All persistence condition calculations could be performed once, offline,
 and then used directly for approximate reasoning about the knowledge of
 an agent.
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
TODO: copy more out of thesis discussion
\end_layout

\begin_layout Standard
In this section, we have first developed a principled axiomatisation of
 the observability of actions, using the notion of observations and views
 as analogues of actions and situations that are localised to an individual
 agent.
 This terminology has been deliberately chosen to match similar concepts
 in other formalisations of knowledge, such as the well-known treatise of
 
\begin_inset CommandInset citation
LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

.
 By reifying these concepts as terms in the logic, we are able to give a
 succinct definition of the dynamics of the knowledge fluent and prove that
 its behaviour matches our intuitive expectations.
\end_layout

\begin_layout Standard
As an example of why this is important, consider one of the few existing
 formulations of knowledge in the situation calculus that allows for hidden
 actions, that of 
\begin_inset CommandInset citation
LatexCommand cite
key "Lesperance99sitcalc_approach"

\end_inset

.
 Their successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent is as follows:
\begin_inset Formula \begin{align*}
K(agt,s'',do(a,s))\equiv\,\,\, & \exists s':\, K(agt,s',s)\\
 & \wedge\,(actor(a)\neq agt\,\rightarrow\, s'\leq_{actor(a)\neq agt}s''))\\
 & \wedge\,(actor(a)=agt\,\rightarrow\,\exists s^{*}:\,\left[s'\leq_{actor(a)\neq agt}s^{*}\wedge\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\left.s''=do(a,s^{*})\wedge Poss(a,s^{*})\wedge sr(a,s)=sr(a,s^{*}))\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Standard
In this case agents are only aware of the actions that they themselves perform,
 and they consider possible an arbitrary sequence of hidden actions preceding
 each action of their own.
 However, this formulation has a subtle problem: an agent's knowledge can
 change in response to actions performed by others.
 Suppose that 
\begin_inset Formula $agt$
\end_inset

 has just performed action 
\begin_inset Formula $a_{1}$
\end_inset

, so the world is in situation 
\begin_inset Formula $do(a_{1},s)$
\end_inset

.
 Another agent then performs the action 
\begin_inset Formula $a_{2}$
\end_inset

, leaving the world in situation 
\begin_inset Formula $do(a_{2},do(a_{1},s))$
\end_inset

.
 Since it is not aware of the occurrence of 
\begin_inset Formula $a_{2}$
\end_inset

, the knowledge of 
\begin_inset Formula $agt$
\end_inset

 should be unchanged between these two situations.
 This is not the case under the formulation of 
\begin_inset CommandInset citation
LatexCommand citeauthor
key "Lesperance99sitcalc_approach"

\end_inset

.
 By explicitly formalising the notion of a view, our framework avoids such
 problems.
\end_layout

\begin_layout Standard
TODO: aware of the passage of time?
\end_layout

\begin_layout Standard
A further advantage of our explicit axiomatisation of observations is in
 establishing properties of the knowledge relation.
 A major theorem of 
\begin_inset CommandInset citation
LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 states that if the 
\begin_inset Formula $K$
\end_inset

-relation is reflexive, symmetric or transitive at the initial situation,
 then it has that property at every situation.
 In our formulation these are all simple corollaries of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

, based on the reflexive, symmetric and transitive nature of the equality
 symbol.
\end_layout

\begin_layout Standard
We have demonstrated that our formalism is expressive enough to capture
 the standard account of knowledge based on public actions, as well as more
 complex formulations where the observability of actions depends on the
 state of the world.
 We have also demonstrated that despite allowing for arbitrarily-long sequences
 of hidden actions, our formalism still permits automated reasoning for
 handling knowledge queries, including a preliminary implementation of such
 a reasoning system.
\end_layout

\begin_layout Standard
Of course, the effectiveness of automated reasoning is now highly dependent
 on the effectiveness of calculating the persistence condition.
 Since this is a fixpoint calculation, it can be computationally expensive
 and even undecidable in very complex domains.
 By factoring out the necessary inductive reasoning into a separate operator,
 it can now be studied and improved in isolation.
 We have already identified several classes of basic action theory in which
 the persistence condition can be calculated quite effectively, and our
 investigations in this area are ongoing; see 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

 for details.
\end_layout

\begin_layout Standard
Finally, we have shown that a simple modification to our regression rules
 allows a situated agent to reason about its own knowledge using only its
 local view, rather than requiring a full situation term.
 Our new observation-based semantics thus provides a powerful account of
 knowledge suitable both for reasoning 
\emph on
about
\emph default
, and for reasoning 
\emph on
in
\emph default
, asynchronous multi-agent domains.
\end_layout

\begin_layout Section
Complex Epistemic Modalities
\begin_inset CommandInset label
LatexCommand label
name "sec:Complex-Epistemic-Modalities"

\end_inset


\end_layout

\begin_layout Standard
So far we have constructed a powerful new account of 
\emph on
individual 
\emph default
knowledge in rich multi-agent domains.
 To be truly useful in a multi-agent setting, our formalism must also support
 reasoning about group-level knowledge and, in particular, about common
 knowledge.
 The primary motivation for this section is a formal treatment of common
 knowledge within our framework, but as we shall see, this requires significant
 technical machinery capable of handling much more general epistemic modalities.
\end_layout

\begin_layout Subsection
Extra
\end_layout

\begin_layout Standard
Following the tradition of 
\begin_inset CommandInset citation
LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

 we develop our formalism as a series of macro-expansions, with no changes
 to the underlying situation calculus theory.
 The language of first-order dynamic logic is used to construct complex
 epistemic paths, with the macro 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 expressing knowledge using such a path.
 Since common knowledge is defined as the transitive closure of the union
 of the agents' base knowledge modalities, it can be expressed in this syntax
 as 
\begin_inset Formula $\PKnows((A_{1}\cup A_{2})^{*},\phi,s)$
\end_inset

.
 Regression is then modified to treat 
\begin_inset Formula $\PKnows(\pi,\phi,do(c,s))$
\end_inset

 as a primitive fluent, producing an equivalent formula 
\begin_inset Formula $\PKnows(\Trn(\pi),\Reg(\phi),s)$
\end_inset

 where 
\begin_inset Formula $\Trn$
\end_inset

 is a new operator called the epistemic path regressor.
 
\end_layout

\begin_layout Standard
While this section naturally parallels the development of LCC, there are
 also substantial differences.
 LCC is built on modal logic and so handles only propositional, synchronous
 domains.
 The richer ontology of the situation calculus means our formalism must
 support first-order preconditions and effects, quantifying-in and de-dicto/de-r
e, and arbitrary sets of concurrent actions.
 It must also incorporate our new technique for handling hidden actions
 while remaining compatible with other extensions to the situation calculus.
 The macro-expansion approach, coupled with our rigorous observation-based
 semantics, allow our formalism to neatly fulfil all these requirements.
\end_layout

\begin_layout Subsection
Group-Level Epistemic Modalities
\end_layout

\begin_layout Standard
We briefly review the various group-level epistemic modalities commonly
 found in the literature; an excellent overview and discussion can be found
 in the work of 
\begin_inset CommandInset citation
LatexCommand citet
key "halpern90knowledge_distrib"

\end_inset

.
 Let 
\begin_inset Formula $G$
\end_inset

 be a finite group of agents.
 The basic group-level modality is 
\begin_inset Quotes eld
\end_inset

everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

, which is defined as:
\begin_inset Formula \[
\EKnows(G,\phi,s)\isdef\,\forall agt\in G:\,\Knows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $G$
\end_inset

 is a finite set, this can be written equivalently as a finite conjunction:
\begin_inset Formula \[
\mathbf{EKnows}(G,\phi,s)\,\isdef\,\bigwedge_{agt\in G}\,\mathbf{Knows}(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
To assert more complete knowledge by members of the group, one can say 
\begin_inset Quotes eld
\end_inset

everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

 by nesting 
\begin_inset Formula $\mathbf{EKnows}$
\end_inset

 operators.
 In general:
\begin_inset Formula \begin{gather*}
\mathbf{EKnows}^{1}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\phi,s)\\
\mathbf{EKnows}^{n}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\mathbf{EKnows}^{n-1}(G,\phi),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The higher the value of 
\begin_inset Formula $n$
\end_inset

, the stronger an assertion is made about the knowledge of the group.
 The strongest group-level modality is 
\begin_inset Quotes eld
\end_inset

it is common knowledge that 
\begin_inset Formula $\phi$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Intuitively this indicates that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, everyone knows that everyone knows 
\begin_inset Formula $\phi$
\end_inset

, and so on ad infinitum.
 Formally, it can be defined as the infinite conjunction:
\begin_inset Formula \[
\mathbf{CKnows}(G,\phi,s)\,\isdef\,\bigwedge_{n\in\mathbb{N}}\mathbf{EKnows}^{n}(G,\phi,s)\]

\end_inset


\end_layout

\begin_layout Standard
Equivalently, common knowledge can be defined as a fixpoint or transitive
 closure of the 
\begin_inset Formula $\EKnows$
\end_inset

 relation.
 Common knowledge is an extremely powerful form of knowledge that has deep
 implications for coordinated group behaviour.
 For example, in the famous 
\begin_inset Quotes eld
\end_inset

Coordinated Attack
\begin_inset Quotes erd
\end_inset

 problem, the proof that the generals cannot coordinate an attack depends
 heavily on their inability to obtain common knowledge 
\begin_inset CommandInset citation
LatexCommand citep
key "halpern90knowledge_distrib"

\end_inset

.
\end_layout

\begin_layout Subsection
Reasoning about Common Knowledge
\end_layout

\begin_layout Standard
Existing treatments of common knowledge in the situation calculus and related
 literature specify it as the transitive closure of 
\begin_inset Formula $\EKnows$
\end_inset

 using an explicit second-order axiom 
\begin_inset CommandInset citation
LatexCommand citep
key "davis05fo_ma_theory,ghaderi07sc_joint_ability"

\end_inset

.
 While logically sound, this approach forgoes the use of regression as an
 effective reasoning technique.
 Indeed, reasoning in such formalisms requires a second-order theorem prover.
\end_layout

\begin_layout Standard
This difficulty in effectively handling common knowledge can be attributed
 to a famous expressivity result from the related field of dynamic epistemic
 logic:
\end_layout

\begin_layout Quote
Epistemic logic with actions and common knowledge is more expressive than
 epistemic logic with common knowledge alone 
\begin_inset CommandInset citation
LatexCommand citep
key "baltag98pa_ck"

\end_inset


\end_layout

\begin_layout Standard
In our terminology: given a formula 
\begin_inset Formula $\CKnows(G,\phi,do(c,s))$
\end_inset

, it is impossible in general to find an equivalent formula 
\begin_inset Formula $\CKnows(G,\psi,s)$
\end_inset

.
 It is thus impossible to formulate a regression rule for common knowledge
 using only the 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\CKnows$
\end_inset

 operators.
\end_layout

\begin_layout Standard
TODO rough, reword.
 Given the deep similarities between the situation calculus and dynamic
 epistemic logic 
\begin_inset CommandInset citation
LatexCommand citep
key "vanbentham07ml_sitcalc"

\end_inset

, we can be confident that this expressivity limitation also holds in the
 situation calculus.
 To see why, consider again the successor state axiom for the 
\begin_inset Formula $K$
\end_inset

 fluent, which has the simplified general form:
\begin_inset Formula \[
K(do(c',s'),do(c,s))\,\equiv\, K(s',s)\wedge\Phi_{K}(c',s',s)\]

\end_inset


\end_layout

\begin_layout Standard
We could construct an analogous fluent 
\begin_inset Formula $E$
\end_inset

 that captures the 
\begin_inset Formula $\EKnows$
\end_inset

 relation, with a successor state axiom of the general form:
\begin_inset Formula \[
E(do(c',s'),do(c,s))\,\equiv\, E(s',s)\wedge\Phi_{E}(c',s',s)\]

\end_inset


\end_layout

\begin_layout Standard
Now consider constructing such a fluent for the 
\begin_inset Formula $\EKnows^{2}$
\end_inset

 relation.
 The general form for its successor state axiom would be:
\begin_inset Formula \begin{align*}
E^{2}(do(c',s'),do(c,s)) & \equiv\exists c'',s'':\, E(do(c'',s''),do(c,s))\wedge E(do(c',s'),do(c'',s''))\\
 & \Rightarrow\exists c'',s'':\, E(s'',s)\wedge E(s',s'')\wedge\Phi_{E}(c',s')\wedge\Phi_{E}(c'',s'')\\
 & \Rightarrow\exists c'',s'':\, E^{2}(s',s)\wedge\Phi_{E}(c',s')\wedge\Phi_{E}(c'',s'')\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This successor state axiom must make assertions not only about 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, but also about the hypothesised intermediate situation 
\begin_inset Formula $s''$
\end_inset

.
 Extending this reasoning, a successor state axiom for common knowledge
 would be required make assertions not only about 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, but all of the intermediate situations in the transitive closure.
 However, the macro 
\begin_inset Formula $\CKnows$
\end_inset

 can only make assertions about the final situation reached in the transitive
 closure, not about the path leading to it.
 It is thus not expressive enough to formulate a proper regression rule.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
To overcome this expressiveness limitation, we follow the recent promising
 work of 
\begin_inset CommandInset citation
LatexCommand cite
key "vanBenthem06lcc"

\end_inset

, who use two important new ideas to produce a regression rule for common
 knowledge in their logic LCC:
\end_layout

\begin_layout Itemize
Form more expressive epistemic modalities using the syntax of dynamic logic,
 interpreted over the epistemic frame of the agents.
\end_layout

\begin_layout Itemize
Apply regression within the modality as well as to the enclosed formula.
\end_layout

\begin_layout Standard
We apply these ideas to perform epistemic reasoning in the situation calculus,
 allowing common knowledge to be handled using regression.
 While the development naturally parallels that of LCC, the much richer
 ontology of the situation calculus means there are also substantial differences.
 In particular:
\end_layout

\begin_layout Itemize
LCC is 
\emph on
propositional
\emph default
: actions do not take arguments, there are finitely many actions, and no
 quantification is required.
\end_layout

\begin_layout Itemize
LCC is 
\emph on
synchronous
\emph default
:
\emph on
 
\emph default
reasoning is performed by regressing one action at a time, without the 
\begin_inset Quotes eld
\end_inset

all possible futures
\begin_inset Quotes erd
\end_inset

 approach needed to handle hidden actions.
\end_layout

\begin_layout Standard
By contrast, our formalism must capture first-order preconditions and effects,
 quantifying-in and de-dicto/de-re, and arbitrary sets of concurrent actions,
 while incorporating our new technique for handling hidden actions and remaining
 compatible with other extensions to the situation calculus.
\end_layout

\begin_layout Standard
The remainder of this section proceeds as follows.
 TODO: mention section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Syncrhonous-Knowledge"

\end_inset

.
\end_layout

\begin_layout Standard
In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Epistemic-Paths"

\end_inset

 we define a variant of first-order dynamic logic for use as an epistemic
 path language, which is encoded in the situation calculus using the macro
 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

.
 This macro is analogous to the fluent 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 from the previous section, but expresses more complex epistemic relationships
 between situations.
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Synchronous-Epistemic-Fluent"

\end_inset

 develops a 
\emph on
synchronous
\emph default
 account of complex epistemic modalities.
 The macro 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 expresses knowledge using an epistemic path 
\begin_inset Formula $\pi$
\end_inset

 under the assumption that there have been no hidden actions.
 We develop a regression rule using a new operator 
\begin_inset Formula $\Trn$
\end_inset

 to perform regression inside the epistemic path, transforming 
\begin_inset Formula $\PKnowsZ(\pi,\phi,do(c,s))$
\end_inset

 into an equivalent expression 
\begin_inset Formula $\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)$
\end_inset

.
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Introducing-Hidden-Actions"

\end_inset

 introduces hidden actions by explicitly representing them with an empty
 action set.
 We simulate agents reasoning about arbitrarily-long sequences of hidden
 actions by inserting arbitrarily many empty action terms between each real
 action in a situation, and show how a fixpoint construction can reason
 about such modified situations.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:The-Link-with-IK"

\end_inset

 then relates this fixpoint construction back to the results of Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

 by showing that in the case of a single agent, it precisely matches the
 fixpoint generated by the persistence condition operator in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

.
 
\end_layout

\begin_layout Standard
The end result is a powerful account of complex epistemic modalities constructed
 almost entirely in the meta-level reasoning machinery of the situation
 calculus.
 We need only a single new successor state axiom, given below.
\end_layout

\begin_layout Subsection
Synchronous Knowledge
\begin_inset CommandInset label
LatexCommand label
name "sub:Syncrhonous-Knowledge"

\end_inset


\end_layout

\begin_layout Standard
To begin, we must define the 
\emph on
synchronous 
\emph default
knowledge of an individual agent in an arbitrary situation 
\begin_inset Formula $s$
\end_inset

.
 This is the agent's knowledge when it assumes that no hidden actions have
 occurred, and so it is not required to do any 
\begin_inset Quotes eld
\end_inset

all possible futures
\begin_inset Quotes erd
\end_inset

 style reasoning.
 We extend the fluent 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 which is already used to represent synchronous knowledge in the initial
 situation.
 The axiom set 
\begin_inset Formula $\Dt_{K}^{obs}$
\end_inset

 gains the following successor state axiom for 
\begin_inset Formula $K_{0}$
\end_inset

:
\begin_inset Formula \begin{align}
K_{0}(agt,s'',do(c,s))\,\equiv\,\, & \exists s',c':\,\left(s''=do(c',s')\wedge Poss(c',s')\,\,\vee\,\, s''=s'\wedge c'=\{\}\right)\nonumber \\
 & \,\,\,\,\,\wedge Obs(agt,c,s)=Obs(agt,c',s')\wedge K_{0}(agt,s',s)\label{eq:K0_ssa}\end{align}

\end_inset


\end_layout

\begin_layout Standard
Given synchronicity, this axiom is a simple modification of the standard
 successor state axiom for knowledge from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:k_ssa_standard"

\end_inset

.
 The only complication is in handling the empty action 
\begin_inset Formula $\{\}$
\end_inset

.
 When 
\series bold

\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset


\series default
 then 
\begin_inset Formula $c'$
\end_inset

 is allowed to be 
\begin_inset Formula $\{\}$
\end_inset

, and the agent considers it possible that no actions were actually performed
 (i.e.
 
\begin_inset Formula $s''=s'$
\end_inset

).
 Thus the number of actions in 
\begin_inset Formula $s$
\end_inset

 puts an upper bound on the number of actions that the agent thinks might
 have occurred.
 
\end_layout

\begin_layout Standard
Beginning with the assumption of synchronicity allows us to focus first
 on increasing the expressiveness of the epistemic language.
 Once this have been achieved, we will generalise the formalism to asynchronous
 domains.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Epistemic Paths
\begin_inset CommandInset label
LatexCommand label
name "sub:Epistemic-Paths"

\end_inset


\end_layout

\begin_layout Standard
In this section, we adopt the language of dynamic logic to express complex
 epistemic modalities.
 To deal gracefully with the many first-order aspects of the situation calculus
 we use a variant of 
\emph on
first-order dynamic logic,
\emph default
 adapted from the dynamic term-modal logic of 
\begin_inset CommandInset citation
LatexCommand citet
key "kooi07dyn_termmodal_logic"

\end_inset

 but with some simplifications.
\end_layout

\begin_layout Standard
First, we must specify the syntax of our epistemic path language.
 We will use 
\begin_inset Formula $\pi$
\end_inset

 to denote an arbitrary epistemic path expression.
 
\end_layout

\begin_layout DefinitionLbld
Epistemic
\begin_inset space ~
\end_inset

Path Let 
\begin_inset Formula $agt$
\end_inset

 be an 
\noun on
Agent 
\noun default
term, 
\begin_inset Formula $\phi$
\end_inset

 a situation-suppressed uniform formula and 
\begin_inset Formula $x$
\end_inset

 a variable name, then the epistemic path terms 
\begin_inset Formula $\pi$
\end_inset

 are the smallest set matching the following structural rules:
\begin_inset Formula \[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
The test (
\begin_inset Formula $?$
\end_inset

), sequence (
\begin_inset Formula $;$
\end_inset

), choice (
\begin_inset Formula $\cup$
\end_inset

) and transitive closure (
\begin_inset Formula $^{*}$
\end_inset

) operators are standard in dynamic logic, although test formulae may now
 contain variables that must be interpreted.
 The operator 
\begin_inset Formula $\exists x$
\end_inset

 allows the value of a variable to change during path traversal, by non-determin
istically re-binding 
\begin_inset Formula $x$
\end_inset

 to some value.
\end_layout

\begin_layout Standard
The semantics of this epistemic path language are defined at the meta-level
 as a series of macro expansions.
 The full details of this development can be found in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Encoding-Dynamic-Logic"

\end_inset

, and would complicate the presentation here.
 Instead we give a simplified presentation that treats variable bindings
 as concrete terms in the logic.
 Formulae of first-order dynamic logic are interpreted relative to both
 a 
\begin_inset Quotes eld
\end_inset

current world
\begin_inset Quotes erd
\end_inset

 and a 
\begin_inset Quotes eld
\end_inset

current variable binding
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "kooi07dyn_termmodal_logic"

\end_inset

.
 Variable bindings are represented below by a first-order substitution 
\begin_inset Formula $\mu$
\end_inset

, with 
\begin_inset Formula $\mu(\phi)$
\end_inset

 applying the substitution to the variables in 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\mu[x/z]$
\end_inset

 setting the value of variable 
\begin_inset Formula $x$
\end_inset

 to the term 
\begin_inset Formula $z$
\end_inset

.
 The semantics operate over pairs 
\begin_inset Formula $(\mu,s)$
\end_inset

.
\end_layout

\begin_layout DefinitionLbld
Epistemic
\begin_inset space ~
\end_inset

Path
\begin_inset space ~
\end_inset

Semantics 
\begin_inset CommandInset label
LatexCommand label
name "def:KDo"

\end_inset

A situation 
\begin_inset Formula $s'$
\end_inset

 is reachable from situation 
\begin_inset Formula $s$
\end_inset

 via epistemic path 
\begin_inset Formula $\pi$
\end_inset

, denoted 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

, according to the following definitions.
 These semantics are encoded using macro expansion as detailed in Appendix
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Encoding-Dynamic-Logic"

\end_inset

.
\begin_inset Formula \[
\KDo(\pi,s,s')\,\,\equiv\,\,\exists\mu,\mu':\,\KTrans(\pi,\mu,s,\mu',s')\]

\end_inset


\begin_inset Formula \begin{gather*}
\KTrans(agt,\mu,s,\mu',s')\,\equiv\,\mu'=\mu\,\wedge\, K_{0}(agt,s',s)\\
\KTrans(?\phi,\mu,s,\mu',s')\,\equiv\, s'=s\,\wedge\,\mu'=\mu\,\wedge\,\mu(\phi)[s]\\
\KTrans(\pi_{1};\pi_{2},\mu,s,\mu',s')\,\equiv\,\exists\mu'',s'':\,\KTrans(\pi_{1},\mu,s,\mu'',s'')\,\wedge\,\KTrans(\pi_{2},\mu'',s'',\mu',s')\\
\KTrans(\pi_{1}\cup\pi_{2},\mu,s,\mu',s')\,\equiv\,\KTrans(\pi_{1},\mu,s,\mu',s')\,\vee\,\KTrans(\pi_{2},\mu,s,\mu',s')\\
\KTrans(\exists x,\mu,s,\mu',s')\,\equiv\,\exists z:\, s'=s\,\wedge\,\mu'=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu,s,\mu',s')\rightarrow\KTrans(\pi^{*},\mu,s,\mu',s')\right]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Where we use the following abbreviations (standing for 
\begin_inset Quotes eld
\end_inset

reflexive
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

transitive
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

contains
\begin_inset Quotes erd
\end_inset

 respectively) to specify that 
\begin_inset Formula $\pi^{*}$
\end_inset

 is the reflexive transitive closure of 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{align*}
\mathbf{refl}\isdef & \,\, P(\mu,s,\mu,s)\\
\mathbf{tran\isdef} & \,\,\forall\mu_{1},s_{1},\mu_{2},s_{2}:\, P(\mu_{1},s_{1},\mu,s)\wedge\KTrans(\pi,\mu_{2},s_{2},\mu_{1},s_{1})\,\rightarrow\, P(\mu_{2},s_{2},\mu,s)\\
\mathbf{cont}\isdef & \,\,\forall\mu',s':\,\KTrans(\pi,\mu',s',\mu,s)\,\rightarrow\, P(\mu',s',\mu,s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Let us re-iterate: these are 
\emph on
not
\emph default
 axioms to be included in our basic action theory, but are intended only
 to demonstrate the semantics of the epistemic path language and the macro
 
\begin_inset Formula $\KDo$
\end_inset

.
 Paths do not appear in situation calculus terms, but are handled by macro-expan
sion of 
\begin_inset Formula $\KDo(\pi,s,s')$
\end_inset

 into second-order sentences of the situation calculus.
\end_layout

\begin_layout Subsection
A Synchronous Epistemic Fluent
\begin_inset CommandInset label
LatexCommand label
name "sub:Synchronous-Epistemic-Fluent"

\end_inset


\end_layout

\begin_layout Standard
At this point it's worth reviewing again the purpose of this path language.
 Despite utilising the syntax of dynamic logic, it is 
\emph on
not
\emph default
 related to actions in any way.
 Rather it expresses complex 
\emph on
epistemic
\emph default
 paths, and is interpreted over the epistemic frame generated by the agents'
 knowledge relations.
 We will be introducing a new macro 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 (read this as 
\begin_inset Quotes eld
\end_inset

Path-Knows
\begin_inset Quotes erd
\end_inset

) to express knowledge using these epistemic paths.
 To make this clear, here is how some different kinds of knowledge would
 be expressed using the standard account of knowledge, and how we intend
 to express them using epistemic paths:
\begin_inset Formula \begin{align}
\Knows(A,\phi,s) & \,\,\equiv\,\,\PKnows(A,\phi,s)\nonumber \\
\Knows(A,\Knows(B,\phi),s) & \,\,\equiv\,\,\PKnows(A;B,\phi,s)\nonumber \\
\Knows(A,\phi)\wedge\Knows(B,\phi,s) & \,\,\equiv\,\,\PKnows(A\cup B,\phi,s)\nonumber \\
\EKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows(\bigcup_{a\in G}a,\phi,s)\nonumber \\
\CKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)\label{eq:pknows_identities}\end{align}

\end_inset


\end_layout

\begin_layout Standard
TODO: don't state them all here, try to make this clearer
\end_layout

\begin_layout Standard
In this section, we develop a synchronous version 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 of our path-knowledge operator, building on the synchronous 
\begin_inset Formula $K_{0}$
\end_inset

 relation defined earlier.
 Its definition is a straightforward analogue of the individual-level 
\begin_inset Formula $\Knows$
\end_inset

 macro:
\begin_inset Formula \[
\PKnowsZ(\pi,\phi,s)\isdef\forall s':\,\KDo(\pi,s,s')\,\rightarrow\,\phi[s']\]

\end_inset

but this macro expands to a complicated second-order formula in the base
 language of the situation calculus.
 As with the case of the basic 
\begin_inset Formula $\Knows$
\end_inset

 macro, we need to treat 
\begin_inset Formula $\PKnowsZ$
\end_inset

 syntactically during regression, as if it were a primitive fluent.
 This means we need a regression rule for such expressions.
 It is here that we incorporate the second key idea from LCC - use of a
 syntactic transform to encode the effects of actions within epistemic paths
 as well as in primitive formulae.
 Mirroring LCC, we introduce the meta-operator 
\begin_inset Formula $\Trn$
\end_inset

 for this purpose.
\end_layout

\begin_layout Standard
TODO: diagram?
\end_layout

\begin_layout Standard
Let us consider the required operation of 
\begin_inset Formula $\Trn$
\end_inset

 by analogy with the standard regression operator 
\begin_inset Formula $\Reg$
\end_inset

.
 One can think of regression as a 
\begin_inset Quotes eld
\end_inset

pre-encoding
\begin_inset Quotes erd
\end_inset

 of the effects of an action: 
\begin_inset Formula $\phi$
\end_inset

 will hold in 
\begin_inset Formula $do(c,s)$
\end_inset

 if and only if 
\begin_inset Formula $\Reg(\phi,c)$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

.
 The path regressor 
\begin_inset Formula $\Trn$
\end_inset

 needs to lift this idea to epistemic paths as follows: there is a 
\begin_inset Formula $\pi$
\end_inset

-path from 
\begin_inset Formula $do(c,s)$
\end_inset

 to 
\begin_inset Formula $do(c',s')$
\end_inset

 if and only if there is a 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

-path from 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $s'$
\end_inset

.
\end_layout

\begin_layout Standard
In order to accomplish this task of pre-encoding the effects of actions,
 the path regressor will need to make various assertions about the action
 that is to be performed in each situation traversed by the path.
 It uses a fresh variable to track this 
\begin_inset Quotes eld
\end_inset

current action
\begin_inset Quotes erd
\end_inset

 in the regressed path.
 The basic operation of 
\begin_inset Formula $\Trn$
\end_inset

 is as follows:
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Itemize
Introduce a fresh variable 
\begin_inset Formula $x$
\end_inset

 to hold the action to be performed in the current situation;
\end_layout

\begin_layout Itemize
at the beginning of the path, bind 
\begin_inset Formula $x$
\end_inset

 to the known action 
\begin_inset Formula $c$
\end_inset

;
\end_layout

\begin_layout Itemize
at the end of the path, assert that 
\begin_inset Formula $x$
\end_inset

 is the known action 
\begin_inset Formula $c'$
\end_inset

; and
\end_layout

\begin_layout Itemize
when the path moves to a new situation, select a new action using 
\begin_inset Formula $\exists x$
\end_inset

.
\end_layout

\begin_layout Standard
This is accomplished with an auxiliary operator 
\begin_inset Formula $\TrnA(\pi,x)$
\end_inset

, which translates 
\begin_inset Formula $\pi$
\end_inset

 under the assumption that variable 
\begin_inset Formula $x$
\end_inset

 contains the action to be performed in the current situation.
 
\end_layout

\begin_layout DefinitionLbld
Epistemic
\begin_inset space ~
\end_inset

Path
\begin_inset space ~
\end_inset

Regressor
\begin_inset CommandInset label
LatexCommand label
name "def:EpistemicPathRegression"

\end_inset

 The epistemic path regressor 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

 operates according to the definitions below, where 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

 are fresh variables not appearing in 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{align*}
\Trn(\pi,c,c')\,\isdef\,\, & \exists x\,;\,?x=c\,;\,\TrnA(\pi,x)\,;\,?x=c'\\
\\\TrnA(agt,x)\,\isdef\,\, & \exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\\
\TrnA(?\phi,x)\isdef\,\, & ?\Reg(\phi,x)\\
\TrnA(\exists y,x)\isdef\,\, & \exists y\\
\begin{array}{c}
\TrnA(\pi_{1};\pi_{2},x)\isdef\,\,\end{array} & \TrnA(\pi_{1},x)\,;\,\TrnA(\pi_{2},x)\\
\TrnA(\pi_{1}\cup\pi_{2},x)\isdef\,\, & \TrnA(\pi_{1},x)\cup\TrnA(\pi_{2},x)\\
\TrnA(\pi^{*},x)\isdef\,\, & \TrnA(\pi,x)^{*}\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Most of these clauses are straightforward, but note how the clause for an
 individual agent term encodes the successor-state axiom for 
\begin_inset Formula $K_{0}$
\end_inset

.
 (TODO: more on exactly what this means).
\end_layout

\begin_layout Standard
The following theorem states that these definitions behave has desired,
 respecting the semantics of epistemic paths:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Trn-respects-epi-paths"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models\,\KDo(\pi,do(c,s),s'')\,\equiv\\
\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDo(\Trn(\pi,c,c'),s,s')\end{multline*}

\end_inset


\end_layout

\begin_layout ProofSketch
The proof proceeds by cases, covering each path operator in turn.
 The base cases 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $?\phi$
\end_inset

 and 
\begin_inset Formula $\exists y$
\end_inset

 follow from Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:KDo"

\end_inset

 and the successor state axiom for 
\begin_inset Formula $K_{0}$
\end_inset

 in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:K0_ssa"

\end_inset

.
 The inductive cases are straightforward as 
\begin_inset Formula $\Trn_{a}$
\end_inset

 is simply pushed inside each operator.
\end_layout

\begin_layout Standard
Given that 
\begin_inset Formula $\Trn$
\end_inset

 correctly regresses our epistemic path language, we are free to use it
 to define the regression of a complex epistemic modality.
 We define the regression of a 
\begin_inset Formula $\PKnowsZ$
\end_inset

 expression as follows:
\begin_inset Formula \[
\Reg(\PKnowsZ(\pi,\phi,do(c,s)))\isdef\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\]

\end_inset


\end_layout

\begin_layout Standard
TODO: expand definition of regressible formula
\end_layout

\begin_layout Standard
Note that this rule must universally quantify over action terms 
\begin_inset Formula $c'$
\end_inset

 in order to account for different actions producing the same observation.
 Such quantification is also found in the rule for individual knowledge
 from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

, although in the current instance it has been taken outside the scope of
 the knowledge macro.
 
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Reg_PKnowsZ"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action 
\begin_inset Formula $c$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{gather*}

\end_inset


\end_layout

\begin_layout ProofSketch
The mechanics of this proof mirror that of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Reg_Knows"

\end_inset

: we expand the 
\begin_inset Formula $\PKnowsZ$
\end_inset

 macro, apply Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 as a successor state axiom for 
\begin_inset Formula $\KDo$
\end_inset

, re-arrange to eliminate existential quantifiers, then collect terms back
 into forms that match 
\begin_inset Formula $\PKnowsZ$
\end_inset

.
\end_layout

\begin_layout Subsection
Introducing Hidden Actions
\begin_inset CommandInset label
LatexCommand label
name "sub:Introducing-Hidden-Actions"

\end_inset


\end_layout

\begin_layout Standard
We now have a powerful account of multi-agent knowledge for 
\emph on
synchronous
\emph default
 domains, but it remains to generalise this to 
\emph on
asynchronous
\emph default
 domains by incorporating support for arbitrarily-long sequences of hidden
 actions.
 We continue to operate at the meta-level, developing support for hidden
 actions directly in the rules governing the regression operator.
\end_layout

\begin_layout Standard
The idea is to use the empty action term 
\begin_inset Formula $\{\}$
\end_inset

 to explicitly represent the notion that 
\begin_inset Quotes eld
\end_inset

nothing happens
\begin_inset Quotes erd
\end_inset

.
 We simulate agents reasoning about hypothetical futures in which they make
 no more observations by inserting these empty actions between each regular
 action in a situation term.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $\mathcal{E}^{n}(s)$
\end_inset

 be 
\begin_inset Formula $s$
\end_inset

 with 
\begin_inset Formula $n$
\end_inset

 empty actions inserted between each action, as follows:
\begin_inset Formula \begin{align*}
\mathcal{E}^{0}(s)\,\isdef\,\, & s\\
\mathcal{E}^{1}(S_{0})\,\isdef\,\, & do(\{\},S_{0})\\
\mathcal{E}^{1}(do(c,s))\,\isdef\,\, & do(\{\},do(c,\mathcal{E}^{1}(s)))\\
\mathcal{E}^{n}(s)\,\isdef\,\, & \mathcal{E}^{1}(\mathcal{E}^{n-1}(s))\end{align*}

\end_inset


\end_layout

\begin_layout Standard
TODO: Recall that the empty action term is never actually possible, so we
 are actually constructing non-legal situation terms.
 Refer back to reflexivity etc for why this is OK.
\end_layout

\begin_layout Standard
The intuition here is that we want 
\begin_inset Formula $\PKnows(\pi,\phi)$
\end_inset

 to hold if 
\begin_inset Formula $\PKnowsZ(\pi,\phi)$
\end_inset

 holds after allowing for any number of empty actions.
 Formally, we want to use the following infinite conjunction as the definition
 of 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

:
\begin_inset Formula \[
\PKnows(\pi,\phi,s)\isdef\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\]

\end_inset


\end_layout

\begin_layout Standard
TODO: a proper fixpoint definition
\end_layout

\begin_layout Standard
Of course we cannot use this definition directly for automated reasoning,
 any more than we can use an infinitary definition of 
\begin_inset Formula $\CKnows$
\end_inset

.
 Instead we will construct a series of regression rules that simulate the
 infinite conjunction.
 This requires the following results: 
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:En_impl_En-1"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

: 
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\PKnowsZ(\pi,\phi,s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
By a case analysis on the definition of 
\begin_inset Formula $\Trn$
\end_inset

, we determine that that path 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 always contains the path 
\begin_inset Formula $\pi$
\end_inset

.
 Thus any situations reachable by 
\begin_inset Formula $\pi$
\end_inset

 are also reachable by 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

.
 Since 
\begin_inset Formula $\Trn(\pi,\{\},\{\})$
\end_inset

 is always in the regression of 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 and 
\begin_inset Formula $\Reg(\phi,\{\})=\phi$
\end_inset

 always, we can conclude that 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
\end_inset

 always implies 
\begin_inset Formula $\PKnowsZ(\Trn(\pi,\{\},\{\}),\phi,s)$
\end_inset

, which implies 
\begin_inset Formula $\PKnowsZ(\pi,\phi,s)$
\end_inset

 as required.
\end_layout

\begin_layout Theorem
For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, if there is some 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

 such that:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{n+1}(s))\]

\end_inset

Then:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\,\equiv\,\bigwedge_{m\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))\]

\end_inset


\end_layout

\begin_layout Proof
By Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:En_impl_En-1"

\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n+1}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))$
\end_inset

 always.
 So for this hypothesised value of 
\begin_inset Formula $n$
\end_inset

, the implication in the current theorem is in fact an equivalence.
 We then have 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m<n$
\end_inset

, and 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\equiv\PKnowsZ(\pi,\phi,\mathcal{E}^{m}(s))$
\end_inset

 for 
\begin_inset Formula $m\geq n$
\end_inset

, which is enough to establish the infinite conjunction as required.
\end_layout

\begin_layout Standard
This pair of results allows us to replace the infinite conjunction with
 a fixpoint calculation, so we will use the following suggestive notation:
\begin_inset Formula \[
\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(s))\isdef\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\]

\end_inset


\end_layout

\begin_layout Standard
We can therefore use the following as our definition of 
\begin_inset Formula $\PKnows$
\end_inset

:
\begin_inset Formula \[
\PKnows(\pi,\phi,s)\,\isdef\,\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(s))\]

\end_inset


\end_layout

\begin_layout Standard
This macro would once again expand into a complicated second-order sentence
 of the situation calculus, encoding both the semantics of the epistemic
 path and the fixpoint definition of 
\begin_inset Formula $\mathcal{E}^{\infty}$
\end_inset

.
 As before, regression needs to avoid such expansion by treating 
\begin_inset Formula $\PKnows$
\end_inset

 as a primitive fluent.
 It can calculate 
\begin_inset Formula $\PKnows$
\end_inset

 from 
\begin_inset Formula $\PKnowsZ$
\end_inset

 by performing a fixpoint calculation very similar to that performed for
 the persistence condition, using proof techniques for dynamic logic directly
 to avoid expanding 
\begin_inset Formula $\PKnowsZ$
\end_inset

 and 
\begin_inset Formula $\KDo$
\end_inset

.
\end_layout

\begin_layout Standard
Again, the question must be asked: can this really be considered an effective
 technique in practice? Many of our earlier comments on the persistence
 condition operator also apply here.
 Moreover, note that the epistemic path regressor preserves much of the
 structure of 
\begin_inset Formula $\pi$
\end_inset

, such that there is a good deal of similarity between the epistemic paths
 in 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))$
\end_inset

 and 
\begin_inset Formula $\PKnowsZ(\pi,\phi,\mathcal{E}^{n+1}(s))$
\end_inset

.
 Our preliminary implementation contains some special-case logic to simplify
 the reasoning based on this similarity, and we are currently investigating
 further such enhancements.
 
\end_layout

\begin_layout Standard
Clearly this definition of 
\begin_inset Formula $\PKnows$
\end_inset

 operates in a very similar way to the regression rule for 
\begin_inset Formula $\Knows$
\end_inset

 from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

, using a fixpoint calculation to account for arbitrarily long sequences
 of hidden actions.
  In the following section we formalism the precise relationship between
 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\PKnows$
\end_inset

.
\end_layout

\begin_layout Subsection
The Link with Individual Knowledge
\begin_inset CommandInset label
LatexCommand label
name "sub:The-Link-with-IK"

\end_inset


\end_layout

\begin_layout Standard
The last remaining link is the most important of all: showing that this
 new path-based account of knowledge actually captures the knowledge of
 the agents, according to the semantics of individual knowledge developed
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Obs-Knowledge"

\end_inset

.
 The following series of theorems establish this important link.
 First, we produce special cases of the regression rule for 
\begin_inset Formula $\PKnows(\pi,\phi)$
\end_inset

 for the case of a single agent:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Pknows_PbU_S0"

\end_inset

For any 
\begin_inset Formula $agt$
\end_inset

 and 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows(agt,\phi,S_{0})\,\equiv\,\PKnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout ProofSketch
By stepping through the regression of 
\begin_inset Formula $\PKnowsZ(agt,\phi,do(\{\},S_{0}))$
\end_inset

 we show that for any 
\begin_inset Formula $n$
\end_inset

, 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{n}(S_{0}))\equiv\PKnowsZ(agt,\Pst^{n}(\phi,\PbU(agt)),S_{0})$
\end_inset

.
 The fixpoint calculation for 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{\infty}(S_{0}))$
\end_inset

 is then clearly the same calculation required to derive 
\begin_inset Formula $\PKnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})$
\end_inset

 and we can equate the two expressions.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Pknows_PbU_do"

\end_inset

For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\left[z=\{\}\,\rightarrow\,\PKnows(agt,\Pst(\phi,\PbU(agt)),s)\right]\\
\wedge\,\left[z\neq\{\}\,\rightarrow\,\PKnows(agt,\forall c':\,\left(Poss(c')\wedge Obs(agt,c')=z\right)\rightarrow\Reg(\Pst(\phi,\PbU(agt)),c),s)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout ProofSketch
Repeating the calculations from lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Pknows_PbU_S0"

\end_inset

 on 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(do(c,s)))$
\end_inset

, and pushing the application of 
\begin_inset Formula $\mathcal{E}^{\infty}$
\end_inset

 past the actions 
\begin_inset Formula $c$
\end_inset

, we obtain the following:
\begin_inset Formula \[
\PKnows(agt,\phi,do(c,s))\,\equiv\,\PKnowsZ(agt,\Pst(\phi,\PbU(agt)),do(c,\mathcal{E}^{\infty}(s)))\]

\end_inset


\end_layout

\begin_layout ProofSketch
Regressing the RHS through the action 
\begin_inset Formula $c$
\end_inset

, we obtain:
\begin_inset Formula \begin{align*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\, & \forall c':\,\PKnowsZ(\Trn(agt,c,c'),\Reg(\Pst(\phi,\PbU(agt)),c'),\mathcal{E}^{\infty}(s))\\
\equiv\,\, & \forall c':\,\PKnows(\Trn(agt,c,c'),\Reg(\Pst(\phi,\PbU(agt)),c'),s)\end{align*}

\end_inset


\end_layout

\begin_layout ProofSketch
Simplifying 
\begin_inset Formula $\Trn(agt,c,c')$
\end_inset

 and using it to re-arrange the above expression gives the desired result.
\end_layout

\begin_layout Standard
We will also need the following result for individual knowledge:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Knows_impl_KnowsPbU"

\end_inset

For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\equiv\,\Knows(agt,\Pst(\phi,PbU(agt)),s)\]

\end_inset


\end_layout

\begin_layout ProofSketch
By induction on the regression rules for knowledge, and using the following
 property of the persistence condition (
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $\phi$
\end_inset

 persists, then 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 persists
\begin_inset Quotes erd
\end_inset

):
\begin_inset Formula \[
\forall s':\,\Pst(\phi,\alpha)[s]\,\wedge\, s\leq_{\alpha}s'\,\rightarrow\,\Pst(\phi,\alpha)[s']\]

\end_inset


\end_layout

\begin_layout ProofSketch
We consider three cases: 
\begin_inset Formula $s=S_{0}$
\end_inset

, and 
\begin_inset Formula $s=do(c,s)$
\end_inset

 with 
\begin_inset Formula $c$
\end_inset

 both observable and unobservable.
 Each case requires only a simple re-arrangement of the relevant regression
 rule.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Finally, we are in a position to state the major theorem of this section
 - that 
\begin_inset Formula $\PKnows$
\end_inset

 for a single agent is equivalent to the standard 
\begin_inset Formula $\Knows$
\end_inset

 macro.
\end_layout

\begin_layout Theorem
For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Theorem
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\,\equiv\,\,\PKnows(agt,\phi,s)\]

\end_inset


\end_layout

\begin_layout Proof
By induction on the regression rules for each expression.
 For the 
\begin_inset Formula $S_{0}$
\end_inset

 case, we require the following result which is true by the definition of
 
\begin_inset Formula $\KDo$
\end_inset

:
\begin_inset Formula \[
\KnowsZ(agt,\phi,S_{0})\equiv\PKnowsZ(agt,\phi,S_{0})\]

\end_inset

The regression rule for 
\begin_inset Formula $\Knows$
\end_inset

 from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_s0"

\end_inset

 then precisely matches the result of theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Pknows_PbU_S0"

\end_inset

 and we have the required equivalence.
 For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, we can substitute the result of theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Knows_impl_KnowsPbU"

\end_inset

 into the regression rule for 
\begin_inset Formula $\Knows$
\end_inset

 from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 to produce an expression precisely matching the result of theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Pknows_PbU_do"

\end_inset

.
 Using 
\begin_inset Formula $\Knows(agt,\phi,s)\equiv\PKnows(agt,\phi,s)$
\end_inset

 from the inductive hypothesis renders the two equivalent.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
Thus the expressions 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 and 
\begin_inset Formula $\PKnows(agt,\phi,s)$
\end_inset

 are equivalent under our formulation.
 This link is all that is required to validate the additional complex modalities
 shown in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pknows_identities"

\end_inset

, which we will repeat below for convenience.
\end_layout

\begin_layout Theorem
The following identities hold under the theory of action 
\begin_inset Formula $\Dt\cup\Dt_{K}^{obs}$
\end_inset

:
\begin_inset Formula \begin{align*}
\Knows(A,\phi,s) & \,\,\equiv\,\,\PKnows(A,\phi,s)\\
\Knows(A,\Knows(B,\phi),s) & \,\,\equiv\,\,\PKnows(A;B,\phi,s)\\
\Knows(A,\phi)\wedge\Knows(B,\phi,s) & \,\,\equiv\,\,\PKnows(A\cup B,\phi,s)\\
\EKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows(\bigcup_{a\in G}a,\phi,s)\\
\CKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Each follows from the equivalence of 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

 and 
\begin_inset Formula $\PKnows(agt,\phi,s)$
\end_inset

, using the semantics of first-order dynamic logic as defined by 
\begin_inset Formula $\KDo$
\end_inset

.
 For example, in the 
\begin_inset Formula $\CKnows$
\end_inset

 case we argue as follows: By definition, 
\begin_inset Formula $\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)$
\end_inset

 is the transitive closure of the union of 
\begin_inset Formula $\PKnows(a,\phi,s)$
\end_inset

 for 
\begin_inset Formula $a\in G$
\end_inset

.
 Also by definition, 
\begin_inset Formula $\CKnows(G,\phi,s)$
\end_inset

 is the transitive closure of the union of 
\begin_inset Formula $\Knows(a,\phi,s)$
\end_inset

 for 
\begin_inset Formula $a\in G$
\end_inset

.
 Since 
\begin_inset Formula $\PKnows(a,\phi,s)$
\end_inset

 and 
\begin_inset Formula $\Knows(a,\phi,s)$
\end_inset

 are the same relation, their transitive closures are also the same and
 the identity is entailed.
\end_layout

\begin_layout Subsection
Answering the Regressed Query
\end_layout

\begin_layout Standard
We are now in a position to reduce an epistemic query 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 at some future situation to an epistemic query 
\begin_inset Formula $\PKnows(\Trn^{*}(\pi),\Reg^{*}(\phi),S_{0})$
\end_inset

 at the initial situation.
 While this is a significant gain for effective automated reasoning, it
 still remains to answer the regressed query.
\end_layout

\begin_layout Standard
As with individual knowledge, we assume that regressed queries will be handled
 by a special-purpose theorem prover rather than by expanding the macros.
 However, we should note that validity in first-order dynamic logic is undecidab
le; in fact it is 
\begin_inset Formula $\Pi_{1}^{1}$
\end_inset

-hard 
\begin_inset CommandInset citation
LatexCommand citep
key "kooi07dyn_termmodal_logic"

\end_inset

.
 As with previous work in the situation calculus, we must assume that axioms
 about the initial situation are in a restricted form amenable to effective
 reasoning.
 There are several special cases that can simplify answering the regressed
 query.
\end_layout

\begin_layout Standard
A common simplifying assumption is that the potential values of each variable
 can be finitely enumerated.
 In this case it is possible to translate our epistemic paths into propositional
 dynamic logic, which is decidable.
 The only difficulty is the elimination of variable bindings inside an iteration
 operator, which can be handled using a Kleene-style technique similar to
 the 
\begin_inset Formula $\mathcal{K}$
\end_inset

 translator of 
\begin_inset CommandInset citation
LatexCommand citet
key "vanBenthem06lcc"

\end_inset

.
 
\end_layout

\begin_layout Standard
Alternately, it may be that the initial situation is completely known and
 uncertainty is introduced only due to partial observability of actions.
 In this case the initial epistemic frame contains the lone situation 
\begin_inset Formula $S_{0}$
\end_inset

, and the regressed path can be reduced to a series of tests and variable
 re-bindings.
\end_layout

\begin_layout Standard
We have produced a preliminary implementation for propositional domains
 using the PDL prover from the Tableaux Workbench suite 
\begin_inset CommandInset citation
LatexCommand citep
key "abate07twb_pdl"

\end_inset

, and have used it to verify some simple examples.
 We are also investigating further techniques for answering the regressed
 query in a more effective manner.
\end_layout

\begin_layout Subsection
An Illustrative Example
\end_layout

\begin_layout Standard
With this technical machinery in place, we are now able to reason about
 the group-level epistemic modalities of a team of agents.
 To demonstrate, we revisit our example domain from Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:An-Illustrative-Example"

\end_inset

.
 We add the the following initial knowledge axiom to 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

:
\begin_inset Formula \begin{gather*}
\PKnowsZ((Ann\cup Bob)^{*},InRoom(Ann)\wedge InRoom(Bob),S_{0})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The preconditions and effects of actions in this domain are relatively simple,
 such that there is nothing that can be accomplished by a sequence of hidden
 actions that cannot be accomplished by a single hidden action.
 More formally, it is possible to show that:
\begin_inset Formula \[
\phi[\mathcal{E}^{\infty}(s)]\,\equiv\,\phi[\mathcal{E}^{1}(s)]\]

\end_inset

 In other words, the fixpoint calculation required for reasoning about 
\begin_inset Formula $\PKnows$
\end_inset

 will always terminate after a single iteration.
 We will therefore use the following identity to simplify presentation of
 the example:
\begin_inset Formula \begin{align*}
\Reg(\PKnows(\pi,\phi,do(c,s))\,\Rightarrow & \,\,\,\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(do(c,s)))\\
\equiv & \,\,\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(do(c,s)))\\
\equiv & \,\,\,\PKnowsZ(\pi,\phi,do(\{\},do(c,s)))\\
\equiv & \,\,\,\forall c',c'':\,\PKnows(\Trn(\Trn(\pi,\{\},c'),c,c''),\Reg(\Reg(\phi,c'),c''),s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
To keep the presentation compact, we will abbreviate agent names to 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 and the fluent 
\begin_inset Formula $InRoom(agt)$
\end_inset

 to 
\begin_inset Formula $IR(agt)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Example
After Bob reads the invitation, it is common knowledge that he knows where
 the party is:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((A\cup B)^{*},\exists x:\Knows(B,loc=x),do(\{read(B)\},S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
This example hinges on the fact that initially, it is common knowledge that
 both agents are in the room.
 It is thus common knowledge that the occurrence of 
\begin_inset Formula $read(Bob)$
\end_inset

 will be observed by both agents.
 Suppressing the inner expression for the moment, regressing using the above-men
tioned identity gives:
\begin_inset Formula \begin{multline*}
\Reg(\PKnows((A\cup B)^{*},\phi,do(read(B),S_{0})))\\
\Rightarrow\,\,\forall c,c':\,\PKnows(\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c'),\Reg(\Reg(\phi,c),c'),S_{0})\\
\Rightarrow\,\,\forall c,c',c'':\,\PKnowsZ(\Trn(\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c'),\{\},c''),\Reg(\Reg(\Reg(\phi,c),c'),c''),S_{0})\end{multline*}

\end_inset

We begin by evaluating 
\begin_inset Formula $\Trn(\pi,\{\},c)$
\end_inset

 :
\begin_inset Formula \[
\Trn((A\cup B)^{*},\{\},c)\,\Rightarrow\,\exists x\,;\,?x=\{\}\,;\,(\TrnA(A,x)\cup\TrnA(B,x))^{*}\,;\,?x=c\]

\end_inset

With the cases for 
\begin_inset Formula $\TrnA(agt,x)$
\end_inset

 both evaluating to:
\begin_inset Formula \[
\TrnA(agt,x)\,\Rightarrow\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\]

\end_inset

Since we know all possible observations that Ann could make, let us expand
 the path 
\begin_inset Formula $\TrnA(A,x)$
\end_inset

 by enumerating the possible values for 
\begin_inset Formula $z$
\end_inset

.
 The first line in the result gives the case where 
\begin_inset Formula $Obs(Ann,x)=\{\}$
\end_inset

, and the last line is the case where 
\begin_inset Formula $Obs(Ann,x)=read(Ann)\#r$
\end_inset

.
 All other lines are where Ann simply observes the action 
\begin_inset Formula $x$
\end_inset

.
 
\begin_inset Formula \begin{gather*}
\TrnA(A,x)\,\Rightarrow\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\\
?\, x=\{\}\vee(x=read(B)\wedge\neg IR(A)))\,;\, A\,;\,\exists x\,;\,?\, x=\{\}\vee(x=read(B)\wedge IR(B)\wedge\neg IR(A))\\
\cup\,\,?x=enter(A)\,;\, A\,;\,\exists x\,;\,?x=enter(A)\wedge IR(A)\\
\cup\,\,?x=enter(B)\,;\, A\,;\,\exists x\,;\,?x=enter(B)\wedge IR(B)\\
\cup\,\,?x=leave(A)\,;\, A\,;\,\exists x\,;\,?x=leave(A)\wedge\neg IR(A)\\
\cup\,\,?x=leave(B)\,;\, A\,;\,\exists x\,;\,?x=leave(B)\wedge\neg IR(B)\\
\cup\,\,?\, x=read(B)\wedge IR(A)\,;\, A\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x=read(A)\wedge loc(r)\,;\, A\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(A)\wedge loc(r)\end{gather*}

\end_inset

Now consider starting with 
\begin_inset Formula $x$
\end_inset

 set to 
\begin_inset Formula $\{\}$
\end_inset

 and following this path some number of times.
 On the first iteration, 
\begin_inset Formula $x$
\end_inset

 may get rebound to either 
\begin_inset Formula $\{\}$
\end_inset

 or 
\begin_inset Formula $read(B)$
\end_inset

.
 Subsequent iterations may alternate between these values, but can never
 bind 
\begin_inset Formula $x$
\end_inset

 to any other action.
 An analogous argument for 
\begin_inset Formula $\TrnA(B,x)$
\end_inset

 shows that the path 
\begin_inset Formula $\Trn((A\cup B)^{*},\{\},c)$
\end_inset

 can be simplified to consider only the actions 
\begin_inset Formula $\{\}$
\end_inset

, 
\begin_inset Formula $read(A)$
\end_inset

 and 
\begin_inset Formula $read(B)$
\end_inset

, with any other binding of 
\begin_inset Formula $x$
\end_inset

 being unreachable:
\begin_inset Formula \begin{multline*}
\Trn((A\cup B)^{*},\{\},c)\,\Rightarrow\,\exists x\,;\,?x=\{\}\,;\,(\\
?\, x=\{\}\vee(x=read(B)\wedge\neg IR(A)))\,;\, A\,;\,\exists x\,;\,?\, x=\{\}\vee(x=read(B)\wedge IR(B)\wedge\neg IR(A))\\
\cup\,\,?\, x=\{\}\vee(x=read(A)\wedge\neg IR(B)))\,;\, B\,;\,\exists x\,;\,?\, x=\{\}\vee(x=read(A)\wedge IR(A)\wedge\neg IR(B))\\
\cup\,\,?\, x=read(B)\wedge IR(A)\,;\, A\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x=read(A)\wedge loc(r)\,;\, A\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(A)\wedge loc(r)\\
\cup\,\,?\, x=read(A)\wedge IR(B)\,;\, B\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(B)\wedge IR(A)\\
\cup\,\,\exists r\,;\,?\, x=read(B)\wedge loc(r)\,;\, B\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(B)\wedge loc(r)\\
)^{*}\,;\,?x=c\end{multline*}

\end_inset

This path matches with our intuitions about the observability of actions.
 Since the 
\begin_inset Formula $enter$
\end_inset

 and 
\begin_inset Formula $leave$
\end_inset

 actions are always public, they can never be mistaken for the empty action
 and are irrelevant in the path 
\begin_inset Formula $\Trn(\pi,\{\},c)$
\end_inset

.
 Moreover, the binding of 
\begin_inset Formula $x$
\end_inset

 may only switch from 
\begin_inset Formula $\{\}$
\end_inset

 to 
\begin_inset Formula $read(B)$
\end_inset

 if there is a possible world in which Ann is not in the room, reflecting
 the conditions under which that action would be hidden.
\end_layout

\begin_layout Standard
Next we evaluate the 
\begin_inset Formula $\Trn(\pi,read(B),c')$
\end_inset

 portion, which will produce:
\begin_inset Formula \begin{multline*}
\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c')\,\Rightarrow\,\exists x'\,;\,?x'=read(B)\,;\,\exists x\,;\,?x=\{\}\,;\\
(\TrnA(\TrnA(A,x),x')\cup\TrnA(\TrnA(B,x),x'))^{*}\,;\,?x=c\,;\,?x'=c'\end{multline*}

\end_inset

As before, the only possible values of 
\begin_inset Formula $x'$
\end_inset

 are 
\begin_inset Formula $\{\}$
\end_inset

, 
\begin_inset Formula $read(A)$
\end_inset

 and 
\begin_inset Formula $read(B)$
\end_inset

.
 None of these actions affect any of the tests present in 
\begin_inset Formula $\Trn((A\cup B)^{*},\{\},c)$
\end_inset

, so we can safely leave them unchanged in the resulting path:
\begin_inset Formula \begin{multline*}
\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c')\,\Rightarrow\,\exists x'\,;\,?x'=read(B)\,;\,\exists x\,;\,?x=\{\}\,;\,(\\
?x=\{\}\vee(x=read(B)\wedge\neg IR(A)));\TrnA(A,x');\exists x;?x=\{\}\vee(x=read(B)\wedge IR(B)\wedge\neg IR(A))\\
\cup\,?x=\{\}\vee(x=read(A)\wedge\neg IR(B)));\TrnA(B,x');\exists x;?x=\{\}\vee(x=read(A)\wedge IR(A)\wedge\neg IR(B))\\
\cup\,\,?\, x=read(B)\wedge IR(A)\,;\,\TrnA(A,x')\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x=read(A)\wedge loc(r)\,;\,\TrnA(A,x')\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(A)\wedge loc(r)\\
\cup\,\,?\, x=read(A)\wedge IR(B)\,;\,\TrnA(B,x')\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(B)\wedge IR(A)\\
\cup\,\,\exists r\,;\,?\, x=read(B)\wedge loc(r)\,;\,\TrnA(B,x')\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(B)\wedge loc(r)\\
)^{*}\,;\,?x=c\,;\, x'=c'\end{multline*}

\end_inset

We can complete this expansion using the previously calculated result for
 
\begin_inset Formula $\TrnA(A,x)$
\end_inset

, but will proceed leaving this implicit.
 Finally, we must apply 
\begin_inset Formula $\Trn$
\end_inset

 again for the 
\begin_inset Formula $\Trn(\pi,\{\},c'')$
\end_inset

 portion.
 The process is identical and we will not repeat it here.
\end_layout

\begin_layout Standard
We next evaluate this path over the initial epistemic relation of the agents,
 about which we know:
\begin_inset Formula \[
\PKnowsZ((A\cup B)^{*},IR(A)\wedge IR(B),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
Consider how this restricts the possible bindings of 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $x'$
\end_inset

 etc.
 For 
\begin_inset Formula $x$
\end_inset

 to switch from its initial value of 
\begin_inset Formula $\{\}$
\end_inset

 to 
\begin_inset Formula $read(A)$
\end_inset

 (resp.
 
\begin_inset Formula $read(B)$
\end_inset

) the path must traverse a test for 
\begin_inset Formula $\neg IR(B)$
\end_inset

 (resp.
 
\begin_inset Formula $\neg IR(A)$
\end_inset

).
 Since we know that these tests will never succeed on the initial epistemic
 frame, we can conclude that 
\begin_inset Formula $x$
\end_inset

 will always be bound to 
\begin_inset Formula $\{\}$
\end_inset

.
 Since the path insists that 
\begin_inset Formula $x=c$
\end_inset

 at termination, this is the only interesting value for 
\begin_inset Formula $c$
\end_inset

 - any value of 
\begin_inset Formula $c$
\end_inset

 other than 
\begin_inset Formula $\{\}$
\end_inset

 will result in no worlds being reachable by the regressed path and will
 thus have 
\begin_inset Formula $\PKnowsZ$
\end_inset

 vacuously true.
 By a similar argument, we find that the only interesting values of 
\begin_inset Formula $c'$
\end_inset

 and 
\begin_inset Formula $c''$
\end_inset

 are 
\begin_inset Formula $read(B)$
\end_inset

 and 
\begin_inset Formula $\{\}$
\end_inset

 respectively.
\end_layout

\begin_layout Standard
Turning now to the regression of the inner formula, we have:
\begin_inset Formula \begin{gather*}
\Reg(\Reg(\Reg(\exists x:\,\Knows(B,loc=x),c),c'),c'')\\
\Rightarrow\Reg(\Reg(\Reg(\exists x:\,\Knows(B,loc=x),\{\}),read(B)),\{\})\\
\Rightarrow\Reg(\Reg(\exists x:\,\Knows(B,loc=x),read(B),\{\})\\
\Rightarrow true\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Thus for 
\begin_inset Formula $c=\{\}$
\end_inset

, 
\begin_inset Formula $c'=read(B)$
\end_inset

, 
\begin_inset Formula $c''=\{\}$
\end_inset

 the known formula is a tautology, while for any other values the regressed
 epistemic path has no reachable worlds.
 The example is therefore entailed by the domain.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Example
After Bob reads the invitation, the location is not common knowledge
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\not\models\,\PKnows((Ann\cup Bob)^{*},loc=C,do(read(Bob),S_{0}))\]

\end_inset


\end_layout

\begin_layout Standard
Regression of the epistemic path proceeds as with the previous example,
 but regression of the inner formula no longer produces a tautology.
 If we ignore the path components dealing with 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $c''$
\end_inset

, which from the previous example we know to be redundant, regressing this
 expression produces the following:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\PKnowsZ(\dots\\
\cup\,\,?\, x'=read(B)\wedge IR(A)\,;\, A\,;\,\exists x'\,;\,?\, x'=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x'=read(B)\wedge loc(r)\,;\, B\,;\,\exists x'\,;\,?\, x'=read(B)\wedge IR(B)\wedge loc(r)\\
\cup\dots,loc=C,S_{0})\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
This means, very roughly, that 
\begin_inset Formula $read(B)$
\end_inset

 could result in common knowledge that 
\begin_inset Formula $loc=C$
\end_inset

 if it was commonly known that the preconditions of 
\begin_inset Formula $read(B)$
\end_inset

 implied 
\begin_inset Formula $loc=C$
\end_inset

.
 Since this is not given in the domain description, the example is not entailed.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Example
After Ann also reads the invitation, the location becomes common knowledge:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((Ann\cup Bob)^{*},loc=C,do(read(Ann),do(read(Bob),S_{0})))\]

\end_inset


\end_layout

\begin_layout Standard
The additional action here can be handled in the same manner as the previous
 example.
 We will not repeat the working, but simply state that this indeed is a
 consequence of our theory.
\end_layout

\begin_layout Subsection
Discussion
\begin_inset CommandInset label
LatexCommand label
name "sub:CEM-Discussion"

\end_inset


\end_layout

\begin_layout Standard
In this section we have introduced a technique for representing and reasoning
 about complex epistemic modalities in the situation calculus.
 In order to formulate an effective reasoning procedure, we have had to
 move beyond just 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\CKnows$
\end_inset

 and introduce a powerful epistemic path language based on dynamic logic.
 Mirroring the development of knowledge for individual agents, group-level
 modalities are introduced as macros of the form 
\begin_inset Formula $\PKnows(\pi,\phi,s)$
\end_inset

 where 
\begin_inset Formula $\pi$
\end_inset

 is a complex epistemic path.
 To avoid having to expand these macros during reasoning, we have modified
 the regression operator to treat them as primitive fluents.
\end_layout

\begin_layout Standard
Demonstrating the utility of our approach, we have presented an example
 of effective automated reasoning about common knowledge in an asynchronous,
 partially observable domain.
 This powerful new ability is a first for the situation calculus.
\end_layout

\begin_layout Standard
Our development has clear parallels with the development of LCC 
\begin_inset CommandInset citation
LatexCommand citep
key "vanBenthem06lcc"

\end_inset

.
 We choose the situation calculus for its much richer ontology, e.g.
 preconditions and effects are first order, while actions take arguments
 and may be performed concurrently.
 On one hand, this forces us to use a more powerful dynamic logic for our
 epistemic language and run the risk of undecidability.
 On the other, it actually simplifies some aspects of our presentation.
 We do not need explicit update frames, and the definition of our path regressor
 does not require an auxiliary Kleene-style operator to handle iteration.
 
\end_layout

\begin_layout Standard
In synchronous domains with a finite state-space the situation calculus
 may not offer a gain in expressiveness, but it can certainly provide a
 more succinct axiomatisation.
 Moving beyond such domains, our formalism offers the potential to incorporate
 other rich domain features that have been developed for the situation calculus,
 such as continuous time and actions with duration 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter96sc_nat_conc"

\end_inset

.
 
\end_layout

\begin_layout Standard
The expressiveness of our epistemic path language means that answering a
 regressed knowledge query can be difficult in the general case.
 However, starting from the expression for common knowledge, the epistemic
 path regressor 
\begin_inset Formula $\Trn$
\end_inset

 will generate only a fragment of the full epistemic language.
 For example, it generates only formulae without nested iteration operators,
 a property which is known to simplify proof search in PDL 
\begin_inset CommandInset citation
LatexCommand citep
key "abate07twb_pdl"

\end_inset

.
 Restricting the domain can weaken this generated fragment, as shown in
 
\begin_inset CommandInset citation
LatexCommand cite
key "vanBenthem06lcc"

\end_inset

 where a relativised common-knowledge operator is proven sufficient for
 domains in which all actions are publicly observable.
 Identifying restrictions such as this that can simplify reasoning in the
 epistemic language is a promising avenue for future research.
 
\end_layout

\begin_layout Standard
As with our account of individual-level knowledge, hidden actions are handled
 using a fixpoint calculation.
 However, this calculation is no longer based on objective formulae and
 the unique names axioms, but requires reasoning in first-order dynamic
 logic.
 The above considerations must be taken into account not only when answering
 the final regressed query, but also when generating the intermediate fixpoints.
\end_layout

\begin_layout Section
Conclusions
\begin_inset CommandInset label
LatexCommand label
name "sec:Conclusions"

\end_inset


\end_layout

\begin_layout Standard
We have now enriched the standard account of knowledge in the situation
 calculus with two important new features: hidden actions, and common knowledge.
 We conclude the paper with a high-level summary of our achievements, and
 discussions of related and future work.
 
\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
In this paper we have enriched the standard account of knowledge in the
 situation calculus with the following technical results:
\end_layout

\begin_layout Itemize
A formal account of 
\emph on
Common Knowledge
\emph default
 and other group-level epistemic modalities, including a regression rule
 for reasoning about common knowledge;
\end_layout

\begin_layout Itemize
support for 
\emph on
Hidden Actions
\emph default
 and actions that are partially observable, including a reasoning technique
 to deal with arbitrarily-long sequences of hidden actions; and
\end_layout

\begin_layout Itemize
a solution to the 
\emph on
Frame Problem
\emph default
 for knowledge, built on the successor state axioms for primitive actions,
 maintaining regression as the primary reasoning tool, and allowing agents
 to reason about their own knowledge using only their local information.
\end_layout

\begin_layout Standard
The standard account of knowledge required the common knowledge operator
 
\begin_inset Formula $\CKnows$
\end_inset

 to be introduced via a separate second-order axiom, which precluded the
 use of regression for effective automated reasoning.
 The key limitation here was the expressiveness of the epistemic language,
 since the regression of 
\begin_inset Formula $\CKnows$
\end_inset

 could not be expressed in terms of 
\begin_inset Formula $\Knows$
\end_inset

 and 
\begin_inset Formula $\CKnows$
\end_inset

 alone.
 We have developed a more powerful epistemic language using the 
\begin_inset Formula $\PKnows$
\end_inset

 operator and the language of dynamic logic, that allows common knowledge
 to be reasoned about using familiar regression techniques.
 
\end_layout

\begin_layout Standard
The standard account also required that domains be synchronous, so that
 the 
\begin_inset Formula $\Knows$
\end_inset

 operator need not consider arbitrarily-long sequences of hidden actions.
 Handling hidden actions requires a second-order induction axiom to universally
 quantify over situation terms, again precluding the use of regression for
 effective automated reasoning.
 We have shown that this second-order axiom can be avoided during regression,
 by replacing it with a fixpoint calculation performed by the meta-level
 reasoning machinery.
 This fixpoint calculation requires theorem proving based on a very restricted
 set of axioms, offering a significant advantage over generic second-order
 theorem proving.
\end_layout

\begin_layout Standard
Key to achieving both of these results has been a focus on the frame problem
 -- not just in soundly capturing the interplay between knowledge and action,
 but in constructing the formalism to be compatible with existing regression
 techniques.
 By capturing the second-order aspects of common knowledge in a series of
 macro definitions, we were able to directly formulate a successor-state
 axiom for 
\begin_inset Formula $\PKnows$
\end_inset

 and let regression treat it like a primitive fluent; and by factoring the
 second-order aspects of dealing with hidden actions into a separate fixpoint
 calculation, we were able to formulate a proper regression rule and study
 the fixpoint calculation in isolation.
 Both have been a significant win for effective automated reasoning.
\end_layout

\begin_layout Standard
The end result is a rich multi-agent theory of knowledge and action, suitable
 for asynchronous, partially-observable domains, in which complex group-level
 epistemic modalities are amenable to effective automated reasoning.
\end_layout

\begin_layout Subsection
Related Work
\begin_inset CommandInset label
LatexCommand label
name "sec:Related-Work"

\end_inset


\end_layout

\begin_layout Standard
There has been a great deal of work on multi-agent systems in the situation
 calculus, including: specification of multi-agent systems 
\begin_inset CommandInset citation
LatexCommand cite
key "shapiro02casl"

\end_inset

; theories of coordination 
\begin_inset CommandInset citation
LatexCommand citep
key "ghaderi07sc_joint_ability"

\end_inset

 and ability 
\begin_inset CommandInset citation
LatexCommand citep
key "levesque00knowing_how"

\end_inset

; reasoning about the epistemic feasibility of plans 
\begin_inset CommandInset citation
LatexCommand citep
key "Lesperance01epi_feas_casl"

\end_inset

; analysing multi-player games 
\begin_inset CommandInset citation
LatexCommand citep
key "delgrande01sitcalc_cleudo"

\end_inset

; and our own work on the cooperative execution of Golog programs 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly06hlp_dps"

\end_inset

.
 Many of these explicitly assume that all actions are public, in order to
 use regression to reason about knowledge.
 Additionally, they either do not use common knowledge in their formalisms,
 or use an explicit second-order axiom and forgo the use of regression in
 such cases.
 Our richer theory of knowledge could immediately be used to extend and
 generalise formalisms such as these to more complex multi-agent domains.
\end_layout

\begin_layout Standard
While our formalism has explicitly focused on modelling knowledge, there
 has also been substantial work on modelling 
\emph on
belief
\emph default
 in the situation calculus, where agents may be mistaken about the state
 of the world 
\begin_inset CommandInset citation
LatexCommand citep
key "shapiro00sc_belief"

\end_inset

.
 In such systems there are alternatives to reasoning about arbitrarily-long
 sequences of hidden actions, such as assuming that no hidden actions occur
 until there is evidence to the contrary.
 
\begin_inset CommandInset citation
LatexCommand citet
key "shapiro04sc_belief_exog"

\end_inset

 show how agents may hypothesise the occurrence of hidden exogenous actions
 when they discover that their beliefs are wrong.
 We note that these belief-based systems are also based on the original
 formulation of epistemic modalities by 
\begin_inset CommandInset citation
LatexCommand citet
key "scherl03sc_knowledge"

\end_inset

, and are confident that aspects of our approach could be used to enrich
 such systems.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Our development clearly owes much to the heritage of dynamic epistemic logics
 in general 
\begin_inset CommandInset citation
LatexCommand citep
key "halpern90knowledge_distrib,baltag98pa_ck"

\end_inset

 and the development of LCC in particular 
\begin_inset CommandInset citation
LatexCommand citep
key "vanBenthem06lcc"

\end_inset

; discussion and comparison can be found in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:CEM-Discussion"

\end_inset

.
 We echo the sentiment of 
\begin_inset CommandInset citation
LatexCommand citet
key "vanbentham07ml_sitcalc"

\end_inset

 and look forward to continued cross-pollination between these two related
 disciplines.
\end_layout

\begin_layout Standard
One common feature of epistemic logics that is not found in our work is
 the notion of a 
\emph on
protocol
\emph default
 - an explicit restriction on the sequences of actions that are permissible
 in the world.
 Our formalism corresponds to a simple 
\begin_inset Quotes eld
\end_inset

anything goes
\begin_inset Quotes erd
\end_inset

 protocol - the agents assume that if an action is physically possible,
 then it might have occurred.
 This is suitable for adversarial domains but does not necessarily capture
 cooperative domains where, for example, other agents may be trusted not
 to change the world in certain ways.
\end_layout

\begin_layout Standard
The approach can be generalised to some extent by replacing the use of 
\begin_inset Formula $Poss(c,s)$
\end_inset

 with a more specific action description predicate, that axiomatises the
 actions that are permissible.
 For example, agents could assume no interference from other agents and
 consider only hidden actions performed by the environment.
 Alternatively, if other mental attitudes are also part of the theory, they
 may consider only those actions that are compatible with each other's goals
 or desires; such a formulation echos the intuition behind motivated action
 theory 
\begin_inset CommandInset citation
LatexCommand citep
key "morgenstern90knowledge"

\end_inset

.
\end_layout

\begin_layout Standard
However, such changes can only accommodate 
\emph on
local
\emph default
 protocols, where the permissible actions depend solely on the state of
 the world.
 A more general formalism would allow protocols to be specified as programs,
 perhaps in the Golog language 
\begin_inset CommandInset citation
LatexCommand citep
key "levesque97golog"

\end_inset

.
 Combining epistemic and dynamic aspects in such flexible ways is known
 to be highly undecidable even in very simple domains 
\begin_inset CommandInset citation
LatexCommand citep
key "vanBentham06tree_of_knowledge"

\end_inset

 and we leave such considerations for future work.
\end_layout

\begin_layout Subsection
Future Work
\end_layout

\begin_layout Standard
As noted above, there are interesting applications for reasoning about knowledge
 under a protocol, where the protocol may be expressed as some Golog program
 
\begin_inset Formula $\delta$
\end_inset

.
 The desired modality would be something like the following, stating that
 
\begin_inset Quotes eld
\end_inset

it is 
\begin_inset Formula $\pi$
\end_inset

-known that 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 under protocol 
\begin_inset Formula $\delta$
\end_inset


\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula \[
\mathbf{PDKnows}(\pi,\delta,\phi,s)\]

\end_inset

Our ongoing research program is investigating modalities such as this.
 One challenging aspect is that while knowledge is usually handled by reasoning
 
\emph on
backward
\emph default
 in time using regression, Golog programs are executed by reasoning 
\emph on
forward
\emph default
 in time to find a valid sequence of actions.
 Such a modality would also need to reason about invariants of a Golog program
 in order to handle iterative protocols, and we are aware of no existing
 work in this area.
\end_layout

\begin_layout Standard
A significant short-term focus of our future work is in increasing the tractabil
ity of our reasoning techniques.
 As noted in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:CEM-Discussion"

\end_inset

, we are searching for fragments of first-order dynamic logic that are easier
 to reason about while still be expressive enough to represent common knowledge
 in some domains.
 
\end_layout

\begin_layout Standard
Another approach to more tractable reasoning is to approximate knowledge
 in the style of 
\begin_inset CommandInset citation
LatexCommand citet
key "demolombe00tractable_sc_belief"

\end_inset

.
 Here knowledge is restricted to primitive fluents only, rather than arbitrary
 uniform formulae.
 Knowledge of more complex formulae may be expressed approximately, by splitting
 the 
\begin_inset Formula $\Knows$
\end_inset

 macro until it operates only on primitive fluents, e.g.
 
\begin_inset Formula $\Knows(F_{1}\vee F_{2})\Rightarrow\Knows(F_{1})\vee\Knows(F_{2})$
\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand citet
key "petrick02knowledge_equivalence"

\end_inset

 have developed a formal correspondence between this account of knowledge
 and the standard possible-worlds model in the case of a single agent.
 Extending the correspondence to multiple agents and hidden actions would
 be a promising avenue of future work.
\end_layout

\begin_layout Section
\start_of_appendix
Complete Proofs
\begin_inset CommandInset label
LatexCommand label
name "sec:Complete-Proofs"

\end_inset


\end_layout

\begin_layout Standard
This appendix contains complete proofs for various lemmas and theorems throughou
t the paper, along with some additional lemmas.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:pbu-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, Legal(s)\wedge s\leq_{\PbU(agt)}s'\,\rightarrow\, Legal(s')\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, since 
\begin_inset Formula $\PbU$
\end_inset

 implies 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Legal$
\end_inset

 is equivalent to 
\begin_inset Formula $\leq_{Poss}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:pbu-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, s\leq_{\PbU(agt)}s'\,\rightarrow\, View(agt,s')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
Trivial, by induction on the definition of 
\begin_inset Formula $View$
\end_inset

 from equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:view_defn"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:K-implies-root"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, K(agt,s'',s)\,\rightarrow\, K(agt,root(s''),root(s))\]

\end_inset


\end_layout

\begin_layout Proof
Trivial in the base case of 
\begin_inset Formula $Init(s)$
\end_inset

.
 For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, suppose that we have 
\begin_inset Formula $K(agt,s'',do(c,s))$
\end_inset

.
 Then by equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) there is some 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $s'\sqsubseteq s''$
\end_inset

 and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 Then 
\begin_inset Formula $root(s'')$
\end_inset

 = 
\begin_inset Formula $root(s')$
\end_inset

, and 
\begin_inset Formula $K(root(s'),root(s))$
\end_inset

 by the inductive hypothesis, giving the required result.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:K-implies-legal"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, K(agt,s'',s)\,\rightarrow\, Legal(s'')\]

\end_inset


\end_layout

\begin_layout Proof
All 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $K_{0}(agt,s',s)$
\end_inset

 are initial and therefore legal.
 So using equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) in the base case, there must be a legal 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $s'\leq_{\PbU(agt)}s''$
\end_inset

, making 
\begin_inset Formula $s''$
\end_inset

 legal by lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:pbu-implies-legal"

\end_inset

.
 For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) ensures that 
\begin_inset Formula $do(c',s')\leq_{\PbU(agt)}s''$
\end_inset

 for some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $c'$
\end_inset

 satisfying 
\begin_inset Formula $K(agt,s',s)$
\end_inset

 and 
\begin_inset Formula $Poss(c',s')$
\end_inset

.
 So 
\begin_inset Formula $s'$
\end_inset

 is legal by the inductive hypothesis, making 
\begin_inset Formula $s''$
\end_inset

 legal as required.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:K-implies-view"

\end_inset

For situation terms 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

, and agent 
\begin_inset Formula $agt$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\, K(agt,s'',s)\,\rightarrow View(agt,s'')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the base case of 
\begin_inset Formula $Init(s)$
\end_inset

, using equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:new_k_s0"

\end_inset

, 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 implies that there must be an 
\begin_inset Formula $s'$
\end_inset

 such that 
\begin_inset Formula $Init(s')$
\end_inset

 and 
\begin_inset Formula $s'\leq_{\PbU(agt)}s''$
\end_inset

.
 Therefore 
\begin_inset Formula $View(s'')$
\end_inset

 = 
\begin_inset Formula $View(s')$
\end_inset

 = 
\begin_inset Formula $\epsilon$
\end_inset

 = 
\begin_inset Formula $View(s)$
\end_inset

 as required.
\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(c,s)$
\end_inset

 case, suppose 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

.
 Then we have 
\begin_inset Formula $View(agt,do(c,s))$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
= 
\begin_inset Formula $View(agt,s)$
\end_inset

, while equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:new_k_ssa"

\end_inset

 gives us 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

, which yields 
\begin_inset Formula $View(agt,s'')$
\end_inset

 = 
\begin_inset Formula $View(agt,s)$
\end_inset

 by the inductive hypothesis.
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $Obs(agt,c,s)\neq\{\}$
\end_inset

, then equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:new_k_ssa"

\end_inset

 gives us 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $c'$
\end_inset

 such that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $do(c',s')\leq_{\PbU(agt)}s''$
\end_inset

, 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

 = 
\begin_inset Formula $Obs(agt,c',s')$
\end_inset

, and 
\begin_inset Formula $K(agt,s',s)$
\end_inset

.
 By the inductive hypothesis 
\begin_inset Formula $View(agt,s')=View(agt,s)$
\end_inset

, and we have the following: 
\begin_inset Formula $View(agt,s'')$
\end_inset

 = 
\begin_inset Formula $View(agt,do(c',s'))$
\end_inset

 = 
\begin_inset Formula $Obs(agt,c,s)\cdot View(agt,s')$
\end_inset

 = 
\begin_inset Formula $View(agt,do(c,s))$
\end_inset

 as required.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:k_obs_equiv"

\end_inset

 For any agent 
\begin_inset Formula $agt$
\end_inset

 and situations 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s''$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models K(agt,s'',s)\equiv K(root(s''),root(s))\wedge Legal(s'')\wedge View(agt,s'')=View(agt,s)\]

\end_inset


\end_layout

\begin_layout Proof
For the 
\emph on
if
\emph default
 direction, we simply combine lemmas 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:K-implies-root"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:K-implies-legal"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:K-implies-view"

\end_inset

.
 For the 
\emph on
only-if
\emph default
 base case of 
\begin_inset Formula $Init(s)$
\end_inset

, the 
\begin_inset Formula $\exists s'$
\end_inset

 part of equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_s0"

\end_inset

) is trivially satisfied by 
\begin_inset Formula $root(s'')$
\end_inset

 and the equivalence holds as required.
\end_layout

\begin_layout Proof
For the 
\emph on
only-if
\emph default
 inductive case with 
\begin_inset Formula $do(c,s)$
\end_inset

, we have two sub-cases to consider.
 Suppose 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

: then 
\begin_inset Formula $View(agt,s'')$
\end_inset

 = 
\begin_inset Formula $View(agt,do(c,s))$
\end_inset

 = 
\begin_inset Formula $View(agt,s)$
\end_inset

 and 
\begin_inset Formula $K(agt,s'',s)$
\end_inset

 holds by the inductive hypothesis, satisfying the equivalence in equation
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

).
 
\end_layout

\begin_layout Proof
Alternately, suppose 
\begin_inset Formula $Obs(agt,c,s)\neq\{\}$
\end_inset

: then we have:
\begin_inset Formula \[
View(agt,do(c,s))=Obs(agt,c,s)\cdot View(agt,s)=View(agt,s'')\]

\end_inset

For this to be the case, and since 
\begin_inset Formula $s''$
\end_inset

 is legal, there must be some 
\begin_inset Formula $s'$
\end_inset

,
\begin_inset Formula $c'$
\end_inset

 satisfying 
\begin_inset Formula $Obs(agt,c',s')$
\end_inset

 = 
\begin_inset Formula $Obs(agt,c,s)$
\end_inset

, 
\begin_inset Formula $View(agt,s')$
\end_inset

 = 
\begin_inset Formula $View(agt,s)$
\end_inset

 and 
\begin_inset Formula $do(c',s')\leq_{\PbU(agt)}s''$
\end_inset

 .
 This is enough to satisfy the 
\begin_inset Formula $\exists s',a'$
\end_inset

 part of equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:new_k_ssa"

\end_inset

) and so the equivalence holds as required.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Reg_Knows"

\end_inset

 Given a basic action theory 
\begin_inset Formula $\Dt\cup\Dt_{K}^{obs}$
\end_inset

 and a uniform formula 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\phi[do(c,s)]\equiv\Reg(\phi,c)[s]\]

\end_inset

 
\end_layout

\begin_layout Proof
We need only consider applications of 
\begin_inset Formula $\Reg$
\end_inset

 when 
\begin_inset Formula $\phi$
\end_inset

 has the form 
\begin_inset Formula $\Knows(agt,\phi,s)$
\end_inset

, as other regression rules have not been modified.
 We must establish that our new regression rules in equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_s0"

\end_inset

 are equivalences under the theory of action 
\begin_inset Formula $\Dt\cup\Dt_{K}^{obs}$
\end_inset

.
\end_layout

\begin_layout Proof
For notational clarity we define the abbreviation 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s)$
\end_inset

 (for 
\begin_inset Quotes eld
\end_inset

persists under equivalent observations
\begin_inset Quotes erd
\end_inset

) which states that 
\begin_inset Formula $\phi$
\end_inset

 holds in all legal futures of 
\begin_inset Formula $s$
\end_inset

 compatible with observations 
\begin_inset Formula $o$
\end_inset

:
\begin_inset Formula \begin{multline*}
\mathbf{PEO}(agt,\phi,o,s)\,\isdef\,\\
\forall c':\, Obs(agt,c',s)=o\wedge Poss(c',s)\rightarrow\left[\forall s':\, do(c',s)\leq_{\PbU(agt)}s'\rightarrow\,\phi[s']\right]\end{multline*}

\end_inset

 Expanding the definition of the 
\begin_inset Formula $\Knows$
\end_inset

 macro at 
\begin_inset Formula $do(c,s)$
\end_inset

, and applying the successor state axiom from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:new_k_ssa"

\end_inset

 to the 
\begin_inset Formula $K(agt,s'',do(c,s))$
\end_inset

 term, we can produce the following:
\begin_inset Formula \begin{align*}
\Knows(agt,\phi,do(c,s))\equiv\, & \forall s'':\, K(agt,s'',do(c,s))\,\rightarrow\,\phi[s'']\\
\equiv\, & \exists o\,.\, Obs(agt,c,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\forall s':\, K(agt,s',s)\rightarrow\phi[s']\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\forall s':\, K(agt,s',s)\rightarrow\mathbf{PEO}(agt,\phi,o,s')\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Proof
Noting that both conjuncts contain sub-formulae matching the form of the
 
\begin_inset Formula $\Knows$
\end_inset

 macro, it can be substituted back in to give:
\begin_inset Formula \begin{align*}
\mathbf{Knows}(agt,\phi,do(c,s))\equiv\, & \exists o\,.\, Obs(agt,c,s)=o\\
 & \wedge\,\left[o=\{\}\rightarrow\mathbf{Knows}(agt,\phi,s)\right]\\
 & \wedge\,\left[o\neq\{\}\rightarrow\mathbf{Knows}(agt,\mathbf{PEO}(agt,\phi,o,s'),s)\right]\end{align*}

\end_inset

 
\end_layout

\begin_layout Proof
For 
\begin_inset Formula $\mathbf{PEO}(agt,\phi,o,s')$
\end_inset

 to legitimately appear inside the 
\begin_inset Formula $\mathbf{Knows}$
\end_inset

 macro it must be uniform in the situation variable 
\begin_inset Formula $s'$
\end_inset

.
 Applying the persistence condition and regressing to make the expression
 uniform, we develop the following equivalence:
\begin_inset Formula \[
\mathbf{PEO}(agt,\phi,o,s)\equiv\forall c':\, Obs(agt,c',s)=o\wedge Poss(c',s)\rightarrow\mathcal{R}_{\mathcal{D}}(\mathcal{P}_{\mathcal{D}}(\phi,\PbU(agt)),c')\]

\end_inset

 
\end_layout

\begin_layout Proof
Suppressing the situation term in this uniform formula gives the regression
 rule from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 as required.
\end_layout

\begin_layout Proof
For 
\begin_inset Formula $S_{0}$
\end_inset

, a straightforward transformation of equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:knows_def"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:new_k_s0"

\end_inset

 gives:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\left[\forall s'\,.\, s\leq_{\PbU(agt)}s'\rightarrow\phi[s']\right]\]

\end_inset

 Applying the persistence condition operator, this can easily be re-written
 as:
\begin_inset Formula \[
\mathbf{Knows}(agt,\phi,S_{0})\equiv\forall s\,.\, K_{0}(agt,s,S_{0})\rightarrow\Pst(\phi,\PbU(agt))[s]\]

\end_inset


\end_layout

\begin_layout Proof
This matches the form of the definition for 
\begin_inset Formula $\KnowsZ$
\end_inset

, which we can substitute in to give:
\begin_inset Formula \[
\Knows(agt,\phi,S_{0})\equiv\KnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Proof
This is the regression rule from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_s0"

\end_inset

 as required.
 Our modified regression rules are thus equivalences under the theory 
\begin_inset Formula $\Dt\cup\Dt_{K}^{obs}$
\end_inset

, and the theorem holds.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:TrnA_works"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models\,\KDo(\pi,do(c,s),s'')\,\equiv\,\exists\mu,\mu',c',s':\\
\mu(x)=c\wedge\mu'(x)=c'\wedge\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDo(\Trn_{a}(\pi,x),\mu,s,\mu',s')\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Proceed by cases, covering each path operator in turn.
 For the base case of an individual agent, we have:
\begin_inset Formula \begin{align*}
\KDo(\pi,do(c,s),s'')\,\equiv\, & K_{0}(agt,s'',do(c,s))\end{align*}

\end_inset


\begin_inset Formula \[
\TrnA(agt,x)\Rightarrow\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\]

\end_inset

Expanding 
\begin_inset Formula $\KDo(\TrnA(agt,x),\mu,s,\mu',s')$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 thus produces:
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Formula \begin{multline*}
\KDo(\TrnA(agt,x),\mu,s,\mu',s')\equiv\exists z:\, Obs(agt,\mu(x),s)=z\,\wedge\,\exists s'':\, K_{0}(agt,s'',s)\,\wedge\\
\left(Poss(\mu'(x),s'')\vee\mu'(x)=\{\}\right)\,\wedge\, Obs(agt,\mu'(x),s'')=z\,\wedge\, s''=s'\end{multline*}

\end_inset

Note that 
\begin_inset Formula $\mu$
\end_inset

 and 
\begin_inset Formula $\mu'$
\end_inset

 are never applied to a variable other than 
\begin_inset Formula $x$
\end_inset

.
 When we substitute this into the RHS of the hypothesis, 
\begin_inset Formula $\mu(x)$
\end_inset

 and 
\begin_inset Formula $\mu'(x)$
\end_inset

 are asserted to be 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $c'$
\end_inset

 respectively, so they can be simplified away to give:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models K(agt,s'',do(c,s))\equiv\exists c',s':\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\\
\wedge K_{0}(agt,s,s')\,\wedge\,\left(Poss(c',s')\vee c'=\{\}\right)\wedge\, Obs(agt,c,s)=Obs(agt,c',s')\end{multline*}

\end_inset

This is the successor state axiom for 
\begin_inset Formula $K_{0}$
\end_inset

, which is trivially entailed by the domain.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $?\phi$
\end_inset

 case, we have:
\begin_inset Formula \[
\KDo(?\phi,do(c,s),s'')\equiv\phi[do(c,s)]\wedge s''=do(c,s)\]

\end_inset


\begin_inset Formula \[
\TrnA(?\phi,x)\Rightarrow?\Reg(\phi,x)\]

\end_inset


\end_layout

\begin_layout Proof
Giving:
\begin_inset Formula \[
\KDo(\TrnA(?\phi,x),\mu,s,\mu',s')\equiv\Reg(\phi,x)[s]\wedge s=s'\wedge\mu=\mu'\]

\end_inset

Substituting into the RHS of the hypothesis, this asserts that 
\begin_inset Formula $c=c'$
\end_inset

 and hence 
\begin_inset Formula $s''=do(c,s)$
\end_inset

, so the hypothesis is clearly entailed.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Proof
The case for 
\begin_inset Formula $\exists y$
\end_inset

 is trivial as 
\begin_inset Formula $\KDo(\exists y,s,s')\equiv s=s'$
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Proof
The inductive cases are straightforward as 
\begin_inset Formula $\Trn_{a}$
\end_inset

 is simply pushed inside each operator.
 We will take the 
\begin_inset Formula $\pi^{*}$
\end_inset

 case as an example.
 The inductive hypothesis gives us:
\begin_inset Formula \begin{multline*}
\KDo(\pi,do(c,s),s'')\,\equiv\exists\mu,\mu',c',s':\\
\mu(x)=c\wedge\mu'(x)=c'\wedge\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDo(\Trn_{a}(\pi,x),\mu,s,\mu,'s')\end{multline*}

\end_inset

We can apply 
\begin_inset Formula $RTC$
\end_inset

 to both sides of this equivalence, along with two rearrangements: the LHS
 is expanded to put 
\begin_inset Formula $\exists\mu,\mu''$
\end_inset

 at its front, and the rigid tests on the RHS are taken outside the 
\begin_inset Formula $RTC$
\end_inset

 operation.
 The result is:
\begin_inset Formula \begin{multline}
\exists\mu,\mu'':\, RTC[\KDo(\pi,\mu,do(c,s),\mu'',s'')]\,\equiv\\
\exists\mu,\mu',c',s':\,\mu(x)=c\wedge\mu'(x)=c'\wedge s''=do(c',s')\wedge RTC[\KDo(\Trn_{a}(\pi,x),\mu,s,\mu,'s')]\label{eq:rtc-inductive-hyp}\end{multline}

\end_inset

Using the definitions of 
\begin_inset Formula $\KDo$
\end_inset

 and 
\begin_inset Formula $\TrnA$
\end_inset

 we have:
\begin_inset Formula \[
\KDo(\pi^{*},do(c,s),s'')\equiv\exists\mu,\mu'':\, RTC[\KTrans(\pi,\mu,do(c,s),\mu'',s'')]\]

\end_inset


\begin_inset Formula \[
\KDo(\TrnA(\pi^{*},x),\mu,s,\mu',s')\equiv RTC[\KDo(\TrnA(\pi,x),\mu,s,\mu',s')]\]

\end_inset

Substituting these into the 
\begin_inset Formula $RTC$
\end_inset

 of the inductive hypothesis from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:rtc-inductive-hyp"

\end_inset

 completes the proof.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models\,\KDo(\pi,do(c,s),s'')\,\equiv\\
\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDo(\Trn(\pi,c,c'),s,s')\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Recall the rule for 
\begin_inset Formula $\Trn(\pi,c,c')$
\end_inset

:
\begin_inset Formula \[
\Trn(\pi,c,c')\Rightarrow\exists x\,;\,?x=c\,;\,\TrnA(\pi,x)\,;\,?x=c'\]

\end_inset

Expanding 
\begin_inset Formula $\KDo$
\end_inset

 for this rule:
\begin_inset Formula \[
\KDo(\Trn(\pi,c,c'),s,s')\equiv\exists\mu,\mu':\,\mu(x)=c\,\wedge\mu'(x)=c'\wedge\KDo(\TrnA(\pi,x),\mu,s,\mu',s')\]

\end_inset

We can thus substitute 
\begin_inset Formula $\KDo(\Trn(\pi,c,c'),s,s')$
\end_inset

 into the RHS of Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:TrnA_works"

\end_inset

 to get the required result.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Reg_PKnowsZ"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action 
\begin_inset Formula $c$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
This mechanics of this proof mirror that of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Reg_Knows"

\end_inset

: we expand the 
\begin_inset Formula $\PKnowsZ$
\end_inset

 macro, apply Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 as a successor state axiom for 
\begin_inset Formula $\KDo$
\end_inset

, re-arrange to eliminate existential quantifiers, then collect terms back
 into forms that match 
\begin_inset Formula $\PKnowsZ$
\end_inset

.
 We begin with the following:
\begin_inset Formula \begin{align*}
\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\, & \forall s'':\,\KDo(\pi,do(c,s),s'')\,\rightarrow\,\phi[s'']\\
\equiv\,\, & \forall s'':\,\left[\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\left.\wedge\KDo(\Trn(\pi,c,c'),s,s')\right]\rightarrow\,\phi[s'']\\
\equiv\,\, & \forall s'',c',s':\,\left[\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\left.\wedge\KDo(\Trn(\pi,c,c'),s,s')\right]\rightarrow\,\phi[s'']\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Case-splitting on the disjunction, we see that:
\begin_inset Formula \begin{gather*}
s''=do(c',s')\,\rightarrow\,\left(\phi[s'']\equiv\Reg(\phi,c')[s']\right)\end{gather*}

\end_inset


\begin_inset Formula \[
s''=s'\wedge c'=\{\}\,\rightarrow\,\left(\phi[s'']\equiv\Reg(\phi,c')[s']\right)\]

\end_inset


\end_layout

\begin_layout Proof
This allows us to remove the variable 
\begin_inset Formula $s''$
\end_inset

 from the consequent of the implication, making it redundant in the antecedent
 and allowing us to eliminate it entirely.
 Folding the quantification over 
\begin_inset Formula $s'$
\end_inset

 back into the 
\begin_inset Formula $\PKnowsZ$
\end_inset

 macro completes the proof:
\begin_inset Formula \begin{align*}
\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\, & \forall s'',c',s':\,\left[\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\right.\\
 & \,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\left.\wedge\KDo(\Trn(\pi,c,c'),s,s')\right]\rightarrow\,\Reg(\phi,c')[s']\\
\equiv\,\, & \forall c',s':\,\KDo(\Trn(\pi,c,c'),s,s')\,\rightarrow\,\Reg(\phi,c')[s']\\
\equiv\,\, & \forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:KDo_E1_impl_KDo"

\end_inset

For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\KDo(\Trn(\pi,\{\},\{\}),s,s')\,\rightarrow\,\KDo(\pi,s,s')\]

\end_inset


\end_layout

\begin_layout Proof
By a case analysis on the epistemic path operators.
 For the base case of an individual agent, we have:
\begin_inset Formula \begin{align*}
\Trn(agt,\{\},\{\})\,=\, & \exists x\,;\,?x=\{\}\,;\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\\
 & \,\,\,\,\,\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,\,?Obs(agt,x_{a})=z\,;\,?x=\{\}\\
=\, & \exists z\,;\,?z=\{\}\,;\, agt\,;\,?Poss(\{\})\vee\{\}=\{\}\,;\,?z=\{\}\\
=\, & agt\end{align*}

\end_inset


\end_layout

\begin_layout Proof
So the hypothesis is clearly entailed.
 For the 
\begin_inset Formula $?\phi$
\end_inset

 case:
\begin_inset Formula \begin{align*}
\Trn(?\phi,\{\},\{\})= & \exists x\,;\,?x=\{\}\,;\,?\Reg(\phi,x)\,;\,?x=\{\}\\
= & ?\Reg(\phi,\{\})\\
= & ?\phi\end{align*}

\end_inset


\end_layout

\begin_layout Proof
So the hypothesis is clearly entailed.
 For the 
\begin_inset Formula $\exists z$
\end_inset

 case:
\begin_inset Formula \begin{align*}
\Trn(\exists z,\{\},\{\})= & \exists x\,;\,?x=\{\}\,;\,\exists z\,;\,?x=\{\}\\
= & \exists z\end{align*}

\end_inset


\end_layout

\begin_layout Proof
So the hypothesis is clearly entailed.
 The inductive cases are then straightforward, by choosing 
\begin_inset Formula $x=\{\}$
\end_inset

 uniformly whenever 
\begin_inset Formula $\exists x$
\end_inset

 is encountered in the translated path.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:En_impl_En-1"

\end_inset

 For any epistemic path 
\begin_inset Formula $\pi$
\end_inset

: 
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\PKnowsZ(\pi,\phi,s)\]

\end_inset


\end_layout

\begin_layout Proof
Expanding the macros, we have:
\begin_inset Formula \[
\left(\forall s'':\,\KDo(\pi,do(\{\},s),s'')\rightarrow\phi[s'']\right)\,\,\rightarrow\,\,\left(\forall s':\,\KDo(\pi,s,s')\rightarrow\phi[s']\right)\]

\end_inset


\end_layout

\begin_layout Proof
Using equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Trn-respects-epi-paths"

\end_inset

 on the LHS gives:
\begin_inset Formula \begin{multline*}
\left(\forall s'':\,\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\right.\\
\left.\wedge\KDo(\Trn(\pi,\{\},c'),s,s')\rightarrow\phi[s'']\right)\,\,\rightarrow\,\,\left(\forall s':\,\KDo(\pi,s,s')\rightarrow\phi[s']\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
This implication must hold individually for each disjunct in the antecedent.
 We can thus break out the 
\begin_inset Formula $c'=\{\}$
\end_inset

 case to obtain:
\begin_inset Formula \begin{multline*}
\left(\forall s'':\,\exists c',s':\, s''=s'\wedge c'=\{\}\wedge\KDo(\Trn(\pi,\{\},c'),s,s')\rightarrow\phi[s'']\right)\,\,\rightarrow\\
\left(\forall s':\,\KDo(\pi,s,s')\rightarrow\phi[s']\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Simplifying away the variables 
\begin_inset Formula $s''$
\end_inset

 and 
\begin_inset Formula $c'$
\end_inset

 gives:
\begin_inset Formula \[
\left(\forall s':\,\KDo(\Trn(\pi,\{\},\{\}),s,s')\rightarrow\phi[s']\right)\,\,\rightarrow\,\,\left(\forall s':\,\KDo(\pi,s,s')\rightarrow\phi[s']\right)\]

\end_inset


\end_layout

\begin_layout Proof
This implication is a trivial consequence of lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:KDo_E1_impl_KDo"

\end_inset

, so the theorem holds.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Pknows_PbU_S0"

\end_inset

 For any 
\begin_inset Formula $agt$
\end_inset

 and 
\begin_inset Formula $\phi$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows(agt,\phi,S_{0})\,\equiv\,\PKnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Proof
Recall the definition of 
\begin_inset Formula $\PKnows$
\end_inset

:
\begin_inset Formula \[
\PKnows(agt,\phi,S_{0})\,\isdef\,\PKnowsZ(agt,\phi,\mathcal{E}^{\infty}(S_{0}))\]

\end_inset

Begin by considering the sequence of calculations required to calculate
 the regression of 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(S_{0}))$
\end_inset

.
 First, we perform some simplification on 
\begin_inset Formula $\Trn(agt,\{\},c')$
\end_inset

:
\begin_inset Formula \begin{align*}
\Trn(agt,\{\},c')=\,\,\, & \exists x\,;\,?x=\{\}\,;\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\\
 & \,\,\,\,\,\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,\,?Obs(agt,x)=z\,;\,?x=c'\\
=\,\,\, & \exists z\,;\,?Obs(agt,\{\})=z\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?Obs(agt,c')=z\\
=\,\,\, & agt\,;\,?Obs(agt,c')=\{\}\wedge\left(Poss(c')\vee c'=\{\}\right)\\
=\,\,\, & agt\,;\,?\left(\PbU(agt,c')\vee c'=\{\}\right)\end{align*}

\end_inset

 Now we can use this in the regression of 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{1}(S_{0}))$
\end_inset

, as follows: 
\begin_inset Formula \begin{align*}
\PKnowsZ(agt,\phi,\mathcal{E}^{1}(S_{0}))\equiv\,\, & \Reg(\PKnows_{0}(agt,\phi,do(\{\},S_{0})))\\
\equiv\,\, & \forall c':\,\PKnowsZ(\Trn(agt,\{\},c'),\Reg(\phi,c'),S_{0})\\
\equiv\,\, & \forall c':\,\PKnowsZ(agt\,;\,?\left(\PbU(agt,c')\vee c'=\{\}\right),\Reg(\phi,c'),S_{0})\\
\equiv\,\, & \PKnowsZ(agt,\forall c':\,\left(\PbU(agt,c')\vee c'=\{\}\right)\rightarrow\Reg(\phi,c'),S_{0})\\
\equiv\,\, & \PKnowsZ(agt,\phi\,\wedge\,\forall c':\, PbU(agt,c')\rightarrow\Reg(\phi,c'),S_{0})\\
\equiv\,\, & \PKnowsZ(agt,\Pst^{1}(\phi,\PbU(agt)),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Using the same construction, we can show that in general:
\begin_inset Formula \begin{align*}
\PKnowsZ(agt,\phi,\mathcal{E}^{n}(S_{0}))\equiv\,\, & \PKnowsZ(agt,\Pst^{1}(\phi,\PbU(agt)),\mathcal{E}^{n-1}(S_{0}))\\
\equiv\,\, & \PKnowsZ(agt,\Pst^{n}(\phi,\PbU(agt)),S_{0})\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Clearly the fixpoint calculation used to find 
\begin_inset Formula $\PKnowsZ$
\end_inset

 at 
\begin_inset Formula $\mathcal{E}^{\infty}$
\end_inset

 is the same as the fixpoint calculation used to find 
\begin_inset Formula $\Pst(\phi,\PbU(agt))$
\end_inset

.
 Therefore, we have the required:
\begin_inset Formula \[
\PKnows(agt,\phi,S_{0})\,\equiv\,\PKnowsZ(agt,\Pst(\phi,\PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Pknows_PbU_do"

\end_inset

 For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

, 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\left[z=\{\}\,\rightarrow\,\PKnows(agt,\Pst(\phi,\PbU(agt)),s)\right]\\
\wedge\,\left[z\neq\{\}\,\rightarrow\,\PKnows(agt,\forall c':\,\left(Poss(c')\wedge Obs(agt,c')=z\right)\rightarrow\Reg(\Pst(\phi,\PbU(agt)),c),s)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Repeating the calculations from Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Pknows_PbU_S0"

\end_inset

 on 
\begin_inset Formula $\PKnowsZ(agt,\phi,\mathcal{E}^{\infty}(do(c,s)))$
\end_inset

, and pushing the application of 
\begin_inset Formula $\mathcal{E}^{\infty}$
\end_inset

 past the actions 
\begin_inset Formula $c$
\end_inset

, we obtain the following:
\begin_inset Formula \[
\PKnows(agt,\phi,do(c,s))\,\equiv\,\PKnowsZ(agt,\Pst(\phi,\PbU(agt)),do(c,\mathcal{E}^{\infty}(s)))\]

\end_inset


\end_layout

\begin_layout Proof
Regressing the RHS over the actions 
\begin_inset Formula $c$
\end_inset

, we obtain:
\begin_inset Formula \begin{align*}
\PKnows(agt,\phi,do(c,s))\,\equiv & \forall c':\,\PKnowsZ(\Trn(agt,c,c'),\Reg(\Pst(\phi,\PbU(agt)),c'),\mathcal{E}^{\infty}(s))\\
\equiv & \forall c':\,\PKnows(\Trn(agt,c,c'),\Reg(\Pst(\phi,\PbU(agt)),c'),s)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Now, let us expand and re-arrange 
\begin_inset Formula $\Trn(agt,c,c')$
\end_inset

:
\begin_inset Formula \begin{align*}
\Trn(agt,c,c')=\,\,\, & \exists x\,;\,?x=c\,;\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\\
 & \,\,\,\,\,\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,\,?Obs(agt,x_{a})=z\,;\,?x=c'\\
=\,\,\, & \exists z\,;\,?Obs(agt,c)=z\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?Obs(agt,c')=z\\
=\,\, & \exists z\,;\,?Obs(agt,c)=z\,;\\
 & \,\,\,\,\,\,\left(z=\{\}\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?Obs(agt,c')=\{\}\right)\\
 & \,\,\,\cup\left(z\neq\{\}\,;\, agt\,;\,?Poss(c')\vee c'=\{\}\,;\,?Obs(agt,c')=z\right)\\
=\,\, & \exists z\,;\,?Obs(agt,c)=z\,;\,\left(z=\{\}\,;\, agt\,;\,?c'=\{\}\right)\\
 & \,\,\,\cup\left(z=\{\}\,;\, agt\,;\,?PbU(agt,c')\right)\\
 & \,\,\,\cup\left(z\neq\{\}\,;\, agt\,;\,?Poss(c')\wedge Obs(agt,c')=z\right)\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Substituting this back into the RHS, we can bring the leading tests outside
 the macro and split the 
\begin_inset Formula $\cup$
\end_inset

 into a conjunction to give:
\begin_inset Formula \begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\forall c':\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\PKnows(\left(?z=\{\};\, agt\right),\Reg(\Pst(\phi,\PbU(agt)),\{\}),s)\\
\wedge\,\PKnows(\left(?z=\{\};agt;?PbU(agt,c')\right),\Reg(\Pst(\phi,\PbU(agt)),c'),s)\\
\wedge\,\PKnows(\left(?z\neq\{\};agt;?Poss(c')\wedge Obs(agt,c')=z\right),\Reg(\Pst(\phi,\PbU(agt)),c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Extracting the remaining tests from these paths, removing regression over
 the empty action, and pushing the quantification over 
\begin_inset Formula $c'$
\end_inset

 into its narrowest scope, we get:
\begin_inset Formula \begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\left[z=\{\}\rightarrow\PKnows(agt,\Pst(\phi,\PbU(agt)),s)\right]\\
\wedge\,\left[z=\{\}\rightarrow\PKnows(agt,\forall c':\, PbU(agt,c')\,\rightarrow\,\Reg(\Pst(\phi,\PbU(agt)),c'),s)\right]\\
\wedge\,\left[z\neq\{\}\rightarrow\PKnows(agt,\forall c':\left(Poss(c')\wedge Obs(agt,c')=z\right)\rightarrow\Reg(\Pst(\phi,\PbU(agt)),c'),s)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
To complete the proof, we need the following property of the persistence
 condition, which follows directly from its definition:
\begin_inset Formula \[
\Dt\,\models\,\left(\forall c:\,\alpha(c,s)\rightarrow\Reg(\Pst(\phi,\alpha),c)[s]\right)\,\equiv\,\Pst(\phi,\alpha)[s]\]

\end_inset


\end_layout

\begin_layout Proof
Using this we see that the two 
\begin_inset Formula $z=\{\}$
\end_inset

 clauses are equivalent, and we can drop the more complicated one to get
 the theorem as required.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout TheoremExt
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Knows_impl_KnowsPbU"

\end_inset

 For any 
\begin_inset Formula $agt$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\equiv\,\Knows(agt,\Pst(\phi,PbU(agt)),s)\]

\end_inset


\end_layout

\begin_layout Proof
By induction on the regression rules for knowledge, and using the following
 properties of the persistence condition:
\begin_inset Formula \[
\forall s':\,\Pst(\phi,\alpha)[s]\,\wedge\, s\leq_{\alpha}s'\,\rightarrow\,\Pst(\phi,\alpha)[s']\]

\end_inset


\begin_inset Formula \[
\Pst(\Pst(\phi,\alpha),\alpha)[s]\,\equiv\,\Pst(\phi,\alpha)[s]\]

\end_inset


\end_layout

\begin_layout Proof
For 
\begin_inset Formula $s=S_{0}$
\end_inset

 the regression rule in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_s0"

\end_inset

 gives us the following equivalence:
\begin_inset Formula \begin{align*}
\Knows(agt,\phi,S_{0})\equiv & \KnowsZ(agt,\Pst(\phi,PbU(agt)),S_{0})\\
\equiv & \forall s':\, K_{0}(agt,s',S_{0})\,\rightarrow\,\Pst(\phi,PbU(agt))[s']\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Which, by the above properties of 
\begin_inset Formula $\Pst$
\end_inset

, yields:
\begin_inset Formula \[
\Knows(agt,\phi,S_{0})\equiv\forall s',s'':\, K_{0}(agt,s',S_{0})\wedge s'\leq_{PbU(agt)}s''\,\rightarrow\,\Pst(\phi,PbU(agt))[s'']\]

\end_inset


\end_layout

\begin_layout Proof
This matches the form of the 
\begin_inset Formula $\Knows$
\end_inset

 macro, and can be restructured to give the required:
\begin_inset Formula \[
\Knows(agt,\phi,S_{0})\,\equiv\,\Knows(agt,\Pst(\phi,PbU(agt)),S_{0})\]

\end_inset


\end_layout

\begin_layout Proof
For the 
\begin_inset Formula $do(c,s)$
\end_inset

 the inductive hypothesis gives us:
\begin_inset Formula \[
\Knows(agt,\phi,s)\equiv\Knows(agt,\Pst(\phi,PbU(agt)),s)\]

\end_inset


\end_layout

\begin_layout Proof
We have two sub-cases to consider.
 If 
\begin_inset Formula $Obs(agt,c,s)=\{\}$
\end_inset

 then the regression rule in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:R_do_c_s"

\end_inset

 gives us:
\begin_inset Formula \[
\Knows(agt,\phi,do(c,s))\equiv\Knows(agt,\phi,s)\]

\end_inset


\begin_inset Formula \[
\Knows(agt,\Pst(\phi,PbU(agt)),do(c,s))\equiv\Knows(agt,\Pst(\phi,PbU(agt)),s)\]

\end_inset


\end_layout

\begin_layout Proof
These can be directly equated using the inductive hypothesis, so the theorem
 holds in this case.
 Alternately, if 
\begin_inset Formula $Obs(agt,c,s)\neq\{\}$
\end_inset

 then the regression rule gives us:
\begin_inset Formula \begin{multline*}
\Knows(agt,\phi,do(c,s))\equiv\exists o:\, Obs(agt,c,s)=o\,\wedge\\
\Knows(agt,\forall c':\, Poss(c')\wedge Obs(agt,c')=o\,\rightarrow\,\Reg(\Pst(\phi,PbU(agt)),c'),s)\end{multline*}

\end_inset


\begin_inset Formula \begin{multline*}
\Knows(agt,\Pst(\phi,PbU(agt)),do(c,s))\equiv\exists o:\, Obs(agt,c,s)=o\,\wedge\\
\Knows(agt,\forall c':\, Poss(c')\wedge Obs(agt,c')=o\,\rightarrow\,\Reg(\Pst(\Pst(\phi,PbU(agt)),PbU(agt)),c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Simplifying the second equation using the properties of 
\begin_inset Formula $\Pst$
\end_inset

 gives:
\begin_inset Formula \begin{multline*}
\Knows(agt,\Pst(\phi,PbU(agt)),do(c,s))\equiv\exists o:\, Obs(agt,c,s)=o\,\wedge\\
\Knows(agt,\forall c':\, Poss(c')\wedge Obs(agt,c')=o\,\rightarrow\,\Reg(\Pst(\phi,PbU(agt)),c'),s)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Which matches the equivalence for 
\begin_inset Formula $\Knows(agt,\phi,do(c,s))$
\end_inset

, so the theorem holds.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../../../library/references"
options "theapa"

\end_inset


\end_layout

\end_body
\end_document
