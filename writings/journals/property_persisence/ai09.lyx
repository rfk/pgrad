#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass tech-elsarticle
\begin_preamble
\usepackage{algorithm}
\usepackage{algorithmic}

\journal{Artificial Intelligence}
\end_preamble
\options preprint,12pt
\use_default_options true
\language british
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isdef}{\stackrel{\mbox{\tiny def}}{=}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\Dt}{\mathcal{D}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\Reg}{\mathcal{R}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\Pst}{\mathcal{P}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\vars}[1]{\bar{#1}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\PstD}{\Pst_{\Dt}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\PstDI}{\Pst_{\Dt}^{1}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\Lsit}{\mathcal{L}_{sitcalc}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Knows}{\mathbf{Knows}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
author{Ryan F.
 Kelly}
\end_layout

\begin_layout Plain Layout


\backslash
ead{rfk@csse.unimelb.edu.au}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
author{Adrian R.
 Pearce}
\end_layout

\begin_layout Plain Layout


\backslash
ead{adrian@csse.unimelb.edu.au}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
address{Department of Computer Science and Software Engineering}
\end_layout

\begin_layout Plain Layout


\backslash
address{The University of Melbourne} 
\end_layout

\begin_layout Plain Layout


\backslash
address{Victoria, 3010, Australia}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Property Persistence in the Situation Calculus
\end_layout

\begin_layout Abstract
We develop a new automated reasoning technique for the situation calculus
 that can handle queries containing universal quantification over situation
 terms.
 The situation calculus defines such quantification using a second-order
 induction axiom, making automated reasoning difficult for such queries.
 We show how to reduce queries about property persistence, a common family
 of universally-quantified query, to an equivalent form that does not quantify
 over situations.
 The algorithm for doing so utilizes only first-order reasoning.
 We give several examples of important reasoning tasks that are facilitated
 by our approach, including checking for goal impossibility and reasoning
 about knowledge with partial observability of actions.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 has long been one of the most popular formalisms for reasoning about dynamic
 worlds.
 It has more recently become a popular choice for 
\emph on
implementing
\emph default
 systems situated in a dynamic world, as it offers, among other advantages:
 a formalism based in first-order logic; an elegant monotonic solution to
 the frame problem; and an effective reasoning procedure for the projection
 problem 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter91frameprob"

\end_inset

.
 Coupled with logic programming languages such as Prolog, it has facilitated
 the implementation of a wide range of systems [TODO: refs].
\end_layout

\begin_layout Standard
A crucial consideration for applications of the situation calculus is whether
 queries can be restricted to forms that are amenable to automated reasoning.
 The foundational axioms of the situation calculus include an induction
 axiom to define the structure of situations terms, so answering arbitrary
 queries requires reasoning in second-oder logic 
\begin_inset CommandInset citation
LatexCommand citep
key "Reiter93proving"

\end_inset

.
 Much of the work on implementing systems with the situation calculus has
 been on reducing the number of axioms required to answer a given query,
 to allow more efficient reasoning - for example, queries that contain only
 
\emph on
existential
\emph default
 quantification over situation terms can be answered using only first-order
 logic.
 
\end_layout

\begin_layout Standard
Unfortunately there are many reasoning tasks that require universal quantificati
on over situations.
 One of the most basic is determining that a goal is impossible -- this
 is equivalent to stating that for all situations, the goal formula does
 not hold.
 In this paper we are interested in a subset of universally-quantified queries
 which we refer to as 
\emph on
persistence queries
\emph default
: under a particular situation calculus theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, and given some property 
\begin_inset Formula $\phi$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, determine whether 
\begin_inset Formula $\phi$
\end_inset

 will hold in all situations in the future of 
\begin_inset Formula $\sigma$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\forall s:\,\sigma\sqsubseteq s\,\rightarrow\,\phi[s]\]

\end_inset

The need for second-order logic has traditionally limited automated reasoning
 about such queries.
 We introduce a new approach that is similar in spirit to the regression
 operator of 
\begin_inset CommandInset citation
LatexCommand cite
key "reiter91frameprob"

\end_inset

: define an operator that transforms a formula 
\begin_inset Formula $\phi$
\end_inset

 into a formula 
\begin_inset Formula $\PstD(\phi)$
\end_inset

, such that 
\begin_inset Formula $\phi$
\end_inset

 persists at 
\begin_inset Formula $\sigma$
\end_inset

 if and only if 
\begin_inset Formula $\PstD(\phi)$
\end_inset

 holds at 
\begin_inset Formula $\sigma$
\end_inset

.
 We term this the 
\emph on
persistence condition
\emph default
 of 
\begin_inset Formula $\phi$
\end_inset

, and show how to calculate it in a form suitable for effective automated
 reasoning.
\end_layout

\begin_layout Standard
To determine 
\begin_inset Formula $\PstD(\phi)$
\end_inset

, we first define an operator 
\begin_inset Formula $\PstDI(\phi)$
\end_inset

 that holds at 
\begin_inset Formula $\sigma$
\end_inset

 whenever 
\begin_inset Formula $\phi$
\end_inset

 holds at 
\begin_inset Formula $\sigma$
\end_inset

 and all its immediate successors.
 The persistence condition is shown to be a fixpoint of this operator, which
 can be sought using a straightforward iterative algorithm.
 The resulting formula can then be used in combination with standard regression-
based reasoning techniques, allowing the inductive component of the reasoning
 to be 
\begin_inset Quotes eld
\end_inset

factored out
\begin_inset Quotes erd
\end_inset

 and approached using a special-purpose reasoning algorithm.
 The technique is sound and complete, and provably terminates in several
 interesting cases.
\end_layout

\begin_layout Standard
A preliminary version of this paper as appeared in 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

; this revised edition includes extended and additional proofs, a more comprehen
sive discussion of the termination properties of our algorithm, and a detailed
 example of our technique in action.
\end_layout

\begin_layout Standard
The paper is organised as follows: after some background material on the
 situation calculus in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Background"

\end_inset

, we formally define the class of property persistence queries in Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Definitions"

\end_inset

, along with several examples of practical queries that are of this form.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Condition"

\end_inset

 defines the persistence condition operator and demonstrates that it is
 equivalent to the result of a meta-level fixpoint calculation.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Calculating"

\end_inset

 presents a simple iterative algorithm for calculating the persistence condition
, and discusses its correctness, completeness, and effectiveness.
 We conclude with some general discussion in Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Conclusion"

\end_inset

.
\end_layout

\begin_layout Section
The Situation Calculus
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Background"

\end_inset


\end_layout

\begin_layout Standard
The situation calculus is a powerful formalism for describing and reasoning
 about dynamic worlds.
 It was first introduced by 
\begin_inset CommandInset citation
LatexCommand citet
key "McCHay69sitcalc"

\end_inset

 and has since been significantly expanded and formalised 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter91frameprob,pirri99contributions_sitcalc"

\end_inset

.
 We use the particular variant due to Reiter et.
 al.
 at the University of Toronto, sometimes called the 
\begin_inset Quotes eld
\end_inset

Toronto school
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

situations-as-histories
\begin_inset Quotes erd
\end_inset

 version.
 The formalisation below is based on the standard definitions from 
\begin_inset CommandInset citation
LatexCommand citep
key "levesque98sc_foundations,pirri99contributions_sitcalc,reiter01kia"

\end_inset

, with some conservative extensions.
\end_layout

\begin_layout Standard
Readers familiar with the situation calculus should note some modified notation:
 the unique names axioms 
\begin_inset Formula $\Dt_{una}$
\end_inset

 are incorporated into a general background theory 
\begin_inset Formula $\Dt_{bg}$
\end_inset

; the 
\begin_inset Formula $Poss$
\end_inset

 fluent is subsumed by a general class of 
\emph on
action description predicates
\emph default
 defined in 
\begin_inset Formula $\Dt_{ad}$
\end_inset

; we parameterise the 
\begin_inset Quotes eld
\end_inset

future situations
\begin_inset Quotes erd
\end_inset

 predicate 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 to assert that all intermediate actions satisfy a given predicate using
 
\begin_inset Formula $s<_{\alpha}s'$
\end_inset

; and we use the single-step variant of the regression operator, with correspond
ing definitions of regressable formulae.
\end_layout

\begin_layout Subsection
Notation and Axioms
\begin_inset CommandInset label
LatexCommand label
name "sec:Background:SC:Notation"

\end_inset


\end_layout

\begin_layout Standard
The language 
\begin_inset Formula $\Lsit$
\end_inset

 of the situation calculus is a many-sorted language of first-order logic
 with equality, augmented with a second-order induction axiom, containing
 the following disjoint sorts:
\end_layout

\begin_layout Itemize

\emph on
\noun on
Action
\emph default
\noun default
 terms denote individual instantaneous events that can cause the state of
 the world to change; 
\end_layout

\begin_layout Itemize

\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\end_layout

\begin_layout Itemize

\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\end_layout

\begin_layout Standard

\emph on
Fluents
\emph default
 are predicates or functions that represent properties of the world that
 may change between situations, and so take a situation term as their final
 argument.
 Predicates and functions that do not take a situation term are called 
\emph on
rigid
\emph default
.
 We use the term 
\emph on
primitive fluent
\emph default
 to describe fluents that are directly affected by actions, rather than
 being defined in terms of other fluents.
 No functions other than 
\begin_inset Formula $S_{0}$
\end_inset

 and 
\begin_inset Formula $do$
\end_inset

 produce values of sort 
\noun on
Situation
\noun default
.
\end_layout

\begin_layout Standard
\begin_inset Formula $\Lsit$
\end_inset

 contains the standard alphabet of logical connectives, constants 
\begin_inset Formula $\top$
\end_inset

 and 
\begin_inset Formula $\bot$
\end_inset

, countably infinitely many variables of each sort, countably infinitely
 many predicates of each arity, etc; for a complete definition, consult
 the foundational paper by 
\begin_inset CommandInset citation
LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

.
 We follow standard naming conventions for the situation calculus: upper-case
 roman names indicate constants; lower-case roman names indicate variables;
 greek characters indicate meta-variables or formula templates.
 All axioms universally close over their free variables at outermost scope.
 The notation 
\begin_inset Formula $\vars t$
\end_inset

 indicates a vector of terms of context-appropriate arity and type.
 The connectives 
\begin_inset Formula $\wedge$
\end_inset

, 
\begin_inset Formula $\neg$
\end_inset

, 
\begin_inset Formula $\exists$
\end_inset

 are taken as primitive, with 
\begin_inset Formula $\vee$
\end_inset

, 
\begin_inset Formula $\rightarrow$
\end_inset

, 
\begin_inset Formula $\equiv$
\end_inset

, 
\begin_inset Formula $\forall$
\end_inset

 defined in the usual manner.
\end_layout

\begin_layout Standard
Complex properties of the state of the world are represented using 
\emph on
uniform formulae
\emph default
.
 These are basically logical combinations of fluents referring to a common
 situation term.
\end_layout

\begin_layout Labelled Definition
Uniform
\begin_inset space ~
\end_inset

Terms Let 
\begin_inset Formula $\sigma$
\end_inset

 be a fixed situation term, 
\begin_inset Formula $r$
\end_inset

 an arbitrary rigid function symbol, 
\begin_inset Formula $f$
\end_inset

 an arbitrary fluent function symbol, and 
\begin_inset Formula $x$
\end_inset

 a variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the terms uniform in 
\begin_inset Formula $\sigma$
\end_inset

 are the smallest set of syntactically-valid terms satisfying:
\begin_inset Formula \[
\tau\,::=x\,|\, r(\vars{\tau})\,|\, f(\vars{\tau},\sigma)\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Labelled Definition
Uniform
\begin_inset space ~
\end_inset

Formulae Let 
\begin_inset Formula $\sigma$
\end_inset

 be a fixed situation term, 
\begin_inset Formula $R$
\end_inset

 an arbitrary rigid predicate, 
\begin_inset Formula $F$
\end_inset

 an arbitrary primitive fluent predicate, 
\begin_inset Formula $\tau$
\end_inset

 an arbitrary term uniform in 
\begin_inset Formula $\sigma$
\end_inset

, and 
\begin_inset Formula $x$
\end_inset

 an arbitrary variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the formulae uniform in 
\begin_inset Formula $\sigma$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{\tau},\sigma)\,|\, R(\vars{\tau})\,|\,\tau_{1}=\tau_{2}\,|\,\phi_{1}\wedge\phi_{2}\,|\,\neg\phi\,|\,\exists x:\phi\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
We will call a formula 
\emph on
uniform
\emph default
 if it is uniform in some situation.
 The important aspect of this definition is that the formula refers to no
 situation other than 
\begin_inset Formula $\sigma$
\end_inset

, which appears as the final argument of all fluents in the formula.
 In particular, uniform formulae cannot quantify over situations or compare
 situation terms, and cannot contain non-primitive fluents.
\end_layout

\begin_layout Standard
The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout to refer to an arbitrary uniform formula.
 Since they represent some aspect of the state of the world, it is frequently
 useful to evaluate a uniform formula at several different situation terms.
 The notation 
\begin_inset Formula $\phi[s']$
\end_inset

 represents a uniform formula with the particular situation 
\begin_inset Formula $s'$
\end_inset

 inserted into all its fluents, repalcing whatever situation term was previously
 there.
 We may also completely suppress the situation term to simplify the presentation
, using 
\begin_inset Formula $\phi^{-1}$
\end_inset

 to represent a uniform formula with the situation argument removed from
 all its fluents.
 Note that these are strictly meta-level operations, corresponding to possibly
 quite complex sentences from the underlying logic.
 They are 
\emph on
not
\emph default
 terms or operators from the logic itself.
\end_layout

\begin_layout Standard
The dynamics of a particular domain are captured by a set of sentences called
 a 
\emph on
basic action theory
\emph default
.
 Queries about the behaviour of the world are posed as logical entailment
 queries relative to this theory.
\end_layout

\begin_layout Labelled Definition
Basic
\begin_inset space ~
\end_inset

Action
\begin_inset space ~
\end_inset

Theory A basic action theory, denoted 
\begin_inset Formula $\Dt$
\end_inset

, is a set of situation calculus sentences (of the specific syntactic form
 outlined below) describing a particular dynamic world.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); action description axioms defining various aspects of action performance,
 such as preconditions (
\begin_inset Formula $\Dt_{ad}$
\end_inset

); successor state axioms describing how primitive fluents change between
 situations (
\begin_inset Formula $\Dt_{ssa}$
\end_inset

); axioms describing the value of primitive fluents in the initial situation
 (
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

); and axioms describing the static background facts of the domain (
\begin_inset Formula $\Dt_{bg}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{ad}\cup\Dt_{ssa}\cup\Dt_{S_{0}}\cup\Dt_{bg}\]

\end_inset


\end_layout

\begin_layout Standard
These axioms must satisfy some simple consistency criteria to constitute
 a valid domain description 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 This is a conservative extension of the definition used by 
\begin_inset CommandInset citation
LatexCommand citeauthor
key "pirri99contributions_sitcalc"

\end_inset

, intended to simplify the details of our forthcoming development.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 contains all the situation-independent facts about the domain, and must
 include a set of unique names axioms to ensure that action terms with different
 names or different arguments are in fact different.
 The set 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 is a collection of sentences uniform in 
\begin_inset Formula $S_{0}$
\end_inset

, stating what holds before any actions have been performed.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 contains one 
\emph on
successor state axiom
\emph default
 for each primitive fluent in the domain, providing a monotonic solution
 to the frame problem for that fluent.
 These axioms would typically have the following form: 
\begin_inset Formula \[
F(\vars x,do(a,s))\equiv\Phi_{F}^{+}(\vars x,a,s)\,\,\vee\,\, F(\vars x,s)\wedge\neg\Phi_{F}^{-}(\vars x,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi_{F}^{+}$
\end_inset

 and 
\begin_inset Formula $\Phi_{F}^{-}$
\end_inset

 are formulae uniform in 
\begin_inset Formula $s$
\end_inset

.
 This may be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after performing 
\begin_inset Formula $a$
\end_inset

 if 
\begin_inset Formula $a$
\end_inset

 made it true, or it was previously true and 
\begin_inset Formula $a$
\end_inset

 did not make it false
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 defines fluents that describe various aspects of the performance of an
 action, which we call 
\emph on
action description predicates
\emph default
.
 The precondition predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 is the canonical example, indicating whether it is possible to perform
 an action in a given situation.
 In principle there can be any number of predicates or functions defined
 in a similar way -- a common example is the function 
\begin_inset Formula $SR$
\end_inset

 used to axiomatise sensing actions in 
\begin_inset CommandInset citation
LatexCommand citep
key "scherl03sc_knowledge"

\end_inset

.
 The meta-predicate 
\begin_inset Formula $\alpha$
\end_inset

 will denote an arbitrary action description predicate.
 For each such predicate the set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains a single axiom of the following form, where 
\begin_inset Formula $\Pi_{\alpha}$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\alpha(\vars x,a,s)\,\equiv\,\Pi_{\alpha}(\vars x,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
Note that this is a departure from the standard approach of 
\begin_inset CommandInset citation
LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

 where a separate axiom specifies the preconditions for each individual
 action type.
 The single-axiom approach used in this paper embodies a domain-closure
 assumption on the 
\noun on
Action
\noun default
 sort.
 It is necessary when reasoning about formulae that universally quantify
 over actions 
\begin_inset CommandInset citation
LatexCommand citep
key "savelli06sc_quantum_levels,vassos08progression_future_queries"

\end_inset

.
\end_layout

\begin_layout Standard
For convenience we will allow action description predicates to be defined
 in terms of other action description predicates; as long as these definitions
 are well-founded they can be expanded out to a definition that uses only
 uniform formulae.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 ensure that situations form a branching-time account of the world state.
 There is a distinguished situation term 
\begin_inset Formula $S_{0}$
\end_inset

 called the
\emph on
 initial situation
\emph default
, and situations in general form a tree structure with 
\begin_inset Formula $S_{0}$
\end_inset

 at the root and 
\begin_inset Formula $do(a,s)$
\end_inset

 constructing the successor situation resulting when the action 
\begin_inset Formula $a$
\end_inset

 is performed in 
\begin_inset Formula $s$
\end_inset

; all situations thus produced are distinct:
\begin_inset Formula \[
do(a_{1},s_{1})=do(a_{2},s_{2})\,\rightarrow\, a_{1}=a_{2}\,\wedge\, s_{1}=s_{2}\]

\end_inset


\end_layout

\begin_layout Standard
We abbreviate the performance of several successive actions by writing:
\begin_inset Formula \[
do([a_{1},\dots,a_{n}],s)\,\isdef\, do(a_{n},do(\dots,do(a_{1},s)))\]

\end_inset


\end_layout

\begin_layout Standard
There is also a second-order induction axiom asserting that all situations
 must be constructed in this way, which is needed to prove statements that
 universally quantify over situations 
\begin_inset CommandInset citation
LatexCommand citep
key "Reiter93proving"

\end_inset

:
\begin_inset Formula \[
\forall P:\,\left[P(S_{0})\wedge\forall s,a:\,\left(P(s)\rightarrow P(do(a,s))\right)\right]\,\rightarrow\,\forall s:\, P(s)\]

\end_inset


\end_layout

\begin_layout Standard
The relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 indicates that 
\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset

 and is defined as follows:
\begin_inset Formula \begin{gather*}
\neg(s\sqsubset S_{0})\\
s\sqsubset do(a,s')\equiv s\sqsubseteq s'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 This notation for 
\begin_inset Quotes eld
\end_inset

in the future of
\begin_inset Quotes erd
\end_inset

 can be extended to consider only those futures in which all actions satisfy
 a particular action description predicate.
 We include a relation 
\begin_inset Formula $<_{\alpha}$
\end_inset

 for each action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, with the following definitions:
\begin_inset Formula \begin{gather*}
\neg\left(s<_{\alpha}S_{0}\right)\\
s<_{\alpha}do(a,s')\equiv s\leq_{\alpha}s'\wedge\alpha(a,s')\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
For example, by stating that 
\begin_inset Formula $s<_{Poss}s'$
\end_inset

 we assert that not only is 
\begin_inset Formula $s'$
\end_inset

 in the future of 
\begin_inset Formula $s$
\end_inset

, but that all actions performed between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 were actually possible; this is equivalent to the 
\begin_inset Formula $<$
\end_inset

 operator of 
\begin_inset CommandInset citation
LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

.
 Note that we suppress the action and situation arguments to the action
 description predicate in order to simplify the presentation.
\end_layout

\begin_layout Subsection
Reasoning
\end_layout

\begin_layout Standard
An important feature of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 These are generally based on syntactic manipulation of a query into a form
 that is more amenable to automated reasoning, for example because it can
 be proven without using some of the axioms from 
\begin_inset Formula $\Dt$
\end_inset

.
\end_layout

\begin_layout Standard
In the general case, answering a query about a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 is a theorem-proving task in second-order logic (denoted SOL) due to the
 induction axiom included in the foundational axioms:
\begin_inset Formula \[
\Dt\models_{SOL}\psi\]

\end_inset

 This is clearly problematic for effective automated reasoning, but fortunately
 there exist particular syntactic forms for which some of the axioms in
 
\begin_inset Formula $\Dt$
\end_inset

 are not required.
\end_layout

\begin_layout Standard
If a query only performs 
\emph on
existential
\emph default
 quantification over situation terms, it can be answered without the induction
 axiom (denoted 
\begin_inset Formula $I$
\end_inset

) and thus using only first-order logic (FOL) 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

:
\begin_inset Formula \[
\Dt\models_{SOL}\exists s:\,\psi(s)\,\,\,\,\mathrm{iff}\,\,\,\,\Dt-\{I\}\models_{FOL}\exists s:\,\psi(s)\]

\end_inset


\end_layout

\begin_layout Standard
While this is a substantial improvement over requiring a second-order theorem
 prover, it is still far from an effective technique.
 Effective reasoning requires that the set of axioms be reduced as much
 as possible.
\end_layout

\begin_layout Standard
In their work on state constraints, 
\begin_inset CommandInset citation
LatexCommand citet
key "Lin94-StateConstraints"

\end_inset

 show how to reduce the task of verifying a state constraint to a reasoning
 task we call 
\emph on
static domain reasoning
\emph default
, where only the background axioms need to be considered:
\begin_inset Formula \[
\Dt_{bg}\models_{FOL}\forall s:\,\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
Since the axioms in 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 do not mention situation terms, the leading quantification in such queries
 has no effect -- 
\begin_inset Formula $\phi$
\end_inset

 will be entailed for all 
\begin_inset Formula $s$
\end_inset

 if and only if it is entailed for some 
\begin_inset Formula $s$
\end_inset

.
 This is a major improvement because universal quantification over situation
 terms usually requires the second-order induction axiom.
 Their work has shown that this requirement can be circumvented in some
 cases.
\end_layout

\begin_layout Standard
Simpler still are queries uniform in the initial situation, which can be
 answered using only first-order logic and a limited set of axioms:
\begin_inset Formula \[
\Dt\models_{SOL}\phi[S_{0}]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{bg}\models_{FOL}\phi[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
We call such reasoning 
\emph on
initial
\emph default
 
\emph on
situation reasoning
\emph default
.
 Since the axioms 
\begin_inset Formula $\Dt_{S_{0}}\cup\Dt_{bg}$
\end_inset

 often satisfy the closed-world assumption, provers such as Prolog can be
 employed to handle this type of query quite effectively.
\end_layout

\begin_layout Standard
Even given the use of regression to reduce the number of axioms required,
 reasoning still requires first-order logic and is thus only semi-decidable
 in general.
 Practical systems implemented on top of the situation calculus typically
 enforce additional restrictions on the domain in order to gain decidability.
\end_layout

\begin_layout Standard
A common restriction is to assume that the 
\noun on
Action
\noun default
 and 
\noun on
Object
\noun default
 domains are finite.
 This allows quantification over these variables to be replaced with finite
 conjunctions or disjunctions, essentially 
\begin_inset Quotes eld
\end_inset

propositionalising
\begin_inset Quotes erd
\end_inset

 the domain 
\begin_inset CommandInset citation
LatexCommand citep
key "giacomo99impl_robots,reiter01kia,levesque04krr_book"

\end_inset

.
 Both static domain and initial situation reasoning can then be performed
 using propositional logic, which is decidable.
 This may also be combined with special-purpose decision procedures for
 particular objects in the domain, such as deciding linear constraints over
 the integers or reals 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter96sc_nat_conc,reiter01kia"

\end_inset

.
\end_layout

\begin_layout Standard
A similar, but slightly less onerous restriction, is to ensure that the
 construction of function terms is well-founded 
\begin_inset CommandInset citation
LatexCommand citep
key "levesque04krr_book"

\end_inset

.
 This prevents building the arbitrarily-nested terms from the Herbrand universe
 that cause non-termination in first-order theorem provers, again gaining
 decidability.
\end_layout

\begin_layout Standard
Recent work by 
\begin_inset CommandInset citation
LatexCommand citet
key "yu07twovar_sitcalc"

\end_inset

 has shown how to model some situation calculus domains using to the two-variabl
e fragment of first-order logic.
 Since this fragment is decidable in general, both static domain and initial
 situation reasoning are decidable in such domains.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The principle tool for effective reasoning in the situation calculus is
 the regression meta-operator 
\begin_inset Formula $\Reg_{\Dt}$
\end_inset

, a syntactic manipulation that encodes the preconditions and effects of
 actions into the query itself, meaning fewer axioms are needed for the
 final reasoning task 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 The idea is to reduce a query about some future situation to a query about
 the initial situation only.
\end_layout

\begin_layout Standard
There are two styles of regression operator commonly defined in the literature:
 the single-pass operator as defined in 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 which reduces to 
\begin_inset Formula $S_{0}$
\end_inset

 in a single application, the the single-step operator as defined in 
\begin_inset CommandInset citation
LatexCommand citep
key "scherl03sc_knowledge"

\end_inset

 which operates one action at a time.
 We use the single-step variant because it is the more expressive of the
 two -- while it is straightforward to define the single-pass operator in
 terms of the single-step operator, the reverse is not the case.
\end_layout

\begin_layout Standard
Regression is only defined for a certain class of formulae, the 
\emph on
regressable formulae
\emph default
.
\end_layout

\begin_layout Labelled Definition
Regressable
\begin_inset space ~
\end_inset

Terms Let 
\begin_inset Formula $\sigma$
\end_inset

 be an arbitrary situation term, 
\begin_inset Formula $x$
\end_inset

 an arbitrary variable not of sort situation, 
\begin_inset Formula $r$
\end_inset

 an arbitrary rigid function and 
\begin_inset Formula $f$
\end_inset

 an arbitrary fluent function.
 Then the regressable terms are the smallest set of syntactically-valid
 terms satisfying: 
\begin_inset Formula \[
\nu::=\sigma\,|\, x\,|\, f(\vars{\nu},\sigma)\,|\, r(\vars{\nu})\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Labelled Definition
Regressable
\begin_inset space ~
\end_inset

Formulae 
\begin_inset CommandInset label
LatexCommand label
name "def:Background:Regressable-Formulae"

\end_inset

Let 
\begin_inset Formula $\sigma$
\end_inset

 be an arbitrary situation term, 
\begin_inset Formula $x$
\end_inset

 an arbitrary variable not of sort situation, 
\begin_inset Formula $\nu$
\end_inset

 an arbitrary regressable term, 
\begin_inset Formula $R$
\end_inset

 an arbitrary rigid predicate, 
\begin_inset Formula $F$
\end_inset

 an arbitrary primitive fluent predicate, and 
\begin_inset Formula $\alpha$
\end_inset

 an arbitrary action description predicate.
 Then the regressable formulae are the smallest set of syntactically-valid
 formulae satisfying: 
\begin_inset Formula \[
\varphi::=F(\vars{\nu},\sigma)\,|\,\alpha(\vars{\nu},a,\sigma)\,|\, R(\vars{\nu})\,|\,\nu_{1}=\nu_{2}\,|\,\neg\varphi\,|\,\varphi_{1}\wedge\varphi_{2}\,|\,\exists x:\,\varphi\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Regressable formulae are more general than uniform formulae.
 In particular, they can contain action description predicates and may mention
 different situation terms.
 They cannot, however, quantify over situation terms or compare situations
 using the 
\begin_inset Formula $\sqsubset$
\end_inset

 predicate.
\end_layout

\begin_layout Standard
The regression operator is then defined using a series of 
\emph on
regression rules
\emph default
 such as those shown below, which mirror the structural definition of regressabl
e formulae.
\end_layout

\begin_layout Labelled Definition
Regression
\begin_inset space ~
\end_inset

Operator Let 
\begin_inset Formula $R$
\end_inset

 be a rigid predicate, 
\begin_inset Formula $\alpha$
\end_inset

 be an action description predicate with axiom 
\begin_inset Formula $\alpha(\vars{\nu},a,s)\equiv\Pi_{\alpha}(a,s)$
\end_inset

 in 
\begin_inset Formula $\Dt_{ad}$
\end_inset

, and 
\begin_inset Formula $F$
\end_inset

 be a primitive fluent with axiom 
\begin_inset Formula $F(\vars x,s)\equiv\Phi_{F}(\vars x,s)$
\end_inset

 in 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

.
 Then the regression of 
\begin_inset Formula $\phi$
\end_inset

, denoted 
\begin_inset Formula $\Reg_{\Dt}(\phi)$
\end_inset

, is defined according to the following structural rules:
\begin_inset Formula \begin{gather*}
\Reg_{\Dt}(\varphi_{1}\wedge\varphi_{2})\,\isdef\,\Reg_{\Dt}(\varphi_{1})\wedge\Reg_{\Dt}(\varphi_{2})\\
\Reg_{\Dt}(\exists x:\,\varphi)\,\isdef\,\exists x:\,\Reg_{\Dt}(\varphi)\\
\Reg_{\Dt}(\neg\varphi)\,\isdef\,\neg\Reg_{\Dt}(\varphi)\\
\Reg_{\Dt}(\alpha(\vars{\nu},a,\sigma))\,\isdef\,\Reg_{\Dt}(\Pi_{\alpha}(\vars{\nu},a,\sigma))\\
\Reg_{\Dt}(F(\vars{\nu},do(a,\sigma)))\,\isdef\,\Phi_{F}(\vars{\nu},a,\sigma)\\
\Reg_{\Dt}(F(\vars{\nu},s))\,\isdef\, F(\vars{\nu},s)\\
\Reg_{\Dt}(F(\vars{\nu},S_{0}))\,\isdef\, F(\vars{\nu},S_{0})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We have omitted some technical details here, such as the handling of functional
 fluents; consult 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 for the details.
 The key point is that each application of the regression operator replaces
 action description predicates with their definitions from 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and primitive fluents with their successor state axioms from 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

, 
\begin_inset Quotes eld
\end_inset

unwinding
\begin_inset Quotes erd
\end_inset

 a single action from each 
\begin_inset Formula $do(a,\sigma)$
\end_inset

 situation term in the query.
 If the situation term is not constructed using 
\begin_inset Formula $do$
\end_inset

, it is left unchanged.
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\Dt$
\end_inset

 is fixed, we will henceforth drop the subscript and simply write 
\begin_inset Formula $\Reg$
\end_inset

 for the regression operator.
 When dealing with situation-suppressed uniform formulae, we will use a
 two-argument operator 
\begin_inset Formula $\Reg(\phi,a)$
\end_inset

 to indicate the regression of 
\begin_inset Formula $\phi$
\end_inset

 over the action 
\begin_inset Formula $a$
\end_inset

.
 It should be read as a shorthand for 
\begin_inset Formula $\Reg(\phi[do(a,s)])^{-1}$
\end_inset

 using the situation-suppression operator from Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Background:SC:Notation"

\end_inset

.
\end_layout

\begin_layout Standard
Let us briefly state some important properties of the regression operator.
 First, and most importantly, it preserves equivalence of formulae:
\end_layout

\begin_layout Proposition
Let 
\begin_inset Formula $\varphi$
\end_inset

 be a regressable formula, then 
\begin_inset Formula $\Dt\,\models\,\varphi\,\equiv\,\Reg(\varphi)$
\end_inset

 
\end_layout

\begin_layout Standard
Any formula uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

 is regressable, and the resulting formula is uniform in 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Proposition
Let 
\begin_inset Formula $\phi$
\end_inset

 be uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

, then 
\begin_inset Formula $\Reg(\phi)$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\Reg^{*}$
\end_inset

 denote repeated applications of 
\begin_inset Formula $\Reg$
\end_inset

 until the formula remains unchanged.
 Such applications can transform a query about some future situation into
 a query about the initial situation only:
\end_layout

\begin_layout Proposition
Let 
\begin_inset Formula $\phi$
\end_inset

 be uniform in 
\emph on

\begin_inset Formula $do([a_{1}\dots a_{n}],S_{0})$
\end_inset

,
\emph default
 then 
\begin_inset Formula $\Reg^{*}(\phi)$
\end_inset

 is uniform in 
\begin_inset Formula $S_{0}$
\end_inset

 
\end_layout

\begin_layout Standard
This last property is key to effective reasoning in the situation calculus,
 as it allows one to answer the 
\emph on
projection problem
\emph default
.
 To determine whether 
\begin_inset Formula $\phi$
\end_inset

 holds in a given future situation, it suffices to determine whether 
\begin_inset Formula $\Reg^{*}(\phi)$
\end_inset

 holds in the initial situation.
 As discussed above, queries uniform in 
\begin_inset Formula $S_{0}$
\end_inset

 are much easier to answer.
 The axioms 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 are essentially 
\begin_inset Quotes eld
\end_inset

compiled into the query
\begin_inset Quotes erd
\end_inset

 by the 
\begin_inset Formula $\Reg^{*}$
\end_inset

 operator.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice 
\begin_inset CommandInset citation
LatexCommand citep
key "levesque97golog,pirri99contributions_sitcalc"

\end_inset

 and there are techniques to avoid exponential growth of the query in some
 cases 
\begin_inset CommandInset citation
LatexCommand citep
key "vandtmarsh07optimal_regression"

\end_inset

.
\end_layout

\begin_layout Subsection
Inductive Reasoning
\end_layout

\begin_layout Standard
While there is a rich and diverse literature base for the situation calculus,
 there appears to have been little work on reasoning about universally quantifie
d queries.
 
\begin_inset CommandInset citation
LatexCommand citet
key "Reiter93proving"

\end_inset

 has shown why the induction axiom is necessary to prove statements that
 universally quantify over situation terms; this work demonstrates the use
 of the axiom in manual proofs, but offers no procedure for answering such
 queries automatically.
\end_layout

\begin_layout Standard
Other work considering queries that universally quantify over situations
 focuses exclusively on verifying state constraints.
 These are uniform formulae that must hold in every possible situation,
 a highly specialised form of the more general persistence queries we define
 in this paper.
 The work of 
\begin_inset CommandInset citation
LatexCommand citet
key "Lin94-StateConstraints"

\end_inset

 shows that the induction axiom can be 
\begin_inset Quotes eld
\end_inset

compiled away
\begin_inset Quotes erd
\end_inset

 when verifying a state constraint, by means of the following equivalence:
\begin_inset Formula \begin{gather*}
\Dt\,\models\,\phi[S_{0}]\rightarrow\left(\forall s:\, S_{0}\leq s\rightarrow\phi[s]\right)\\
\mathit{iff}\\
\Dt_{una}\models\forall s,a:\,\phi[s]\wedge\Reg_{\Dt}(Poss(a,s))\,\rightarrow\,\Reg_{\Dt}(\phi[do(a,s)])\end{gather*}

\end_inset

 The set 
\begin_inset Formula $\Dt_{una}$
\end_inset

 here performs the same role as our background axioms 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 but contains only the unique names axioms for actions.
 Verification of a state constraint can thus be reduced to reasoning about
 a universally quantified uniform formula using only the static background
 theory, a comparatively straightforward reasoning task which we call 
\emph on
static domain reasoning
\emph default
.
 Verification of state constraints was also approached by 
\begin_inset CommandInset citation
LatexCommand citet
key "bertossi96automating"

\end_inset

, who develop an automatic constraint verification system using an induction
 theorem prover.
\end_layout

\begin_layout Standard
However, there are many issues that are not addressed by work specific to
 state constraints.
 What if we are interested in the future of some arbitrary situation 
\begin_inset Formula $\sigma$
\end_inset

, rather than only 
\begin_inset Formula $S_{0}$
\end_inset

? What if want to restrict future actions according to an arbitrary action
 description predicate? Can we integrate a method for handling universally-quant
ified queries with existing regression techniques? Our treatment of property
 persistence can provide a concrete basis for these considerations, and
 is hence significantly more general than this existing work.
\end_layout

\begin_layout Standard
Another field that deals with induction over situations is the verification
 of ConGolog programs.
 
\begin_inset CommandInset citation
LatexCommand citet
key "ternovska97congolog_fixpoint"

\end_inset

 show how to formulate various safety, liveness, and starvation properties
 of a ConGolog program as fixpoint queries in second-order logic.
 A preliminary model-checker capable of verifying these properties is described
 in 
\begin_inset CommandInset citation
LatexCommand citep
key "ternovska02congolog_model_checker"

\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand citet
key "classen08golog_properties"

\end_inset

 develop a logic of ConGolog programs in 
\begin_inset Formula $\mathcal{ES}$
\end_inset

, a variant of the situation calculus based on modal logic.
 They demonstrate that properties of a program can be verified using an
 iterative fixpoint computation similar to the one we propose in this paper.
\end_layout

\begin_layout Standard
As we shall see, property persistence queries are equivalent to a particular
 kind of safety property of a ConGolog program, so our work is in some ways
 less general than that described above.
 This means, however, that we can be more specific in our algorithm and
 approach.
 These ConGolog verifiers are designed to operate in isolation, while we
 seek a method of handling universally-quantified queries that can integrate
 directly with the existing meta-theoretical reasoning machinery of the
 situation calculus, in particular with the regression operator.
\end_layout

\begin_layout Standard
Finally, let us introduce an important property of situations first formally
 identified by 
\begin_inset CommandInset citation
LatexCommand citet
key "savelli06sc_quantum_levels"

\end_inset

: that universal quantification over situation terms is equivalent to an
 infinite conjunction over the 
\emph on
levels
\emph default
 of the tree of situations:
\begin_inset Formula \begin{gather*}
\Dt\,\models\,\forall s:\,\psi(s)\\
\mathrm{iff}\\
\Dt\,\models\,\bigwedge_{n\in\mathbb{N}}\forall a_{1},\dots,a_{n}:\,\psi(do([a_{1},\dots,a_{n}],S_{0}))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
This is a direct consequence of the induction axiom for situations, which
 restricts situations to be constructed by performing some countable number
 of actions in the initial situation.
 This result captures an important intuition about situation terms that
 is fundamental to the operation of our approach.
\end_layout

\begin_layout Section
Property Persistence Queries
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Definitions"

\end_inset


\end_layout

\begin_layout Standard
Let us now formally define the kinds of query that will be approached in
 this paper.
 Given some property 
\begin_inset Formula $\phi$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, a 
\emph on
property persistence query
\emph default
 asks whether 
\begin_inset Formula $\phi$
\end_inset

 will hold in all situations in the future of 
\begin_inset Formula $\sigma$
\end_inset

: 
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\sqsubseteq s\,\rightarrow\,\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
More generally, one may wish to limit the futures under consideration to
 those brought about by actions satisfying a certain action description
 predicate 
\begin_inset Formula $\alpha$
\end_inset

, which is easily accomplished using the 
\begin_inset Formula $\leq_{\alpha}$
\end_inset

 macro.
 We thus have the following definition of a persistence query:
\end_layout

\begin_layout Labelled Definition
Property
\begin_inset space ~
\end_inset

Persistence
\begin_inset space ~
\end_inset

Query Let 
\begin_inset Formula $\phi$
\end_inset

 be a uniform formula, 
\begin_inset Formula $\alpha$
\end_inset

 an action description predicate, and 
\begin_inset Formula $\sigma$
\end_inset

 a situation term.
 Then a property persistence query is a query of the form:
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\le_{\alpha}s\rightarrow\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
In words, a persistence query states that 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

, and assuming all subsequent actions satisfy 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 will continue to hold
\begin_inset Quotes erd
\end_inset

.
 For succinctness we will henceforth describe this as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Queries of this form are involved in many useful reasoning tasks, of which
 the following are a small selection:
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Goal Impossibility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no legal situation in which that goal is achieved:
\begin_inset Formula \[
\Dt\models\forall s:\, S_{0}\leq_{Legal}s\rightarrow\neg G(s)\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Goal Futility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, establish that the goal cannot be achieved in any legal future of 
\begin_inset Formula $\sigma$
\end_inset

:
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\leq_{Legal}s\rightarrow\neg G(s)\]

\end_inset


\end_layout

\begin_layout Standard
Note how this differs from goal impossibility: while the agent may have
 initially been able to achieve its goal, the actions that have subsequently
 been performed have rendered the goal unachievable.
 Agents would be well advised to avoid such situations.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Checking State Constraints:
\series default
 Given a state constraint 
\begin_inset Formula $SC$
\end_inset

, show that the constraint holds in every legal situation:
\begin_inset Formula \[
\Dt\models\forall s:\, S_{0}\leq_{Legal}s\rightarrow SC(s)\]

\end_inset

 This can be seen as a variant of goal impossibility, by showing that the
 constraint can never be violated.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Need for Cooperation:
\series default
 Given an agent 
\begin_inset Formula $agt$
\end_inset

, goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, establish that no sequence of actions performed by that agent can achieve
 the goal.
 Suppose we define 
\begin_inset Formula $MyAction$
\end_inset

 to identify the agent's own actions:
\begin_inset Formula \[
MyAction(a,s)\,\isdef\, actor(a)=agt\]

\end_inset


\end_layout

\begin_layout Standard
Then the appropriate query is:
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\leq_{MyAction}s\rightarrow\neg G(s)\]

\end_inset

 If this is the case, the agent will need to seek cooperation from another
 agent in order to achieve its goal.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Knowledge with Hidden Actions:
\series default
 An agent reasoning about its own knowledge in asynchronous domains must
 account for arbitrarily-long sequences of hidden actions.
 To establish that it knows 
\begin_inset Formula $\phi$
\end_inset

, it must establish that 
\begin_inset Formula $\phi$
\end_inset

 cannot become false through a sequence of hidden actions:
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\leq_{Hidden}s\rightarrow\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
Unfortunately, persistence queries do not meet the criteria for regressable
 formulae found in Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:Background:Regressable-Formulae"

\end_inset

, since they quantify over situation terms.
 Such queries therefore cannot be handled using the standard regression
 operator.
 Indeed, since universal quantification over situation terms requires the
 use of a second order induction axiom, current systems needing to answer
 such queries must resort to second-order theorem proving.
 This is hardly an attractive prospect for effective automated reasoning.
\end_layout

\begin_layout Section
The Persistence Condition
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Condition"

\end_inset


\end_layout

\begin_layout Standard
To implement practical systems that can perform persistence queries, we
 clearly need to transform the query into a form suitable for effective
 automated reasoning.
 Our approach is to transform a property persistence query at 
\begin_inset Formula $\sigma$
\end_inset

 into the evaluation of a uniform formula at 
\begin_inset Formula $\sigma$
\end_inset

.
 This transformed query can then be handled effectively using the standard
 regression operator.
\end_layout

\begin_layout Standard
To achieve this we need some transformation of a property 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

 into a uniform formula 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 that is true at precisely the situations in which 
\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

.
 We call such a formula the 
\emph on
persistence condition
\emph default
 of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Labelled Definition
Persistence
\begin_inset space ~
\end_inset

Condition The persistence condition of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

, denoted 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

, is a uniform formula that is equivalent to the persistence of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

 with respect to a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 without the initial situation axioms.
 Formally:
\begin_inset CommandInset label
LatexCommand label
name "def:persistence-condition"

\end_inset


\begin_inset Formula \[
\Dt-\Dt_{S_{0}}\models\forall s:\,\left(\Pst_{\Dt}(\phi,\alpha)[s]\,\equiv\,\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\]

\end_inset


\end_layout

\begin_layout Standard
Defining 
\begin_inset Formula $\Pst_{\Dt}$
\end_inset

 to be independent of the initial world state allows an agent to calculate
 it regardless of what (if anything) is known about the actual state of
 the world -- after all, an agent may not know all the details of 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

, and we still want it to be able to use this technique.
\end_layout

\begin_layout Standard
This definition alone clearly does not make the task of answering a persistence
 query any easier, since it gives no indication of how the persistence condition
 might be calculated in practice.
 Indeed, we have not yet even shown whether such a formula actually exists.
 In order to establish these results, we first need to define the weaker
 notion of a formula 
\emph on
persisting to depth 
\begin_inset Formula $n$
\end_inset


\emph default
 in a situation.
\end_layout

\begin_layout Labelled Definition
Persistence
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

Depth
\begin_inset space ~
\end_inset

1 A uniform formula 
\begin_inset Formula $\phi$
\end_inset

 persists to depth 1 under 
\begin_inset Formula $\alpha$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

 when the formula 
\begin_inset Formula $\Pst_{\Dt}^{1}(\phi,\alpha)[s]$
\end_inset

 holds, as defined by:
\begin_inset CommandInset label
LatexCommand label
name "def:persists-depth-n"

\end_inset


\begin_inset Formula \[
\Pst_{\Dt}^{1}(\phi,\alpha)\,\isdef\,\phi^{-1}\,\wedge\,\forall a:\,\Reg_{\Dt}(\alpha[a,s])^{-1}\rightarrow\Reg_{\Dt}(\phi[do(a,s)])^{-1}\]

\end_inset


\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $\Pst_{\Dt}^{1}$
\end_inset

 is a literal encoding of the requirement 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and in all its direct successors
\begin_inset Quotes erd
\end_inset

, using the standard regression operator 
\begin_inset Formula $\Reg_{\Dt}$
\end_inset

 and the situation-suppression operator 
\begin_inset Formula $\phi^{-1}$
\end_inset

 to produce a situation-suppressed uniform formula.
 Without the use of regression, the definition would appear as follows:
\begin_inset Formula \[
\PstDI(\phi,\alpha)[s]\,\equiv\,\phi[s]\,\wedge\,\forall a:\,\alpha[a,s]\,\rightarrow\,\phi[do(a,s)]\]

\end_inset

 Since 
\begin_inset Formula $\alpha$
\end_inset

 is an action description predicate and 
\begin_inset Formula $\phi$
\end_inset

 is a uniform formula, the expressions 
\begin_inset Formula $\Reg_{\Dt}(\alpha[a,s])^{-1}$
\end_inset

 and 
\begin_inset Formula $\Reg(\phi[do(a,s)])^{-1}$
\end_inset

 are always defined and always produce uniform formulae.
 Successive applications of 
\begin_inset Formula $\Pst_{\Dt}^{1}$
\end_inset

 can then assert persistence to greater depths:
\end_layout

\begin_layout Labelled Definition
Persistence
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

Depth
\begin_inset space ~
\end_inset

N For any 
\begin_inset Formula $n\geq0$
\end_inset

, a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 persists to depth 
\begin_inset Formula $n$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

 when the formula 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)[s]$
\end_inset

 holds, as defined by:
\begin_inset Formula \begin{gather*}
\Pst_{\Dt}^{0}(\phi,\alpha)\,\isdef\,\phi\\
\Pst_{\Dt}^{n}(\phi,\alpha)\,\isdef\,\Pst_{\Dt}^{1}(\Pst_{D}^{n-1}(\phi,\alpha),\alpha)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The following theorem confirms that 
\begin_inset Formula $\Pst_{\Dt}^{n}$
\end_inset

 operates according to this intuition -- that for any sequence of actions
 of length 
\begin_inset Formula $i=0$
\end_inset

 to 
\begin_inset Formula $i=n$
\end_inset

, if each action satisfies 
\begin_inset Formula $\alpha$
\end_inset

 in the situation it is executed in, then 
\begin_inset Formula $\phi$
\end_inset

 will hold after executing those actions.
\end_layout

\begin_layout Theorem
For any 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

 iff 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

 and in all successors of 
\begin_inset Formula $\sigma$
\end_inset

 reached by performing at most 
\begin_inset Formula $n$
\end_inset

 actions satisfying 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "thm:PstN-works"

\end_inset


\begin_inset Formula \begin{multline*}
\Dt\,\models\,\Pst_{\Dt}^{n}(\phi,\alpha)[\sigma]\,\equiv\,\\
\bigwedge_{i\leq n}\forall a_{1},\dots,a_{i}:\,\left(\bigwedge_{j\leq i}\alpha[a_{j},do([a_{1},\dots,a_{j-1}],\sigma)]\,\,\rightarrow\,\,\phi[do([a_{1},\dots,a_{i}],\sigma)]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof Sketch
By induction on the natural numbers.
 For 
\begin_inset Formula $n=0$
\end_inset

 we have 
\begin_inset Formula $\phi[\sigma]\equiv\phi[\sigma]$
\end_inset

 by definition.
 For the inductive case, we expand the definition of 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)[\sigma]$
\end_inset

 to get the following for the LHS:
\begin_inset Formula \[
\Pst_{\Dt}^{n-1}(\phi,\alpha)[\sigma]\wedge\forall a:\,\Reg_{\Dt}(\alpha[a,\sigma])\rightarrow\Reg_{\Dt}(\Pst_{\Dt}^{n-1}(\phi,\alpha)[do(a,\sigma)])\]

\end_inset


\end_layout

\begin_layout Proof Sketch
Substituting for 
\begin_inset Formula $\Pst_{\Dt}^{n-1}$
\end_inset

 using the inductive hypothesis gives us a conjunction ranging over 
\begin_inset Formula $i\leq n-1$
\end_inset

, with universally quantified variables 
\begin_inset Formula $a_{1},\dots,a_{i}$
\end_inset

, and we must establish the 
\begin_inset Formula $i=n$
\end_inset

 case.
 Pushing this conjunction inside the scope of the 
\begin_inset Formula $\forall a$
\end_inset

 quantifier, we find we can rename 
\begin_inset Formula $a\Rightarrow a_{1}$
\end_inset

, 
\begin_inset Formula $a_{1}\Rightarrow a_{2}$
\end_inset

 etc to get the required expression.
 For the complete proof see Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Detailed-Proofs"

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\Pst_{\Dt}^{n}$
\end_inset

 operator thus allows us to express the persistence of a formula to any
 given depth using a simple syntactic translation based on regression.
 Intuitively, one would expect 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 to be some sort of fixpoint of 
\begin_inset Formula $\Pst_{\Dt}^{1}(\phi,\alpha)$
\end_inset

, since 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 must imply persistence up to any depth.
 Such a fixpoint could then be calculated using standard iterative approximation
 techniques.
 The remainder of this section is devoted to verifying this intuition.
\end_layout

\begin_layout Standard
We begin by adapting two existing results involving induction from the situation
 calculus literature, so that they operate with our generalised 
\begin_inset Formula $\leq_{\alpha}$
\end_inset

 notation and can be based at situations other than 
\begin_inset Formula $S_{0}$
\end_inset

.
\end_layout

\begin_layout Proposition
For any action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, the foundational axioms of the situation calculus entail the following
 induction principle:
\begin_inset CommandInset label
LatexCommand label
name "prop:a-order-induction"

\end_inset


\begin_inset Formula \begin{multline*}
\forall W,s:\,\, W(s)\wedge\left[\forall a,s':\,\alpha[a,s']\wedge s\leq_{\alpha}s'\wedge W(s')\rightarrow W(do(a,s'))\right]\\
\rightarrow\forall s':\, s\leq_{\alpha}s'\rightarrow W(s')\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
A trivial adaptation of Theorem 1 in 
\begin_inset CommandInset citation
LatexCommand citep
key "Reiter93proving"

\end_inset

.
 
\end_layout

\begin_layout Proposition
For any basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "prop:a-order-reduction"

\end_inset


\begin_inset Formula \begin{gather*}
\Dt-\Dt_{S_{0}}\models\forall s:\,\phi[s]\rightarrow\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\\
\mathrm{iff}\\
\Dt_{bg}\models\forall s,a:\,\phi[s]\wedge\Reg_{\Dt}(\alpha[a,s])\rightarrow\Reg_{\Dt}(\phi[do(a,s)])\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
A straightforward generalisation of the model-construction proof of Lemma
 5 in 
\begin_inset CommandInset citation
LatexCommand citep
key "Lin94-StateConstraints"

\end_inset

, utilising Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-induction"

\end_inset

.
 The details of this generalisation can be found in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Detailed-Proofs"

\end_inset

.
\end_layout

\begin_layout Standard
Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-reduction"

\end_inset

 will be key in our algorithm for calculating the persistence condition.
 It allows one to establish the result 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

, then 
\begin_inset Formula $\phi$
\end_inset

 persists in 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

 by using static domain reasoning, a comparatively straightforward reasoning
 task.
\end_layout

\begin_layout Standard
We next formalise some basic relationships between 
\begin_inset Formula $\Pst_{\Dt}$
\end_inset

 and 
\begin_inset Formula $\Pst_{\Dt}^{n}$
\end_inset

.
\end_layout

\begin_layout Lemma
Given a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "lem:p-equiv-p(pn)"

\end_inset


\begin_inset Formula \[
\Dt-\Dt_{S_{0}}\models\forall s:\,\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\,\equiv\,\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\Pst_{D}^{n}(\phi,\alpha)[s']\right)\]

\end_inset

 That is, 
\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

 iff 
\begin_inset Formula $\,\Pst_{\Dt}^{n}[\phi,\alpha]$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

.
 
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $\Pst_{\Dt}^{n}[\phi,\alpha]$
\end_inset

 implies 
\begin_inset Formula $\phi$
\end_inset

 by definition, the 
\emph on
if
\emph default
 direction is trivial.
 For the 
\emph on
only-if
\emph default
 direction we proceed by induction on 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Proof
For the base case, assume that 
\begin_inset Formula $\phi$
\end_inset

 persists but 
\begin_inset Formula $\Pst_{\Dt}^{1}(\phi,\alpha)$
\end_inset

 does not, then we must have some 
\begin_inset Formula $s'$
\end_inset

 with 
\begin_inset Formula $s\leq_{\alpha}s'$
\end_inset

 and 
\begin_inset Formula $\neg\Pst_{\Dt}^{1}(\phi,\alpha)[s']$
\end_inset

.
 By the definition of 
\begin_inset Formula $\Pst_{\Dt}^{1}$
\end_inset

, this means that:
\begin_inset Formula \[
\neg\left(\phi[s']\,\wedge\,\forall a:\,\alpha[a,s']\rightarrow\phi[do(a,s')]\right)\]

\end_inset


\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $\phi$
\end_inset

 persists it must hold at 
\begin_inset Formula $s'$
\end_inset

, so there must be some 
\begin_inset Formula $a$
\end_inset

 such that 
\begin_inset Formula $\alpha[a,s']$
\end_inset

 and 
\begin_inset Formula $\neg\phi[do(a,s')]$
\end_inset

.
 But 
\begin_inset Formula $s\leq_{\alpha}do(a,s')$
\end_inset

 and so 
\begin_inset Formula $\phi[do(a,s')]$
\end_inset

 must hold by our assumption that 
\begin_inset Formula $\phi$
\end_inset

 persists, and we have a contradiction.
\end_layout

\begin_layout Proof
For the inductive case, assume that 
\begin_inset Formula $\Pst_{\Dt}^{n-1}(\phi,\alpha)$
\end_inset

 persists but 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 does not.
 By definition we have 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)=\Pst_{\Dt}^{1}(\Pst_{\Dt}^{n-1}(\phi,\alpha),\phi)$
\end_inset

, and we repeat the base case proof using 
\begin_inset Formula $\phi'=\Pst_{\Dt}^{n-1}(\phi,\alpha)$
\end_inset

 in place of 
\begin_inset Formula $\phi$
\end_inset

 to obtain a contradiction.
 
\end_layout

\begin_layout Lemma
Given a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "lem:p-implies-pn"

\end_inset


\begin_inset Formula \[
\Dt-\Dt_{S_{0}}\models\forall s:\,\left(\Pst_{\Dt}(\phi,\alpha)[s]\rightarrow\Pst_{\Dt}^{n}(\phi,\alpha)[s]\right)\]

\end_inset


\end_layout

\begin_layout Proof
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

 by definition.
 If 
\begin_inset Formula $\phi$
\end_inset

 persists at 
\begin_inset Formula $s$
\end_inset

, then by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:p-equiv-p(pn)"

\end_inset

 we have that 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 persists at 
\begin_inset Formula $s$
\end_inset

 .
 Since the persistence of 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 at 
\begin_inset Formula $s$
\end_inset

 implies that 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 holds at 
\begin_inset Formula $s$
\end_inset

 by definition, we have the lemma as desired.
 
\end_layout

\begin_layout Standard
We are now equipped to prove the major theorem of this paper: that if 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 implies 
\begin_inset Formula $\Pst_{\Dt}^{n+1}(\phi,\alpha)$
\end_inset

, then 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 is the persistence condition for 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Theorem
Given a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "thm:p(pn)-equiv-p"

\end_inset


\begin_inset Formula \begin{gather}
\Dt_{bg}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\Pst_{\Dt}^{n+1}(\phi,\alpha)[s]\label{eqn:pn_persists}\\
\mathit{\mathrm{iff}}\nonumber \\
\Dt-\Dt_{s_{0}}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\equiv\Pst_{\Dt}(\phi,\alpha)[s]\label{eqn:pn_equiv_persists}\end{gather}

\end_inset


\end_layout

\begin_layout Proof
For the 
\emph on
if
\emph default
 direction, we begin by expanding equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:pn_persists"

\end_inset

 using the definition of 
\begin_inset Formula $\Pst_{\Dt}^{1}$
\end_inset

 to get the equivalent form:
\begin_inset Formula \begin{gather*}
\Dt_{bg}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\Pst_{\Dt}^{1}(\Pst_{\Dt}^{n}(\phi,\alpha),\alpha)[s]\\
\Dt_{bg}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\left(\Pst_{\Dt}^{n}(\phi,\alpha)[s]\wedge\forall a:\,\Reg_{\Dt}(\alpha[a,s])\rightarrow\Reg_{\Dt}(\phi[do(a,s)])\right)\\
\Dt_{bg}\models\forall s,a:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\wedge\forall a:\,\Reg_{\Dt}(\alpha[a,s])\rightarrow\Reg_{\Dt}(\phi[do(a,s)])\end{gather*}

\end_inset

 By Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-reduction"

\end_inset

, equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:pn_persists"

\end_inset

 thus lets us conclude that 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

.
 By Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:p-equiv-p(pn)"

\end_inset

 this is equivalent to the persistence of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

, which is equivalent to 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 by definition, giving:
\begin_inset Formula \[
\Dt-\Dt_{s_{0}}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\Pst_{\Dt}(\phi,\alpha)[s]\]

\end_inset

 By Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:p-implies-pn"

\end_inset

 this implication is an equivalence, yielding equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_equiv_persists"

\end_inset

) as required.
\end_layout

\begin_layout Proof
The 
\emph on
only if
\emph default
 direction is a straightforward reversal of this reasoning: 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

, which implies the persistence of 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

, which yields equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_persists"

\end_inset

) by Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-reduction"

\end_inset

.
 
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\Dt_{bg}\models\Pst_{\Dt}^{n+1}(\phi,\alpha)\rightarrow\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 by definition, equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_persists"

\end_inset

) identifies 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 as a fixpoint of the 
\begin_inset Formula $\Pst_{\Dt}^{1}$
\end_inset

 operator, as our initial intuition suggested.
 In fact, we can use the constructive proof of Tarski's fixpoint theorem
 
\begin_inset CommandInset citation
LatexCommand citep
key "cousot79constructive_tarski"

\end_inset

 to establish that the persistence condition always exists for a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Theorem
Given a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, the persistence condition 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 always exists, and is unique up to equivalence under the static background
 theory 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "thm:p-always-exists"

\end_inset

 
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $L$
\end_inset

 be the subset of the Lindenbaum algebra of the static background theory
 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 containing only sentences uniform in 
\begin_inset Formula $s$
\end_inset

.
 
\begin_inset Formula $L$
\end_inset

 is thus a boolean lattice in which each element is a set of sentences uniform
 in 
\begin_inset Formula $s$
\end_inset

 that are equivalent under 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 
\begin_inset Formula $L$
\end_inset

 is a complete lattice with minimal element the equivalence class of 
\begin_inset Formula $\bot$
\end_inset

 and maximal element the equivalence class of 
\begin_inset Formula $\top$
\end_inset

.
 Fixing 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\PstDI$
\end_inset

 is a function whose domain and range are the elements of 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Proof
By definition, we have that 
\begin_inset Formula $\PstDI(\phi,\alpha)\,\rightarrow\,\phi$
\end_inset

, and 
\begin_inset Formula $\PstDI$
\end_inset

 is thus a 
\emph on
monotone decreasing
\emph default
 function over 
\begin_inset Formula $L$
\end_inset

.
 By the constructive proof of Tarski's fixpoint theorem, 
\begin_inset Formula $\PstDI$
\end_inset

 must have a unique greatest fixpoint less than the equivalence class of
 
\begin_inset Formula $\phi$
\end_inset

, which can be determined by transfinite iteration of the application of
 
\begin_inset Formula $\PstDI$
\end_inset

.
 By Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p(pn)-equiv-p"

\end_inset

, this fixpoint is the equivalence class of 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 under 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 
\end_layout

\begin_layout Standard
This theorem legitimates the use of the persistence condition for reasoning
 about property persistence queries -- for any persistence query at situation
 
\begin_inset Formula $\sigma$
\end_inset

, there is a unique (up to equivalence) corresponding query that is uniform
 in 
\begin_inset Formula $\sigma$
\end_inset

 and is thus amenable to standard effective reasoning techniques of the
 situation calculus.
\end_layout

\begin_layout Standard
Of course, it remains to actually calculate the persistence condition for
 a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

.
 The definition of 
\begin_inset Formula $\PstD(\phi,\alpha)$
\end_inset

 as a fixpoint suggests that it can be calculated by iterative approximation,
 which we discuss in the next section.
\end_layout

\begin_layout Section
Calculating 
\begin_inset Formula $\PstD$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Calculating"

\end_inset


\end_layout

\begin_layout Standard
Since we can easily calculate 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 for any 
\begin_inset Formula $n$
\end_inset

, we have a straightforward algorithm for determining 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

: search for an 
\begin_inset Formula $n$
\end_inset

 such that
\begin_inset Formula \[
\Dt_{bg}\models\forall s:\,\left(\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\Pst_{\Dt}^{n+1}(\phi,\alpha)[s]\right)\]

\end_inset

 Since we expect 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 to be simpler than 
\begin_inset Formula $\Pst_{\Dt}^{n+1}(\phi,\alpha)$
\end_inset

, we should look for the smallest such 
\begin_inset Formula $n$
\end_inset

.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 presents an iterative procedure for doing just that.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement !t
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Calculate 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:calc_p"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn}\Leftarrow\phi$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn1}\Leftarrow\Pst_{\Dt}^{1}(\mathtt{pn},\alpha)$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WHILE
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\Dt_{bg}\not\models\forall s:\,\mathtt{pn}[s]\rightarrow\mathtt{pn1}[s]$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn}\Leftarrow\mathtt{pn1}$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn1}\Leftarrow\Pst_{\Dt}^{1}[\mathtt{pn},\alpha]$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
ENDWHILE
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
RETURN
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn}$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the calculation of 
\begin_inset Formula $\Pst_{\Dt}^{1}(\phi,\alpha)$
\end_inset

 is a straightforward syntactic transformation, so we do not present an
 algorithm for it.
\end_layout

\begin_layout Subsection
Correctness
\end_layout

\begin_layout Standard
If Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 terminates, it terminates returning a value of 
\begin_inset Formula $pn$
\end_inset

 for which equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_persists"

\end_inset

) holds.
 By Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p(pn)-equiv-p"

\end_inset

 this value of 
\begin_inset Formula $pn$
\end_inset

 is equivalent to the persistence condition for 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
 The algorithm therefore correctly calculates the persistence condition.
\end_layout

\begin_layout Standard
In particular, note that equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_persists"

\end_inset

) holds when 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 is unsatisfiable for any situation, as it appears in the antecedent of
 an implication.
 The algorithm thus correctly returns an unsatisfiable condition (equivalent
 to 
\begin_inset Formula $\bot$
\end_inset

) when 
\begin_inset Formula $\phi$
\end_inset

 can never persist under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Subsection
Completeness
\end_layout

\begin_layout Standard
Since Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p(pn)-equiv-p"

\end_inset

 is an equivalence, the persistence condition is always the fixpoint of
 
\begin_inset Formula $\PstDI$
\end_inset

.
 From Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p-always-exists"

\end_inset

 this fixpoint always exists and can be calculated by transfinite iteration.
 Therefore, the only source of incompleteness in our algorithm will be failure
 to terminate.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 may fail to terminate for two reasons: the loop condition may never be
 satisfied, or the first-order logical inference in the loop condition may
 be undecidable and fail to terminate.
\end_layout

\begin_layout Standard
The later case indicates that the background theory 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 is undecidable.
 While this is a concern, it affects more than just our algorithm -- any
 system implemented around such an action theory will be incomplete.
 With respect to this source of incompleteness, our algorithm is no more
 incomplete than any larger reasoning system it would form a part of.
\end_layout

\begin_layout Standard
The former case is of more direct consequence to our work.
 Unfortunately, there is no guarantee in general that the fixpoint can be
 reached via 
\emph on
finite
\emph default
 iteration, which is required for termination of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

.
\end_layout

\begin_layout Standard
Indeed, it is straightforward to construct a fluent for which the algorithm
 never terminates: consider a fluent 
\begin_inset Formula $F(x,s)$
\end_inset

 that is affected by a single action that makes it false whenever 
\begin_inset Formula $F(suc(x),s)$
\end_inset

 is false.
 Letting 
\begin_inset Formula $\alpha$
\end_inset

 be vacuously true, the sequence of iterations produced by our algorithm
 would be:
\begin_inset Formula \begin{gather*}
\Pst_{\Dt}^{1}(F(x,s))\equiv F(x,s)\wedge F(suc(x),s)\\
\Pst_{\Dt}^{2}(F(x,s))\equiv F(x,s)\wedge F(suc(x),s)\wedge F(suc(suc(x)),s)\\
\vdots\\
\Pst_{\Dt}^{n}(F(x,s))\equiv\bigwedge_{i=0}^{i=n}F(suc^{i}(x),s)\end{gather*}

\end_inset

 The persistence condition in this case is clearly: 
\begin_inset Formula \[
\Pst_{\Dt}(F(x,s))\equiv\forall y:\, x\leq y\rightarrow F(y,s)\]

\end_inset

 While this is equivalent to the infinite conjunction produced as the limit
 of iteration in our algorithm, it will not be found after any finite number
 of steps.
\end_layout

\begin_layout Standard
As discussed in the proof of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p-always-exists"

\end_inset

, 
\begin_inset Formula $\Pst_{\Dt}^{1}$
\end_inset

 operates over the boolean lattice of equivalence classes of formulae uniform
 in 
\begin_inset Formula $s$
\end_inset

, and the theory of fixpoints requires that this lattice be 
\emph on
well-founded
\emph default
 to guarantee termination of an iterative approximation algorithm such as
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

.
 We must therefore identify restricted kinds of basic action theory for
 which this well-foundedness can be guaranteed.
\end_layout

\begin_layout Standard
The most obvious case is theories in which the action and object sorts are
 finite.
 In such theories the lattice of equivalence classes of formulae uniform
 in 
\begin_inset Formula $s$
\end_inset

 is finite, and any finite lattice is well-founded.
 These theories also have the advantage that the static domain reasoning
 performed by Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 can be done using propositional logic, meaning it is decidable and so providing
 a strong termination guarantee.
\end_layout

\begin_layout Standard
Alternately, suppose all successor state axioms and action description predicate
s have the following restricted form, where the terms in 
\begin_inset Formula $\vars y$
\end_inset

 are a subset of the terms in 
\begin_inset Formula $\vars x$
\end_inset

 and 
\begin_inset Formula $\Phi_{F}$
\end_inset

, 
\begin_inset Formula $\Pi_{ADP}$
\end_inset

 mention no terms other than 
\begin_inset Formula $\vars x$
\end_inset

, 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather*}
F(\vars x,do(a,s))\,\equiv\,\bigwedge_{i=1}^{n}a=a_{i}(\vars y_{i})\wedge\Phi_{F}(\vars x,a,s)\\
ADP(\vars x,a,s)\,\equiv\,\bigwedge_{i=1}^{n}a=a_{i}(\vars y)\wedge\Pi_{ADP}(\vars x,a,s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Under such theories, applications of 
\begin_inset Formula $\PstDI$
\end_inset

 will introduce no new terms into the query, apart from finitely many action
 terms 
\begin_inset Formula $a_{i}$
\end_inset

.
 The range of 
\begin_inset Formula $\PstDI$
\end_inset

 applied to 
\begin_inset Formula $\phi$
\end_inset

 is then a finite subset of the lattice of equivalence classes of formulae
 uniform in 
\begin_inset Formula $s$
\end_inset

, again guaranteed well-foundedness and terminating calculation of 
\begin_inset Formula $\Pst_{\Dt}$
\end_inset

.
\end_layout

\begin_layout Standard
Of course this is a very strong restriction on the structure of the theory,
 as the successor state axioms are not able to contain any quantifiers.
 It does demonstrate, however, that certain syntactical restrictions on
 
\begin_inset Formula $\Dt$
\end_inset

 are able to guarantee terminating calculation of 
\begin_inset Formula $\Pst_{\Dt}$
\end_inset

.
 It seems there should be a more general 
\begin_inset Quotes eld
\end_inset

syntactic well-foundedness
\begin_inset Quotes erd
\end_inset

 restriction that can be applied to these axioms, but we have not successfully
 formulated one at this stage.
\end_layout

\begin_layout Standard
In a similar vein, suppose that the theory of action is 
\emph on
context free
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter97progression"

\end_inset

.
 In such theories successor state axioms have the following form:
\begin_inset Formula \[
F(\vars x,do(a,s))\,\equiv\,\Phi_{F}^{+}(\vars x,a)\,\vee\,\left(F(\vars x,s)\,\wedge\,\neg\Phi_{F}^{-}(\vars x,a)\right)\]

\end_inset


\end_layout

\begin_layout Standard
The effects of an action are thus independent of the situation it is performed
 in.
 
\begin_inset CommandInset citation
LatexCommand citet
key "levesque98what_robots_can_do"

\end_inset

 demonstrate that such theories have a finite state space, again ensuring
 our algorithm operates over a finite lattice and hence guaranteeing termination.
 Context free domains are surprisingly expressive; for example, domains
 described in the style of STRIPS operators are context free.
\end_layout

\begin_layout Standard
From a slightly different perspective, suppose that 
\begin_inset Formula $\phi$
\end_inset

 can never persist under 
\begin_inset Formula $\alpha$
\end_inset

, so that 
\begin_inset Formula $\PstD(\phi,\alpha)\equiv\bot$
\end_inset

.
 Further suppose that 
\begin_inset Formula $\Dt$
\end_inset

 has the 
\emph on
compactness
\emph default
 property as in standard first-order logic.
 Then the 
\begin_inset Quotes eld
\end_inset

quantum levels
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset CommandInset citation
LatexCommand citet
key "savelli06sc_quantum_levels"

\end_inset

 guarantee that there is a fixed, finite number of actions within which
 
\begin_inset Formula $\neg\phi$
\end_inset

 can always be achieved.
 In this case Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 will determine 
\begin_inset Formula $\PstD(\phi,\alpha)\equiv\bot$
\end_inset

 within finitely many iterations.
\end_layout

\begin_layout Standard
It would also be interesting to determine whether known decidable variants
 of the situation calculus (such as 
\begin_inset CommandInset citation
LatexCommand citep
key "yu07twovar_sitcalc"

\end_inset

) are able to guarantee termination of the fixpoint construction, or whether
 more sophisticated fixpoint algorithms can be applied instead of simple
 iterative approximation.
 Investigating such algorithms would be a promising avenue for future research.
\end_layout

\begin_layout Standard
The important point here is not that we can guarantee completeness in general,
 but that we have precisely characterised the inductive reasoning necessary
 to answer property persistence queries, and shown that it can always be
 replaced by the evaluation of a uniform formula at the situation in question.
\end_layout

\begin_layout Subsection
Effectiveness
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Effectiveness"

\end_inset


\end_layout

\begin_layout Standard
Our algorithm replaces a single reasoning task based on the full action
 theory 
\begin_inset Formula $\Dt$
\end_inset

 with a series of reasoning tasks based on the static background theory
 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 Is this a worthwhile trade-off in practice? The following points weigh
 strongly in favour of our approach.
\end_layout

\begin_layout Standard
First and foremost, we avoid the need for the second-order induction axiom.
 All the reasoning tasks can be performed using standard first-order reasoning,
 for which there are high-quality automated provers.
 Second, the calculation of 
\begin_inset Formula $\Pst_{\Dt}$
\end_inset

 performs only 
\emph on
static doing reasoning
\emph default
, which as discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Background"

\end_inset

 is a comparatively straightforward task which can be made decidable under
 certain conditions.
 Third, 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)[\sigma]$
\end_inset

 is in a form amenable to regression, a standard tool for effective reasoning
 in the situation calculus.
 Fourth, the persistence condition for a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

 can be cached and re-used for a series of related queries about different
 situations, a significant gain in amortised efficiency.
 Finally, in realistic domains we expect many properties to fail to persist
 beyond a few situations into the future, meaning that our algorithm will
 require few iterations in a large number of cases.
\end_layout

\begin_layout Standard
Of course, we also inherit the potential disadvantage of the regression
 operator: the length of 
\begin_inset Formula $\Pst_{\Dt}(\phi,\alpha)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 As with regression, our experience has been that this is rarely a problem
 in practice, and is more than compensated for by the reduced complexity
 of the resulting reasoning task.
\end_layout

\begin_layout Subsection
Applications
\end_layout

\begin_layout Standard
The persistence condition is readily applicable to the example persistence
 query problems given in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Definitions"

\end_inset

.
 All of the transformed queries can then be answered using standard regression.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Goal Impossibility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no legal situation in which that goal is satisfied:
\begin_inset Formula \[
\Dt\,\models\,\Pst_{\Dt}(\neg G,Poss)[S_{0}]\]

\end_inset

 The persistence condition of 
\begin_inset Formula $\neg G$
\end_inset

 with respect to action legality allows goal impossibility to be checked
 easily.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Goal Futility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, establish that the goal cannot be satisfied in any legal future situation
 from 
\begin_inset Formula $\sigma$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\Pst_{\Dt}(\neg G,Poss)[\sigma]\]

\end_inset

 Precisely the same formula is required for checking goal impossibility
 and goal futility.
 This highlights the advantage of re-using the persistence condition at
 multiple situations.
 Our approach makes it feasible for an agent to check for goal futility
 each time it considers performing an action, and avoid situations that
 would make its goals unachievable.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Checking State Constraints:
\series default
 Given a state constraint 
\begin_inset Formula $SC$
\end_inset

, show that the constraint holds in every legal situation:
\begin_inset Formula \[
\Dt\,\models\,\Pst_{\Dt}(SC,Poss)[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
However, since we want a state constraint to 
\emph on
always
\emph default
 persist, it must satisfy the following equivalence:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Dt_{bg}\models\phi\equiv\Pst_{\Dt}(\phi,Poss)\]

\end_inset


\end_layout

\begin_layout Standard
If this equivalence does not hold then 
\begin_inset Formula $\Pst_{\Dt}(\phi,Poss)$
\end_inset

 indicates the additional conditions that are necessary to ensure that 
\begin_inset Formula $\phi$
\end_inset

 persists, which may be used to adjust the action theory to enforce the
 constraint.
 This particular application has strong parallels to the approach to state
 constraints developed by 
\begin_inset CommandInset citation
LatexCommand citet
key "Lin94-StateConstraints"

\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Need for Cooperation:
\series default
 Given an agent 
\begin_inset Formula $agt$
\end_inset

, goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, establish that no sequence of actions performed by that agent can achieve
 the goal:
\begin_inset Formula \[
\Dt\models\Pst_{\Dt}(\neg G,MyAction)[\sigma]\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Knowledge with Hidden Actions:
\series default
 In recent work 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_know_obs"

\end_inset

 we have developed a regression rule for knowledge that uses the persistence
 condition to account for arbitrarily-long sequences of hidden actions.
 While the details of this formulation are outside the scope of the current
 paper, the general form of the regression rule is:
\begin_inset Formula \[
\Reg_{\Dt}(\Knows(\phi,do(a,s)))\isdef\Knows(\Reg_{\Dt}(\Pst_{\Dt}(\phi,Hidden),a),s)\]

\end_inset


\end_layout

\begin_layout Section
An Example
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Conclusions
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Conclusion"

\end_inset


\end_layout

\begin_layout Standard
In this paper we have developed an algorithm that transforms property persistenc
e queries, a very general and useful class of situation calculus query,
 to a form that is amenable to standard techniques for effective reasoning
 in the situation calculus.
 The algorithm replaces a second-order induction axiom with a meta-level
 fixpoint calculation based on iterative application of the standard regression
 operator.
 It is shown to be correct, and also complete in some interesting cases.
\end_layout

\begin_layout Standard
Our approach generalises previous work on universally-quantified queries
 in several important ways.
 It can consider sequences of actions satisfying a range of conditions,
 not just the standard ordering over action possibility, enabling us to
 treat problems such as need for cooperation and knowledge with hidden actions.
 It can establish that properties persist in the future of an arbitrary
 situation, not necessarily the initial situation, enabling us to answer
 the question of goal futility.
 The results of calculating the persistence condition can be cached, allowing
 for example the goal futility question to be efficiently posed on a large
 number of situations once the persistence condition has been calculated.
\end_layout

\begin_layout Standard
Most importantly for the remainder of this thesis, we have 
\emph on
factored out
\emph default
 the inductive reasoning required to answer these queries.
 Work on increasing the effectiveness of this inductive reasoning, and on
 guaranteeing a terminating calculation in stronger classes of action theory,
 can now proceed independently from the development of formalisms that utilise
 persistence queries.
 We will henceforth use 
\begin_inset Formula $\PstD$
\end_inset

 as a kind of 
\begin_inset Quotes eld
\end_inset

black box
\begin_inset Quotes erd
\end_inset

 operator to formulate regression rules within our framework, dropping the
 explicit 
\begin_inset Formula $\Dt$
\end_inset

 subscript as we do for the regression operator.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
As noted in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Background"

\end_inset

, our use of fixpoints in this paper has much in common with the study of
 properties of ConGolog programs by 
\begin_inset CommandInset citation
LatexCommand citep
key "ternovska97congolog_fixpoint,classen08golog_properties"

\end_inset

.
 Indeed, a property persistence query is equivalent to a safety query stating
 that the property 
\begin_inset Formula $\phi$
\end_inset

 never becomes false during execution of the following program:
\begin_inset Formula \[
\delta_{P\alpha}\isdef\left(\pi(a,\,\alpha[a]?\,;\, a)\right)^{*}\]

\end_inset


\end_layout

\begin_layout Standard
Formally:
\begin_inset Formula \begin{gather*}
\Dt\,\models\,\forall s:\,\sigma\leq_{\alpha}s\,\rightarrow\,\phi[s]\\
\mathrm{iff}\\
\Dt\cup\Dt_{golog}\,\models\,\forall s,\delta:\, Trans^{*}(\delta_{P\alpha},\sigma,\delta,s)\,\rightarrow\,\phi[s]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Since we intend to use persistence queries as part of a larger reasoning
 apparatus, rather than as a stand-alone query, we cannot directly leverage
 the existing work on verifying ConGolog programs.
 However, given the similarity between the approaches, we are confident
 that advances in reasoning effectively about ConGolog programs will also
 advance our ability to effectively answer persistence queries.
\end_layout

\begin_layout Standard
This paper has thus significantly increased the scope of queries that can
 be posed when building systems upon the situation calculus.
 In the coming papers, the persistence condition operator will allow us
 to factor out certain inductive aspects of reasoning, treating them as
 separate, well-defined components of the overall reasoning machinery.
\end_layout

\begin_layout Section
Notes
\end_layout

\begin_layout Standard
push it harder, using wording similar to thesis examiner - 
\begin_inset Quotes eld
\end_inset

sound and complete
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

terminates in many interesting cases
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

verify sophisticated properties
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
example: goal impossibility using a context-free domain (to guarantee terminatio
n)
\end_layout

\begin_layout Section
\start_of_appendix
Detailed Proofs
\begin_inset CommandInset label
LatexCommand label
name "sec:Detailed-Proofs"

\end_inset


\end_layout

\begin_layout Extended Theorem
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:PstN-works"

\end_inset

 For any 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

 iff 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

 and in all successors of 
\begin_inset Formula $\sigma$
\end_inset

 reached by performing at most 
\begin_inset Formula $n$
\end_inset

 actions satisfying 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\,\models\,\Pst_{\Dt}^{n}(\phi,\alpha)[\sigma]\,\equiv\,\\
\bigwedge_{i\leq n}\forall a_{1},\dots,a_{i}:\,\left(\bigwedge_{j\leq i}\alpha[a_{j},do([a_{1},\dots,a_{j-1}],\sigma)]\,\,\rightarrow\,\,\phi[do([a_{1},\dots,a_{i}],\sigma)]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
By induction on the natural numbers.
 For 
\begin_inset Formula $n=0$
\end_inset

 we have 
\begin_inset Formula $\phi[\sigma]\equiv\phi[\sigma]$
\end_inset

 by definition.
 For the inductive case, we expand the definition of 
\begin_inset Formula $\Pst_{\Dt}^{n}(\phi,\alpha)[\sigma]$
\end_inset

 to get the following for the LHS:
\begin_inset Formula \[
\Pst_{\Dt}^{n-1}(\phi,\alpha)[\sigma]\wedge\forall a:\,\Reg_{\Dt}(\alpha[a,\sigma])\rightarrow\Reg_{\Dt}(\Pst_{\Dt}^{n-1}(\phi,\alpha)[do(a,\sigma)])\]

\end_inset


\end_layout

\begin_layout Proof
By the inductive hypothesis we can equate 
\begin_inset Formula $\Pst_{\Dt}^{n-1}(\phi,\alpha)[\sigma]$
\end_inset

 in this LHS with all but the 
\begin_inset Formula $i=n$
\end_inset

 clause from the RHS conjunction, and we suppress them on both sides.
 If we also drop the regression operators we are left with the following
 to establish:
\begin_inset Formula \begin{multline*}
\Dt\,\models\,\forall a:\,\alpha[a,\sigma]\rightarrow\Pst_{\Dt}^{n-1}(\phi,\alpha)[do(a,\sigma)]\,\equiv\,\\
\forall a_{1},\dots,a_{n}:\,\left(\bigwedge_{j\leq n}\alpha[a_{j},do([a_{1},\dots,a_{j-1}],\sigma)]\,\,\rightarrow\,\,\phi[do([a_{1},\dots,a_{n}],\sigma)]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
We can again use the inductive hypothesis on 
\begin_inset Formula $\Pst_{\Dt}^{n-1}$
\end_inset

 in the LHS of this equivalence.
 If we then distribute the 
\begin_inset Formula $\alpha[a,\sigma]$
\end_inset

 implication over the outermost conjunction and collect quantifiers, we
 obtain the following for the LHS:
\begin_inset Formula \begin{multline*}
\bigwedge_{i\leq n-1}\forall a,a_{1},\dots,a_{i}:\\
\left(\alpha[a,\sigma]\wedge\bigwedge_{j\leq i}\alpha[a_{j},do([a,a_{1},\dots,a_{j-1}],\sigma)]\rightarrow\phi[do([a,a_{1},\dots,a_{i}],\sigma)]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Renaming 
\begin_inset Formula $a\Rightarrow a_{1}$
\end_inset

, 
\begin_inset Formula $a_{1}\Rightarrow a_{2}$
\end_inset

, \SpecialChar \ldots{}
,
\begin_inset Formula $a_{i}\Rightarrow a_{i+1}$
\end_inset

, we see that each of the 
\begin_inset Formula $i<n-1$
\end_inset

 clauses on the LHS is equivalent to one of the 
\begin_inset Formula $i<n$
\end_inset

 clauses that have been suppressed on the RHS.
 The remaining 
\begin_inset Formula $i=n-1$
\end_inset

 clause is equivalent to the required RHS: 
\begin_inset Formula \[
\forall a_{1},\dots,a_{n}:\,\left(\bigwedge_{j\leq n}\alpha[a_{j},do([a_{1},\dots,a_{j-1}],\sigma)]\,\,\rightarrow\,\,\phi[do([a_{1},\dots,a_{n}],\sigma)]\right)\]

\end_inset


\end_layout

\begin_layout Proof
We therefore have the desired equivalence.
 
\end_layout

\begin_layout Lemma
For any basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "lem:a-order-reduction-lemma"

\end_inset


\begin_inset Formula \begin{gather*}
\mathrm{if}\\
\Sigma\cup\Dt_{bg}\cup\Dt_{ssa}\cup\Dt_{ad}\cup\{\phi[S_{0}]\}\models\forall s:\, S_{0}\leq_{\alpha}s\rightarrow\phi[s]\\
\mathrm{then}\\
\Dt_{bg}\models\forall s,a:\,\phi[s]\wedge\Reg_{\Dt}(\alpha[a,s])\rightarrow\Reg_{\Dt}(\phi[do(a,s)])\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
This is a straightforward generalisation of the proof of Lemma 5 in 
\begin_inset CommandInset citation
LatexCommand citep
key "Lin94-StateConstraints"

\end_inset

 using our modified notation.
 We repeat the details of the proof below for convenience.
\end_layout

\begin_layout Proof
Begin by assuming the antecedent:
\begin_inset Formula \begin{equation}
\Sigma\cup\Dt_{bg}\cup\Dt_{ssa}\cup\Dt_{ad}\cup\{\phi[S_{0}]\}\models\forall s:\, S_{0}\leq_{\alpha}s\rightarrow\phi[s]\label{eq:pst-at-s0}\end{equation}

\end_inset

Let 
\begin_inset Formula $M$
\end_inset

 be a model of 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 Suppose 
\begin_inset Formula $\mu_{s}$
\end_inset

 and 
\begin_inset Formula $\mu_{a}$
\end_inset

 are variable assignments for situation and action variables respectively,
 such that 
\begin_inset Formula $M,\mu_{s},\mu_{a}\models\phi[s]\wedge\Reg_{\Dt}(\alpha[a,s])$
\end_inset

.
 We show that 
\begin_inset Formula $M,\mu_{s},\mu_{a}\models\Reg_{\Dt}(\phi[do(a,s)])$
\end_inset

.
 Construct a model 
\begin_inset Formula $M'$
\end_inset

 such that:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $M'$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 share the same domains for sorts 
\noun on
Action
\noun default
 and 
\noun on
Object
\end_layout

\begin_layout Itemize
\begin_inset Formula $M'$
\end_inset

 interprets every rigid predicate and function the same as 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $M'\models\Sigma\cup\Dt_{ssa}\cup\Dt_{ad}$
\end_inset


\end_layout

\begin_layout Itemize
For every variable assignment for object variables 
\begin_inset Formula $\mu_{o}$
\end_inset

, and for every fluent 
\begin_inset Formula $F(\vars x,s),$
\end_inset

 
\begin_inset Formula $M',\mu_{o}\models F(\vars x,S_{0})$
\end_inset

 iff 
\begin_inset Formula $M,\mu_{s},\mu_{o}\models F(\vars x,s)$
\end_inset


\end_layout

\end_deeper
\begin_layout Proof
Since 
\begin_inset Formula $M,\mu_{s},\mu_{a}\models\Reg(\alpha[a,s])$
\end_inset

 and 
\begin_inset Formula $M'\models\Dt_{ad}$
\end_inset

 we have:
\begin_inset Formula \[
M',\mu_{a}\models\Sigma\cup\Dt_{bg}\cup\Dt_{ssa}\cup\Dt_{ad}\cup\{\phi[S_{0}]\}\cup\{\alpha[a,S_{0}]\}\]

\end_inset


\end_layout

\begin_layout Proof
By our assumption 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pst-at-s0"

\end_inset

, 
\begin_inset Formula $M',\mu_{a}\models\phi[do(a,S_{0})]$
\end_inset

.
 Since 
\begin_inset Formula $M'$
\end_inset

 satisfies 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 the regression operator can be employed to yield 
\begin_inset Formula $M',\mu_{a}\models\Reg_{\Dt}(\phi[do(a,s)])$
\end_inset

.
 This is the same as the result of replacing 
\begin_inset Formula $s$
\end_inset

 with 
\begin_inset Formula $S_{0}$
\end_inset

 in 
\begin_inset Formula $\Reg_{\Dt}(\phi[do(a,s)])$
\end_inset

, so we obtain:
\begin_inset Formula \[
M',\mu_{a}\models\Reg_{\Dt}(\phi[do(a,S_{0})])\,\,\mathrm{iff}\,\, M,\mu_{s},\mu_{a}\models\Reg_{\Dt}(\phi[do(a,s)])\]

\end_inset


\end_layout

\begin_layout Proof
Since we have the LHS of this equivalence by construction, we can conclude
 the RHS.
 This suffices to establish the lemma.
\end_layout

\begin_layout Extended Proposition
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-reduction"

\end_inset

 For any basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt-\Dt_{S_{0}}\models\forall s:\,\phi[s]\rightarrow\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\\
\mathrm{iff}\\
\Dt_{bg}\models\forall s,a:\,\phi[s]\wedge\Reg_{\Dt}(\alpha[a,s])\rightarrow\Reg_{\Dt}(\phi[do(a,s)])\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
The 
\emph on
if 
\emph default
direction is straightforward using the induction axiom from Proposition
 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-induction"

\end_inset

.
 For the 
\emph on
only-if
\emph default
 direction, we can take the 
\begin_inset Formula $S_{0}$
\end_inset

 case of the LHS to obtain:
\begin_inset Formula \[
\Dt-\Dt_{S_{0}}\models\phi[S_{0}]\rightarrow\left(\forall s:\, S_{0}\leq_{\alpha}s\rightarrow\phi[s]\right)\]

\end_inset


\end_layout

\begin_layout Proof
Lifting 
\begin_inset Formula $\phi[S_{0}]$
\end_inset

 into the axioms, this precisely matches the form of Lemma 
\begin_inset CommandInset ref
LatexCommand eqref
reference "lem:a-order-reduction-lemma"

\end_inset

 and we have the theorem as desired.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../../../library/references"
options "plainnat"

\end_inset


\end_layout

\end_body
\end_document
