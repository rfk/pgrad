#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass tech-elsarticle
\begin_preamble
\usepackage{algorithm}
\usepackage{algorithmic}
\biboptions{sort}
\journal{Artificial Intelligence}
\end_preamble
\options preprint,12pt
\use_default_options true
\language british
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine natbib_authoryear
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\isdef}{\stackrel{\mbox{\tiny def}}{=}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\Dt}{\mathcal{D}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\Reg}{\mathcal{R}_{\Dt}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\Pst}{\mathcal{P}_{\Dt}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\vars}[1]{\bar{#1}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\Lsit}{\mathcal{L}_{sitcalc}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\Knows}{\mathbf{Knows}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\PstN}[1]{\Pst^{#1}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
author{Ryan F.
 Kelly}
\end_layout

\begin_layout Plain Layout


\backslash
ead{rfk@csse.unimelb.edu.au}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
author{Adrian R.
 Pearce}
\end_layout

\begin_layout Plain Layout


\backslash
ead{adrian@csse.unimelb.edu.au}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
address{Department of Computer Science and Software Engineering}
\end_layout

\begin_layout Plain Layout


\backslash
address{The University of Melbourne} 
\end_layout

\begin_layout Plain Layout


\backslash
address{Victoria, 3010, Australia}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Property Persistence in the Situation Calculus
\end_layout

\begin_layout Abstract
We develop a new automated reasoning technique for the situation calculus
 that can handle queries containing universal quantification over situation
 terms.
 Although such queries arise naturally in many important reasoning tasks,
 they are difficult to automate in the situation calculus due to the presence
 of a second-order induction axiom.
 We show how to reduce queries about property persistence, a common type
 of universally-quantified query, to an equivalent form that does not quantify
 over situations and is thus amenable to existing automated reasoning techniques.
 The algorithm for doing so replaces induction with a meta-level fixpoint
 calculation; crucially, this calculation utilises only first-order reasoning
 with a limited set of axioms.
 The result is a powerful new tool for verifying sophisticated domain properties
 in the situation calculus.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus is one of the most popular and influential AI formalisms
 for reasoning about action and change, having found application in a wide
 variety of both theoretical and practical works 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter91frameprob,shapiro02casl,giacomo04sem_delib_indigolog,ghaderi07sc_joint_ability,Ferrein2005readylog,farinelli07team_golog"

\end_inset

.
 A major contributor to the success of the formalism is that it combines
 a powerful modelling language built on first-order logic with easily implementa
ble techniques for effective automated reasoning.
\end_layout

\begin_layout Standard
A key challenge when working with the situation calculus is managing this
 balance between expressivity and effectiveness.
 An induction axiom is used to define the structure of situations terms,
 so answering arbitrary queries requires reasoning in second-order logic
 and is prohibitively expensive in general 
\begin_inset CommandInset citation
LatexCommand citep
key "Reiter93proving"

\end_inset

.
 But if queries are restricted to certain syntactic forms, it is possible
 obtain much more effective reasoning procedures -- for example, queries
 restricted to existential quantification over situations can be answered
 using only first-order logic 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

, while queries containing only ground situation terms permit special-purpose
 techniques such as regression 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter91frameprob"

\end_inset

.
\end_layout

\begin_layout Standard
However, there are many important reasoning tasks that require 
\emph on
universal
\emph default
 quantification over situation terms, for which the situation calculus currently
 offers no effective reasoning tools.
 One simple example is the problem of goal impossibility -- establishing
 that all possible situations fail to satisfy a goal.
 In this paper we study a subset of universally-quantified queries which
 we refer to as 
\emph on
property persistence queries
\emph default
: under a particular situation calculus theory 
\begin_inset Formula $\mathcal{D}$
\end_inset

, and given some formula 
\begin_inset Formula $\phi$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, determine whether 
\begin_inset Formula $\phi$
\end_inset

 will hold in all situations in the future of 
\begin_inset Formula $\sigma$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\models\forall s:\,\sigma\sqsubseteq s\,\rightarrow\,\phi[s]\]

\end_inset

The need for second-order logic has traditionally limited automated reasoning
 about such queries.
 We introduce a new approach to property persistence that is similar in
 spirit to the standard regression operator, by defining a meta-level operator
 
\begin_inset Formula $\Pst$
\end_inset

 such that 
\begin_inset Formula $\phi$
\end_inset

 persists at 
\begin_inset Formula $\sigma$
\end_inset

 if and only if 
\begin_inset Formula $\Pst(\phi)$
\end_inset

 holds at 
\begin_inset Formula $\sigma$
\end_inset

.
 We term the resulting formula the 
\emph on
persistence condition
\emph default
 of 
\begin_inset Formula $\phi$
\end_inset

 and show how to calculate it as a fixpoint of applications of the regression
 operator; crucially, this calculation requires only first-order logic and
 a limited set of axioms.
 The persistence condition is also guaranteed to be in a form amenable to
 existing automated reasoning techniques.
\end_layout

\begin_layout Standard
The result is a powerful new technique for exploring sophisticated domain
 properties in the situation calculus.
 It allows some second-order aspects of the theory to be 
\begin_inset Quotes eld
\end_inset

factored out
\begin_inset Quotes erd
\end_inset

 and handled using a special-purpose algorithm.
 The technique is sound and complete for property persistence queries, and
 the fixpoint calculation provably terminates in several interesting cases.
 Perhaps most importantly, it builds upon and integrates well with the current
 standard techniques for effective automated reasoning, so our technique
 can be used directly in existing theories and systems based on the situation
 calculus.
\end_layout

\begin_layout Standard
A preliminary version of this paper has previously appeared as 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_persistence"

\end_inset

; this revised edition includes extended and additional proofs, a more comprehen
sive discussion of the termination properties of our algorithm, and a detailed
 example of how the persistence condition can be used to reason about goal
 impossibility -- a deceptively simple task which is nonetheless beyond
 the reach of existing reasoning techniques.
\end_layout

\begin_layout Standard
The paper now proceeds with a brief review of the situation calculus, before
 formally defining the persistence condition and establishing its effectiveness
 as a reasoning tool.
 Readers familiar with the situation calculus are encouraged to review the
 background material in Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Background"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Effective-Reasoning"

\end_inset

, as we make some conservative extensions to the standard notation that
 greatly simplify the development of our approach: the unique names axioms
 
\begin_inset Formula $\Dt_{una}$
\end_inset

 are incorporated into a general background theory 
\begin_inset Formula $\Dt_{bg}$
\end_inset

; the 
\begin_inset Formula $Poss$
\end_inset

 fluent is subsumed by a general class of 
\emph on
action description predicates
\emph default
 defined in 
\begin_inset Formula $\Dt_{ad}$
\end_inset

; we parameterise the 
\begin_inset Quotes eld
\end_inset

future situations
\begin_inset Quotes erd
\end_inset

 predicate 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 to assert that all intermediate actions satisfy a given predicate using
 
\begin_inset Formula $s<_{\alpha}s'$
\end_inset

; and we use the single-step variant of the regression operator, with correspond
ing definitions of regressable formulae.
\end_layout

\begin_layout Section
The Situation Calculus
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Background"

\end_inset


\end_layout

\begin_layout Standard
The situation calculus is a powerful formalism for describing and reasoning
 about dynamic worlds.
 It was first introduced by 
\begin_inset CommandInset citation
LatexCommand citet
key "McCHay69sitcalc"

\end_inset

 and has since been significantly expanded and formalised 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter91frameprob,pirri99contributions_sitcalc"

\end_inset

.
 We use the particular variant due to Reiter et.
 al.
 at the University of Toronto, sometimes called the 
\begin_inset Quotes eld
\end_inset

Toronto school
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

situations-as-histories
\begin_inset Quotes erd
\end_inset

 version.
 The formalisation below is based on the standard definitions from 
\begin_inset CommandInset citation
LatexCommand citep
key "levesque98sc_foundations,pirri99contributions_sitcalc,reiter01kia"

\end_inset

, with some conservative extensions.
\end_layout

\begin_layout Standard
The language 
\begin_inset Formula $\Lsit$
\end_inset

 of the situation calculus is a many-sorted language of second-order logic
 with equality, containing the following disjoint sorts:
\end_layout

\begin_layout Itemize

\emph on
\noun on
Action
\emph default
\noun default
 terms denote individual instantaneous events that can cause the state of
 the world to change; 
\end_layout

\begin_layout Itemize

\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\end_layout

\begin_layout Itemize

\noun on
Object
\noun default
 terms represent any other object in the domain.
 
\end_layout

\begin_layout Standard
\begin_inset space \thinspace{}
\end_inset


\end_layout

\begin_layout Standard

\emph on
Fluents
\emph default
 are predicates representing properties of the world that may change between
 situations, and so take a situation term as their final argument.
 Predicates and functions that do not take a situation term are called 
\emph on
rigid
\emph default
.
 We use the term 
\emph on
primitive fluent
\emph default
 to describe fluents that are directly affected by actions, rather than
 being defined in terms of other fluents.
 No functions other than 
\begin_inset Formula $S_{0}$
\end_inset

 and 
\begin_inset Formula $do$
\end_inset

 produce values of sort 
\noun on
Situation
\noun default
.
 For the sake of clarity we will not consider functional fluents in this
 paper; this is a common simplifying assumption in the situation calculus
 literature and does not result in a loss of generality.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\Lsit$
\end_inset

 contains the standard alphabet of logical connectives, constants 
\begin_inset Formula $\top$
\end_inset

 and 
\begin_inset Formula $\bot$
\end_inset

, countably infinitely many variables of each sort, countably infinitely
 many predicates of each arity, etc; for a complete definition, consult
 the foundational paper by 
\begin_inset CommandInset citation
LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

.
 We follow standard naming conventions for the situation calculus: upper-case
 roman names indicate constants; lower-case roman names indicate variables;
 greek characters indicate meta-variables or formula templates.
 All axioms universally close over their free variables at outermost scope.
 The notation 
\begin_inset Formula $\vars t$
\end_inset

 indicates a vector of terms of context-appropriate arity and type.
 The connectives 
\begin_inset Formula $\wedge$
\end_inset

, 
\begin_inset Formula $\neg$
\end_inset

, 
\begin_inset Formula $\exists$
\end_inset

 are taken as primitive, with 
\begin_inset Formula $\vee$
\end_inset

, 
\begin_inset Formula $\rightarrow$
\end_inset

, 
\begin_inset Formula $\equiv$
\end_inset

, 
\begin_inset Formula $\forall$
\end_inset

 defined in the usual manner.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Complex properties of the state of the world are represented using 
\emph on
uniform formulae
\emph default
.
 These are basically logical combinations of fluents referring to a common
 situation term.
\end_layout

\begin_layout Labelled Definition
Uniform
\begin_inset space ~
\end_inset

Formulae Let 
\begin_inset Formula $\sigma$
\end_inset

 be a fixed situation term, 
\begin_inset Formula $R$
\end_inset

 an arbitrary rigid predicate, 
\begin_inset Formula $F$
\end_inset

 an arbitrary primitive fluent predicate, 
\begin_inset Formula $\tau$
\end_inset

 an arbitrary term that is not of sort 
\noun on
Situation
\noun default
, and 
\begin_inset Formula $x$
\end_inset

 an arbitrary variable that is not of sort 
\noun on
Situation
\noun default
.
 Then the formulae uniform in 
\begin_inset Formula $\sigma$
\end_inset

 are the smallest set of syntactically-valid formulae satisfying:
\begin_inset Formula \[
\phi::=F(\vars{\tau},\sigma)\,|\, R(\vars{\tau})\,|\,\tau_{1}=\tau_{2}\,|\,\phi_{1}\wedge\phi_{2}\,|\,\neg\phi\,|\,\exists x:\phi\]

\end_inset


\end_layout

\begin_layout Standard
We will call a formula 
\emph on
uniform
\emph default
 if it is uniform in some situation.
 The important aspect of this definition is that the formula refers to no
 situation other than 
\begin_inset Formula $\sigma$
\end_inset

, which appears as the final argument of all fluents in the formula.
 In particular, uniform formulae cannot quantify over situations or compare
 situation terms, and cannot contain non-primitive fluents.
\end_layout

\begin_layout Standard
The meta-variable 
\begin_inset Formula $\phi$
\end_inset

 is used throughout to refer to an arbitrary uniform formula.
 The notation 
\begin_inset Formula $\phi[s']$
\end_inset

 represents a uniform formula with the particular situation 
\begin_inset Formula $s'$
\end_inset

 inserted into all its fluents, replacing whatever situation term was previously
 there.
 Note that this is simply a syntactic shorthands designed to keep the presentati
on clean and readable -- it is 
\emph on
not
\emph default
 an operation from the logic itself.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The dynamics of a particular domain are captured by a set of sentences called
 a 
\emph on
basic action theory
\emph default
.
 Queries about the behaviour of the world are posed as logical entailment
 queries relative to this theory.
\end_layout

\begin_layout Labelled Definition
Basic
\begin_inset space ~
\end_inset

Action
\begin_inset space ~
\end_inset

Theory A basic action theory, denoted 
\begin_inset Formula $\Dt$
\end_inset

, is a set of situation calculus sentences (of the specific syntactic form
 outlined below) describing a particular dynamic world.
 It consists of the following disjoint sets: the foundational axioms of
 the situation calculus (
\begin_inset Formula $\Sigma$
\end_inset

); action description axioms defining various aspects of action performance,
 such as preconditions (
\begin_inset Formula $\Dt_{ad}$
\end_inset

); successor state axioms describing how primitive fluents change between
 situations (
\begin_inset Formula $\Dt_{ssa}$
\end_inset

); axioms describing the value of primitive fluents in the initial situation
 (
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

); and axioms describing the static background facts of the domain (
\begin_inset Formula $\Dt_{bg}$
\end_inset

):
\begin_inset Formula \[
\Dt=\Sigma\cup\Dt_{ad}\cup\Dt_{ssa}\cup\Dt_{S_{0}}\cup\Dt_{bg}\]

\end_inset


\end_layout

\begin_layout Standard
These axioms must satisfy some simple consistency criteria in order to constitut
e a valid domain description 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 This is a conservative extension of the standard definition of a basic
 action theory, intended to simplify the details of our forthcoming development.
\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 is a collection of sentences uniform in 
\begin_inset Formula $S_{0}$
\end_inset

 that describe the initial state of the world, while the set 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 contains all the situation-independent facts about the domain.
 Standard notation includes situation-independent facts in 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

, but our upcoming definitions require that they be separate.
 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 includes the standard unique names axioms for actions 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 contains one 
\emph on
successor state axiom
\emph default
 for each primitive fluent in the domain, providing a monotonic solution
 to the frame problem for that fluent.
 These axioms would typically have the following form: 
\begin_inset Formula \[
F(\vars x,do(a,s))\equiv\Phi_{F}^{+}(\vars x,a,s)\,\,\vee\,\, F(\vars x,s)\wedge\neg\Phi_{F}^{-}(\vars x,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $\Phi_{F}^{+}$
\end_inset

 and 
\begin_inset Formula $\Phi_{F}^{-}$
\end_inset

 are formulae uniform in 
\begin_inset Formula $s$
\end_inset

.
 This may be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $F$
\end_inset

 is true after performing 
\begin_inset Formula $a$
\end_inset

 if 
\begin_inset Formula $a$
\end_inset

 made it true, or it was previously true and 
\begin_inset Formula $a$
\end_inset

 did not make it false
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The axiom set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 defines fluents that describe various aspects of the performance of an
 action, which we call 
\emph on
action description predicates
\emph default
.
 The precondition predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 is the canonical example, indicating whether it is possible to perform
 an action in a given situation.
 In principle there can be any number of predicates or functions defined
 in a similar way -- a common example is the function 
\begin_inset Formula $SR$
\end_inset

 used to axiomatise sensing actions in 
\begin_inset CommandInset citation
LatexCommand citep
key "scherl03sc_knowledge"

\end_inset

.
 The meta-predicate 
\begin_inset Formula $\alpha$
\end_inset

 will denote an arbitrary action description predicate.
 For each such predicate the set 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 contains a single axiom of the following form, where 
\begin_inset Formula $\Pi_{\alpha}$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \[
\alpha(\vars x,a,s)\,\equiv\,\Pi_{\alpha}(\vars x,a,s)\]

\end_inset


\end_layout

\begin_layout Standard
Note that this is a departure from the standard notion, where a separate
 axiom specifies the preconditions for each individual action type 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

.
 The single-axiom approach used here embodies a domain closure assumption
 on the 
\noun on
Action
\noun default
 sort, and is necessary when reasoning about formulae that universally quantify
 over actions 
\begin_inset CommandInset citation
LatexCommand citep
key "savelli06sc_quantum_levels,vassos08progression_future_queries"

\end_inset

.
\end_layout

\begin_layout Standard
For convenience we will allow action description predicates to be defined
 in terms of other action description predicates; as long as these definitions
 are well-founded they can be expanded out to reference only primitive fluents.
\end_layout

\begin_layout Standard
The foundational axioms 
\begin_inset Formula $\Sigma$
\end_inset

 ensure that situations form a branching-time account of the world state.
 There is a distinguished situation term 
\begin_inset Formula $S_{0}$
\end_inset

 called the
\emph on
 initial situation
\emph default
, and situations in general form a tree structure with 
\begin_inset Formula $S_{0}$
\end_inset

 at the root and 
\begin_inset Formula $do(a,s)$
\end_inset

 constructing the situation that results from performing action 
\begin_inset Formula $a$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

.
 We abbreviate the performance of several successive actions by writing:
\begin_inset Formula \[
do([a_{1},\dots,a_{n}],s)\,\isdef\, do(a_{n},do(\dots,do(a_{1},s)))\]

\end_inset


\end_layout

\begin_layout Standard
The relation 
\begin_inset Formula $s\sqsubset s'$
\end_inset

 indicates that 
\begin_inset Formula $s'$
\end_inset

 is in the future of 
\begin_inset Formula $s$
\end_inset

:
\begin_inset Formula \begin{gather*}
\neg(s\sqsubset S_{0})\\
s\sqsubset do(a,s')\equiv s\sqsubseteq s'\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $s\sqsubseteq s'$
\end_inset

 is the standard abbreviation for 
\begin_inset Formula $s\sqsubset s'\vee s=s'$
\end_inset

.
 This notation for 
\begin_inset Quotes eld
\end_inset

in the future of
\begin_inset Quotes erd
\end_inset

 can be extended to consider only those futures in which all actions satisfy
 a particular action description predicate.
 We include a relation 
\begin_inset Formula $<_{\alpha}$
\end_inset

 for each action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, with the following definitions:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather*}
\neg\left(s<_{\alpha}S_{0}\right)\\
s<_{\alpha}do(a,s')\equiv s\leq_{\alpha}s'\wedge\alpha(a,s')\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
For example, by stating that 
\begin_inset Formula $s<_{Poss}s'$
\end_inset

 we assert that not only is 
\begin_inset Formula $s'$
\end_inset

 in the future of 
\begin_inset Formula $s$
\end_inset

, but that all actions performed between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 were actually possible; this is equivalent to the 
\begin_inset Formula $<$
\end_inset

 operator of 
\begin_inset CommandInset citation
LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

.
 Note that we suppress the action and situation arguments of the action
 description predicate in order to simplify the presentation.
\end_layout

\begin_layout Standard
Finally, a second-order induction axiom is used to assert that all situations
 must be constructed by performing a finite sequence of actions:
\begin_inset Formula \[
\forall P:\,\left[P(S_{0})\wedge\forall s,a:\,\left(P(s)\rightarrow P(do(a,s))\right)\right]\,\rightarrow\,\forall s:\, P(s)\]

\end_inset


\end_layout

\begin_layout Standard
This axiom is the only second-order sentence in a basic action theory, and
 is vital to the proper semantics of statements that universally quantify
 over situation terms 
\begin_inset CommandInset citation
LatexCommand citep
key "Reiter93proving"

\end_inset

.
\end_layout

\begin_layout Section
Property Persistence Queries
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence-Queries"

\end_inset


\end_layout

\begin_layout Standard
With this notation in hand, let us now formally define the kinds of query
 that are of interest in this paper.
 Given some uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, a 
\emph on
property persistence query
\emph default
 asks whether 
\begin_inset Formula $\phi$
\end_inset

 will hold in all situations in the future of 
\begin_inset Formula $\sigma$
\end_inset

: 
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\sqsubseteq s\,\rightarrow\,\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
More generally, one may wish to limit the futures under consideration to
 those brought about by actions satisfying a certain predicate 
\begin_inset Formula $\alpha$
\end_inset

, which is easily accomplished using the 
\begin_inset Formula $\leq_{\alpha}$
\end_inset

 relation.
 We thus have the following definition of a property persistence query:
\end_layout

\begin_layout Labelled Definition
Property
\begin_inset space ~
\end_inset

Persistence
\begin_inset space ~
\end_inset

Query Let 
\begin_inset Formula $\phi$
\end_inset

 be a uniform formula, 
\begin_inset Formula $\alpha$
\end_inset

 an action description predicate, and 
\begin_inset Formula $\sigma$
\end_inset

 a situation term.
 Then a property persistence query is a query of the form:
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\le_{\alpha}s\rightarrow\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
In words, a persistence query states that 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

, and assuming all subsequent actions satisfy 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\phi$
\end_inset

 will continue to hold
\begin_inset Quotes erd
\end_inset

.
 For succinctness we will henceforth describe this as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Such queries are involved in many useful reasoning tasks; the following
 are a small selection:
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Goal Impossibility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no legal situation in which that goal is achieved:
\begin_inset Formula \[
\Dt\models\forall s:\, S_{0}\leq_{Poss}s\rightarrow\neg G(s)\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Goal Futility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, establish that the goal cannot be achieved in any legal future of 
\begin_inset Formula $\sigma$
\end_inset

:
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\leq_{Poss}s\rightarrow\neg G(s)\]

\end_inset


\end_layout

\begin_layout Standard
Note how this differs from goal impossibility: while the goal may have initially
 been achievable, subsequent actions have rendered the goal unachievable.
 Detecting and avoiding such situations could be a very important task.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Checking State Constraints:
\series default
 Given a state constraint 
\begin_inset Formula $SC$
\end_inset

, show that the constraint holds in every legal situation:
\begin_inset Formula \[
\Dt\models\forall s:\, S_{0}\leq_{Poss}s\rightarrow SC(s)\]

\end_inset

 This can be seen as a variant of goal impossibility, by showing that the
 constraint can never be violated.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Need for Cooperation:
\series default
 Given an agent 
\begin_inset Formula $agt$
\end_inset

, goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, establish that no sequence of actions performed by that agent only can
 achieve the goal.
 Suppose we define 
\begin_inset Formula $MyAction$
\end_inset

 to identify the agent's own actions:
\begin_inset Formula \[
MyAction(a,s)\,\isdef\, actor(a)=agt\]

\end_inset


\end_layout

\begin_layout Standard
Then the appropriate query is:
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\leq_{MyAction}s\rightarrow\neg G(s)\]

\end_inset

 If this is the case, the agent will need to seek cooperation from another
 agent in order to achieve its goal.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Knowledge with Hidden Actions:
\series default
 An agent reasoning about its own knowledge in an asynchronous domain must
 take into account arbitrarily-long sequences of hidden actions 
\begin_inset CommandInset citation
LatexCommand citep
key "vanBentham06tree_of_knowledge,kelly07sc_know_obs"

\end_inset

.
 To establish that it knows 
\begin_inset Formula $\phi$
\end_inset

, it must establish that 
\begin_inset Formula $\phi$
\end_inset

 cannot become false through such a sequence:
\begin_inset Formula \[
\Dt\models\forall s:\,\sigma\leq_{Hidden}s\rightarrow\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
As a more detailed example, which we will revisit in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Example:"

\end_inset

, consider a domain in which a thief may try to steal some gold from a safe.
 There is a light in the room, and a security camera that will detect the
 thief's actions as long as the light is on.
 The safe can be open or closed, but the gold can only be stolen if the
 safe is open.
 It is possible for the thief to crack the safe and force it open, but only
 if the light is on.
 
\end_layout

\begin_layout Standard
The actions in this domain are 
\begin_inset Formula $takeGold$
\end_inset

, 
\begin_inset Formula $crackSafe$
\end_inset

 and 
\begin_inset Formula $toggleLight$
\end_inset

, the primitive fluents are 
\begin_inset Formula $SafeOpen$
\end_inset

, 
\begin_inset Formula $LightOn$
\end_inset

 and 
\begin_inset Formula $Stolen$
\end_inset

, and the action description predicates include the standard 
\begin_inset Formula $Poss(a,s)$
\end_inset

 and and a custom predicate 
\begin_inset Formula $Undet(a,s)$
\end_inset

 indicating that action 
\begin_inset Formula $a$
\end_inset

 would not be detected by the security camera.
 The complete axioms can be found in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "apdx:Axioms"

\end_inset

.
\end_layout

\begin_layout Standard
As the owners of the gold, we would like to ensure that the thief cannot
 steal it.
 Unfortunately this is not possible, as nothing prevents him from simply
 cracking the safe and taking the gold.
 We can, however, ensure that the thief cannot take steal the gold 
\emph on
undetected.

\emph default
 Formally, we want to establish that 
\begin_inset Quotes eld
\end_inset

no sequence of undetected actions results in the gold being stolen
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\forall s:\, S_{0}\leq_{Undet}s\,\rightarrow\,\neg Stolen(s)\]

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Intuitively, this will be the case as long as the gold is not already stolen,
 and either the light is on (so the thief's actions will be detected) or
 the safe is closed (so the thief must switch on the light to crack it):
\begin_inset Formula \[
\Dt_{bg}\cup\Dt_{S_{0}}\,\models\,\neg Stolen(S_{0})\wedge\left[\neg SafeOpen(S_{0})\vee LightOn(S_{0})\right]\]

\end_inset


\end_layout

\begin_layout Standard
A manual proof of this simple domain property is straightforward, but it
 is beyond the reach of the standard automated reasoning tools of the situation
 calculus.
 The difficulty, as we shall explore in the next section, stems from the
 use of a second-order induction axiom to define the set of all situations.
\end_layout

\begin_layout Section
Effective Reasoning
\begin_inset CommandInset label
LatexCommand label
name "sec:Effective-Reasoning"

\end_inset


\end_layout

\begin_layout Standard
An important feature of the situation calculus is the existence of effective
 reasoning procedures for certain types of query.
 In the general case, answering a query about a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 is a theorem-proving task in second-order logic (denoted SOL) due to the
 induction axiom:
\begin_inset Formula \[
\Dt\models_{SOL}\psi\]

\end_inset

 
\end_layout

\begin_layout Standard
This is clearly problematic for effective automated reasoning.
 Fortunately, restricting the syntactic form of queries can allow us to
 discard some axioms from 
\begin_inset Formula $\Dt$
\end_inset

 and make automated reasoning easier.
\end_layout

\begin_layout Standard
A core result of 
\begin_inset CommandInset citation
LatexCommand citet
key "pirri99contributions_sitcalc"

\end_inset

 is that if a query performs only 
\emph on
existential
\emph default
 quantification over situations, then it can be answered without the induction
 axiom (denoted 
\begin_inset Formula $I$
\end_inset

) and thus using only first-order logic (FOL):
\begin_inset Formula \begin{gather*}
\Dt\models_{SOL}\exists s:\,\psi(s)\\
\mathrm{iff}\\
\Dt-\{I\}\models_{FOL}\exists s:\,\psi(s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
While this is a substantial improvement over requiring a second-order theorem
 prover, it is still far from an effective technique.
 Effective reasoning requires that the set of axioms be reduced as much
 as possible.
\end_layout

\begin_layout Standard
In their work on state constraints, 
\begin_inset CommandInset citation
LatexCommand citet
key "Lin94-StateConstraints"

\end_inset

 show how to reduce the task of verifying a state constraint to a reasoning
 task we call 
\emph on
static domain reasoning
\emph default
, where only the background axioms need to be considered:
\begin_inset Formula \[
\Dt_{bg}\models_{FOL}\forall s:\,\phi[s]\]

\end_inset


\end_layout

\begin_layout Standard
Since the axioms in 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 do not mention situation terms, the leading quantification in such queries
 has no effect -- 
\begin_inset Formula $\phi$
\end_inset

 will hold for all 
\begin_inset Formula $s$
\end_inset

 if and only if it holds for some 
\begin_inset Formula $s$
\end_inset

.
 This is a major improvement because universal quantification over situation
 terms usually requires the second-order induction axiom.
 Their work has shown that induction can be circumvented in some cases.
\end_layout

\begin_layout Standard
Simpler still are queries uniform in the initial situation, which can be
 answered using only first-order logic and a limited set of axioms:
\begin_inset Formula \begin{gather*}
\Dt\models_{SOL}\phi[S_{0}]\\
\mathrm{iff}\\
\Dt_{S_{0}}\cup\Dt_{bg}\models_{FOL}\phi[S_{0}]\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We call such reasoning 
\emph on
initial
\emph default
 
\emph on
situation reasoning
\emph default
.
 Since the axioms 
\begin_inset Formula $\Dt_{S_{0}}\cup\Dt_{bg}$
\end_inset

 often satisfy the closed-world assumption, provers such as Prolog can be
 employed to handle this type of query quite effectively.
\end_layout

\begin_layout Standard
While few useful queries happen to precisely match these restricted forms,
 it is possible to answer quite broad classes of query by 
\emph on
transforming
\emph default
 them into such a form.
 This insight is at the heart of the principle tool for effective reasoning
 in the situation calculus: regression.
\end_layout

\begin_layout Subsection
Regression
\end_layout

\begin_layout Standard
The regression meta-operator 
\begin_inset Formula $\Reg$
\end_inset

 is a syntactic manipulation that encodes the preconditions and effects
 of actions into the query itself, meaning fewer axioms are needed for the
 final reasoning task 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter91frameprob,pirri99contributions_sitcalc"

\end_inset

.
 The idea is to reduce a query about some future situation to a query about
 the initial situation only, which is much easier to answer.
\end_layout

\begin_layout Standard
There are two styles of regression operator commonly defined in the literature:
 the single-pass operator as defined in 
\begin_inset CommandInset citation
LatexCommand citep
key "pirri99contributions_sitcalc"

\end_inset

 which reduces to 
\begin_inset Formula $S_{0}$
\end_inset

 in a single application, the the single-step operator as defined in 
\begin_inset CommandInset citation
LatexCommand citep
key "scherl03sc_knowledge"

\end_inset

 which operates one action at a time.
 We use the single-step variant as it is the more expressive of the two;
 the single-pass operator can be trivially constructed as the transitive
 closure of the single-step operator.
\end_layout

\begin_layout Standard
Regression is only defined for formulae that are 
\emph on
regressable:
\end_layout

\begin_layout Labelled Definition
Regressable
\begin_inset space ~
\end_inset

Formulae 
\begin_inset CommandInset label
LatexCommand label
name "def:Background:Regressable-Formulae"

\end_inset

Let 
\begin_inset Formula $\sigma$
\end_inset

 be an arbitrary situation term, 
\begin_inset Formula $x$
\end_inset

 an arbitrary variable not of sort 
\noun on
Situation
\noun default
, 
\begin_inset Formula $\tau$
\end_inset

 an arbitrary term not of sort 
\noun on
Situation
\noun default
, 
\begin_inset Formula $R$
\end_inset

 an arbitrary rigid predicate, 
\begin_inset Formula $F$
\end_inset

 an arbitrary primitive fluent predicate, and 
\begin_inset Formula $\alpha$
\end_inset

 an arbitrary action description predicate.
 Then the regressable formulae are the smallest set of syntactically-valid
 formulae satisfying: 
\begin_inset Formula \[
\varphi::=F(\vars{\tau},\sigma)\,|\,\alpha(\vars{\tau},a,\sigma)\,|\, R(\vars{\tau})\,|\,\tau_{1}=\tau_{2}\,|\,\neg\varphi\,|\,\varphi_{1}\wedge\varphi_{2}\,|\,\exists x:\,\varphi\]

\end_inset


\end_layout

\begin_layout Standard
Regressable formulae are more general than uniform formulae.
 In particular, they can contain action description predicates and may mention
 different situation terms.
 They cannot, however, quantify over situation terms or compare situations
 using the 
\begin_inset Formula $\sqsubset$
\end_inset

 predicate.
\end_layout

\begin_layout Standard
The regression operator is defined using a series of 
\emph on
regression rules
\emph default
 such as those shown below, mirroring the structure of regressable formulae:
\end_layout

\begin_layout Labelled Definition
Regression
\begin_inset space ~
\end_inset

Operator Let 
\begin_inset Formula $R$
\end_inset

 be a rigid predicate, 
\begin_inset Formula $\alpha$
\end_inset

 be an action description predicate with axiom 
\begin_inset Formula $\alpha(\vars{\nu},a,s)\equiv\Pi_{\alpha}(a,s)$
\end_inset

 in 
\begin_inset Formula $\Dt_{ad}$
\end_inset

, and 
\begin_inset Formula $F$
\end_inset

 be a primitive fluent with axiom 
\begin_inset Formula $F(\vars x,s)\equiv\Phi_{F}(\vars x,s)$
\end_inset

 in 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

.
 Then the regression of 
\begin_inset Formula $\phi$
\end_inset

, denoted 
\begin_inset Formula $\Reg(\phi)$
\end_inset

, is defined according to the following structural rules:
\begin_inset Formula \begin{gather*}
\Reg(\varphi_{1}\wedge\varphi_{2})\,\isdef\,\Reg(\varphi_{1})\wedge\Reg(\varphi_{2})\\
\Reg(\exists x:\,\varphi)\,\isdef\,\exists x:\,\Reg(\varphi)\\
\Reg(\neg\varphi)\,\isdef\,\neg\Reg(\varphi)\\
\Reg(\alpha(\vars{\tau},a,\sigma))\,\isdef\,\Reg(\Pi_{\alpha}(\vars{\tau},a,\sigma))\\
\Reg(F(\vars{\tau},do(a,\sigma)))\,\isdef\,\Phi_{F}(\vars{\tau},a,\sigma)\\
\Reg(F(\vars{\tau},s))\,\isdef\, F(\vars{\tau},s)\\
\Reg(F(\vars{\tau},S_{0}))\,\isdef\, F(\vars{\tau},S_{0})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The key point here is that each application of 
\begin_inset Formula $\Reg$
\end_inset

 replaces action description predicates with their definitions from 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and primitive fluents with their successor state axioms from 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

, 
\begin_inset Quotes eld
\end_inset

unwinding
\begin_inset Quotes erd
\end_inset

 a single action from each 
\begin_inset Formula $do(a,\sigma)$
\end_inset

 situation term in the query.
 If the situation term is not constructed using 
\begin_inset Formula $do$
\end_inset

, it is left unchanged.
\end_layout

\begin_layout Standard
Let us briefly state some important properties of the regression operator.
 First, and most importantly, it preserves equivalence of formulae:
\end_layout

\begin_layout Proposition
For 
\begin_inset Formula $\varphi$
\end_inset

 a regressable formula, 
\begin_inset Formula $\Dt\,\models\,\varphi\,\equiv\,\Reg(\varphi)$
\end_inset

 
\end_layout

\begin_layout Standard
Any formula uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

 is regressable, and the resulting formula will always be uniform in 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Proposition
For 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\begin_inset Formula $do(a,s)$
\end_inset

, 
\begin_inset Formula $\Reg(\phi)$
\end_inset

 is uniform in 
\begin_inset Formula $s$
\end_inset

 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\Reg^{*}$
\end_inset

 denote repeated applications of 
\begin_inset Formula $\Reg$
\end_inset

 until the formula remains unchanged.
 Such applications can transform a query about some future situation into
 a query about the initial situation only:
\end_layout

\begin_layout Proposition
For 
\begin_inset Formula $\phi$
\end_inset

 uniform in 
\emph on

\begin_inset Formula $do([a_{1}\dots a_{n}],S_{0})$
\end_inset

,
\emph default
 
\begin_inset Formula $\Reg^{*}(\phi)$
\end_inset

 is uniform in 
\begin_inset Formula $S_{0}$
\end_inset

 
\end_layout

\begin_layout Standard
This last property is key to effective reasoning in the situation calculus,
 as it allows one to answer the 
\emph on
projection problem
\emph default
.
 To determine whether 
\begin_inset Formula $\phi$
\end_inset

 holds in a given future situation, it suffices to determine whether 
\begin_inset Formula $\Reg^{*}(\phi)$
\end_inset

 holds in the initial situation, a much simpler query to answer.
 The axioms 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 and 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 are essentially 
\begin_inset Quotes eld
\end_inset

compiled into the query
\begin_inset Quotes erd
\end_inset

 by the 
\begin_inset Formula $\Reg^{*}$
\end_inset

 operator.
 While an efficiency gain is not guaranteed, regression has proven a very
 effective technique in practice 
\begin_inset CommandInset citation
LatexCommand citep
key "levesque97golog,pirri99contributions_sitcalc"

\end_inset

, particularly when combined with techniques to limit the resulting increase
 in query size 
\begin_inset CommandInset citation
LatexCommand citep
key "vandtmarsh07optimal_regression"

\end_inset

.
\end_layout

\begin_layout Standard
Unfortunately, this powerful technique cannot be applied to formulae that
 are not regressable.
 Its operation depends crucially on knowing how many actions there are in
 each situation term, so that each action can be 
\begin_inset Quotes eld
\end_inset

unwound
\begin_inset Quotes erd
\end_inset

 from the query in turn.
 Queries that universally quantify over situations, such as the property
 persistence queries of interest in this paper, fall squarely outside the
 reach of standard regression techniques.
\end_layout

\begin_layout Subsection
Inductive Reasoning
\end_layout

\begin_layout Standard
While there is a rich and diverse literature base for the situation calculus,
 there appears to have been little work on queries that universally quantify
 over situation terms.
 
\begin_inset CommandInset citation
LatexCommand citet
key "Reiter93proving"

\end_inset

 has shown why the induction axiom cannot in general be eliminated when
 proving such statements, demonstrating the use of the axiom in manual proofs
 but offering no automated procedure.
\end_layout

\begin_layout Standard
Other work on universally-quantified queries focuses on highly specialised
 applications, such as verifying state constraints 
\begin_inset CommandInset citation
LatexCommand citep
key "Lin94-StateConstraints,bertossi96automating"

\end_inset

 or studying properties of ConGolog programs 
\begin_inset CommandInset citation
LatexCommand citep
key "ternovska97congolog_fixpoint,ternovska02congolog_model_checker,classen08golog_properties"

\end_inset

.
 While these works have produced useful results, they are typically intended
 as stand-alone techniques rather than general reasoning tools for the situation
 calculus.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "Lin94-StateConstraints"

\end_inset

 have shown that the induction axiom can be 
\begin_inset Quotes eld
\end_inset

compiled away
\begin_inset Quotes erd
\end_inset

 when verifying a state constraint, by means of the following equivalence:
\begin_inset Formula \begin{gather*}
\Dt\,\models\,\phi[S_{0}]\rightarrow\left(\forall s:\, S_{0}\leq s\rightarrow\phi[s]\right)\\
\mathit{iff}\\
\Dt_{una}\models\forall s,a:\,\phi[s]\wedge\Reg(Poss(a,s))\,\rightarrow\,\Reg(\phi[do(a,s)])\end{gather*}

\end_inset

 The set 
\begin_inset Formula $\Dt_{una}$
\end_inset

 here is equivalent to our background axioms 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 Verification of a state constraint can thus be reduced to the comparatively
 straightforward task of 
\emph on
static domain reasoning
\emph default
.
 Verification of state constraints was also approached by 
\begin_inset CommandInset citation
LatexCommand citet
key "bertossi96automating"

\end_inset

, who develop an automatic constraint verification system using an induction
 theorem prover.
\end_layout

\begin_layout Standard
Formulating various safety, liveness and starvation properties of ConGolog
 programs also requires universal quantification over situations.
 
\begin_inset CommandInset citation
LatexCommand citet
key "ternovska97congolog_fixpoint"

\end_inset

 show how to re-cast these properties as fixpoint queries in second-order
 logic, and a preliminary model-checker capable of verifying them is described
 in 
\begin_inset CommandInset citation
LatexCommand citep
key "ternovska02congolog_model_checker"

\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand citet
key "classen08golog_properties"

\end_inset

 have developed a logic of ConGolog programs based on an iterative fixpoint
 computation similar to the one we propose in this paper.
\end_layout

\begin_layout Standard
However, there are many issues that are not addressed by these highly specialise
d works.
 What if we are interested in the future of some arbitrary situation 
\begin_inset Formula $\sigma$
\end_inset

, rather than only 
\begin_inset Formula $S_{0}$
\end_inset

? What if we restrict future actions according to an arbitrary action descriptio
n predicate? Can we integrate a method for handling universally-quantified
 queries with existing regression techniques? Our treatment of property
 persistence can provide a concrete basis for these considerations, and
 is hence significantly more general than existing work.
\end_layout

\begin_layout Standard
Finally, let us introduce an important property of situations first formally
 identified by 
\begin_inset CommandInset citation
LatexCommand citet
key "savelli06sc_quantum_levels"

\end_inset

: that universal quantification over situation terms is equivalent to an
 infinite conjunction over the 
\emph on
levels
\emph default
 of the tree of situations:
\begin_inset Formula \begin{gather*}
\Dt\,\models\,\forall s:\,\psi(s)\\
\mathrm{iff}\\
\Dt\,\models\,\bigwedge_{n\in\mathbb{N}}\forall a_{1},\dots,a_{n}:\,\psi(do([a_{1},\dots,a_{n}],S_{0}))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
This is a direct consequence of the induction axiom for situations, which
 restricts situations to be constructed by performing some countable number
 of actions in the initial situation.
 We will not use this result directly, but it captures an important intuition
 about situation terms that is fundamental to the operation of our approach.
\end_layout

\begin_layout Section
The Persistence Condition
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Condition"

\end_inset


\end_layout

\begin_layout Standard
To enable the use of persistence queries in practical systems, we clearly
 need a more effective reasoning technique than open-ended second order
 theorem proving.
 Our approach is inspired by the success of Reiter's regression technique:
 use a meta-level operator to transform the query into one that is easier
 to answer.
 Specifically, our technique transforms a property persistence query at
 
\begin_inset Formula $\sigma$
\end_inset

 into the evaluation of a uniform formula at 
\begin_inset Formula $\sigma$
\end_inset

 -- a much simpler query which can be approached using existing techniques.
\end_layout

\begin_layout Standard
Formally, we seek a method for transforming a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

 into a uniform formula 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 that is true at precisely the situations in which 
\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

.
 We call such a formula the 
\emph on
persistence condition
\emph default
 of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Labelled Definition
Persistence
\begin_inset space ~
\end_inset

Condition The persistence condition of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

, denoted 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

, is a uniform formula that is equivalent to the persistence of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

 with respect to a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

 without the initial situation axioms.
 Formally:
\begin_inset CommandInset label
LatexCommand label
name "def:persistence-condition"

\end_inset


\begin_inset Formula \[
\Dt-\Dt_{S_{0}}\models\forall s:\,\left(\Pst(\phi,\alpha)[s]\,\equiv\,\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\]

\end_inset


\end_layout

\begin_layout Standard
Defining 
\begin_inset Formula $\Pst$
\end_inset

 to be independent of the initial world state allows it to be calculated
 regardless of what (if anything) is known about the actual state of the
 world -- after all, a situated agent may not know all the details of 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

, and we still want it to be able to use this technique.
\end_layout

\begin_layout Standard
This definition alone clearly does not make the task of answering a persistence
 query any easier, since it gives no indication of how the persistence condition
 might be calculated in practice.
 Indeed, we have not yet even shown whether such a formula actually exists.
 In order to establish these results, we first need to define the weaker
 notion of a formula 
\emph on
persisting to depth 
\begin_inset Formula $n$
\end_inset


\emph default
 in a situation.
\end_layout

\begin_layout Labelled Definition
Persistence
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

Depth
\begin_inset space ~
\end_inset

1 A uniform formula 
\begin_inset Formula $\phi$
\end_inset

 persists to depth 1 under 
\begin_inset Formula $\alpha$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

 when the formula 
\begin_inset Formula $\PstN 1(\phi,\alpha)[s]$
\end_inset

 holds, as defined by:
\begin_inset CommandInset label
LatexCommand label
name "def:persists-depth-n"

\end_inset


\begin_inset Formula \[
\PstN 1(\phi,\alpha)[s]\,\isdef\,\phi[s]\,\wedge\,\forall a:\,\Reg(\alpha[a,s])\rightarrow\Reg(\phi[do(a,s)])\]

\end_inset


\end_layout

\begin_layout Standard
Note that 
\begin_inset Formula $\PstN 1$
\end_inset

 is equivalent to the following literal encoding of the requirement 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

 and in all its direct successors
\begin_inset Quotes erd
\end_inset

:
\begin_inset Formula \[
\PstN 1(\phi,\alpha)[s]\,\equiv\,\phi[s]\,\wedge\,\forall a:\,\alpha[a,s]\,\rightarrow\,\phi[do(a,s)]\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\alpha$
\end_inset

 is an action description predicate and 
\begin_inset Formula $\phi$
\end_inset

 is a uniform formula, the expressions 
\begin_inset Formula $\Reg(\alpha[a,s])$
\end_inset

 and 
\begin_inset Formula $\Reg(\phi[do(a,s)])$
\end_inset

 are always defined and the resulting formula is always uniform in 
\begin_inset Formula $s$
\end_inset

.
 Successive applications of 
\begin_inset Formula $\PstN 1$
\end_inset

 can then assert persistence to greater depths:
\end_layout

\begin_layout Labelled Definition
Persistence
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

Depth
\begin_inset space ~
\end_inset

N For any 
\begin_inset Formula $n\geq0$
\end_inset

, a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 persists to depth 
\begin_inset Formula $n$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

 when the formula 
\begin_inset Formula $\PstN n(\phi,\alpha)[s]$
\end_inset

 holds, as defined by:
\begin_inset Formula \begin{gather*}
\PstN 0(\phi,\alpha)\,\isdef\,\phi\\
\PstN n(\phi,\alpha)\,\isdef\,\PstN 1(\PstN{n-1}(\phi,\alpha),\alpha)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The following theorem confirms that 
\begin_inset Formula $\PstN n$
\end_inset

 operates according to this intuition -- for any sequence of actions of
 length 
\begin_inset Formula $i\leq n$
\end_inset

, if each action satisfies 
\begin_inset Formula $\alpha$
\end_inset

 when it is executed, then 
\begin_inset Formula $\phi$
\end_inset

 will hold after performing those actions.
\end_layout

\begin_layout Theorem
For any 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

 iff 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

 and in all successors of 
\begin_inset Formula $\sigma$
\end_inset

 reached by performing at most 
\begin_inset Formula $n$
\end_inset

 actions satisfying 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "thm:PstN-works"

\end_inset


\begin_inset Formula \begin{multline*}
\Dt\,\models\,\PstN n(\phi,\alpha)[\sigma]\,\equiv\,\\
\bigwedge_{i\leq n}\forall a_{1},\dots,a_{i}:\,\left(\bigwedge_{j\leq i}\alpha[a_{j},do([a_{1},\dots,a_{j-1}],\sigma)]\,\,\rightarrow\,\,\phi[do([a_{1},\dots,a_{i}],\sigma)]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof Sketch
By induction on the natural numbers.
 For 
\begin_inset Formula $n=0$
\end_inset

 we have 
\begin_inset Formula $\phi[\sigma]\equiv\phi[\sigma]$
\end_inset

 by definition.
 For the inductive case, we expand the definition of 
\begin_inset Formula $\PstN n(\phi,\alpha)[\sigma]$
\end_inset

 to get the following for the LHS:
\begin_inset Formula \[
\PstN{n-1}(\phi,\alpha)[\sigma]\wedge\forall a:\,\Reg(\alpha[a,\sigma])\rightarrow\Reg(\PstN{n-1}(\phi,\alpha)[do(a,\sigma)])\]

\end_inset


\end_layout

\begin_layout Proof Sketch
Substituting for 
\begin_inset Formula $\PstN{n-1}$
\end_inset

 using the inductive hypothesis gives us a conjunction ranging over 
\begin_inset Formula $i\leq n-1$
\end_inset

, with universally quantified variables 
\begin_inset Formula $a_{1},\dots,a_{i}$
\end_inset

, and we must establish the 
\begin_inset Formula $i=n$
\end_inset

 case.
 Pushing this conjunction inside the scope of the 
\begin_inset Formula $\forall a$
\end_inset

 quantifier, we find we can rename 
\begin_inset Formula $a\Rightarrow a_{1}$
\end_inset

, 
\begin_inset Formula $a_{1}\Rightarrow a_{2}$
\end_inset

 etc to get the required expression.
 For the complete proof see Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Detailed-Proofs"

\end_inset

.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\PstN n$
\end_inset

 operator thus allows us to express the persistence of a formula to any
 given depth using a simple syntactic translation based on regression.
 Intuitively, one would expect 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 to be some sort of fixpoint of 
\begin_inset Formula $\PstN 1(\phi,\alpha)$
\end_inset

, since 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 must imply persistence up to any depth.
 Such a fixpoint could then be calculated using standard iterative approximation
 techniques.
 The remainder of this section is devoted to verifying this intuition.
\end_layout

\begin_layout Standard
We begin with two straightforward generalisations of results from the situation
 calculus literature, adapting them to our 
\begin_inset Formula $\leq_{\alpha}$
\end_inset

 notation:
\end_layout

\begin_layout Proposition
For any action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, the foundational axioms of the situation calculus entail the following
 induction principle:
\begin_inset CommandInset label
LatexCommand label
name "prop:a-order-induction"

\end_inset


\begin_inset Formula \begin{multline*}
\forall W,s:\,\, W(s)\wedge\left[\forall a,s':\,\alpha[a,s']\wedge s\leq_{\alpha}s'\wedge W(s')\rightarrow W(do(a,s'))\right]\\
\rightarrow\forall s':\, s\leq_{\alpha}s'\rightarrow W(s')\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
A trivial adaptation of Theorem 1 in 
\begin_inset CommandInset citation
LatexCommand citep
key "Reiter93proving"

\end_inset

.
 
\end_layout

\begin_layout Proposition
For any basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "prop:a-order-reduction"

\end_inset


\begin_inset Formula \begin{gather*}
\Dt-\Dt_{S_{0}}\models\forall s:\,\phi[s]\rightarrow\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\\
\mathrm{iff}\\
\Dt_{bg}\models\forall s,a:\,\phi[s]\wedge\Reg(\alpha[a,s])\rightarrow\Reg(\phi[do(a,s)])\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
A straightforward generalisation of the model-construction proof of Lemma
 5 in 
\begin_inset CommandInset citation
LatexCommand citep
key "Lin94-StateConstraints"

\end_inset

, utilising Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-induction"

\end_inset

.
 The details of this proof are reproduced in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Detailed-Proofs"

\end_inset

.
\end_layout

\begin_layout Standard
Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-reduction"

\end_inset

 will be key in our algorithm for calculating the persistence condition.
 It allows one to establish the result 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $s$
\end_inset

, then 
\begin_inset Formula $\phi$
\end_inset

 persists in 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

 by using static domain reasoning, a comparatively straightforward reasoning
 task.
\end_layout

\begin_layout Standard
We next formalise some basic relationships between 
\begin_inset Formula $\Pst$
\end_inset

 and 
\begin_inset Formula $\PstN n$
\end_inset

:
\end_layout

\begin_layout Lemma
Given a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "lem:p-equiv-p(pn)"

\end_inset


\begin_inset Formula \[
\Dt-\Dt_{S_{0}}\models\forall s:\,\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\,\equiv\,\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\PstN n(\phi,\alpha)[s']\right)\]

\end_inset

 That is, 
\begin_inset Formula $\phi$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

 iff 
\begin_inset Formula $\,\PstN n[\phi,\alpha]$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

.
 
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $\PstN n[\phi,\alpha]$
\end_inset

 implies 
\begin_inset Formula $\phi$
\end_inset

 by definition, the 
\emph on
if
\emph default
 direction is trivial.
 For the 
\emph on
only-if
\emph default
 direction we proceed by induction on 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Proof
For the base case, assume that 
\begin_inset Formula $\phi$
\end_inset

 persists but 
\begin_inset Formula $\PstN 1(\phi,\alpha)$
\end_inset

 does not, then we must have some 
\begin_inset Formula $s'$
\end_inset

 with 
\begin_inset Formula $s\leq_{\alpha}s'$
\end_inset

 and 
\begin_inset Formula $\neg\PstN 1(\phi,\alpha)[s']$
\end_inset

.
 By the definition of 
\begin_inset Formula $\PstN 1$
\end_inset

, this means that:
\begin_inset Formula \[
\neg\left(\phi[s']\,\wedge\,\forall a:\,\alpha[a,s']\rightarrow\phi[do(a,s')]\right)\]

\end_inset


\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $\phi$
\end_inset

 persists it must hold at 
\begin_inset Formula $s'$
\end_inset

, so there must be some 
\begin_inset Formula $a$
\end_inset

 such that 
\begin_inset Formula $\alpha[a,s']$
\end_inset

 and 
\begin_inset Formula $\neg\phi[do(a,s')]$
\end_inset

.
 But 
\begin_inset Formula $s\leq_{\alpha}do(a,s')$
\end_inset

 and so 
\begin_inset Formula $\phi[do(a,s')]$
\end_inset

 must hold by our assumption that 
\begin_inset Formula $\phi$
\end_inset

 persists, and we have a contradiction.
\end_layout

\begin_layout Proof
For the inductive case, assume that 
\begin_inset Formula $\PstN{n-1}(\phi,\alpha)$
\end_inset

 persists but 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 does not.
 By definition we have 
\begin_inset Formula $\PstN n(\phi,\alpha)=\PstN 1(\PstN{n-1}(\phi,\alpha),\phi)$
\end_inset

, and we repeat the base case proof using 
\begin_inset Formula $\phi'=\PstN{n-1}(\phi,\alpha)$
\end_inset

 in place of 
\begin_inset Formula $\phi$
\end_inset

 to obtain a contradiction.
 
\end_layout

\begin_layout Lemma
Given a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "lem:p-implies-pn"

\end_inset


\begin_inset Formula \[
\Dt-\Dt_{S_{0}}\models\forall s:\,\left(\Pst(\phi,\alpha)[s]\rightarrow\PstN n(\phi,\alpha)[s]\right)\]

\end_inset


\end_layout

\begin_layout Proof
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

 by definition.
 If 
\begin_inset Formula $\phi$
\end_inset

 persists at 
\begin_inset Formula $s$
\end_inset

, then by Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:p-equiv-p(pn)"

\end_inset

 we have that 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 persists at 
\begin_inset Formula $s$
\end_inset

 .
 Since the persistence of 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 at 
\begin_inset Formula $s$
\end_inset

 implies that 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 holds at 
\begin_inset Formula $s$
\end_inset

 by definition, we have the lemma as desired.
 
\end_layout

\begin_layout Standard
We are now equipped to prove the major theorem of this paper: that if 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 implies 
\begin_inset Formula $\PstN{n+1}(\phi,\alpha)$
\end_inset

, then 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 is equivalent to the persistence condition for 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Theorem
Given a basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, then for any 
\begin_inset Formula $n$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "thm:p(pn)-equiv-p"

\end_inset


\begin_inset Formula \begin{gather}
\Dt_{bg}\models\forall s:\,\PstN n(\phi,\alpha)[s]\rightarrow\PstN{n+1}(\phi,\alpha)[s]\label{eqn:pn_persists}\\
\mathit{\mathrm{iff}}\nonumber \\
\Dt-\Dt_{s_{0}}\models\forall s:\,\PstN n(\phi,\alpha)[s]\equiv\Pst(\phi,\alpha)[s]\label{eqn:pn_equiv_persists}\end{gather}

\end_inset


\end_layout

\begin_layout Proof
For the 
\emph on
if
\emph default
 direction, we begin by expanding equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:pn_persists"

\end_inset

 using the definition of 
\begin_inset Formula $\PstN 1$
\end_inset

 to get the equivalent form:
\begin_inset Formula \begin{gather*}
\Dt_{bg}\models\forall s:\,\PstN n(\phi,\alpha)[s]\rightarrow\PstN 1(\PstN n(\phi,\alpha),\alpha)[s]\\
\Dt_{bg}\models\forall s:\,\PstN n(\phi,\alpha)[s]\rightarrow\left(\PstN n(\phi,\alpha)[s]\wedge\forall a:\,\Reg(\alpha[a,s])\rightarrow\Reg(\phi[do(a,s)])\right)\\
\Dt_{bg}\models\forall s,a:\,\PstN n(\phi,\alpha)[s]\wedge\forall a:\,\Reg(\alpha[a,s])\rightarrow\Reg(\phi[do(a,s)])\end{gather*}

\end_inset

 By Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-reduction"

\end_inset

, equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eqn:pn_persists"

\end_inset

 thus lets us conclude that 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 persists under 
\begin_inset Formula $\alpha$
\end_inset

.
 By Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:p-equiv-p(pn)"

\end_inset

 this is equivalent to the persistence of 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

, which is equivalent to 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 by definition, giving:
\begin_inset Formula \[
\Dt-\Dt_{s_{0}}\models\forall s:\,\PstN n(\phi,\alpha)[s]\rightarrow\Pst(\phi,\alpha)[s]\]

\end_inset

 By Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lem:p-implies-pn"

\end_inset

 this is an equivalence, yielding equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_equiv_persists"

\end_inset

) as required.
\end_layout

\begin_layout Proof
The 
\emph on
only if
\emph default
 direction is a straightforward reversal of this reasoning process: 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 implies the persistence of 
\begin_inset Formula $\phi$
\end_inset

, which implies the persistence of 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

, which yields equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_persists"

\end_inset

) by Proposition 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-reduction"

\end_inset

.
 
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\Dt_{bg}\models\PstN{n+1}(\phi,\alpha)\rightarrow\PstN n(\phi,\alpha)$
\end_inset

 by definition, equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_persists"

\end_inset

) identifies 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 as a fixpoint of the 
\begin_inset Formula $\PstN 1$
\end_inset

 operator, as our initial intuition suggested.
 In fact, we can use the constructive proof of Tarski's fixpoint theorem
 
\begin_inset CommandInset citation
LatexCommand citep
key "cousot79constructive_tarski"

\end_inset

 to establish that the persistence condition always exists for a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Theorem
Given a uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

, the persistence condition 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 always exists, and is unique up to equivalence under the static background
 theory 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "thm:p-always-exists"

\end_inset

 
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $L$
\end_inset

 be the subset of the Lindenbaum algebra of the static background theory
 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 containing only sentences uniform in 
\begin_inset Formula $s$
\end_inset

.
 
\begin_inset Formula $L$
\end_inset

 is thus a boolean lattice in which each element is a set of sentences uniform
 in 
\begin_inset Formula $s$
\end_inset

 that are equivalent under 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 
\begin_inset Formula $L$
\end_inset

 is a complete lattice with minimal element the equivalence class of 
\begin_inset Formula $\bot$
\end_inset

 and maximal element the equivalence class of 
\begin_inset Formula $\top$
\end_inset

.
 Fixing 
\begin_inset Formula $\alpha$
\end_inset

, 
\begin_inset Formula $\PstN 1$
\end_inset

 is a function whose domain and range are the elements of 
\begin_inset Formula $L$
\end_inset

.
\end_layout

\begin_layout Proof
By definition, we have that 
\begin_inset Formula $\PstN 1(\phi,\alpha)\,\rightarrow\,\phi$
\end_inset

, and 
\begin_inset Formula $\PstN 1$
\end_inset

 is thus a 
\emph on
monotone decreasing
\emph default
 function over 
\begin_inset Formula $L$
\end_inset

.
 By the constructive proof of Tarski's fixpoint theorem, 
\begin_inset Formula $\PstN 1$
\end_inset

 must have a unique greatest fixpoint less than the equivalence class of
 
\begin_inset Formula $\phi$
\end_inset

, which can be found by transfinite iteration of applications of 
\begin_inset Formula $\PstN 1$
\end_inset

.
 By Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p(pn)-equiv-p"

\end_inset

 this fixpoint is the equivalence class of 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 under 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 
\end_layout

\begin_layout Standard
This theorem legitimises the use of the persistence condition for reasoning
 about property persistence queries -- for any persistence query at situation
 
\begin_inset Formula $\sigma$
\end_inset

, there is a unique (up to equivalence) corresponding query that is uniform
 in 
\begin_inset Formula $\sigma$
\end_inset

 and is thus amenable to standard effective reasoning techniques of the
 situation calculus.
\end_layout

\begin_layout Standard
Of course, it remains to actually calculate the persistence condition for
 a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

.
 The definition of 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 as a fixpoint suggests that it can be calculated by a simple iterative
 approximation.
\end_layout

\begin_layout Section
Calculating 
\begin_inset Formula $\Pst$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Calculating"

\end_inset


\end_layout

\begin_layout Standard
Since we can easily calculate 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 for any 
\begin_inset Formula $n$
\end_inset

, we have a straightforward algorithm for determining 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

: search for an 
\begin_inset Formula $n$
\end_inset

 such that
\begin_inset Formula \[
\Dt_{bg}\models\forall s:\,\left(\PstN n(\phi,\alpha)[s]\rightarrow\PstN{n+1}(\phi,\alpha)[s]\right)\]

\end_inset

 Since we expect 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 to be simpler than 
\begin_inset Formula $\PstN{n+1}(\phi,\alpha)$
\end_inset

, we should look for the smallest such 
\begin_inset Formula $n$
\end_inset

.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 presents an iterative procedure for doing just that.
 Note that the calculation of 
\begin_inset Formula $\PstN 1(\phi,\alpha)$
\end_inset

 is a straightforward syntactic transformation, so we do not present an
 algorithm for it.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement !t
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Calculate 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:calc_p"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithmic}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn}\Leftarrow\phi$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn1}\Leftarrow\PstN 1(\mathtt{pn},\alpha)$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WHILE
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $\Dt_{bg}\not\models\forall s:\,\mathtt{pn}[s]\rightarrow\mathtt{pn1}[s]$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn}\Leftarrow\mathtt{pn1}$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
STATE
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn1}\Leftarrow\PstN 1[\mathtt{pn},\alpha]$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
ENDWHILE
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
RETURN
\end_layout

\end_inset

 
\begin_inset Formula $\mathtt{pn}$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Correctness
\end_layout

\begin_layout Standard
If Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 terminates, it terminates returning a value of 
\begin_inset Formula $pn$
\end_inset

 for which equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_persists"

\end_inset

) holds.
 By Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p(pn)-equiv-p"

\end_inset

 this value of 
\begin_inset Formula $pn$
\end_inset

 is equivalent to the persistence condition for 
\begin_inset Formula $\phi$
\end_inset

 under 
\begin_inset Formula $\alpha$
\end_inset

.
 The algorithm therefore correctly calculates the persistence condition.
\end_layout

\begin_layout Standard
In particular, note that equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eqn:pn_persists"

\end_inset

) holds when 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 is unsatisfiable for any situation, as it appears in the antecedent of
 an implication.
 The algorithm thus correctly returns an unsatisfiable condition (equivalent
 to 
\begin_inset Formula $\bot$
\end_inset

) when 
\begin_inset Formula $\phi$
\end_inset

 can never persist under 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Subsection
Completeness
\end_layout

\begin_layout Standard
Since Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p(pn)-equiv-p"

\end_inset

 is an equivalence, the persistence condition is always the fixpoint of
 
\begin_inset Formula $\PstN 1$
\end_inset

.
 From Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p-always-exists"

\end_inset

 this fixpoint always exists, is unique up to equivalence, and can be calculated
 by transfinite iteration.
 Therefore, the only source of incompleteness in our algorithm will be failure
 to terminate.
\end_layout

\begin_layout Subsection
Termination
\end_layout

\begin_layout Standard
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 may fail to terminate for two reasons: the loop condition may never be
 satisfied, or the first-order logical inference in the loop condition may
 be undecidable and fail to terminate.
\end_layout

\begin_layout Standard
The later case indicates that the background theory 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 is undecidable.
 While this is a concern, it affects more than just our algorithm -- any
 system implemented around such an action theory will be incomplete.
 With respect to this source of incompleteness, our algorithm is no more
 incomplete than any larger reasoning system it would form a part of.
\end_layout

\begin_layout Standard
The former case is of more direct consequence to our work.
 Unfortunately, there is no guarantee in general that the fixpoint can be
 reached via 
\emph on
finite
\emph default
 iteration, which is required for termination of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

.
\end_layout

\begin_layout Standard
Indeed, it is straightforward to construct a fluent for which the algorithm
 never terminates: consider a fluent 
\begin_inset Formula $F(x,s)$
\end_inset

 that is affected by a single action that makes it false whenever 
\begin_inset Formula $F(suc(x),s)$
\end_inset

 is false.
 Letting 
\begin_inset Formula $\alpha$
\end_inset

 be vacuously true, the sequence of iterations produced by our algorithm
 would be:
\begin_inset Formula \begin{gather*}
\PstN 1(F(x,s))\equiv F(x,s)\wedge F(suc(x),s)\\
\PstN 2(F(x,s))\equiv F(x,s)\wedge F(suc(x),s)\wedge F(suc(suc(x)),s)\\
\vdots\\
\PstN n(F(x,s))\equiv\bigwedge_{i=0}^{i=n}F(suc^{i}(x),s)\end{gather*}

\end_inset

 The persistence condition in this case is clearly: 
\begin_inset Formula \[
\Pst(F(x,s))\equiv\forall y:\, x\leq y\rightarrow F(y,s)\]

\end_inset

 While this is equivalent to the infinite conjunction produced as the limit
 of iteration in our algorithm, it won't be found after any finite number
 of steps.
\end_layout

\begin_layout Standard
As discussed in the proof of Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:p-always-exists"

\end_inset

, 
\begin_inset Formula $\PstN 1$
\end_inset

 operates over the boolean lattice of equivalence classes of formulae uniform
 in 
\begin_inset Formula $s$
\end_inset

, and the theory of fixpoints requires that this lattice be 
\emph on
well-founded
\emph default
 to guarantee termination of an iterative approximation algorithm such as
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

.
 We must therefore identify restricted kinds of basic action theory for
 which this well-foundedness can be guaranteed.
\end_layout

\begin_layout Standard
The most obvious case is theories in which the action and object sorts are
 finite.
 In such theories the lattice of equivalence classes of formulae uniform
 in 
\begin_inset Formula $s$
\end_inset

 is finite, and any finite lattice is well-founded.
 These theories also have the advantage that the static domain reasoning
 performed by Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 can be done using propositional logic, meaning it is decidable and so providing
 a strong termination guarantee.
 Similar termination guarantees would also hold for 
\emph on
effectively propositional
\emph default
 fragments of first-order logic, such as the function-free or Bernays-Schönfinke
l class 
\begin_inset CommandInset citation
LatexCommand citep
key "navarro08effectively_propsitional"

\end_inset

.
\end_layout

\begin_layout Standard
Alternately, suppose all successor state axioms and action description predicate
s have the following restricted form, where the terms in 
\begin_inset Formula $\vars y$
\end_inset

 are a subset of the terms in 
\begin_inset Formula $\vars x$
\end_inset

 and 
\begin_inset Formula $\Phi_{F}$
\end_inset

, 
\begin_inset Formula $\Pi_{ADP}$
\end_inset

 mention no terms other than 
\begin_inset Formula $\vars x$
\end_inset

, 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{gather*}
F(\vars x,do(a,s))\,\equiv\,\bigwedge_{i=1}^{n}a=a_{i}(\vars y_{i})\wedge\Phi_{F}(\vars x,a,s)\\
ADP(\vars x,a,s)\,\equiv\,\bigwedge_{i=1}^{n}a=a_{i}(\vars y)\wedge\Pi_{ADP}(\vars x,a,s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Under such theories, applications of 
\begin_inset Formula $\PstN 1$
\end_inset

 will introduce no new terms into the query, apart from finitely many action
 terms 
\begin_inset Formula $a_{i}$
\end_inset

.
 The range of 
\begin_inset Formula $\PstN 1$
\end_inset

 applied to 
\begin_inset Formula $\phi$
\end_inset

 is then a finite subset of the lattice of equivalence classes of formulae
 uniform in 
\begin_inset Formula $s$
\end_inset

, again guaranteeing a terminating calculation of 
\begin_inset Formula $\Pst$
\end_inset

.
\end_layout

\begin_layout Standard
Of course this is a very strong restriction on the structure of the theory,
 as the successor state axioms are not able to contain any quantifiers.
 It does demonstrate, however, that certain syntactic restrictions on 
\begin_inset Formula $\Dt$
\end_inset

 are able to guarantee terminating calculation of 
\begin_inset Formula $\Pst$
\end_inset

.
 It seems there should be a more general 
\begin_inset Quotes eld
\end_inset

syntactic well-foundedness
\begin_inset Quotes erd
\end_inset

 restriction that can be applied to these axioms, but we have not successfully
 formulated one at this stage.
\end_layout

\begin_layout Standard
In a similar vein, suppose that the theory of action is 
\emph on
context free
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "reiter97progression"

\end_inset

.
 In such theories successor state axioms have the following form:
\begin_inset Formula \[
F(\vars x,do(a,s))\,\equiv\,\Phi_{F}^{+}(\vars x,a)\,\vee\,\left(F(\vars x,s)\,\wedge\,\neg\Phi_{F}^{-}(\vars x,a)\right)\]

\end_inset


\end_layout

\begin_layout Standard
The effects of an action are thus independent of the situation in which
 it is performed.
 
\begin_inset CommandInset citation
LatexCommand citet
key "levesque98what_robots_can_do"

\end_inset

 demonstrate that such theories have a finite state space, again ensuring
 our algorithm operates over a finite lattice and hence guaranteeing termination.
 Context free domains are surprisingly expressive; for example, domains
 described in the style of STRIPS operators are context free.
\end_layout

\begin_layout Standard
From a slightly different perspective, suppose that 
\begin_inset Formula $\phi$
\end_inset

 can never persist under 
\begin_inset Formula $\alpha$
\end_inset

, so that 
\begin_inset Formula $\Pst(\phi,\alpha)\equiv\bot$
\end_inset

.
 Further suppose that 
\begin_inset Formula $\Dt$
\end_inset

 has the 
\emph on
compactness
\emph default
 property as in standard first-order logic.
 Then the 
\begin_inset Quotes eld
\end_inset

quantum levels
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset CommandInset citation
LatexCommand citet
key "savelli06sc_quantum_levels"

\end_inset

 guarantee that there is a fixed, finite number of actions within which
 
\begin_inset Formula $\neg\phi$
\end_inset

 can always be achieved.
 In this case Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

 will determine 
\begin_inset Formula $\Pst(\phi,\alpha)\equiv\bot$
\end_inset

 within finitely many iterations.
\end_layout

\begin_layout Standard
It would also be interesting to determine whether known decidable variants
 of the situation calculus (such as 
\begin_inset CommandInset citation
LatexCommand citep
key "yu07twovar_sitcalc"

\end_inset

) are able to guarantee termination of the fixpoint construction, or whether
 more sophisticated fixpoint algorithms can be applied instead of simple
 iterative approximation.
 Investigating such algorithms would be a promising avenue for future research.
\end_layout

\begin_layout Standard
The important point here is not that we can guarantee termination in general,
 but that we have precisely characterised the inductive reasoning necessary
 to answer property persistence queries, and shown that it can always be
 replaced by the evaluation of a uniform formula at the situation in question.
\end_layout

\begin_layout Subsection
Effectiveness
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Effectiveness"

\end_inset


\end_layout

\begin_layout Standard
Our algorithm replaces a single reasoning task based on the full action
 theory 
\begin_inset Formula $\Dt$
\end_inset

 with a series of reasoning tasks based on the static background theory
 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 Is this a worthwhile trade-off in practice? The following points weigh
 strongly in favour of our approach.
\end_layout

\begin_layout Standard
First and foremost, we avoid the need for the second-order induction axiom.
 All the reasoning tasks can be performed using standard first-order reasoning,
 for which there are high-quality automated provers.
 Second, the calculation of 
\begin_inset Formula $\Pst$
\end_inset

 performs only 
\emph on
static doing reasoning
\emph default
, which as discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Background"

\end_inset

 is a comparatively straightforward task which can be made decidable under
 certain conditions.
 Third, 
\begin_inset Formula $\Pst(\phi,\alpha)[\sigma]$
\end_inset

 is in a form amenable to regression, a standard tool for effective reasoning
 in the situation calculus.
 Fourth, the persistence condition for a given 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

 can be cached and re-used for a series of related queries about different
 situations, a significant gain in amortised efficiency.
 Finally, in realistic domains we expect many properties to fail to persist
 beyond a few situations into the future, meaning that our algorithm will
 require few iterations in a large number of cases.
\end_layout

\begin_layout Standard
Of course, we also inherit the potential disadvantage of the regression
 operator: the length of 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 may be exponential in the length of 
\begin_inset Formula $\phi$
\end_inset

.
 As with regression, our experience has been that this is rarely a problem
 in practice, and is more than compensated for by the reduced complexity
 of the resulting reasoning task.
\end_layout

\begin_layout Section
Examples
\begin_inset CommandInset label
LatexCommand label
name "sec:Example:"

\end_inset


\end_layout

\begin_layout Standard
To demonstrate the applicability of our technique, consider again the example
 persistence queries given in Section
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence-Queries"

\end_inset

.
 The persistence condition is readily applicable to each example, and the
 transformed queries can then be answered using standard regression.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Goal Impossibility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

, establish that there is no legal situation in which that goal is satisfied:
\begin_inset Formula \[
\Dt\,\models\,\Pst(\neg G,Poss)[S_{0}]\]

\end_inset

 The persistence condition of 
\begin_inset Formula $\neg G$
\end_inset

 with respect to action legality allows goal impossibility to be checked
 easily.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Goal Futility:
\series default
 Given a goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, establish that the goal cannot be satisfied in any legal future situation
 from 
\begin_inset Formula $\sigma$
\end_inset

:
\begin_inset Formula \[
\Dt\,\models\,\Pst(\neg G,Poss)[\sigma]\]

\end_inset

 Precisely the same formula is required for checking goal impossibility
 and goal futility.
 This highlights the advantage of re-using the persistence condition at
 multiple situations.
 Our approach makes it feasible for an agent to check for goal futility
 each time it considers performing an action, and avoid situations that
 would make its goals unachievable.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Checking State Constraints:
\series default
 Given a state constraint 
\begin_inset Formula $SC$
\end_inset

, show that the constraint holds in every legal situation:
\begin_inset Formula \[
\Dt\,\models\,\Pst(SC,Poss)[S_{0}]\]

\end_inset


\end_layout

\begin_layout Standard
However, since we want a state constraint to 
\emph on
always
\emph default
 persist, it must satisfy the following equivalence:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Dt_{bg}\models\phi\equiv\Pst(\phi,Poss)\]

\end_inset


\end_layout

\begin_layout Standard
If this equivalence does not hold then 
\begin_inset Formula $\Pst(\phi,Poss)$
\end_inset

 indicates the additional conditions that are necessary to ensure that 
\begin_inset Formula $\phi$
\end_inset

 persists, which may be useful for adjusting the action theory to enforce
 the constraint.
 This particular application has strong parallels to the approach to state
 constraints developed by 
\begin_inset CommandInset citation
LatexCommand citet
key "Lin94-StateConstraints"

\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Need for Cooperation:
\series default
 Given an agent 
\begin_inset Formula $agt$
\end_inset

, goal 
\begin_inset Formula $G$
\end_inset

 and situation 
\begin_inset Formula $\sigma$
\end_inset

, establish that no sequence of actions performed by that agent only can
 achieve the goal:
\begin_inset Formula \[
\Dt\models\Pst(\neg G,MyAction)[\sigma]\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Knowledge with Hidden Actions:
\series default
 In recent work we have developed a regression rule for knowledge that uses
 the persistence condition to account for arbitrarily-long sequences of
 hidden actions 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_know_obs"

\end_inset

.
 While the details of this formulation are outside the scope of the current
 paper, the general form of the regression rule is:
\begin_inset Formula \[
\Reg(\Knows(\phi,do(a,s)))\isdef\Knows(\Reg(\Pst(\phi,Hidden)[do(a,s)]),s)\]

\end_inset


\end_layout

\begin_layout Standard
This highlights an important benefit of our approach -- it integrates well
 with existing reasoning techniques.
 Since 
\begin_inset Formula $\Pst(\phi,\alpha)$
\end_inset

 is guaranteed to exist and be unique, it can be used to 
\begin_inset Quotes eld
\end_inset

factor out
\begin_inset Quotes erd
\end_inset

 the inductive reasoning and produce a regression rule for formulae that
 universally quantify over situations.
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
As a detailed example of our technique in action, consider again the 
\begin_inset Quotes eld
\end_inset

gold thief
\begin_inset Quotes erd
\end_inset

 domain as described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence-Queries"

\end_inset

 and axiomatised in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "apdx:Axioms"

\end_inset

.
 We want to establish that:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\Dt\,\models\,\forall s:\, S_{0}\leq_{Undet}s\,\rightarrow\,\neg Stolen(s)\]

\end_inset


\end_layout

\begin_layout Standard
By the definition of the persistence condition, this is equivalent to:
\begin_inset Formula \[
\Dt\models\Pst(\neg Stolen,Undet)[\sigma]\]

\end_inset


\end_layout

\begin_layout Standard
To answer this query we will employ Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

, calculating 
\begin_inset Formula $\PstN n$
\end_inset

 for successively larger values of 
\begin_inset Formula $n$
\end_inset

 until the series converges to a fixpoint.
 Full details of this calculation can be found in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "apdx:complete-example"

\end_inset

; we present only the major results below.
 The case of 
\begin_inset Formula $n=0$
\end_inset

 is trivial:
\begin_inset Formula \[
\PstN 0(\neg Stolen,Undet)[s]\,=\,\neg Stolen(s)\]

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $n=1$
\end_inset

 case is given by definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:persists-depth-n"

\end_inset

 as:
\begin_inset Formula \[
\PstN 1(\dots)[s]=\neg Stolen(s)\wedge\forall a:\,\Reg(Undet(a,s))\rightarrow\Reg(\neg Stolen(do(a,s)))\]

\end_inset


\end_layout

\begin_layout Standard
Expanding the 
\begin_inset Formula $\forall a$
\end_inset

 quantifier over each of the three actions in this domain we obtain:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\PstN 1(\dots)[s]=\neg Stolen(s)\,\\
\wedge\,\Reg(Undet(takeGold,s))\rightarrow\Reg(\neg Stolen(do(takeGold,s)))\\
\wedge\Reg(Undet(crackSafe,s))\rightarrow\Reg(\neg Stolen(do(crackSafe,s)))\\
\wedge\Reg(Undet(toggleLight,s))\rightarrow\Reg(\neg Stolen(do(toggleLight,s)))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Applying regression and simplifying produces the final result:
\begin_inset Formula \[
\PstN 1(\dots)[s]\,=\,\neg Stolen(s)\wedge\left[\neg SafeOpen(s)\vee LightOn(s)\right]\]

\end_inset


\end_layout

\begin_layout Standard
Intuitively, this indicates that the gold cannot be stolen by a single undetecte
d action if the safe is not open (since it would first have to be cracked)
 or the light is not on (since the action would be detected).
 Since this is clearly not entailed by the 
\begin_inset Formula $\PstN 0$
\end_inset

 case, we must continue to the 
\begin_inset Formula $n=2$
\end_inset

 case.
 Again applying definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:persists-depth-n"

\end_inset

 and expanding out each individual action, we get:
\begin_inset Formula \begin{multline*}
\PstN 2(\dots)[s]\,=\,\neg Stolen(s)\wedge\left[\neg SafeOpen(s)\vee LightOn(s)\right]\\
\wedge\,\Reg(Undet(takeGold,s))\rightarrow\Reg(\neg Stolen(do(takeGold,s))\\
\wedge[\neg SafeOpen(do(takeGold,s))\vee LightOn(do(takeGold,s))])\\
\wedge\,\Reg(Undet(crackSafe,s))\rightarrow\Reg(\neg Stolen(do(crackSafe,s))\\
\wedge[\neg SafeOpen(do(crackSafe,s))\vee LightOn(do(crackSafe,s))])\\
\wedge\,\Reg(Undet(toggleLight,s))\rightarrow\Reg(\neg Stolen(do(toggleLight,s))\\
\wedge[\neg SafeOpen(do(toggleLight(s))\vee LightOn(do(toggleLight,s))])\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Performing the regression and simplifying down, we eventually obtain:
\begin_inset Formula \[
\PstN 2(\dots)[s]\,=\,\neg Stolen(s)\wedge[\neg SafeOpen(s)\vee LightOn(s)]\]

\end_inset


\end_layout

\begin_layout Standard
We have clearly satisfied the termination condition of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

, since 
\begin_inset Formula $\PstN 1\rightarrow\PstN 2$
\end_inset

 , and have thus successfully calculated the persistence condition:
\begin_inset Formula \[
\Pst(\neg Stolen,Undet)=\neg Stolen\wedge\left[\neg SafeOpen\vee LightOn\right]\]

\end_inset


\end_layout

\begin_layout Standard
Checking whether the gold is safe is now a simple matter of reasoning about
 the initial situation:
\begin_inset Formula \[
\Dt\,\models\,\neg Stolen(S_{0})\wedge\left[\neg SafeOpen(S_{0})\vee LightOn(S_{0})\right]\]

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $\Pst(\neg Stolen,Undet)$
\end_inset

 in hand, we can also perform more sophisticated reasoning about the safety
 of the gold -- for example, we can check whether a proposed action would
 jeopardise the safety of the gold and refuse to perform the action if so.
\end_layout

\begin_layout Section
Conclusions
\begin_inset CommandInset label
LatexCommand label
name "sec:Persistence:Conclusion"

\end_inset


\end_layout

\begin_layout Standard
In this paper we have developed an algorithm that transforms property persistenc
e queries, a quite general and useful class of situation calculus query,
 into a form that is amenable to standard techniques for effective reasoning
 in the situation calculus.
 The algorithm replaces a second-order induction axiom with a meta-level
 fixpoint calculation based on iterative application of the standard regression
 operator.
 It is shown to be sound and complete, and terminates in several interesting
 cases.
\end_layout

\begin_layout Standard
Our approach generalises previous work on universally-quantified queries
 in several important ways.
 It can consider sequences of actions satisfying a range of conditions,
 not just the standard ordering over action possibility, enabling us to
 treat problems such as need for cooperation and knowledge with hidden actions.
 It can establish that properties persist in the future of an arbitrary
 situation, not necessarily the initial situation, enabling us to answer
 the question of goal futility.
 The results of calculating the persistence condition can be cached, allowing
 for example the goal futility question to be efficiently posed on a large
 number of situations once the persistence condition has been calculated.
\end_layout

\begin_layout Standard
Perhaps most importantly for the wider situation calculus community, we
 have 
\emph on
factored out
\emph default
 the inductive reasoning required to answer these queries.
 Work on increasing the effectiveness of this inductive reasoning, and on
 guaranteeing a terminating calculation in stronger classes of action theory,
 can proceed independently from the development of formalisms that utilise
 persistence queries.
 Subsequent applications can use the 
\begin_inset Formula $\Pst$
\end_inset

 operator as a kind of 
\begin_inset Quotes eld
\end_inset

black box
\begin_inset Quotes erd
\end_inset

 for dealing with persistence queries, for example to formulate regression
 rules as in our own work on knowledge 
\begin_inset CommandInset citation
LatexCommand citep
key "kelly07sc_know_obs"

\end_inset

.
\end_layout

\begin_layout Standard
As noted in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence:Background"

\end_inset

, our use of fixpoints in this paper has much in common with the study of
 properties of ConGolog programs 
\begin_inset CommandInset citation
LatexCommand citep
key "ternovska97congolog_fixpoint,classen08golog_properties"

\end_inset

.
 Indeed, that we are able to replace an induction axiom with a fixpoint
 calculation should come as no surprise; the important point is that this
 fixpoint exists, but that it can be calculated using quite restricted kinds
 of reasoning and in a way that integrates naturally with existing reasoning
 tools such as regression.
 Given the underlying similarities, we are confident that ongoing advances
 in reasoning effectively about ConGolog programs will also advance our
 ability to effectively answer persistence queries.
\end_layout

\begin_layout Standard
This paper has thus significantly increased the scope of queries that can
 be posed within automated reasoning systems built upon the situation calculus.
\end_layout

\begin_layout Section
\start_of_appendix
Detailed Proofs
\begin_inset CommandInset label
LatexCommand label
name "sec:Detailed-Proofs"

\end_inset


\end_layout

\begin_layout Extended Theorem
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:PstN-works"

\end_inset

 For any 
\begin_inset Formula $n\in\mathbb{N}$
\end_inset

, 
\begin_inset Formula $\PstN n(\phi,\alpha)$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

 iff 
\begin_inset Formula $\phi$
\end_inset

 holds in 
\begin_inset Formula $\sigma$
\end_inset

 and in all successors of 
\begin_inset Formula $\sigma$
\end_inset

 reached by performing at most 
\begin_inset Formula $n$
\end_inset

 actions satisfying 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset Formula \begin{multline*}
\Dt\,\models\,\PstN n(\phi,\alpha)[\sigma]\,\equiv\,\\
\bigwedge_{i\leq n}\forall a_{1},\dots,a_{i}:\,\left(\bigwedge_{j\leq i}\alpha[a_{j},do([a_{1},\dots,a_{j-1}],\sigma)]\,\,\rightarrow\,\,\phi[do([a_{1},\dots,a_{i}],\sigma)]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
By induction on the natural numbers.
 For 
\begin_inset Formula $n=0$
\end_inset

 we have 
\begin_inset Formula $\phi[\sigma]\equiv\phi[\sigma]$
\end_inset

 by definition.
 For the inductive case, we expand the definition of 
\begin_inset Formula $\PstN n(\phi,\alpha)[\sigma]$
\end_inset

 to get the following for the LHS:
\begin_inset Formula \[
\PstN{n-1}(\phi,\alpha)[\sigma]\wedge\forall a:\,\Reg(\alpha[a,\sigma])\rightarrow\Reg(\PstN{n-1}(\phi,\alpha)[do(a,\sigma)])\]
 

\end_inset


\end_layout

\begin_layout Proof
By the inductive hypothesis we can equate 
\begin_inset Formula $\PstN{n-1}(\phi,\alpha)[\sigma]$
\end_inset

 in this LHS with all but the 
\begin_inset Formula $i=n$
\end_inset

 clause from the RHS conjunction, and we suppress them on both sides.
 If we also drop the regression operators we are left with the following
 to establish:
\begin_inset Formula \begin{multline*}
\Dt\,\models\,\forall a:\,\alpha[a,\sigma]\rightarrow\PstN{n-1}(\phi,\alpha)[do(a,\sigma)]\,\equiv\,\\
\forall a_{1},\dots,a_{n}:\,\left(\bigwedge_{j\leq n}\alpha[a_{j},do([a_{1},\dots,a_{j-1}],\sigma)]\,\,\rightarrow\,\,\phi[do([a_{1},\dots,a_{n}],\sigma)]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
We can again use the inductive hypothesis on 
\begin_inset Formula $\PstN{n-1}$
\end_inset

 in the LHS of this equivalence.
 If we then distribute the 
\begin_inset Formula $\alpha[a,\sigma]$
\end_inset

 implication over the outermost conjunction and collect quantifiers, we
 obtain the following for the LHS:
\begin_inset Formula \begin{multline*}
\bigwedge_{i\leq n-1}\forall a,a_{1},\dots,a_{i}:\\
\left(\alpha[a,\sigma]\wedge\bigwedge_{j\leq i}\alpha[a_{j},do([a,a_{1},\dots,a_{j-1}],\sigma)]\rightarrow\phi[do([a,a_{1},\dots,a_{i}],\sigma)]\right)\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
Renaming 
\begin_inset Formula $a\Rightarrow a_{1}$
\end_inset

, 
\begin_inset Formula $a_{1}\Rightarrow a_{2}$
\end_inset

, \SpecialChar \ldots{}
,
\begin_inset Formula $a_{i}\Rightarrow a_{i+1}$
\end_inset

, we see that each of the 
\begin_inset Formula $i<n-1$
\end_inset

 clauses on the LHS is equivalent to one of the 
\begin_inset Formula $i<n$
\end_inset

 clauses that have been suppressed on the RHS.
 The remaining 
\begin_inset Formula $i=n-1$
\end_inset

 clause is equivalent to the required RHS: 
\begin_inset Formula \[
\forall a_{1},\dots,a_{n}:\,\left(\bigwedge_{j\leq n}\alpha[a_{j},do([a_{1},\dots,a_{j-1}],\sigma)]\,\,\rightarrow\,\,\phi[do([a_{1},\dots,a_{n}],\sigma)]\right)\]

\end_inset


\end_layout

\begin_layout Proof
We therefore have the desired equivalence.
 
\end_layout

\begin_layout Lemma
For any basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset CommandInset label
LatexCommand label
name "lem:a-order-reduction-lemma"

\end_inset


\begin_inset Formula \begin{gather*}
\mathrm{if}\\
\Sigma\cup\Dt_{bg}\cup\Dt_{ssa}\cup\Dt_{ad}\cup\{\phi[S_{0}]\}\models\forall s:\, S_{0}\leq_{\alpha}s\rightarrow\phi[s]\\
\mathrm{then}\\
\Dt_{bg}\models\forall s,a:\,\phi[s]\wedge\Reg(\alpha[a,s])\rightarrow\Reg(\phi[do(a,s)])\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
This is a straightforward generalisation of the proof of Lemma 5 in 
\begin_inset CommandInset citation
LatexCommand citep
key "Lin94-StateConstraints"

\end_inset

 using our modified notation.
 We repeat the details of the proof below for convenience.
 Begin by assuming the antecedent:
\begin_inset Formula \begin{equation}
\Sigma\cup\Dt_{bg}\cup\Dt_{ssa}\cup\Dt_{ad}\cup\{\phi[S_{0}]\}\models\forall s:\, S_{0}\leq_{\alpha}s\rightarrow\phi[s]\label{eq:pst-at-s0}\end{equation}

\end_inset

Let 
\begin_inset Formula $M$
\end_inset

 be a model of 
\begin_inset Formula $\Dt_{bg}$
\end_inset

.
 Suppose 
\begin_inset Formula $\mu_{s}$
\end_inset

 and 
\begin_inset Formula $\mu_{a}$
\end_inset

 are variable assignments for situation and action variables respectively,
 such that 
\begin_inset Formula $M,\mu_{s},\mu_{a}\models\phi[s]\wedge\Reg(\alpha[a,s])$
\end_inset

.
 We show that 
\begin_inset Formula $M,\mu_{s},\mu_{a}\models\Reg(\phi[do(a,s)])$
\end_inset

.
 Construct a model 
\begin_inset Formula $M'$
\end_inset

 such that:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $M'$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 share the same domains for sorts 
\noun on
Action
\noun default
 and 
\noun on
Object
\end_layout

\begin_layout Itemize
\begin_inset Formula $M'$
\end_inset

 interprets every rigid predicate and function the same as 
\begin_inset Formula $M$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $M'\models\Sigma\cup\Dt_{ssa}\cup\Dt_{ad}$
\end_inset


\end_layout

\begin_layout Itemize
For every variable assignment for object variables 
\begin_inset Formula $\mu_{o}$
\end_inset

, and for every fluent 
\begin_inset Formula $F(\vars x,s),$
\end_inset

 
\begin_inset Formula $M',\mu_{o}\models F(\vars x,S_{0})$
\end_inset

 iff 
\begin_inset Formula $M,\mu_{s},\mu_{o}\models F(\vars x,s)$
\end_inset


\end_layout

\end_deeper
\begin_layout Proof
Since 
\begin_inset Formula $M,\mu_{s},\mu_{a}\models\Reg(\alpha[a,s])$
\end_inset

 and 
\begin_inset Formula $M'\models\Dt_{ad}$
\end_inset

 we have:
\begin_inset Formula \[
M',\mu_{a}\models\Sigma\cup\Dt_{bg}\cup\Dt_{ssa}\cup\Dt_{ad}\cup\{\phi[S_{0}]\}\cup\{\alpha[a,S_{0}]\}\]

\end_inset


\end_layout

\begin_layout Proof
By our assumption 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:pst-at-s0"

\end_inset

, 
\begin_inset Formula $M',\mu_{a}\models\phi[do(a,S_{0})]$
\end_inset

.
 Since 
\begin_inset Formula $M'$
\end_inset

 satisfies 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 the regression operator can be employed to yield 
\begin_inset Formula $M',\mu_{a}\models\Reg(\phi[do(a,s)])$
\end_inset

.
 This is the same as the result of replacing 
\begin_inset Formula $s$
\end_inset

 with 
\begin_inset Formula $S_{0}$
\end_inset

 in 
\begin_inset Formula $\Reg(\phi[do(a,s)])$
\end_inset

, so we obtain:
\begin_inset Formula \[
M',\mu_{a}\models\Reg(\phi[do(a,S_{0})])\,\,\,\,\,\mathrm{iff}\,\,\,\,\, M,\mu_{s},\mu_{a}\models\Reg(\phi[do(a,s)])\]

\end_inset


\end_layout

\begin_layout Proof
Since we have the LHS of this equivalence by construction, we can conclude
 the RHS.
 This suffices to establish the lemma.
\end_layout

\begin_layout Extended Proposition
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-reduction"

\end_inset

 For any basic action theory 
\begin_inset Formula $\Dt$
\end_inset

, uniform formula 
\begin_inset Formula $\phi$
\end_inset

 and action description predicate 
\begin_inset Formula $\alpha$
\end_inset

:
\begin_inset Formula \begin{gather*}
\Dt-\Dt_{S_{0}}\models\forall s:\,\phi[s]\rightarrow\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\\
\mathrm{iff}\\
\Dt_{bg}\models\forall s,a:\,\phi[s]\wedge\Reg(\alpha[a,s])\rightarrow\Reg(\phi[do(a,s)])\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
The 
\emph on
if 
\emph default
direction is straightforward using the induction axiom from Proposition
 
\begin_inset CommandInset ref
LatexCommand ref
reference "prop:a-order-induction"

\end_inset

.
 For the 
\emph on
only-if
\emph default
 direction, we can take the 
\begin_inset Formula $S_{0}$
\end_inset

 case of the LHS to obtain:
\begin_inset Formula \[
\Dt-\Dt_{S_{0}}\models\phi[S_{0}]\rightarrow\left(\forall s:\, S_{0}\leq_{\alpha}s\rightarrow\phi[s]\right)\]

\end_inset


\end_layout

\begin_layout Proof
Lifting 
\begin_inset Formula $\phi[S_{0}]$
\end_inset

 into the axioms, this precisely matches the form of Lemma 
\begin_inset CommandInset ref
LatexCommand eqref
reference "lem:a-order-reduction-lemma"

\end_inset

 and we have the theorem as desired.
\end_layout

\begin_layout Section
Axioms for the 
\begin_inset Quotes eld
\end_inset

Gold Thief
\begin_inset Quotes erd
\end_inset

 Domain
\begin_inset CommandInset label
LatexCommand label
name "apdx:Axioms"

\end_inset


\end_layout

\begin_layout Standard
This section gives the axioms used for the 
\begin_inset Quotes eld
\end_inset

gold thief
\begin_inset Quotes erd
\end_inset

 example domain in Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Persistence-Queries"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Example:"

\end_inset

.
 In this domain a thief may try to steal some gold from a safe.
 There is a light in the room, and a security camera that will detect the
 thief's actions as long as the light is on.
 The safe can be open or closed, but the gold can only be stolen if the
 safe is open.
 It is possible for the thief to crack the safe and force it open, but only
 if the light is on.
 
\end_layout

\begin_layout Standard
The actions in this domain are 
\begin_inset Formula $takeGold$
\end_inset

, 
\begin_inset Formula $crackSafe$
\end_inset

 and 
\begin_inset Formula $toggleLight$
\end_inset

, the primitive fluents are 
\begin_inset Formula $SafeOpen$
\end_inset

, 
\begin_inset Formula $LightOn$
\end_inset

 and 
\begin_inset Formula $Stolen$
\end_inset

, and the action description predicates include the standard 
\begin_inset Formula $Poss(a,s)$
\end_inset

 and and a custom predicate 
\begin_inset Formula $Undet(a,s)$
\end_inset

 indicating that action 
\begin_inset Formula $a$
\end_inset

 would not be detected by the security camera.
\end_layout

\begin_layout Standard
The successor state axioms 
\begin_inset Formula $\Dt_{ssa}$
\end_inset

 consist of the following sentences:
\begin_inset Formula \begin{gather*}
Stolen(do(takeGold,s))\equiv\top\\
Stolen(do(crackSafe,s))\equiv Stolen(s)\\
Stolen(do(toggleLight,s))\equiv Stolen(s)\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
SafeOpen(do(takeGold,s))\equiv SafeOpen(s)\\
SafeOpen(do(crackSafe,s))\equiv\top\\
SafeOpen(do(toggleLight,s))\equiv SafeOpen(s)\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
LightOn(do(takeGold,s))\equiv LightOn(s)\\
LightOn(do(crackSafe,s))\equiv LightOn(s)\\
LightOn(do(toggleLight,s))\equiv\neg LightOn(s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The action description predicates in 
\begin_inset Formula $\Dt_{ad}$
\end_inset

 are defined by the following:
\begin_inset Formula \begin{gather*}
Poss(takeGold,s)\equiv SafeOpen(s)\\
Poss(crackSafe,s)\equiv LightOn(s)\\
Poss(toggleLight,s)\equiv\top\end{gather*}

\end_inset


\begin_inset Formula \begin{gather*}
Undet(a,s)\equiv Poss(a,s)\,\wedge\, a\neq toggleLight\,\wedge\neg LightOn(s)\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
The background theory 
\begin_inset Formula $\Dt_{bg}$
\end_inset

 is empty, and the initial situation axioms 
\begin_inset Formula $\Dt_{S_{0}}$
\end_inset

 are not specified since they are not used in the discussion.
\end_layout

\begin_layout Section
Complete Calculation for the 
\begin_inset Quotes eld
\end_inset

Gold Thief
\begin_inset Quotes erd
\end_inset

 domain
\begin_inset CommandInset label
LatexCommand label
name "apdx:complete-example"

\end_inset


\end_layout

\begin_layout Standard
This section presents complete details of the calculation of 
\begin_inset Formula $\Pst$
\end_inset

 for the 
\begin_inset Quotes eld
\end_inset

gold thief
\begin_inset Quotes erd
\end_inset

 example as outlined in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Example:"

\end_inset

.
 We need to calculate:
\begin_inset Formula \[
\Pst(\neg Stolen,Undet)[\sigma]\]

\end_inset


\end_layout

\begin_layout Standard
To calculate this persistence condition we follow Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

, calculating 
\begin_inset Formula $\PstN n$
\end_inset

 for successively larger values of 
\begin_inset Formula $n$
\end_inset

 until the series converges to a fixpoint.
 The case of 
\begin_inset Formula $n=0$
\end_inset

 is trivial:
\begin_inset Formula \[
\PstN 0(\neg Stolen,Undet)[s]\,=\,\neg Stolen(s)\]

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $n=1$
\end_inset

 case is given by definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:persists-depth-n"

\end_inset

 as:
\begin_inset Formula \[
\PstN 1(\dots)[s]=\neg Stolen(s)\wedge\forall a:\,\Reg(Undet(a,s))\rightarrow\Reg(\neg Stolen(do(a,s)))\]

\end_inset


\end_layout

\begin_layout Standard
Some straightforward simplifications can be applied at this stage.
 First, since there are finitely many actions in this domain, the 
\begin_inset Formula $\forall a$
\end_inset

 quantification can be replaced with a finite conjunction:
\begin_inset Formula \begin{multline*}
\PstN 1(\dots)[s]=\neg Stolen(s)\,\\
\wedge\,\Reg(Undet(takeGold,s))\rightarrow\Reg(\neg Stolen(do(takeGold,s)))\\
\wedge\Reg(Undet(crackSafe,s))\rightarrow\Reg(\neg Stolen(do(crackSafe,s)))\\
\wedge\Reg(Undet(toggleLight,s))\rightarrow\Reg(\neg Stolen(do(toggleLight,s)))\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
From the domain axioms we know that 
\begin_inset Formula $crackSafe$
\end_inset

 and 
\begin_inset Formula $toggleLight$
\end_inset

 do not affect whether the gold has been stolen, while 
\begin_inset Formula $takeGold$
\end_inset

 will always make 
\begin_inset Formula $Stolen$
\end_inset

 true.
 Performing the regression of 
\begin_inset Formula $\neg Stolen$
\end_inset

 we thus obtain the following result:
\begin_inset Formula \begin{multline*}
\PstN 1(\dots)[s]=\neg Stolen(s)\,\wedge\,\Reg(Undet(takeGold,s))\rightarrow\neg\top\\
\shoveright{\wedge\Reg(Undet(crackSafe,s))\rightarrow\neg Stolen(s)}\\
\wedge\Reg(Undet(toggleCam,s))\rightarrow\neg Stolen(s)\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Since the conjunction already contains 
\begin_inset Formula $\neg Stolen(s)$
\end_inset

 unconditionally, we can simplify away the final three cases.
 We obtain:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\PstN 1(\dots)[s]\,=\,\neg Stolen(s)\wedge\neg\Reg(Undet(takeGold,s))\]

\end_inset


\end_layout

\begin_layout Standard
Performing the remaining regression, we obtain the final result for 
\begin_inset Formula $\PstN 1$
\end_inset

:
\begin_inset Formula \[
\PstN 1(\dots)[s]\,=\,\neg Stolen(s)\wedge\left[\neg SafeOpen(s)\vee LightOn(s)\right]\]

\end_inset


\end_layout

\begin_layout Standard
Since this is clearly not entailed by the 
\begin_inset Formula $\PstN 0$
\end_inset

 case, we must continue to the 
\begin_inset Formula $n=2$
\end_inset

 case.
 Again applying definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "def:persists-depth-n"

\end_inset

 and expanding out each individual action, we get:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\PstN 2(\dots)[s]\,=\,\neg Stolen(s)\wedge\left[\neg SafeOpen(s)\vee LightOn(s)\right]\\
\wedge\,\Reg(Undet(takeGold,s))\rightarrow\Reg(\neg Stolen(do(takeGold,s))\\
\wedge[\neg SafeOpen(do(takeGold,s))\vee LightOn(do(takeGold,s))])\\
\wedge\,\Reg(Undet(crackSafe,s))\rightarrow\Reg(\neg Stolen(do(crackSafe,s))\\
\wedge[\neg SafeOpen(do(crackSafe,s))\vee LightOn(do(crackSafe,s))])\\
\wedge\,\Reg(Undet(toggleLight,s))\rightarrow\Reg(\neg Stolen(do(toggleLight,s))\\
\wedge[\neg SafeOpen(do(toggleLight(s))\vee LightOn(do(toggleLight,s))])\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Applying similar simplifications to the 
\begin_inset Formula $\PstN 1$
\end_inset

 case, we can obtain:
\begin_inset Formula \begin{multline*}
\PstN 2(\dots)[s]\,=\,\neg Stolen(s)\wedge\left[\neg SafeOpen(s)\vee LightOn(s)\right]\\
\wedge\,\Reg(Undet(takeGold,s))\rightarrow\neg\top\wedge[\neg SafeOpen(s)\vee LightOn(s)]\\
\wedge\,\Reg(Undet(crackSafe,s))\rightarrow\neg Stolen(s)\wedge[\neg\top\vee LightOn(s)]\\
\wedge\,\Reg(Undet(toggleLight,s))\rightarrow\neg Stolen(s)\wedge[\neg SafeOpen(s)\vee\neg LightOn(s)]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Further simplifying:
\begin_inset Formula \begin{multline*}
\PstN 2(\dots)[s]\,=\,\neg Stolen(s)\wedge\left[\neg SafeOpen(s)\vee LightOn(s)\right]\\
\wedge\,\neg\Reg(Undet(takeGold,s))\\
\wedge\,[\neg\Reg(Undet(toggleLight,s))\vee\neg SafeOpen(s)\vee\neg LightOn(s)]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Now performing the second regression:
\begin_inset Formula \begin{multline*}
\PstN 2(\dots)[s]\,=\,\neg Stolen(s)\wedge\left[\neg SafeOpen(s)\vee LightOn(s)\right]\\
\shoveright{\wedge\,\left[\neg SafeOpen(s)\vee LightOn(s)\right]}\\
\wedge\,[\neg\bot\vee\neg SafeOpen(s)\vee\neg LightOn(s)]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Further simplification gives:
\begin_inset Formula \[
\PstN 2(\dots)[s]\,=\,\neg Stolen(s)\wedge[\neg SafeOpen(s)\vee LightOn(s)]\]

\end_inset


\end_layout

\begin_layout Standard
We have clearly satisfied the termination condition of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:calc_p"

\end_inset

, since 
\begin_inset Formula $\PstN 1\rightarrow\PstN 2$
\end_inset

 .
 We have thus successfully calculated the persistence condition:
\begin_inset Formula \[
\Pst(\neg Stolen,Undet)=\neg Stolen\wedge\left[\neg SafeOpen\vee LightOn\right]\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../../../library/references"
options "plainnat"

\end_inset


\end_layout

\end_body
\end_document
