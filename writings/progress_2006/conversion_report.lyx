#LyX 1.4.0 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{a4wide}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes true
\end_header

\begin_body

\begin_layout Title
A Programming Language for Multi-Agent Teams: Conversion Report
\end_layout

\begin_layout Author
Ryan Kelly
\newline
Supervisor: Dr.
 Adrian Pearce
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
When a team of agents must cooperate closely in order to achieve some shared
 goal, they may be usefully conceptualized as a single agent with distributed
 sensing, reasoning and acting capabilities.
 Behaviors and goals are naturally ascribed to the team rather than to individua
l members.
 This viewpoint suggests that multi-agent teams may be programmed in a manner
 similar to individual agents - rather than specifying the behavior of each
 team member, write a single program that determines the behavior of the
 team.
 Such a 
\begin_inset Quotes eld
\end_inset

team program
\begin_inset Quotes erd
\end_inset

 could be specified once, then given to any suitable team of agents for
 execution.
\end_layout

\begin_layout Standard
In my thesis I adapt the idea of
\emph on
 high-level program
\emph default
 
\emph on
execution
\emph default
 for use in such a manner.
 A single (potentially non-deterministic) program is written describing
 the desired behavior of the team.
 The individual team members then cooperate amongst themselves to find and
 perform a legal execution of this program.
 Specifically, I extend the Situation Calculus and the Golog family of programmi
ng languages for this purpose to produce a new programming language named
 
\begin_inset Quotes eld
\end_inset

MIndiGolog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
TODO: why is this a good approach?
\end_layout

\begin_layout Standard
- more natural for the programmer
\end_layout

\begin_layout Standard
- easier to predict behavior of team (doesnt rely on emergent behavior)
\end_layout

\begin_layout Standard
- flexible
\end_layout

\begin_layout Standard
- declarative handling of concurrency, conflicy etc
\end_layout

\begin_layout Standard
- agents anticipate actions of others
\end_layout

\begin_layout Standard
- ...more here...
\end_layout

\begin_layout Section
Literature Review
\end_layout

\begin_layout Subsection
Multi-Agent Systems
\end_layout

\begin_layout Standard
taems
\end_layout

\begin_layout Standard
sharedplans
\end_layout

\begin_layout Standard
3apl
\end_layout

\begin_layout Standard
CASL
\end_layout

\begin_layout Standard
MetateM
\end_layout

\begin_layout Standard
STEAM
\end_layout

\begin_layout Standard
Joint Intentions
\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Standard
original sitcalc
\end_layout

\begin_layout Standard
situations-as-histories
\end_layout

\begin_layout Standard
concurrency
\end_layout

\begin_layout Standard
explicit time
\end_layout

\begin_layout Standard
natural actions
\end_layout

\begin_layout Standard
knowledge
\end_layout

\begin_layout Standard
fluent calculus, event calculus?
\end_layout

\begin_layout Subsection
Golog
\end_layout

\begin_layout Standard
Original Golog
\end_layout

\begin_layout Standard
ConGolog
\end_layout

\begin_layout Standard
IndiGolog
\end_layout

\begin_layout Standard
DTGolog
\end_layout

\begin_layout Standard
ReadyLog
\end_layout

\begin_layout Standard
CASL
\end_layout

\begin_layout Standard
other extensions - GTGolog, HTN-Golog, to highlight flexibility of paradigm
\end_layout

\begin_layout Section
Outcomes to Date
\end_layout

\begin_layout Standard
The major outcomes from my research to date have been the following:
\end_layout

\begin_layout Itemize

\series bold
Manuscript:
\series default
 
\begin_inset Quotes eld
\end_inset

High-Level Program Execution for Multi-Agent Teams
\begin_inset Quotes erd
\end_inset


\newline
This paper describes a series of extensions to the semantics of IndiGolog
 that allow it to better represent multi-agent domains, and take advantage
 of the inherent parallellism they offer.
 The paper was submitted to the AAMAS06 and AAAI06 conferences.
\end_layout

\begin_layout Itemize

\series bold
Manuscript:
\series default
 
\begin_inset Quotes eld
\end_inset

Property Persistence in the Situation Calculus
\begin_inset Quotes erd
\end_inset


\newline
Currently in first draft stage, this paper describes a procedure for reasoning
 about the persistence of properties in a situation calculus theory of action
 - that is, given that a property is true in a situation, under what circumstanc
es will it remain true in all future situations? Submission is planned to
 IJCAI07 and the Australian Joint Conference on Artificial Intelligence
 2006.
\end_layout

\begin_layout Itemize

\series bold
Manuscript: 
\series default

\begin_inset Quotes eld
\end_inset

Multi-Agent Knowledge in the Situation Calculus with Partial Awareness of
 Actions
\begin_inset Quotes erd
\end_inset


\newline
Currently in second draft stage, this paper extends the current account
 of knowledge in the multi-agent situation calculus.
 It allows the conditions under which each agent will be aware of the occurance
 of an action to be explicitly axiomatised, and agents then consider possible
 all legal situations that could have come about without them being aware.
 Submission is planned to IJCAI07 and the Australian Joint Conference on
 Artificial Intelligence 2006.
\end_layout

\begin_layout Itemize

\series bold
Software: 
\series default
An implementation of MIndiGolog using the CIAO Prolog system
\newline
This system
 performs the functions of a centralised multi-agent planner - given a team
 program, it finds a complete legal execution that specifies the actions
 of all agents.
 These actions could then be communicated to each agent for execution.
\end_layout

\begin_layout Itemize

\series bold
Software:
\series default
 An implementation of MIndiGolog using the Mozart programming system
\newline
This
 system utilises the distributed logic programming capabilities of Mozart
 to allow a team of agents to share the workload of planning a legal execution.
 Control is still centralised as in the prolog-based system - the entire
 execution needs to be collated in one location then distributed to the
 agents for execution.
\end_layout

\begin_layout Section
Ongoing Work
\end_layout

\begin_layout Standard
In addition to completing the manuscripts described above, I anticipate
 producing two additional major works during the progression of my research:
\end_layout

\begin_layout Itemize

\series bold
Manuscript: 
\series default

\begin_inset Quotes eld
\end_inset

Distributed Execution of MIndiGolog Programs
\begin_inset Quotes erd
\end_inset


\newline
This paper will describe a coordination strategy allowing a team of agents
 to execute a shared MIndiGolog program without the need for centralised
 control.
 The techniques used will be based on standard techniques from multi-agent
 planning, adapted to the Golog paradigm.
 Submission is planned to the AAMAS07 conference.
\end_layout

\begin_layout Itemize

\series bold
Software: 
\series default
An implementation of MIndiGolog with Distributed Execution
\newline
This system will
 implement the strategy described in the above paper, providing a practical
 demonstration of the utility of the techniques developed in my thesis.
 While an initial implementation will be completed using CIAO Prolog, implementa
tions in Mozart and/or Mercury will be considered to increase the efficiency
 of the system.
\end_layout

\begin_layout Standard
These four manuscripts, together with a description and evaluation of the
 implemented software systems, will be merged to form the body of the final
 thesis.
 The proposed timeline for the remainder of the work is as follows:
\end_layout

\begin_layout Itemize
Present - June 2006: Finalise existing papers for submission to IJCAI and
 AI conferences.
 Test preliminary ideas for distributed execution.
\end_layout

\begin_layout Itemize
July - October 2006: Finalise distributed execution strategy.
 Prepare paper for submission to AAMAS07.
\end_layout

\begin_layout Itemize
November 2006 - June 2007: Begin composing manuscripts into final thesis.
 First implementation of final system in prolog.
 First draft of thesis.
\end_layout

\begin_layout Itemize
July - November 2007: Finalise implementation.
 Perform testing using networked departmental machines as agents.
 Continue work on thesis.
 Second draft of thesis.
\end_layout

\begin_layout Itemize
November 2007 - April 2008: Finalisation of thesis.
 Thesis submission.
\end_layout

\end_body
\end_document
