#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{a4wide}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes true
\end_header

\begin_body

\begin_layout Title
A Programming Language for Multi-Agent Teams
\end_layout

\begin_layout Author
PhD Conversion Report
\newline

\newline
Ryan Kelly
\newline
Department of Computer Science and Software
 Engineering
\newline
The University of Melbourne
\newline
Parkville, Australia
\newline
rfk@csse.unimelb.edu.au
\newline

\newline
S
upervisor: Dr.
 Adrian Pearce
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
When a team of agents must cooperate closely in order to achieve some shared
 goal, they may be usefully conceptualized as a single agent with distributed
 sensing, reasoning and acting capabilities.
 Behaviors and goals are more naturally ascribed to the team rather than
 to individual members.
 This viewpoint suggests that techniques for programming in single-agent
 systems may be may be useful when programming the behavior of multi-agent
 teams: rather than specifying the behavior of each team member, write a
 single program that determines the behavior of the entire team.
\end_layout

\begin_layout Standard
In my thesis I adapt the idea of
\emph on
 high-level program
\emph default
 
\emph on
execution
\emph default
 for use in such a manner.
 A single program is written describing the desired behavior of the team.
 The individual team members then cooperate amongst themselves to find and
 perform a legal execution of this program.
 Specifically, I extend the Situation Calculus and the Golog family of programmi
ng languages for this purpose.
 The result is a new programming language named 
\begin_inset Quotes eld
\end_inset

MIndiGolog
\begin_inset Quotes erd
\end_inset

 suitable for specifying the behavior of multi-agent teams.
\end_layout

\begin_layout Subsection
Research Objectives
\end_layout

\begin_layout Standard
The major objectives of my research program are:
\end_layout

\begin_layout Itemize
Develop an appropriate formalism for programming multi-agent teams at the
 level of the team
\end_layout

\begin_layout Itemize
Develop an implementation of the formalism that can be used to program real-worl
d teams
\end_layout

\begin_layout Itemize
Demonstrate the effectiveness of the approach using a small example implemented
 on a set of networked computers
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
TODO: why is this a good approach?
\end_layout

\begin_layout Standard
- more natural for the programmer
\end_layout

\begin_layout Standard
- easier to predict behavior of team (doesn't rely on emergent behavior)
\end_layout

\begin_layout Standard
- flexible
\end_layout

\begin_layout Standard
- declarative handling of concurrency, conflicts etc
\end_layout

\begin_layout Standard
- agents anticipate actions of others
\end_layout

\begin_layout Standard
- ...more here...
\end_layout

\begin_layout Section
Background and Related Work
\end_layout

\begin_layout Subsection
Multi-Agent Systems
\end_layout

\begin_layout Subsubsection
Overview and Terminology
\end_layout

\begin_layout Standard
Multi-agent systems research is a large and diverse field, with a correspondingl
y vast literature base.
 While an overview of the entire field is beyond the scope of this report,
 articles such as 
\begin_inset LatexCommand \cite{nwana95software_agents,mataric95issues_designing_agents}

\end_inset

 provide a useful overview for the interested reader.
 It is however necessary to situate this work within the broader field,
 which we do below.
\end_layout

\begin_layout Standard
While often implicit in the literature, there is a clear distinction between
 two types of systems involving multiple agents, typically termed Multi-Agent
 Systems (MAS) and Distributed Problem Solving (DPS) respectively 
\begin_inset LatexCommand \cite{nwana95software_agents,mataric95issues_designing_agents}

\end_inset

.
\end_layout

\begin_layout Standard
MAS applications involve autonomous agents who act independently, and may
 cooperate or compete depending on their individual goals and desires.
 While arranging and coordinating teamwork in such systems is a fascinating
 and challenging topic, it is outside the scope of this research project.
 DPS applications involve a team of agents cooperating to solve a joint
 problem or perform a joint task, and are the types of application this
 research project is targeted toward.
 A detailed discussion of the field can be found in 
\begin_inset LatexCommand \cite{Durfee91dps}

\end_inset

.
\end_layout

\begin_layout Standard
For a team of agents to form a DPS system, they must have some shared notion
 of the task to be carried out.
 The agents may have differing capabilities or expertise, they may have
 access to differing information about the world, and they may have differing
 ideas about the state of completion of the joint task.
 Somehow, they must coordinate and cooperate to carry out the joint task.
\end_layout

\begin_layout Standard
This research project aims to develop a programming language that can be
 used to specify the tasks to be performed by a DPS system, and a coordination
 strategy that will enable a team of agents to execute such programs.
\end_layout

\begin_layout Standard
[TODO more here]
\end_layout

\begin_layout Subsubsection
Existing Approaches
\end_layout

\begin_layout Standard
HTN
\begin_inset LatexCommand \cite{obst05htn_teams}

\end_inset


\end_layout

\begin_layout Standard
taems/GPGP 
\begin_inset LatexCommand \cite{decker95designing_coordination}

\end_inset

,
\end_layout

\begin_layout Standard
sharedplans
\begin_inset LatexCommand \cite{grosz99planning_together}

\end_inset

 (CAST 
\begin_inset LatexCommand \cite{yen01cast}

\end_inset

)
\end_layout

\begin_layout Standard
STEAM
\begin_inset LatexCommand \cite{tambe97flexible_teamwork}

\end_inset


\end_layout

\begin_layout Standard
STAPLE
\begin_inset LatexCommand \cite{kumar02staple_direct_exec}

\end_inset


\end_layout

\begin_layout Standard
CASL/ReadyLog (see below)
\end_layout

\begin_layout Subsubsection
Coordination
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{jennings96coordination}

\end_inset


\end_layout

\begin_layout Standard
explicit/implicit coordination 
\begin_inset LatexCommand \cite{ephrati95filtering_coord}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{durfee05ma_plan_coordination}

\end_inset


\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Subsubsection
The Basic Situation Calculus
\end_layout

\begin_layout Standard
The situation calculus is a (mostly) first-order logic formalisms for describing
 and reasoning about dynamic worlds.
 It was introduced by McCarthy and Hayes in 
\begin_inset LatexCommand \cite{McCHay69sitcalc}

\end_inset

, and has since been significantly expanded and formalized 
\begin_inset LatexCommand \cite{reiter91frameprob,pirri99contributions_sitcalc,levesque98sc_foundations}

\end_inset

.
 The key elements of the situation calculus are:
\end_layout

\begin_layout Itemize

\series bold
Actions:
\series default
 function terms in the language denoting ways in which the state of the
 world can change.
\end_layout

\begin_layout Itemize

\series bold
Situations:
\series default
 histories of the actions that have occurred in the world
\end_layout

\begin_layout Itemize

\series bold
Fluents:
\series default
 functions or predicates taking a situation as their final argument, indicating
 properties of the world that may change from one situation to another.
\end_layout

\begin_layout Standard
Using these building blocks, along with some foundational axioms, it is
 possible to construct a theory of action that described the behavior of
 a dynamic world.
\end_layout

\begin_layout Standard
One of the most attractive aspects of the situation calculus is that it
 permits an elegant monotonic solution to the infamous frame problem - the
 problem of specifying which properties of the world do not change between
 situations.
 Reiter 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

 describes how to construct 
\emph on
successor state axioms
\emph default
 which completely capture the change and non-change of a fluent with respect
 to various actions.
\end_layout

\begin_layout Subsubsection
Continuous and Concurrent Actions
\end_layout

\begin_layout Standard
Actions in the basic situation calculus are taken to be instantaneous, and
 can only happen in strict sequence.
 For multi-agent domains such limitations are unacceptable.
 Different agents may take different amount of time to perform the same
 action, making it necessary to represent continuous actions.
 There is also the possibility of several agents performing different actions
 at the same instant, necessitating an account of concurrency.
\end_layout

\begin_layout Standard
Fortunately, such issues have a long history in the situation calculus and
 mature formalisms exist for representing both.
 Concurrent actions are introduced in 
\begin_inset LatexCommand \cite{lin92sc_conc}

\end_inset

 and 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 by using sets of actions to represent all the actions that occur at a given
 instant.
 Reiter simplifies this somewhat in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 by appealing to the standard axiomatisation of sets rather than defining
 a new set-like operator to combine action terms.
\end_layout

\begin_layout Standard
These papers, particularly 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

, also introduce a standard mechanism for dealing with actions that have
 finite duration.
 They are split into instantaneous 
\emph on
begin
\emph default
 and 
\emph on
end
\emph default
 actions and an accompanying fluent that indicates that the action is currently
 in progress.
\end_layout

\begin_layout Subsubsection
Explicit Time and Natural Actions
\end_layout

\begin_layout Standard
An explicit notion of time is introduced to the situation calculus in 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

, where the functions 
\emph on
start
\emph default
 and 
\emph on
end
\emph default
 give the starting/ending time of a given situation.
 This was again simplified somewhat by Reiter in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

.
 The key to this representation is that each action has, as its final argument,
 the time at which it was performed.
 Since situations are just sequences of actions, this allows the timing
 of situations to be determined.
\end_layout

\begin_layout Standard
This mechanism interacts with the set-based representation of concurrent
 actions, as all actions that are performed concurrently are required to
 have the same occurrence time.
 In 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 a predicate 
\emph on
coherent
\emph default
 is introduced to enforce this requirement.
 An alternate approach is demonstrated for the related fluent calculus in
 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset

 where the occurrence time is attached directly to situations rather than
 actions.
 This modified approach will be followed in our work.
\end_layout

\begin_layout Standard
Closely related to the temporal situation calculus is the notion of natural
 actions 
\begin_inset LatexCommand \cite{pinto94temporal,reiter96sc_nat_conc}

\end_inset

, those actions which must occur when it is possible for them to occur.
 These are typically used to represent predictable effects of nature, such
 as a dropped ball bouncing when it hits the ground.
\end_layout

\begin_layout Subsubsection
Knowledge
\end_layout

\begin_layout Standard
A robust account of knowledge is important when implementing distributed
 systems where cooperation is required, as the agents need to reason about
 the knowledge possessed by other agents.
 Knowledge can be added to the situation calculus by following the traditional
 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 semantics, as demonstrated in 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

.
 Sherl provides an extension of this account to handle time and concurrent
 actions in 
\begin_inset LatexCommand \cite{scherl03conc_knowledge}

\end_inset

.
\end_layout

\begin_layout Standard
[TODO: discuss limitations of these accounts?]
\end_layout

\begin_layout Subsubsection
Reasoning
\end_layout

\begin_layout Standard
One important aspect of the situation calculus is the tractability of reasoning
 within it.
 The key idea here is 
\emph on
regression
\emph default
, a technique for reducing reasoning about arbitrary future situations to
 reasoning solely about the initial situation.
 Introduced by Reiter to accompany his solution to the frame problem in
 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

, the technique has been expanded to accommodate the various extensions
 outlined above - most importantly, the accommodate regressing formulas
 about knowledge 
\begin_inset LatexCommand \cite{scherl03sc_knowledge,scherl03conc_knowledge}

\end_inset

.
 Lin and Reiter demonstrate in 
\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset

 how these techniques can also accommodate state constraints that must hold
 for all situations.
\end_layout

\begin_layout Standard
Unfortunately, quantification over situations typically requires the use
 of a second-order induction axiom 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
 While this is useful for proving properties of domain specifications by
 hand, it has provided problematic for automated reasoning.
 [TODO: hint at our solution? Reference the one work that actually does
 this automatically.]
\end_layout

\begin_layout Subsubsection
Related Approaches
\end_layout

\begin_layout Standard
The situation calculus is one of a family of approaches to modelling dynamic
 worlds in first-order logic.
 Other approaches include the Event Calculus 
\begin_inset LatexCommand \cite{kowalski86event_calculus}

\end_inset

 and Fluent Calculus 
\begin_inset LatexCommand \cite{thielscher99fluentcalc,theilscher02flux}

\end_inset

.
 These formalisms all share the same basic concepts for describing the world,
 such as fluents and actions.
 Because of this, many techniques developed in one formalism can be imported
 to other without difficulty - for example, see the similarities between
 concurrency, time and natural actions in the situation calculus 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 and fluent calculus 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset

.
 We have chosen the situation calculus because it is the oldest and most
 widely accepted of such formalisms, and with the understanding that our
 results will likely be applicable to other formalisms.
\end_layout

\begin_layout Standard
There is also a growing interest in using techniques from modal logic for
 such applications, particulaly the combination of knowledge and action
 represented by epistemic dynamic logic 
\begin_inset LatexCommand \cite{herzig00edl_partial_obs}

\end_inset

.
 There have even been re-formulations of the situation calculus in modal
 logic 
\begin_inset LatexCommand \cite{Lakemeyer2005Semantic}

\end_inset

 and hybrid logic 
\begin_inset LatexCommand \cite{blackburn01hybrid_sitcalc}

\end_inset

.
 We have chosen to remain in first-order logic largely due to the availability
 of mature programming tools and systems such as Prolog.
 We also belive our ideas to be general enough that they could be imported
 to a modal formalism without difficulty.
\end_layout

\begin_layout Subsection
Golog
\end_layout

\begin_layout Subsubsection
High-Level Program Execution and Golog
\end_layout

\begin_layout Standard
The programming language Golog builds on the situation calculus to provide
 a means for building 
\begin_inset Quotes eld
\end_inset

complex actions
\begin_inset Quotes erd
\end_inset

 from primitive actions using operators such as sequence, iteration and
 if-then-else.
 It is formally introduced in 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

, but is based on ideas dating back much earlier.
 For a discussion of the advantages and applications of this approach, see
 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach,reiter01kia}

\end_inset

.
\end_layout

\begin_layout Standard
[TODO: discuss semantics?]
\end_layout

\begin_layout Standard
Golog is an implementation of the more general paradigm of 
\emph on
high-level program execution
\emph default
.
 As explained in 
\begin_inset LatexCommand \cite{Levesque98beyondplanning}

\end_inset

, high-level program execution is a tractable alternative to traditional
 goal-based planning for single-agent systems.
 Rather than simply specifying some goal state that is to be achieved, the
 programmer specifies a program that the agent should follow that will achieve
 the desired state.
 Crucially, this program may contain non-deterministic constructs where
 the agent is required to determine the sequence of actions at run-time,
 based on its knowledge of how the world behaves.
\end_layout

\begin_layout Standard
[TODO: more on this, it's important]
\end_layout

\begin_layout Standard
The advantages of this approach over other HTN, another popular method for
 reducing the complexity of the planning problem, are detailed in 
\begin_inset LatexCommand \cite{son00htn_golog}

\end_inset

.
 In many instances, the programming constructs of Golog allow a more natural
 and concise encoding of the procedural information than other formalisms.
\end_layout

\begin_layout Subsubsection
ConGolog
\end_layout

\begin_layout Standard
ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog,lesperance99modeling}

\end_inset

 is an extension to Golog that adds concurrency by means of interleaving
 - two programs can be run in parallel with steps of their execution interleaved
 together.
 This operator adds a great deal of flexibility to ConGolog programs - for
 example, they can simulate 
\begin_inset Quotes eld
\end_inset

interrupts
\begin_inset Quotes erd
\end_inset

 that are executed immediately when some condition becomes true in the environme
nt.
\end_layout

\begin_layout Standard
[TODO: talk about altered semantics?]
\end_layout

\begin_layout Standard
ConGolog was initially designed to operate only using basic situation calculus
 theories of action.
 The extension TConGolog is proposed in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

 to integrate interleaved concurrency with the true concurrency of actions
 introduced above.
 However, the approach taken does not fully consider the implications of
 this integration and may, in certain circumstances, call for actions to
 be executed that cannot be performed in the world.
 [TODO: mention that we have improved this?]
\end_layout

\begin_layout Subsubsection
IndiGolog
\end_layout

\begin_layout Standard
Both Golog and ConGolog require the agent to construct a complete execution
 of the program before any actions are carried out in the world, as this
 is the only way it can be sure that the program will eventually run to
 completion.
 For large programs or those involving a lot of nondeterminism, this could
 be intractible.
 The language extension IndiGolog 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

 was introduced to allow planning to be interleaved with action.
 This is accomplished by adding a 
\begin_inset Quotes eld
\end_inset

search
\begin_inset Quotes erd
\end_inset

 operator.
 While programs within the scope of a search operator have a full execution
 planned as before, programs outside the search operator are executed with
 only a single step of lookahead.
\end_layout

\begin_layout Standard
The original semantics of the search operator commited the agent to its
 initial choice of execution.
 Further enhancements 
\begin_inset LatexCommand \cite{Lesperance00improved_indigolog,giacomo04sem_delib_indigolog}

\end_inset

 commit the agent only to those actions it has already performed, allowing
 replanning if the environment has changed.
\end_layout

\begin_layout Subsubsection
DTGolog
\end_layout

\begin_layout Standard
The situation calculus typically requires the world to be deterministic
 - actions always have the same, predictable effects.
 In many situations it is more realistic to assign probabilities to the
 effects of an action, indicating various ways in which it might fail or
 have unintended consequences.
 The branch of AI that deals with acting under such probabilistic models
 is known as Decision Theory.
 DTGolog 
\begin_inset LatexCommand \cite{boutilier00dtgolog}

\end_inset

 is an extension of the Golog semantics of include decision-theoretic concepts,
 such as determining the execution of a program with the highest expected
 utility.
 These techniques have been extended further by GTGolog 
\begin_inset LatexCommand \cite{finzi03gtgolog,finzi05pogtgolog}

\end_inset

, which introduces concepts from Game Theory.
\end_layout

\begin_layout Standard
While these extensions are certainly very powerful and allow Golog to be
 applied to a wider range of domains, they will not be included in my research
 program in order to keep the problem management within the timeframe of
 a PhD thesis.
 We anticipate that these techniques could be combined with our research
 output without significant difficulty.
\end_layout

\begin_layout Subsubsection
CASL 
\end_layout

\begin_layout Standard
The Cognitive Agent Specification Language
\begin_inset LatexCommand \cite{shapiro02casl,lesperance05ecasl}

\end_inset

 is an attempt to build a complete specification and simulation environment
 for multi-agent systems, using the situation calculus and ConGolog to provide
 a formal underpinning.
 While similar to our work in that it seeks to use Golog in a multi-agent
 context, it is focussed more on the specification of open multi-agent systems
 rather than distributed problem solving with multi-agent teams.
 Consequently, each agent has its own individual control program written
 in ConGolog.
\end_layout

\begin_layout Standard
Despite this differing focus, many results from the CASL effort are applicable
 to my thesis - in particular, the account of knowledge for multi-agent
 systems documented in 
\begin_inset LatexCommand \cite{Lesperance01epi_feas_casl}

\end_inset

.
\end_layout

\begin_layout Subsubsection
ReadyLog
\end_layout

\begin_layout Standard
Closer in spirit to our research objectives is the work on Ferrein et.
 al.
 on applying the Golog varient ReadyLog to the control of a robotic soccer
 team 
\begin_inset LatexCommand \cite{Ferrein2003icpgolog_multi,Ferrein2005readylog}

\end_inset

.
 In their approach, the team of agents share a common ReadyLog program describin
g the actions to be performed.
 Each agent reasons individually to determine the best legal execution of
 the program, which they then carry out.
 Because the robotic soccer domain is completely observable, this allows
 the agents to coordinate their actions without the need to communicate.
\end_layout

\begin_layout Standard
Our aim is similar to this scenario, with several improvements:
\end_layout

\begin_layout Itemize
Take advantage of multiple agents to perform actions concurently
\end_layout

\begin_layout Itemize
Take advantage of multiple agents to share the planning workload
\end_layout

\begin_layout Itemize
Allow communication and the ability to deal with partially observable domains
\end_layout

\begin_layout Subsubsection
Other Extensions
\end_layout

\begin_layout Standard
other extensions - to highlight flexibility of paradigm
\end_layout

\begin_layout Standard
cc-Golog
\begin_inset LatexCommand \cite{grosskreutz00ccgolog}

\end_inset


\end_layout

\begin_layout Standard
HTN-Golog 
\begin_inset LatexCommand \cite{son00htn_golog,Son04golog+htn+time}

\end_inset

 (but criticize the demand for precondition information in the plan - this
 can form part of the domain, e.g.
 cant enroll in a class without the prerecs)
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{Reiter98seq_temp_golog}

\end_inset


\end_layout

\begin_layout Subsubsection
Planning
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{Finzi00open_world_sitcalc}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{pirri00planning_nat_acts}

\end_inset


\begin_inset LatexCommand \cite{baier03golog_planning}

\end_inset


\end_layout

\begin_layout Section
Progress to Date
\end_layout

\begin_layout Subsection
Manuscripts
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

High-Level Program Execution for Multi-Agent Teams
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This paper describes a series of extensions to the semantics of IndiGolog
 that allow it to better represent multi-agent domains, and take advantage
 of the inherent parallelism they offer.
 It is an integration and extension of several existing techniques.
 In particular, the language offers:
\end_layout

\begin_layout Itemize
A combined account of true and interleaved concurrency, that is more robust
 than the work of 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset


\end_layout

\begin_layout Itemize
An explicit notion of time, similar to that of 
\begin_inset LatexCommand \cite{Reiter98seq_temp_golog,reiter96sc_nat_conc}

\end_inset

 but avoiding the need to check coherency of concurrent actions
\end_layout

\begin_layout Itemize
The tight integration of natural actions, with all legal executions guaranteed
 to produce legal situations
\end_layout

\begin_layout Standard
The paper was submitted to the AAMAS06 and AAAI06 conferences, but has not
 been accepted for publication.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

Property Persistence in the Situation Calculus
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Currently in first draft stage, this paper describes a procedure for reasoning
 about the persistence of properties in a situation calculus theory of action.
 The type of reasoning it allows is as follows: given that a property is
 true in a situation 
\begin_inset Formula $s$
\end_inset

, under what circumstances will it remain true in all situations in the
 future of 
\begin_inset Formula $s$
\end_inset

? We replace the second-order induction that is typically required for such
 questions with iterated first-order reasoning.
 
\end_layout

\begin_layout Standard
Submission is planned to the IJCAI07 conference and the Australian Joint
 Conference on Artificial Intelligence 2006.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

Multi-Agent Knowledge in the Situation Calculus with Partial Awareness of
 Actions
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Currently in second draft stage, this paper extends the current account
 of knowledge in the multi-agent situation calculus 
\begin_inset LatexCommand \cite{scherl03conc_knowledge,Lesperance01epi_feas_casl}

\end_inset

.
 Existing approaches typically assume that all agents are aware of the occurence
 of all actions.
 We relax this assumption by allowing the conditions under which each agent
 will be aware of the occurrence of an action to be explicitly axiomatised.
 Agents then consider possible all legal situations that could have come
 about without them being aware, which requires reasoning about the persistence
 of properties as detailed above.
\end_layout

\begin_layout Standard
Submission is planned to the IJCAI07 conference and the Australian Joint
 Conference on Artificial Intelligence 2006.
\end_layout

\begin_layout Subsection
Software
\end_layout

\begin_layout Subsubsection
An implementation of MIndiGolog using the CIAO Prolog system
\end_layout

\begin_layout Standard
This system performs the functions of a centralized multi-agent planner
 - given a team program, it finds a complete legal execution that specifies
 the actions of all agents.
 These actions could then be communicated to each agent for execution.
\end_layout

\begin_layout Subsubsection
An implementation of MIndiGolog using the Mozart programming system
\end_layout

\begin_layout Standard
This system utilizes the distributed logic programming capabilities of Mozart
 to allow a team of agents to share the workload of planning a legal execution.
 Control is still centralized as in the prolog-based system - the entire
 execution needs to be collated in one location then distributed to the
 agents for execution.
\end_layout

\begin_layout Subsection
Presentations
\end_layout

\begin_layout Subsubsection
15/11/05: Agentlab Seminar on Golog
\end_layout

\begin_layout Standard
On the 15th of November 2005, I presented a 1-hour seminar to the departmental
 Agentlab group giving a summary of the Golog family of programming languages,
 their advantages and applications.
\end_layout

\begin_layout Subsubsection
29/11/05: Agentlab Seminar on MIndiGolog
\end_layout

\begin_layout Standard
On the 29th of November 2005, I presented a 1-hour seminar to the departmental
 Agentlab group I described our research aims and presented our extensions
 to the IndiGolog programming language to allow it to better represent the
 behavior of multi-agent teams.
\end_layout

\begin_layout Subsubsection
07/04/06: CSSE Postgraduate Seminar
\end_layout

\begin_layout Standard
On the 7th of April 2006, I presented a 1-hour seminar as part of the department
's postgraduate seminar series.
 The seminar provided a desription of our research objects, a summary of
 the work to date, and a brief discussion of our ideas for future work.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
In addition to completing the manuscripts described above, I anticipate
 producing two additional major works during the progression of my research:
\end_layout

\begin_layout Itemize

\series bold
Manuscript: 
\series default

\begin_inset Quotes eld
\end_inset

Distributed Execution of MIndiGolog Programs
\begin_inset Quotes erd
\end_inset


\newline
This paper will describe a coordination strategy allowing a team of agents
 to execute a shared MIndiGolog program without the need for centralised
 control.
 The techniques used will be based on standard techniques from multi-agent
 planning, adapted to the Golog paradigm.
 Submission is planned to the AAMAS07 conference.
\end_layout

\begin_layout Itemize

\series bold
Software: 
\series default
An implementation of MIndiGolog with Distributed Execution
\newline
This system will
 implement the strategy described in the above paper, providing a practical
 demonstration of the utility of the techniques developed in my thesis.
 While an initial implementation will be completed using CIAO Prolog, implementa
tions in Mozart and/or Mercury will be considered to increase the efficiency
 of the system.
\end_layout

\begin_layout Standard
These four manuscripts, together with a description and evaluation of the
 implemented software systems, will be merged to form the body of the final
 thesis.
 The proposed timeline for the remainder of the work is as follows:
\end_layout

\begin_layout Itemize
Present - June 2006: Finalise existing papers for submission to IJCAI and
 AI conferences.
 Test preliminary ideas for distributed execution.
\end_layout

\begin_layout Itemize
July - October 2006: Finalise distributed execution strategy.
 Prepare paper for submission to AAMAS07.
\end_layout

\begin_layout Itemize
November 2006 - June 2007: Begin composing manuscripts into final thesis.
 First implementation of final system in prolog.
 First draft of thesis.
\end_layout

\begin_layout Itemize
July - November 2007: Finalise implementation.
 Perform testing using networked departmental machines as agents.
 Continue work on thesis.
 Second draft of thesis.
\end_layout

\begin_layout Itemize
November 2007 - April 2008: Finalisation of thesis.
 Thesis submission.
\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
