#LyX 1.4.0 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{a4wide}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes true
\end_header

\begin_body

\begin_layout Title
A Programming Language for Multi-Agent Teams
\end_layout

\begin_layout Author
Ryan Kelly
\newline

\newline
Supervisor: Dr.
 Adrian Pearce
\newline

\newline
Department of Computer Science and Software Engineering
\newline
The
 University of Melbourne
\newline
Parkville, Australia
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
When a team of agents must cooperate closely in order to achieve some shared
 goal, they may be usefully conceptualized as a single agent with distributed
 sensing, reasoning and acting capabilities.
 Behaviors and goals are more naturally ascribed to the team rather than
 to individual members.
 This viewpoint suggests that techniques for programming in single-agent
 systems may be may be useful when programming the behavior of multi-agent
 teams: rather than specifying the behavior of each team member, write a
 single program that determines the behavior of the entire team.
\end_layout

\begin_layout Standard
In my thesis I adapt the idea of
\emph on
 high-level program
\emph default
 
\emph on
execution
\emph default
 for use in such a manner.
 A single program is written describing the desired behavior of the team.
 The individual team members then cooperate amongst themselves to find and
 perform a legal execution of this program.
 Specifically, I extend the Situation Calculus and the Golog family of programmi
ng languages for this purpose.
 The result is a new programming language named 
\begin_inset Quotes eld
\end_inset

MIndiGolog
\begin_inset Quotes erd
\end_inset

 suitable for specifying the behavior of multi-agent teams.
\end_layout

\begin_layout Subsection
Research Objectives
\end_layout

\begin_layout Standard
The major objectives of my research program are:
\end_layout

\begin_layout Itemize
Develop an appropriate formalism for programming multi-agent teams at the
 level of the team
\end_layout

\begin_layout Itemize
Develop an implementation of the formalism that can be used to program real-worl
d teams
\end_layout

\begin_layout Itemize
Demonstrate the effectiveness of the approach using a small example implemented
 on a set of networked computers
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
TODO: why is this a good approach?
\end_layout

\begin_layout Standard
- more natural for the programmer
\end_layout

\begin_layout Standard
- easier to predict behavior of team (doesnt rely on emergent behavior)
\end_layout

\begin_layout Standard
- flexible
\end_layout

\begin_layout Standard
- declarative handling of concurrency, conflicy etc
\end_layout

\begin_layout Standard
- agents anticipate actions of others
\end_layout

\begin_layout Standard
- ...more here...
\end_layout

\begin_layout Section
Background and Related Work
\end_layout

\begin_layout Subsection
Multi-Agent Systems
\end_layout

\begin_layout Subsubsection
Overview and Terminology
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{mataric95issues_designing_agents}

\end_inset

 - DPS vs MAS
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{nwana95software_agents}

\end_inset

 overview, topology
\end_layout

\begin_layout Standard
Approaches we're not interested in: 
\begin_inset LatexCommand \cite{DBLP:conf/atal/ClementB03}

\end_inset


\end_layout

\begin_layout Subsubsection
Existing Aproaches
\end_layout

\begin_layout Standard
HTN
\begin_inset LatexCommand \cite{obst05htn_teams}

\end_inset


\end_layout

\begin_layout Standard
taems/GPGP 
\begin_inset LatexCommand \cite{decker95designing_coordination}

\end_inset

,
\end_layout

\begin_layout Standard
sharedplans
\begin_inset LatexCommand \cite{grosz99planning_together}

\end_inset

 (CAST 
\begin_inset LatexCommand \cite{yen01cast}

\end_inset

)
\end_layout

\begin_layout Standard
CASL/ReadyLog (see below)
\end_layout

\begin_layout Standard
STEAM
\begin_inset LatexCommand \cite{tambe97flexible_teamwork}

\end_inset


\end_layout

\begin_layout Standard
STAPLE
\begin_inset LatexCommand \cite{kumar02staple_direct_exec}

\end_inset


\end_layout

\begin_layout Subsubsection
Coordination
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{jennings96coordination}

\end_inset


\end_layout

\begin_layout Standard
explicit/implicit coordination 
\begin_inset LatexCommand \cite{ephrati95filtering_coord}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{durfee05ma_plan_coordination}

\end_inset


\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Subsubsection
The Base Situation Calculus
\end_layout

\begin_layout Standard
original sitcalc
\begin_inset LatexCommand \cite{McCHay69sitcalc}

\end_inset


\end_layout

\begin_layout Standard
situations-as-histories
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset


\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset


\end_layout

\begin_layout Subsubsection
Continuous and Concurrent Actions
\end_layout

\begin_layout Standard
concurrency
\begin_inset LatexCommand \cite{lin92sc_conc}

\end_inset


\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset


\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset


\end_layout

\begin_layout Subsubsection
Explicit Time and Natural Actions
\end_layout

\begin_layout Standard
explicit time
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset


\end_layout

\begin_layout Standard
natural actions
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset


\end_layout

\begin_layout Subsubsection
Knowledge
\end_layout

\begin_layout Standard
knowledge
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset


\begin_inset LatexCommand \cite{scherl03conc_knowledge}

\end_inset


\end_layout

\begin_layout Subsubsection
Reasoning
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset


\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset


\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset


\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset


\end_layout

\begin_layout Subsubsection
Related Approaches
\end_layout

\begin_layout Standard
fluent calculus
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset


\begin_inset LatexCommand \cite{thielscher99fluentcalc}

\end_inset


\begin_inset LatexCommand \cite{theilscher02flux}

\end_inset


\end_layout

\begin_layout Standard
event calculus
\begin_inset LatexCommand \cite{kowalski86event_calculus}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{Lakemeyer2005Semantic}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{davis05fo_ma_theory}

\end_inset


\begin_inset LatexCommand \cite{herzig00edl_partial_obs}

\end_inset


\end_layout

\begin_layout Subsection
Golog
\end_layout

\begin_layout Subsubsection
High-Level Program Execution and Golog
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset


\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach}

\end_inset


\begin_inset LatexCommand \cite{reiter01kia}

\end_inset


\begin_inset LatexCommand \cite{Levesque98beyondplanning}

\end_inset


\begin_inset LatexCommand \cite{son00htn_golog}

\end_inset


\end_layout

\begin_layout Subsubsection
ConGolog
\end_layout

\begin_layout Standard
ConGolog
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset


\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset


\begin_inset LatexCommand \cite{lesperance99modeling}

\end_inset


\end_layout

\begin_layout Subsubsection
IndiGolog
\end_layout

\begin_layout Standard
IndiGolog
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

,
\begin_inset LatexCommand \cite{Lesperance00improved_indigolog}

\end_inset


\begin_inset LatexCommand \cite{giacomo04sem_delib_indigolog}

\end_inset


\end_layout

\begin_layout Subsubsection
DTGolog
\end_layout

\begin_layout Standard
DTGolog
\begin_inset LatexCommand \cite{boutilier00dtgolog}

\end_inset

, plus GTGolog - seems related to what we want to do...
\end_layout

\begin_layout Subsubsection
CASL and ECASL
\end_layout

\begin_layout Standard
CASL
\begin_inset LatexCommand \cite{Lesperance01epi_feas_casl,lesperance05ecasl}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{shapiro02casl}

\end_inset


\end_layout

\begin_layout Subsubsection
ReadyLog
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{Ferrein2003icpgolog_multi,Ferrein2005readylog}

\end_inset


\end_layout

\begin_layout Subsubsection
Other Extensions
\end_layout

\begin_layout Standard
other extensions - to highlight flexibility of paradigm
\end_layout

\begin_layout Standard
cc-Golog
\begin_inset LatexCommand \cite{grosskreutz00ccgolog}

\end_inset


\end_layout

\begin_layout Standard
GTGolog,
\begin_inset LatexCommand \cite{finzi03gtgolog}

\end_inset


\begin_inset LatexCommand \cite{finzi05pogtgolog}

\end_inset


\end_layout

\begin_layout Standard
HTN-Golog 
\begin_inset LatexCommand \cite{son00htn_golog,Son04golog+htn+time}

\end_inset

 (but criticise the demand for precondition information in the plan - this
 can form part of the domain, e.g.
 cant enrol in a class without the prerecs)
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{Reiter98seq_temp_golog}

\end_inset


\end_layout

\begin_layout Subsubsection
Planning
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{Finzi00open_world_sitcalc}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{pirri00planning_nat_acts}

\end_inset


\begin_inset LatexCommand \cite{baier03golog_planning}

\end_inset


\end_layout

\begin_layout Section
Progress to Date
\end_layout

\begin_layout Subsection
Manuscripts
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

High-Level Program Execution for Multi-Agent Teams
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This paper describes a series of extensions to the semantics of IndiGolog
 that allow it to better represent multi-agent domains, and take advantage
 of the inherent parallellism they offer.
 The paper was submitted to the AAMAS06 and AAAI06 conferences.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

Property Persistence in the Situation Calculus
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Currently in first draft stage, this paper describes a procedure for reasoning
 about the persistence of properties in a situation calculus theory of action
 - that is, given that a property is true in a situation, under what circumstanc
es will it remain true in all future situations? Submission is planned to
 IJCAI07 and the Australian Joint Conference on Artificial Intelligence
 2006.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

Multi-Agent Knowledge in the Situation Calculus with Partial Awareness of
 Actions
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Currently in second draft stage, this paper extends the current account
 of knowledge in the multi-agent situation calculus.
 It allows the conditions under which each agent will be aware of the occurance
 of an action to be explicitly axiomatised, and agents then consider possible
 all legal situations that could have come about without them being aware.
 Submission is planned to IJCAI07 and the Australian Joint Conference on
 Artificial Intelligence 2006.
\end_layout

\begin_layout Subsection
Software
\end_layout

\begin_layout Subsubsection
An implementation of MIndiGolog using the CIAO Prolog system
\end_layout

\begin_layout Standard
This system performs the functions of a centralised multi-agent planner
 - given a team program, it finds a complete legal execution that specifies
 the actions of all agents.
 These actions could then be communicated to each agent for execution.
\end_layout

\begin_layout Subsubsection
An implementation of MIndiGolog using the Mozart programming system
\end_layout

\begin_layout Standard
This system utilises the distributed logic programming capabilities of Mozart
 to allow a team of agents to share the workload of planning a legal execution.
 Control is still centralised as in the prolog-based system - the entire
 execution needs to be collated in one location then distributed to the
 agents for execution.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
In addition to completing the manuscripts described above, I anticipate
 producing two additional major works during the progression of my research:
\end_layout

\begin_layout Itemize

\series bold
Manuscript: 
\series default

\begin_inset Quotes eld
\end_inset

Distributed Execution of MIndiGolog Programs
\begin_inset Quotes erd
\end_inset


\newline
This paper will describe a coordination strategy allowing a team of agents
 to execute a shared MIndiGolog program without the need for centralised
 control.
 The techniques used will be based on standard techniques from multi-agent
 planning, adapted to the Golog paradigm.
 Submission is planned to the AAMAS07 conference.
\end_layout

\begin_layout Itemize

\series bold
Software: 
\series default
An implementation of MIndiGolog with Distributed Execution
\newline
This system will
 implement the strategy described in the above paper, providing a practical
 demonstration of the utility of the techniques developed in my thesis.
 While an initial implementation will be completed using CIAO Prolog, implementa
tions in Mozart and/or Mercury will be considered to increase the efficiency
 of the system.
\end_layout

\begin_layout Standard
These four manuscripts, together with a description and evaluation of the
 implemented software systems, will be merged to form the body of the final
 thesis.
 The proposed timeline for the remainder of the work is as follows:
\end_layout

\begin_layout Itemize
Present - June 2006: Finalise existing papers for submission to IJCAI and
 AI conferences.
 Test preliminary ideas for distributed execution.
\end_layout

\begin_layout Itemize
July - October 2006: Finalise distributed execution strategy.
 Prepare paper for submission to AAMAS07.
\end_layout

\begin_layout Itemize
November 2006 - June 2007: Begin composing manuscripts into final thesis.
 First implementation of final system in prolog.
 First draft of thesis.
\end_layout

\begin_layout Itemize
July - November 2007: Finalise implementation.
 Perform testing using networked departmental machines as agents.
 Continue work on thesis.
 Second draft of thesis.
\end_layout

\begin_layout Itemize
November 2007 - April 2008: Finalisation of thesis.
 Thesis submission.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
