

\chapter{Background}

\label{ch:background}

This chapter covers general background material for the thesis, and
serves as a brief literature review. More specific background material
may be found at the beginning of each subsequent chaper.

We begin by introducing the base language of the situation calculus
in section \ref{sec:Background:The-Situation-Calculus}, along with
the {}``cooking agents'' example domain which will be used throughout
the thesis. Section \ref{sec:Background:Golog} introduces the Golog
family of programming languages, which are the standard formalism
for representing complex tasks in the situation calculus. Reasoning
about knowledge is covered in section \ref{sec:Background:Epistemic-Reasoning}.
Finally, section \ref{sec:Background:Mozart/Oz} introduces the Mozart
programming system, which forms the basis of our implementation. Familiarity
with first- and second-order logic is assumed throughout; readers
requiring background on such material may find a gentle introduction
in \citep{kelly96logic} and a more detailed treatment in \citep{fitting96fol_book}.

While there are no new results presented in this chapter, it does
introduce some novel notation which will be needed later in the thesis.
It is introduced here to maintain consistency of the presentation.


\section{The Situation Calculus\label{sec:Background:The-Situation-Calculus}}

The situation calculus is a formalism for describing and reasoning
about dynamic worlds. It was first introduced by \citet{McCHay69sitcalc}
and has since been significantly expanded and formalised \citep{reiter91frameprob,pirri99contributions_sitcalc}.
We use the particular variant due to Reiter et. al. at the University
of Toronto, sometimes called the {}``Toronto school'' or {}``situations-as-histories''
version \citep{levesque98sc_foundations,pirri99contributions_sitcalc}.

A brief overview is presented below. Readers familiar with the situation
calculus should note our generalised characterisation of the background
theory $\Dt_{bg}$, our generalisation of the $Poss$ fluent to action
description predicates, and the parameterised {}``future situation''
predicate $s<_{\alpha}s'$.


\subsection{Notation\label{sec:Background:SC:Notation}}

The language $\mathcal{L}_{sitcalc}$ of the situation calculus is
a many-sorted language of first-order logic with equality, augmented
with a second-order induction axiom, containing the following disjoint
sorts:

\begin{itemize}
\item \emph{\noun{Action}} terms are functions denoting individual instantaneous
events that can cause the state of the world to change; 
\item \noun{Situation} terms are histories of the actions that have occurred
in the world, with the initial situation represented by $S_{0}$ and
successive situations built using the function $do\,:\, Action\times Situation\rightarrow Situation$; 
\item \noun{Object} terms represent any other object in the domain. 
\end{itemize}
\emph{Fluents} are predicates or functions that represent properties
of the world that may change between situations, and so take a situation
term as their final argument. Predicates and functions that do not
take a situation term are called \emph{rigid}. No functions other
than $S_{0}$ and $do$ take values of sort \noun{Situation.}

$\mathcal{L}_{sitcalc}$ contains the standard alphabet of logical
connectives, countably infinitely many variables of each sort, countably
infinitely many predicates of each arity, etc; for a complete definition,
consult the founational paper by \citet{pirri99contributions_sitcalc}.
We follow standard naming conventions for the situation calculus:
upper-case roman names indicate constants; lower-case roman names
indicate variables; greek names indicate meta-variables or formula
templates. All axioms universally close over their free variables
at outermost scope. The notation $\vars{t}$ indicates a vector of
terms of context-appropriate arity and type. The connectives $\wedge$,
$\neg$, $\exists$ are taken as primitive, with $\vee$, $\rightarrow$,
$\equiv$, $\forall$ defined in the usual manner.

In multi-agent domains it is customary to introduce the sort \noun{Agent
}as a sub-sort of \noun{Object} to explicitly represent the agents
operating in the world. The first argument of each action term gives
the performing agent.

\medskip{}


For concreteness, let us present some formulae from an example domain
that will be used throughout the thesis. In the {}``cooking agents''
domain, a group of robotic chefs inhabit a kitchen containing various
ingedianets and utensiles and must cooperate to prepare a meal. Some
example statements from this domain include {}``Ann is not holding
the knife initially'' and {}``Bob is holding the knife after he
picks it up''. Formally:\begin{gather*}
\neg Holding(Ann,Knife1,S_{0})\\
Holding(Bob,Knife1,do(pickup(Bob,Knife1),S_{0}))\end{gather*}


\medskip{}


Complex properties of the state of the world are represented using
\emph{uniform formulae}. These are basically logical combinations
of fluents referring to a common situation term. For the moment we
restrict ourselves to \emph{objective} uniform formulae; the complete
definition includes statements about knowledge and will be introduced
following that material.

\begin{defnL}
[{Uniform~Terms}] Let $s$ be a fixed situation term, $r$
an arbitrary rigid function symbol, $f$ an arbitrary fluent function
symbol, and $x$ a variable that is not of sort \noun{Situation}.
Then the terms uniform in $s$ are the smallest set of syntactically-valid
terms satisfying:\[
\tau\,::=s\,|\, x\,|\, r(\vars{\tau})\,|\, f(\vars{\tau},s)\]

\begin{defnL}
[{Objective~Uniform~Formulae}] Let $s$ be a fixed situation
term, $R$ an arbitrary rigid predicate, $F$ an arbitrary fluent
predicate, $\tau$ an arbitrary of term uniform in $s$, and $x$
an arbitrary variable that is not of sort \noun{Situation}. Then the
objective formulae uniform in $s$ are the smallest set of syntactically-valid
formulae satisfying:\[
\phi::=F(\vars{\tau},s)\,|\, R(\vars{\tau})\,|\,\tau_{1}=\tau_{2}\,|\,\phi_{1}\wedge\phi_{2}\,|\,\neg\phi\,|\,\exists x:\phi\]

\end{defnL}
\end{defnL}
The meta-variable $\phi$ is used throughout to refer to an arbitrary
uniform formula. Since they represent properties of the world, it
is often useful to evaluate uniform formulae at several different
situation terms. We will frequently suppress the situation term in
$\phi$ to simplify the presentation. The notation $\phi[s']$ represents
a uniform formula with the particular situation $s'$ inserted into
all its fluents, while $\phi^{-1}$ represents a uniform formula with
the situation argument removed from all its fluents. For example,
if $\phi=Holding(Ann,Knife,s)\wedge Holding(Bob,Bowl,s)$, then we
have:\begin{gather*}
\phi[s']\,=\, Holding(Ann,Knife,s')\wedge Holding(Bob,Bowl,s')\\
\phi^{-1}\,=\, Holding(Ann,Knife)\wedge Holding(Bob,Bowl)\end{gather*}


\newpage{}


\subsection{Axioms\label{sec:Background:SC:Axioms}}

The dynamics of a particular domain are captured by a set of sentences
from $\mathcal{L}_{sitcalc}$ called a \emph{basic action theory}.
Queries about the behaviour of the world are posed as logical entailment
queries relative to this theory.

\begin{defnL}
[{Basic~Action~Theory}] A basic action theory, denoted
$\Dt$, is a set of situation calculus sentences (of the specific
syntactic form outlined below) describing a particular dynamic world.
It consists of the following disjoint sets: the foundational axioms
of the situation calculus ($\Sigma$); action description axioms defining
preconditions etc for each action ($\Dt_{ad}$); successor state axioms
describing how primitive fluents change between situations ($\Dt_{ssa}$);
axioms describing the value of primitive fluents in the initial situation
($\Dt_{S_{0}}$); and axioms describing the static background facts
of the domain ($\Dt_{bg}$):\[
\Dt=\Sigma\cup\Dt_{ad}\cup\Dt_{ssa}\cup\Dt_{S_{0}}\cup\Dt_{bg}\]

\end{defnL}
These axioms must satisfy some simple consistency criteria to constitute
a valid domain description \citep{pirri99contributions_sitcalc}.
We assume an arbitrary, but fixed, basic action theory.

\medskip{}


The set $\Dt_{bg}$ characterises the static aspects of the domain,
and contains all axioms defining rigid predicates or functions. It
contains unique names axioms asserting that action terms with different
types or arguments are in fact different, e.g.:\begin{gather*}
pickup(agt,obj)\neq drop(agt,obj)\\
pickup(agt_{1},obj_{1})=pickup(agt_{2},obj_{2})\,\rightarrow\, agt_{1}=agt_{2}\,\wedge\, obj_{1}=obj_{2}\end{gather*}


It also contains domain closure axioms for the sorts \noun{Action,
Agent} and \noun{Object}, and defines the function $actor(a)$ to
give the agent performing an action.

\medskip{}


The set $\Dt_{ssa}$ contains one \emph{successor state axiom} for
each primitive fluent in the domain, providing a monotonic solution
to the frame problem for that fluent. These axioms have the following
general form: \[
F(\vars{x},do(a,s))\equiv\Phi_{F}^{+}(\vars{x},a,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},a,s)\]


Here $\Phi_{F}^{+}$ and $\Phi_{F}^{-}$ are formulae uniform in $s$.
This may be read as {}``$F$ is true after performing $a$ if $a$
made it true, or it was previously true and $a$ did not make it false''.
For example, the $Holding$ fluent may be specified using:\begin{multline*}
Holding(agt,obj,do(a,s))\,\equiv\, a=pickup(agt,obj)\\
\vee\, Holding(agt,obj,s)\wedge a\ne drop(agt,obj)\end{multline*}


\medskip{}


The set $\Dt_{ad}$ generalises the standard \emph{action precondition
axioms} \citep{pirri99contributions_sitcalc} to define fluents describing
various aspects of the performance of an action, which we call \emph{action
description predicates}. The predicate $Poss(a,s)$ is the canonical
example, indicating whether it is possible to perform an action in
a given situation. For example, it is only possible for an agent to
pickup an object if nobody is currently holding it:\[
Poss(pickup(agt,obj),s)\equiv\neg\exists agt_{2}:\, Holding(agt_{2},obj,s)\]
 $\Dt_{ad}$ contains one axiom of the form $Poss(A(\vars{x}),s)\equiv\Phi_{Poss}^{A}(\vars{x},s)$
for each type of action $A$. Any number of predicates and functions
can be defined in this way, and we will use the meta-variable $\alpha$
for an arbitrary action description predicate.

We assume that these definitions are finitely enumerable and well-founded,
allowing them to be expanded down to primitive fluents even when they
refer to an action variable. For example, we assume that $Poss(a,s)$
can be replaced by an enumeration over action types such as the following:\[
Poss(a,s)\equiv\,\, a=A_{1}(\vars{x}_{1})\wedge\Phi_{Poss}^{A_{1}}(\vars{x}_{1},s)\,\vee\,\dots\,\vee a=A_{n}(\vars{x}_{n})\wedge\Phi_{Poss}^{A_{n}}(\vars{x}_{n},s)\]


\medskip{}


The foundational axioms $\Sigma$ ensure that situations form a branching-time
account of the world state. There is a distinguished situation $S_{0}$
called the \emph{initial situation}. Situations in general form a
tree structure with the initial situation at the root and $do(a,s)$
constructing the successor situation resulting when the action $a$
is performed in $s$. All situations thus produced are distinct:\[
do(a_{1},s_{1})=do(a_{2},s_{2})\,\rightarrow\, a_{1}=a_{2}\,\wedge\, s_{1}=s_{2}\]


We abbreviate the performance of several successive actions by writing:\[
do([a_{1},\dots,a_{n}],s)\,\isdef\, do(a_{n},do(\dots,do(a_{1},s)))\]


The relation $s\sqsubset s'$ indicates that $s'$ is in the future
of $s$ and is defined as follows:\begin{gather*}
\neg(s\sqsubset S_{0})\\
s\sqsubset do(a,s')\equiv s\sqsubseteq s'\end{gather*}


Here $s\sqsubseteq s'$ is the standard abbreviation for $s\sqsubset s'\vee s=s'$.
There is also a second-order induction axiom asserting that all situations
must be constructed in this way, which is needed to prove statements
that universally quantify over situations:\[
\forall P:\,\left[P(S_{0})\wedge\forall s,a:\,\left(P(s)\rightarrow P(do(a,s))\right)\right]\,\rightarrow\,\forall s:\, P(s)\]


The notation for {}``in the future of'' can be extended to consider
only those futures in which all actions satisfy a particular action
description predicate. We include a relation $<_{\alpha}$ for each
action description predicate $\alpha$, with the following definitions:\begin{gather*}
\neg\left(s<_{\alpha}S_{0}\right)\\
s<_{\alpha}do(a,s')\equiv s\leq_{\alpha}s'\wedge\alpha(a,s')\end{gather*}


The \emph{legal situations} are those in which every action was possible
to perform in the preceding situation. These are of fundamental importance,
as they are the only situations that could be reached in the real
world. The \emph{root} of a situation is the initial situation from
which it was constructed:\begin{gather*}
root(S_{0})=s\\
root(do(c,s))=root(s)\\
Legal(s)\,\equiv\, root(s)\leq_{Poss}s\end{gather*}


\medskip{}


The set $\Dt_{S_{0}}$ describes the actual state of the world before
any actions are performed. It is a collection of sentences of the
form $\phi[S_{0}]$ stating what holds in the initial situation.\medskip{}



\subsection{Reasoning}

One of the attractions of the situation calculus is the existence
of effective reasoning procedures for certain types of query. These
are generally based on syntactic manipulation of a query into a form
that is more amenable to reasoning -- for example, because it can
be proven without using some of the axioms from $\Dt$.

In the general case, answering a query about a basic action theory
$\Dt$ is a theorem-proving task in second-order logic (denoted SOL)
due to the induction axiom included in the foundational axioms:\[
\Dt\models_{SOL}\psi\]
 This is clearly problematic for effective automated reasoning, but
fortunately there exist particular syntactic forms for which some
of the axioms in $\mathcal{D}$ are not required.

If a query existentially quantifies over situation terms, it can be
answered without the induction axiom (denote $I$) and thus using
only first-order logic (FOL) \citep{pirri99contributions_sitcalc}:\[
\Dt\models_{SOL}\exists s:\,\psi(s)\,\,\,\,\mathrm{iff}\,\,\,\,\Dt\models_{FOL}\exists s:\,\psi(s)\]


Even simpler are queries about the initial situation, which can be
answered using only first-order logic and a limited set of axioms:\[
\mathcal{D}\models_{SOL}\phi[S_{0}]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{bg}\models_{FOL}\phi[S_{0}]\]


Since the axioms $\Dt_{S_{0}}\cup\Dt_{bg}$ often satisfy the closed-world
assumption, provers such as Prolog can be employed to handle this
type of query quite effectively. Effective reasoning depends on transforming
queries into more easily-handled forms such as this. \\


TODO: more thorough explanation of regression, and relation to other
formulations (e.g. all-at-once regression)

The principle tool for effective reasoning in the situation calculus
is the regression meta-operator $\Reg_{\Dt}$ \citep{pirri99contributions_sitcalc},
a syntactic manipulation that can transform a formula uniform in $do(a,s)$
into an equivalent formula that is uniform in $s$:\[
\Dt\,\models\,\phi[do(a,s)]\equiv\Reg_{\Dt}(\phi[do(a,s)])[s]\]


Since $\Dt$ is fixed, we drop the subscript and simply write $\Reg$
for regression. Its operation is defined by a set of \emph{regression
rules} such as those shown below:\begin{align*}
\Reg(\phi_{1}\wedge\phi_{2})\isdef & \,\,\,\Reg(\phi_{1})\wedge\Reg(\phi_{2})\\
\Reg(Poss(a,s))\isdef & \,\,\,\bigvee\exists\vars{x}:\, a=A(\vars{x})\wedge\Reg(\Phi_{Poss}^{A}(\vars{x},s))\\
\Reg(F(\vars{x},do(a,s)))\isdef & \,\,\,\Phi_{F}^{+}(\vars{x},a,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},a,s)\end{align*}


Each application of the regression operator replaces action description
predicates with their definitions from $\Dt_{ad}$ and primitive fluents
with their successor state axioms from $\Dt_{ssa}$, {}``unwinding''
a single action from each situation term in the query.

Repeated applications of this operator, denoted by $\Reg^{*}$, can
transform a query about some future situation into a query about the
initial situation only, which is much easier to answer. The axioms
$\Dt_{ad}$ and $\Dt_{ssa}$ are essentially {}``compiled into''
the query. The trade-off is that the length of the regressed query
may be exponential in the length of $\phi$. While an efficiency gain
is not guaranteed, regression has proven a very effective technique
in practice \citep{levesque97golog,pirri99contributions_sitcalc}.

When dealing with situation-suppressed uniform formulae, we will use
a two-argument operator $\Reg(\phi,a)$ to indicate the regression
of $\phi$ over the action $a$. It should be read as a shorthand
for $\Reg(\phi[do(a,s)])^{-1}$ using the situation-suppression operator
from section \ref{sec:Background:SC:Notation}.

TODO: reasoning in the {}``fluent domain''

TODO: decidability: \citep{giacomo99impl_robots} \citep{levesque04krr_book}
\citep{yu07twovar_sitcalc}

TODO: restricted forms of axioms: local effect axioms, context-free
axioms


\subsection{TODO: Extensions}

\textbf{\emph{Time:}} An explicit notion of time can make coordination
between agents easier, as joint actions may be performed at a particular
time. It also allows a richer description of the world, for example
when stating the baking time of a cake.

The standard approach to time in the situation calculus is that of
\citep{reiter96sc_nat_conc,pinto94temporal}. Each action gains an
extra argument indicating the time at which is was performed. Time
itself can be represented by any appropriately-behaved sequence, such
as integers or reals, whose axiomatisation must be included in the
theory of action. The functions $time$ and $start$ are introduced
to give the performance time of an action and the start time of a
situation respectively. The start time of the initial situation may
be defined arbitrarily.

An additional predicate $Coherent$ is defined to ensure that the
performance time is the same for all members in a set of concurrent
actions. The $Poss$ fluent for concurrent actions can then be defined
to ensure that the temporal relation between past and future situations
is respected, as well as accounting for conflicting actions:\begin{multline*}
Poss(c,s)\equiv\forall a.\left[a\in c\rightarrow Poss(a,s)\right]\\
\wedge\,\neg Conflicts(c,s)\,\wedge\, time(c)>start(s)\,\wedge\, Coherent(c)\end{multline*}
 This representation is accompanied by a standard approach to actions
with a finite duration: they are decomposed into instantaneous $start$
and $end$ actions and a fluent indicating that the action is in progress.
For example, a long-running task may be represented by the actions
$beginTask$ and $endTask$ along with a fluent $doingTask$.

\textbf{\emph{Natural Actions:}} These are a special class of exogenous
actions, those actions which occur outside of an agent's control \citep{reiter96sc_nat_conc}.
They are classified according to the following requirement: natural
actions must occur at their predicted times, provided no earlier actions
prevent them from occurring. For example, a timer will ring at the
time it was set for, unless it is switched off. The action $endTask$
from above is another example - it must occur whenever it is possible,
which is at the time when the agent finishes the task. In domains
where many agents may be simultaneously engaged in many long-running
tasks, strong semantic support for natural actions will therefore
be of significant benefit.

Natural actions are indicated by the truth of the predicate $Natural(a)$.
The times at which natural actions may occur are specified by the
$Poss$ predicate as usual. For example, suppose that the fluent $TimerSet(m,s)$
represents the fact that a timer is set to ring in $m$ minutes in
situation $s$. The possibility predicate for the $ringTimer(t)$
action would be:\begin{multline*}
Poss(ringTimer(t),s)\equiv\\
\exists m.\left[TimerSet(m,s)\wedge t=start(s)+m\right]\end{multline*}
 The timer may thus ring only at its predicted time. To enforce the
requirement that natural actions \emph{must} occur whenever possible,
a predicate $Legal(s)$ is introduced which is true only for situations
that respect this requirement. Legal situations are the only situations
that could be brought about in the real world:\begin{multline*}
Legal(S_{0})\equiv True\\
\shoveleft{Legal(do(c,s))\equiv Legal(s)\wedge Poss(c,s)}\\
\wedge\,\forall a.\left[Natural(a)\wedge Poss(a,s)\rightarrow\left[a\in c\vee t<time(a)\right]\right]\end{multline*}
 An important concept when dealing with natural actions is the least
natural time point (LNTP) of a situation, defined as the earliest
time at which a natural action may occur. We assume that the theory
of action avoids certain pathological cases, so that absence of an
LNTP implies that no natural actions are possible.\begin{multline*}
Lntp(s,t)\equiv\\
\exists a.\left[Natural(a)\wedge Poss(a,s)\wedge time(a)=t\right]\wedge\\
\forall a.\left[Natural(a)\wedge Poss(a,s)\rightarrow t\leq time(a)\right]\end{multline*}


TODO: state constraints


\subsection{TODO: Applications}

Golog

Reasoning about multi-agent games \citep{delgrande01sitcalc_cleudo}

process specification language \citep{gruninger04psl}

Readylog \citep{Ferrein2005readylog}, AI for computer games \citep{jacobs05unrealgolog}

casl \citep{shapiro02casl,lesperance05ecasl}

web services composition \citep{mcilraith02golog_web_services}

That Golog is a viable alternative for specifying and implementing
agent behavior is highlighted by the many successful applications
of the technique in different planning tasks, such as \citep{Finzi00open_world_sitcalc},
\citep{pirri00planning_nat_acts}, and \citep{baier03golog_planning}.


\subsection{TODO: Related Formalisms}

There are a wide range of related formalisms for reasoning about knowledge,
action and change, which we do not directly consider in this paper.
We find the notation and meta-theory of the situation calculus particularly
suitable for expressing our main ideas. Moreover, the strong underlying
similarities between the major action formalisms should allow the
these ideas to transcend the specifics of the situation calculus \citet{thielscher06reconcile_sc_fc,thielscher07unifying_action_calculus,vanbentham07ml_sitcalc}.


\section{Golog\label{sec:Background:Golog}}

Golog \citet{levesque97golog} is a declarative agent programming
language based on the situation calculus. Testimony to its success
are its wide range of applications and many extensions to provide
additional functionality (\citet{giacomo00congolog,giacomo99indigolog,Ferrein2005readylog}).
We use {}``Golog'' to refer to the family of languages based on
this technique, including ConGolog \citet{giacomo00congolog} and
IndiGolog \citet{giacomo99indigolog}.

To program an agent using Golog one specifies a situation calculus
theory of action, and a program consisting of actions from the theory
connected by programming constructs such as if-then-else, while loops,
and nondeterministic choice. Table \ref{tbl:Golog-Operators} lists
some of the operators available in various incarnations of the language.%
\begin{table}
\begin{centering}
\begin{tabular}{|c|c|}
\hline 
Operator  & Meaning\tabularnewline
\hline
\hline 
$a$  & Execute action $a$ in the world\tabularnewline
\hline 
$\phi?$  & Proceed if condition $\phi$ is true\tabularnewline
\hline 
$\delta_{1};\delta_{2}$  & Execute $\delta_{1}$followed by $\delta_{2}$\tabularnewline
\hline 
$\delta_{1}|\delta_{2}$  & Execute either $\delta_{1}$ or $\delta_{2}$\tabularnewline
\hline 
$\pi(x)\delta(x)$  & Nondet. select arguments for $\delta$\tabularnewline
\hline 
$\delta*$  & Execute $\delta$ zero or more times\tabularnewline
\hline 
$\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$  & Exec. $\delta_{1}$ if $\phi$ holds, $\delta_{2}$ otherwise\tabularnewline
\hline 
$\mathbf{while\,}\phi\mathbf{\, do}\,\delta$  & Execute $\delta$ while $\phi$ holds\tabularnewline
\hline 
$\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$  & Procedure definition\tabularnewline
\hline 
$\delta_{1}||\delta_{2}$  & Concurrent execution (ConGolog)\tabularnewline
\hline 
$\Sigma\delta$  & Plan execution offline (IndiGolog)\tabularnewline
\hline
\end{tabular}
\par\end{centering}

\caption{ Some Golog Operators\label{tbl:Background:Golog-Operators} }

\end{table}


In line with the idea of high-level program execution, the agent's
control program may be nondeterministic. It is the task of the agent
to plan a deterministic instantiation of the program, a sequence of
actions that can legally be performed in the world. Such a sequence
is called a \emph{legal execution} of the Golog program.

Two predicates $Trans$ and $Final$ define the semantics for each
operator. $Trans(\delta,s,\delta',s')$ holds when executing a step
of program $\delta$ can cause the world to move from situation $s$
to situation $s'$, after which $\delta'$ remains to be executed.
It thus characterises single steps of computation. $Final(\delta,s)$
holds when program $\delta$ may legally terminate its execution in
situation $s$. We base our work on the semantics of IndiGolog, which
builds on ConGolog and is the most feature-full of the standard Golog
variants. The full semantics are available in the references, but
as an example consider equation (\ref{eqn:trans_conc_orig}), which
specifies the concurrent-execution operator as an \emph{interleaving}
of computation steps. It states that it is possible to single-step
the concurrent execution of $\delta_{1}$ and $\delta_{2}$ by performing
either a step from $\delta_{1}$ or a step from $\delta_{2}$, with
the remainder $\gamma$ left to execute concurrently with the other
program:\begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\\
\shoveright{\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\vee\,\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\label{eqn:Background:trans_conc_orig}\end{multline}
 Clearly there are two notions of concurrency to be considered: the
possibility of performing several actions at the same instant (\emph{true
concurrency}), and the possibility of interleaving the execution of
several programs (\emph{interleaved concurrency}). These were combined
in \citet{pinto99tcongolog} by modifying Golog to incorporate sets
of concurrent actions. However, they give a semantics which may call
for actions to be performed that are not possible and which can result
in unintuitive program behaviour. A key aspect of our work is a more
robust integration of these two notions of concurrency.

If the theory of action $\mathcal{D}$ is enriched with $Trans$ and
$Final$, planning an execution of a Golog program $\delta$ is basically
a theorem proving task as shown in equation (\ref{eqn:golog_execution}).
Here $Trans*$ indicates reflexive transitive closure. The situation
$s$ gives a sequence of actions forming a legal execution of the
program.\begin{equation}
\mathcal{D}\models\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]\label{eqn:Background:golog_execution}\end{equation}
 In IndiGolog agents can also proceed without planning a full terminating
execution of their program, by searching for a legal {}``next step''
action $a$ such that $\mathcal{D}\models\exists a\,.\, Trans*(\delta,s,\delta',do(a,s))$.
The search operator ($\Sigma$) controls which parts of the program
are subject to full execution planning, providing fine-grained control
over nondeterminism and the amount of planning work required.

As an example of a multi-agent task specification in Golog, consider
a program $MakeSalad$ that instructs a team of agents to prepare
a simple salad:\begin{multline}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right]\,\,\mathbf{end}\label{eqn:Background:MakeSalad}\end{multline}
 The sub-procedure $ChopTypeInto$ (not shown) picks an object of
the given type and an available chopping board, chops the object using
the board, then transfers it into the destination container. $MakeSalad$
tells the agents to do this for a lettuce, a carrot and a tomato,
then mix the ingredients together for 1 minute. Note the nondeterminism
in this program - the agent assigned to handling each ingredient is
not specified ($\pi$ construct), nor is the order in which they should
be added ($||$ construct). There is thus considerable scope for cooperation
between agents to effectively carry out this task.

While this is a valid program in standard IndiGolog, executing it
using the existing semantics would be far from ideal. The explicit
temporal component described above must to added to IndiGolog to accommodate
the $mix(dest,1)$ task. The lack of true concurrency would mean only
one agent could act at a time, while others would remain idle. And
since there is no support for natural actions, IndiGolog would fail
to find a legal execution of this program: it would find that the
final action $release$ cannot be performed after doing $beginTask$,
as our theory of action ensures agents can only be doing one thing
at a time. But it would not determine that the natural action $endTask$
will occur after one minute and enable to program to finish.

TODO: other Gologs: (DTGolog, HTNGolog, GTGolog). highlight rich cross-pollination,
hope to be a part of it


\section{Epistemic Reasoning\label{sec:Background:Epistemic-Reasoning}}

TODO: general intro to epistemic reasoning \citet{halpern90knowledge_distrib,fagin95}

Epistemic reasoning was first introduced to the situation calculus
by \citet{moore80know_act}, and formalised extensively by \citet{scherl03sc_knowledge}
whose paper is now the canonical reference for these techniques. Their
work has been extended to include concurrent actions \citet{scherl03conc_knowledge}
and multiple agents \citet{shapiro98specifying_ma_systems}. We further
extend this family of techniques in this paper.

The semantics of knowledge are based on a reification of the {}``possible
worlds'' semantics of modal logic, using situation terms rather than
abstract worlds. A special fluent $K(agt,s',s)$ is used to indicate
that {}``in situation $s$, the agent $agt$ considers the alternate
situation $s'$ to be possible''. The macro $\Knows$ is then defined
as a shorthand for the standard possible-worlds definition of knowledge,
stating that an agent knows $\phi$ when $\phi$ is true in all situations
considered possible: \begin{equation}
\Knows(agt,\phi,s)\isdef\forall s':\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:Background:knows_def}\end{equation}


Readers familiar with modal logic will recognise $K(agt,s',s)$ as
the situation calculus analogue of the modal reachability relation
$K_{agt}$, and the macro $\Knows(agt,\phi,s)$ as the equivalent
of the modal box operator $[K_{agt}]\phi$.

The foundational axioms $\Sigma$ define a special fluent $K_{0}(agt,s',s)$
that is used to model the initial epistemic uncertainty of the agents,
with $\Dt_{S_{0}}$ containing sentences of the form $\KnowsZ(agt,\phi,S_{0})$
to specify what is initially known%
\footnote{The standard account does not require a separate $K_{0}$ fluent,
as evidenced by equation \eqref{eq:k_s0_standard}. It is required
when incorporating hidden actions, so we introduce it now to maintain
consistency. %
}:\begin{gather*}
K_{0}(agt,s',s)\,\rightarrow Init(s)\wedge Init(s')\\
\KnowsZ(agt,\phi,s)\isdef\forall s':\, K_{0}(agt,s',s')\rightarrow\phi[s']\end{gather*}


The action description function $SR(a,s)$ specifies the sensing result
returned by action $a$ when executed in situation $s$. For non-sensing
actions the value of $SR$ is set to an arbitrary constant.

The dynamics of knowledge are then specified by an additional set
of axioms, which we will denote $\Dt_{K}$. In the standard account
of knowledge $\Dt_{K}$ contains the following axioms:\begin{equation}
Init(s)\rightarrow\left(K(agt,s',s)\,\equiv\, K_{0}(agt,s',s)\right)\label{eq:k_s0_standard}\end{equation}
 \begin{align}
K(agt,s'',do(c,s))\equiv\exists s': & \, s''=do(c,s')\,\wedge K(agt,s',s)\wedge Poss(c,s')\nonumber \\
 & \wedge\,\forall a\in c:\,\left(actor(a)=agt\,\rightarrow\, SR(a,s)=SR(a,s')\right)\label{eq:k_ssa_standard}\end{align}


Equation \eqref{eq:k_s0_standard} ensures that the agents begin with
their knowledge as specified by $\Dt_{S_{0}}$. Equation \eqref{eq:k_ssa_standard}
takes the form of a standard successor state axiom for the $K$ fluent.
It ensures that $s''$ is considered a possible alternative to $do(c,s)$
when $s''$ is the result of doing the same actions $c$ in a situation
$s'$ that is considered a possible alternative to $s$. It must furthermore
have been possible to perform those actions in $s'$, and the sensing
results must match for each action that was carried out by the agent
in question. Thus an agent's knowledge after the occurrence of an
action is completely determined by the combination of its knowledge
before the action, and the sensing results from the action.

\medskip{}


\begin{defn}
We will denote by $\Dt_{K}^{std}$ the axioms of the standard account
of knowledge due to \citet{scherl03sc_knowledge}, as detailed in
equations (\ref{eq:k_s0_standard},\ref{eq:k_ssa_standard}) above. 
\end{defn}
We can now present the complete definition of a uniform formula, which
may include both action description predicates%
\footnote{This differs from the standard definition, which does not permit action
description predicates \citet{pirri99contributions_sitcalc}. We include
them to simplify notation throughout the paper. This is purely a cosmetic
change, since we assume that action description predicates can always
be expanded into a finite combination of primitive fluents.%
} and knowledge expressions.

\begin{defnL}
[{Uniform~Formulae}] Let $s$ be a fixed situation term,
$F$ a primitive fluent, $\alpha$ an action description predicate,
$\vars{x}$ a vector of terms mentioning no situation term other than
$s$, and $y$ a variable that is not of sort \noun{Situation}. Then
the formulae uniform in $s$ are the smallest set of syntactically-valid
formulae satisfying:\[
\phi::=F(\vars{x},s)\,|\,\alpha(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists y:\phi\,|\,\forall y:\phi\,|\,\Knows(agt,\phi,s)\]

\end{defnL}
While powerful, this knowledge-representation formalism has an important
limitation: it is fundamentally \emph{synchronous.} Each agent is
assumed to have full knowledge of all actions that have occurred -
in other words, all actions are public. While suitable for some domains,
there are clearly many multi-agent domains where achieving total awareness
of actions would be infeasible. A major contribution of this paper
is a more flexible formalism for knowledge that can be applied to
a much wider range of domains.

A key contribution of \citet{scherl03sc_knowledge} was showing how
to apply the regression operator to formulae containing the $\mathbf{Knows}$
macro, allowing it to be treated syntactically as if it were a primitive
fluent. This means that epistemic queries can be approached using
standard reasoning techniques of the situation calculus. Although
we have changed the notation somewhat to foreshadow the techniques
we will develop in Section \ref{sec:Obs-Knowledge}, their definition
operates as follows. First, define the \emph{results} of a concurrent
action to be the set of $action\#result$ pairs for all primitive
actions perform by the agent in question:\[
\mathbf{res}(agt,c,s)\isdef\{a\#SR(a,s)\,\,|\,\, a\in c\,\wedge\, actor(a)=agt\}\]


This definition is then used to formulate a regression rule as follows:\begin{multline}
\Reg(\Knows(agt,\phi,do(c,s))\isdef\\
\exists y:\, y=\mathbf{res}(agt,c,s)\,\wedge\Knows(agt,\left[Poss(c)\wedge\mathbf{res}(agt,c)=y\right]\rightarrow\Reg(\phi[do(c,s)]),s)\label{eq:reg_k_std}\end{multline}


This works by collecting the sensing results from each action performed
by the agent into the set $y$, then ensuring matching sensing results
in every situation considered possible. It expresses the knowledge
of the agent after a concurrent action in terms of what it knew before
the action, along with the information returned by the action. This
technique relies heavily on the fact that all actions are public,
since it requires every agent's knowledge to be updated in response
to every action.

Repeated applications of $\Reg$ can thus transform a knowledge query
into one that is uniform in the initial situation. While it would
be valid to then expand the $\Knows$ macros and handle the query
using first-order logic, in practice the reasoning procedure would
leave $\Knows$ intact and use a specialised prover based on modal
logic.

It is possible to formulate an alternate successor state axiom for
knowledge that does not assume all actions are public, such as that
of \citet{Lesperance99sitcalc_approach}. Such formulations invariably
require universal quantification over situation terms, to account
for arbitrarily-long sequences of hidden actions. This is incompatible
with regression rules like the above, and these formulations offer
no reasoning procedure other than general second-order theorem proving.
By utilising a new reasoning technique called the {}``persistence
condition'' to reason about universal quantification over situation
terms, our work is the first to provide an account of knowledge with
hidden actions while maintaining regression in the style presented
above as an effective reasoning tool.

TODO: shortcomings of multi-agent extensions, decidability/weakening
\citet{demolombe00tractable_sc_belief} \citet{petrick02knowledge_equivalence}

TODO: group-level knowledge, important of common knowledge, inability
to do regression

TODO: epistemic feasibility of plans? \citet{giacomo04sem_delib_indigolog,Lesperance01epi_feas_casl}


\section{Mozart/Oz\label{sec:Background:Mozart/Oz}}

The Mozart system \citep{vanroy99mozart} is an implementation of
the Oz programming language \citep{vanRoyHaridi04ctm} with strong
support for logic programming and distributed computing. While a full
explanation of its features is well outside the scope of this thesis,
we provide a gentle introduction to the subset of its features we
will be using -- in particular, doing prolog-style logic programming
in Oz. Familiarity with logic programming in the style of prolog is
assumed.

While terms, variables and unification in Mozart work similarly to
prolog, the syntax for defining predicates differs substantially.
Predicates are implemented as ordinary procedures and cannot be defined
as a set of indepedent clauses. Figure {[}TODO] shows a Mozart implementation
of a classic prolog example predicate, naive list reverse.%
\begin{figure}[t]
 \programinput{listings/background/Reverse.oz}

\caption{Naive List Reverse implemented in Mozart/Oz}

\end{figure}


Some things to note about this example:

\begin{itemize}
\item The syntax for procedure definition is $\mathbf{proc}\,\{\, Name\, Arg\,\dots\,\}$ 
\item The syntax for procedure calls is $\{\, Name\, Arg\,\dots\,\}$ 
\item The $\mathbf{case}$ statement is used to pattern match the contents
of a variable 
\item Local variables must be explicitly introduced using the keyword $\mathbf{in}$ 
\item Mozart separates functionality into distinct \emph{modules}, such
as the $List$ module used in this example 
\end{itemize}
Procedures in Mozart are deterministic by default, and there is no
in-built search strategy for exploring different alternatives. Instead,
Mozart provides independent facilities for creating choicepoints and
for exploring procedures that contain choicepoints. The resul tis
a much more flexible, although syntactically more cumbersome, approach
to logic programming \citep{lpinoz99}.

The creation of choice points is explicit in Mozart, and performed
using the $\mathbf{choice}$ keyword. To demonstrate, consider another
classic prolog example, the nondeterministic list member predicate..

%
\begin{figure}[t]
 \programinput{listings/background/Member.oz}

\caption{Nondeterministic List Member implemented in Mozart/Oz}

\end{figure}


TODO:

\begin{itemize}
\item Distributed Logi Programming: Parallel Search \citet{schulte00oz_parallel} 
\item include some simple example programs 
\end{itemize}
