


\chapter{Background}

\label{ch:background}

This chapter covers the necessary background material for the thesis.
We begin by introducing the base language of the situation calculus
in section \ref{sec:Background:The-Situation-Calculus}, along with
the {}``cooking agents'' example domain which will be used throughout
the thesis. Section \ref{sec:Background:Golog} introduces the Golog
family of programming languages, which are the standard formalism
for representing complex tasks in the situation calculus. Reasoning
about knowledge is covered in section \ref{sec:Background:Epistemic-Reasoning},
including a discussion of several limitations of the traditional situation
calculus approach. Finally, section \ref{sec:Background:Mozart/Oz}
introduces the Mozart programming system, which forms the basis of
our implementation.

While there are no new results presented in this chapter, it does
introduce several novel pieces of notation which will be needed later
in the thesis. They are introduced here to maintain consistency of
the presentation.


\section{The Situation Calculus\label{sec:Background:The-Situation-Calculus}}

The situation calculus is a formalism for describing and reasoning
about dynamic worlds. It was first introduced by \citet{McCHay69sitcalc}
and has since been significantly expanded and formalised \citep{reiter91frameprob,pirri99contributions_sitcalc}.
We use the particular variant due to Reiter et. al. at the University
of Toronto, sometimes called the {}``Toronto school'' or {}``situations-as-histories''
version \citep{levesque98sc_foundations}, with time and concurrent
actions as per \citep{reiter96sc_nat_conc}.

A brief overview is presented below. Readers familiar with the situation
calculus should note our generalisation of the $Poss$ fluent to action
description predicates.


\subsection{Notation and Axioms\label{sub:Notation-and-Axioms}}

The situation calculus is a many-sorted language of first-order logic
augmented with a second-order induction axiom. Its has the following
sorts: \noun{Agent} terms represent the agents operating in the world;
\emph{\noun{Action}} terms are functions denoting individual instantaneous
events that can cause the state of the world to change, with the initiating
agent indicated by their first argument; \noun{Concurrent} terms are
sets of actions that occur simultaneously; \noun{Situation} terms
are histories of the actions that have occurred in the world, with
the initial situation represented by $S_{0}$ and successive situations
built using the function $do\,:\, Concurrent\times Situation\rightarrow Situation$;
\noun{Object} terms represent any other object in the domain. \emph{Fluents}
are predicates or functions that represent properties of the world
that may change between situations; they take a situation term as
their final argument.

Throughout the thesis we will present examples from a simple multi-agent
domain, in which a group of robotic chefs must cooperate to prepare
a meal. Some example statements from this domain include {}``Ann
is not holding the knife initially'' and {}``Bob is holding the
knife after he picks it up''. Formally:\begin{gather*}
\neg Holding(Ann,Knife1,S_{0})\\
Holding(Bob,Knife1,do(pickup(Bob,Knife1),S_{0}))\end{gather*}


The dynamics of a particular domain are captured by a set of sentences
called a \emph{basic action theory}. Queries about the behaviour of
the world are posed as logical entailment queries relative to this
theory.

\begin{defnL}
[{{[}{Basic~Action~Theory}]}] A basic action theory, denoted
$\Dt$, is a set of situation calculus sentences (of the specific
syntactic form outlined below) describing a particular dynamic world.
It consists of the following disjoint sets: the foundational axioms
of the situation calculus ($\Sigma$); unique names axioms for actions
($\Dt_{una}$); action description axioms defining preconditions etc
for each action ($\Dt_{ad}$); successor state axioms describing how
primitive fluents change between situations ($\Dt_{ssa}$); and axioms
describing the value of primitive fluents in the initial situation
($\Dt_{S_{0}}$):\[
\Dt=\Sigma\cup\Dt_{una}\cup\Dt_{ad}\cup\Dt_{ssa}\cup\Dt_{S_{0}}\]

\end{defnL}
These axioms must satisfy some simple consistency criteria to constitute
a valid domain description \citet{pirri99contributions_sitcalc}.
We assume an arbitrary, but fixed, basic action theory.

The \emph{uniform formulae} can be thought of as properties of the
state of the world. They are basically logical combinations of fluents
referring to a common situation term. For the moment we restrict ourselves
to \emph{objective} uniform formulae; the complete definition includes
statements about knowledge and will be introduced following that material.

\begin{defnL}
[{{[}{Objective~Uniform~Formulae}]}] Let $s$ be a fixed situation
term, $F$ an arbitrary fluent, $\vars{x}$ a vector of terms mentioning
no situation term other than $s$, and $y$ a variable that is not
of sort \noun{Situation}. Then the objective formulae uniform in $s$
are the smallest set of syntactically-valid formulae satisfying:\[
\phi::=F(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists y:\phi\,|\,\forall y:\phi\]

\end{defnL}
The meta-variable $\phi$ is used throughout this paper to refer to
an arbitrary uniform formula. Since they represent properties of the
world, it is often useful to evaluate uniform formulae at several
different situation terms. We will frequently suppress the situation
term in $\phi$ to simplify the presentation. The notation $\phi[s']$
represents a uniform formula with the particular situation $s'$ inserted
into all its fluents, while $\phi^{-1}$ represents a uniform formula
with the situation argument removed from all its fluents.

\medskip{}


The set $\Dt_{una}$ restricts action terms to a finite number of
action types, and ensures that actions with different types or different
arguments are in fact different. The function $actor(a)$ gives the
agent performing an action, which is always the action's first argument.

\medskip{}


The set $\Dt_{ssa}$ contains one \emph{successor state axiom} for
each primitive fluent in the domain, providing a monotonic solution
to the frame problem for that fluent. These axioms have the following
general form%
\footnote{We follow standard naming conventions for the situation calculus:
lower-case roman names indicate variables, and free variables are
implicitly universally quantified at the outermost scope%
}: \[
F(\vars{x},do(c,s))\equiv\Phi_{F}^{+}(\vars{x},c,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},c,s)\]


Here $\Phi_{F}^{+}$ and $\Phi_{F}^{-}$ are formulae uniform in $s$.
This may be read as {}``$F$ is true after performing $c$ if $c$
made it true, or it was previously true and $c$ did not make it false''.

\medskip{}


The set $\Dt_{ad}$ generalises the standard \emph{action precondition
axioms} \citet{pirri99contributions_sitcalc} to define fluents describing
various aspects of the performance of an action, which we call \emph{action
description predicates}. The predicate $Poss(a,s)$ is the canonical
example, indicating whether it is possible to perform an action in
a given situation. For example, it is only possible for an agent to
leave the room if they are actually in it:\[
Poss(leave(agt),s)\equiv InRoom(agt,s)\]
 $\Dt_{ad}$ contains one axiom of the form $Poss(A(\vars{x}),s)\equiv\Phi_{Poss}^{A}(\vars{x},s)$
for each type of action $A$. These are combined into a generalised
$Poss$ axiom for sets of concurrent actions, which in its simplest
form is just:\[
Poss(c,s)\equiv c\neq\{\}\,\wedge\,\forall a\in c:\, Poss(a,s)\]
 Note that it is never possible to perform an empty set of actions.
In more complex domains actions may interact, so that they cannot
be performed concurrently even if possible individually. We assume
that $\Dt_{ad}$ contains an appropriate axiomatisation of such interaction;
\citet{pinto94temporal} provides a full discussion of this issue;

In principle any number of predicates and functions can be defined
in this way, and we will use the meta-variable $\alpha$ to represent
an arbitrary action description predicate. Forthcoming examples include
the sensing-result function $SR(a,s)$ of Section \ref{sub:Knowledge-and-Sensing}
and the observability predicate $CanObs(agt,a,s)$ of Section \ref{sub:Knowledge-and-Observation}.

We assume that these definitions are finitely enumerable and well-founded,
allowing them to be expanded down to primitive fluents even when they
refer to an action variable. For example, we assume that $Poss(a,s)$
can be replaced by an enumeration over action types such as the following:\[
Poss(a,s)\equiv\,\, a=A_{1}(\vars{x}_{1})\wedge\Phi_{Poss}^{A_{1}}(\vars{x}_{1},s)\,\vee\,\dots\,\vee a=A_{n}(\vars{x}_{n})\wedge\Phi_{Poss}^{A_{n}}(\vars{x}_{n},s)\]


\medskip{}


The foundational axioms $\Sigma$ ensure that situations form a branching-time
account of the world state. There are initial situations identified
by the predicate $Init(s)$, and a distinguished initial situation
$S_{0}$ called the \emph{actual} initial situation. Other initial
situations are used to represent the agents' epistemic uncertainty,
and will be discussed in the following section. Situations in general
form a tree structure with an initial situation at the root and $do(c,s)$
constructing the successor situation resulting when the actions $c$
are performed in $s$. We abbreviate the performance of several successive
actions by writing:\[
do([c_{1},\dots,c_{n}],s)\,\isdef\, do(c_{n},do(\dots,do(c_{1},s)))\]


The relation $s\sqsubset s'$ indicates that $s'$ is in the future
of $s$ and is defined as follows:\begin{gather*}
Init(s)\,\rightarrow\,\neg(s'\sqsubset s)\\
s\sqsubset do(c,s')\equiv s\sqsubseteq s'\end{gather*}


Here $s\sqsubseteq s'$ is the standard abbreviation for $s\sqsubset s'\vee s=s'$.
There is also a second-order induction axiom asserting that all situations
must be constructed in this way, which is needed to prove statements
that universally quantify over situations

This notation for {}``in the future of'' can be extended to consider
only those futures in which all actions satisfy a particular action
description predicate. We include a relation $<_{\alpha}$ for each
action description predicate $\alpha$, with the following definitions:\begin{gather*}
Init(s)\,\rightarrow\,\neg\left(s'<_{\alpha}s\right)\\
s<_{\alpha}do(c,s')\equiv s\leq_{\alpha}s'\wedge\alpha(c,s')\end{gather*}


The \emph{legal situations} are those in which every action was possible
to perform in the preceding situation. These are of fundamental importance,
as they are the only situations that could be reached in the real
world. The \emph{root} of a situation is the initial situation from
which it was constructed:\begin{gather*}
Init(s)\,\rightarrow\, root(s)=s\\
root(do(c,s))=root(s)\\
Legal(s)\,\equiv\, root(s)\leq_{Poss}s\end{gather*}


The set $\Dt_{S_{0}}$ describes the actual state of the world before
any actions are performed. It is a collection of sentences of the
form $\phi[S_{0}]$ stating what holds in the actual initial situation.
It also defines the initial knowledge of each agent, as described
in the next section.


\subsection{Reasoning and Regression}

One of the attractions of the situation calculus is the existence
of effective reasoning procedures for certain types of query. These
are generally based on syntactic manipulation of a query into a form
that is more amenable to reasoning -- for example, because it can
be proven without using some of the axioms from $\Dt$.

In the general case, answering a query about a basic action theory
$\Dt$ is a theorem-proving task in second-order logic (denoted SOL)
due to the induction axiom included in the foundational axioms. This
is clearly problematic for effective automated reasoning, but fortunately
there exist particular syntactic forms for which some of the axioms
in $\mathcal{D}$ are not required \citet{pirri99contributions_sitcalc}.
In particular, queries about the initial situation can be answered
using only first-order logic (FOL) and a limited set of axioms:\[
\mathcal{D}\models_{SOL}\phi[S_{0}]\,\,\,\,\,\mathit{\mathrm{iff}}\,\,\,\,\,\Dt_{S_{0}}\cup\Dt_{una}\models_{FOL}\phi[S_{0}]\]


Since the axioms $\Dt_{S_{0}}\cup\Dt_{una}$ often satisfy the closed-world
assumption, provers such as Prolog can be employed to handle this
type of query quite effectively. Effective reasoning depends on transforming
queries into more easily-handled forms such as this. \\


The principle tool for effective reasoning in the situation calculus
is the regression meta-operator $\Reg_{\Dt}$ \citet{pirri99contributions_sitcalc},
a syntactic manipulation that can transform a formula uniform in $do(c,s)$
into an equivalent formula that is uniform in $s$:\[
\Dt\,\models\,\phi[do(c,s)]\equiv\Reg_{\Dt}(\phi[do(c,s)])[s]\]


Since $\Dt$ is fixed, we drop the subscript and simply write $\Reg$
for regression. Its operation is defined by a set of \emph{regression
rules} such as those shown below:\begin{align*}
\Reg(\phi_{1}\wedge\phi_{2})\isdef & \,\,\,\Reg(\phi_{1})\wedge\Reg(\phi_{2})\\
\Reg(Poss(a,s))\isdef & \,\,\, a=A{}_{1}(\vars{x}_{1})\wedge\Reg(\Phi_{Poss}^{A_{1}}(\vars{x}_{1},s))\,\vee\,\dots\,\vee\, a=A_{n}(\vars{x}_{n})\wedge\Reg(\Phi_{Poss}^{A_{n}}(\vars{x}_{n},s))\\
\Reg(F(\vars{x},do(c,s)))\isdef & \,\,\,\Phi_{F}^{+}(\vars{x},c,s)\,\,\vee\,\, F(\vars{x},s)\wedge\neg\Phi_{F}^{-}(\vars{x},c,s)\end{align*}


Each application of the regression operator replaces action description
predicates with their definitions from $\Dt_{ad}$ and primitive fluents
with their successor state axioms from $\Dt_{ssa}$, {}``unwinding''
a single action from each situation term in the query.

Repeated applications of this operator, denoted by $\Reg^{*}$, can
transform a query about some future situation into a query about the
initial situation only, which is much easier to answer. The axioms
$\Dt_{ad}$ and $\Dt_{ssa}$ are essentially {}``compiled into''
the query. The trade-off is that the length of the regressed query
may be exponential in the length of $\phi$. While an efficiency gain
is not guaranteed, regression has proven a very effective technique
in practice \citet{levesque97golog,pirri99contributions_sitcalc}.

When dealing with situation-suppressed uniform formulae, we will use
a two-argument operator $\Reg(\phi,c)$ to indicate the regression
of $\phi$ over the action $c$. It should be read as a shorthand
for $\Reg(\phi[do(c,s)])^{-1}$ using the situation-suppression operator
from Section \ref{sub:Notation-and-Axioms}.

TODO

\begin{itemize}
\item Careful qualification of what we mean by \char`\"{}Effective\char`\"{} 
\item Review basics of reasoning in more detail, esp. regression. 
\item SitCalc as a re-writing system 
\item reasoning in the \char`\"{}fluent domain\char`\"{}: \[
\mathcal{D}_{una}\models\forall s.\phi(\bar{x},s)\,\,\,\,\,\, iff\,\,\,\,\,\,\mathcal{D}_{una}\models\phi(\bar{x})\]

\item using typing of functions to guarantee a finite herbrand universe
(\citet{levesque04krr_book}, pp69) and therefore decidability 
\end{itemize}
Sentences that contain only existential quantification over situation
terms can be proven without the induction axiom and so are more amenable
to automated reasoning \citep{pirri99contributions_sitcalc}. It is
therefore important for systems built on a situation calculus theory
of action to limit queries to existential form. Much of the work on
implementing systems with the situation calculus has been on reducing
the number of axioms required to answer a given query, to allow more
efficient reasoning.


\subsection{TODO}

\textbf{\emph{Time:}} An explicit notion of time can make coordination
between agents easier, as joint actions may be performed at a particular
time. It also allows a richer description of the world, for example
when stating the baking time of a cake.

The standard approach to time in the situation calculus is that of
\citet{reiter96sc_nat_conc,pinto94temporal}. Each action gains an
extra argument indicating the time at which is was performed. Time
itself can be represented by any appropriately-behaved sequence, such
as integers or reals, whose axiomatisation must be included in the
theory of action. The functions $time$ and $start$ are introduced
to give the performance time of an action and the start time of a
situation respectively. The start time of the initial situation may
be defined arbitrarily.

An additional predicate $Coherent$ is defined to ensure that the
performance time is the same for all members in a set of concurrent
actions. The $Poss$ fluent for concurrent actions can then be defined
to ensure that the temporal relation between past and future situations
is respected, as well as accounting for conflicting actions%
\footnote{As usual, lower-case terms are variables and free variables are implicitly
universally quantified%
}:\begin{multline*}
Poss(c,s)\equiv\forall a.\left[a\in c\rightarrow Poss(a,s)\right]\\
\wedge\,\neg Conflicts(c,s)\,\wedge\, time(c)>start(s)\,\wedge\, Coherent(c)\end{multline*}
 This representation is accompanied by a standard approach to actions
with a finite duration: they are decomposed into instantaneous $start$
and $end$ actions and a fluent indicating that the action is in progress.
For example, a long-running task may be represented by the actions
$beginTask$ and $endTask$ along with a fluent $doingTask$.

\textbf{\emph{Natural Actions:}} These are a special class of exogenous
actions, those actions which occur outside of an agent's control \citet{reiter96sc_nat_conc}.
They are classified according to the following requirement: natural
actions must occur at their predicted times, provided no earlier actions
prevent them from occurring. For example, a timer will ring at the
time it was set for, unless it is switched off. The action $endTask$
from above is another example - it must occur whenever it is possible,
which is at the time when the agent finishes the task. In domains
where many agents may be simultaneously engaged in many long-running
tasks, strong semantic support for natural actions will therefore
be of significant benefit.

Natural actions are indicated by the truth of the predicate $Natural(a)$.
The times at which natural actions may occur are specified by the
$Poss$ predicate as usual. For example, suppose that the fluent $TimerSet(m,s)$
represents the fact that a timer is set to ring in $m$ minutes in
situation $s$. The possibility predicate for the $ringTimer(t)$
action would be:\begin{multline*}
Poss(ringTimer(t),s)\equiv\\
\exists m.\left[TimerSet(m,s)\wedge t=start(s)+m\right]\end{multline*}
 The timer may thus ring only at its predicted time. To enforce the
requirement that natural actions \emph{must} occur whenever possible,
a predicate $Legal(s)$ is introduced which is true only for situations
that respect this requirement. Legal situations are the only situations
that could be brought about in the real world:\begin{multline*}
Legal(S_{0})\equiv True\\
\shoveleft{Legal(do(c,s))\equiv Legal(s)\wedge Poss(c,s)}\\
\wedge\,\forall a.\left[Natural(a)\wedge Poss(a,s)\rightarrow\left[a\in c\vee t<time(a)\right]\right]\end{multline*}
 An important concept when dealing with natural actions is the least
natural time point (LNTP) of a situation, defined as the earliest
time at which a natural action may occur. We assume that the theory
of action avoids certain pathological cases, so that absence of an
LNTP implies that no natural actions are possible.\begin{multline*}
Lntp(s,t)\equiv\\
\exists a.\left[Natural(a)\wedge Poss(a,s)\wedge time(a)=t\right]\wedge\\
\forall a.\left[Natural(a)\wedge Poss(a,s)\rightarrow t\leq time(a)\right]\end{multline*}



\subsection{Related Formalisms}

There are a wide range of related formalisms for reasoning about knowledge,
action and change, which we do not directly consider in this paper.
We find the notation and meta-theory of the situation calculus particularly
suitable for expressing our main ideas. Moreover, the strong underlying
similarities between the major action formalisms should allow the
these ideas to transcend the specifics of the situation calculus \citet{thielscher06reconcile_sc_fc,thielscher07unifying_action_calculus,vanbentham07ml_sitcalc}.


\section{Golog\label{sec:Background:Golog}}

Golog \citet{levesque97golog} is a declarative agent programming
language based on the situation calculus. Testimony to its success
are its wide range of applications and many extensions to provide
additional functionality (\citet{giacomo00congolog,giacomo99indigolog,Ferrein2005readylog}).
We use {}``Golog'' to refer to the family of languages based on
this technique, including ConGolog \citet{giacomo00congolog} and
IndiGolog \citet{giacomo99indigolog}.

To program an agent using Golog one specifies a situation calculus
theory of action, and a program consisting of actions from the theory
connected by programming constructs such as if-then-else, while loops,
and nondeterministic choice. Table \ref{tbl:Golog-Operators} lists
some of the operators available in various incarnations of the language.%
\begin{table}
\begin{centering}
\begin{tabular}{|c|c|}
\hline 
Operator  & Meaning\tabularnewline
\hline
\hline 
$a$  & Execute action $a$ in the world\tabularnewline
\hline 
$\phi?$  & Proceed if condition $\phi$ is true\tabularnewline
\hline 
$\delta_{1};\delta_{2}$  & Execute $\delta_{1}$followed by $\delta_{2}$\tabularnewline
\hline 
$\delta_{1}|\delta_{2}$  & Execute either $\delta_{1}$ or $\delta_{2}$\tabularnewline
\hline 
$\pi(x)\delta(x)$  & Nondet. select arguments for $\delta$\tabularnewline
\hline 
$\delta*$  & Execute $\delta$ zero or more times\tabularnewline
\hline 
$\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$  & Exec. $\delta_{1}$ if $\phi$ holds, $\delta_{2}$ otherwise\tabularnewline
\hline 
$\mathbf{while\,}\phi\mathbf{\, do}\,\delta$  & Execute $\delta$ while $\phi$ holds\tabularnewline
\hline 
$\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$  & Procedure definition\tabularnewline
\hline 
$\delta_{1}||\delta_{2}$  & Concurrent execution (ConGolog)\tabularnewline
\hline 
$\Sigma\delta$  & Plan execution offline (IndiGolog)\tabularnewline
\hline
\end{tabular}
\par\end{centering}

\caption{ Some Golog Operators\label{tbl:Golog-Operators} }

\end{table}


In line with the idea of high-level program execution, the agent's
control program may be nondeterministic. It is the task of the agent
to plan a deterministic instantiation of the program, a sequence of
actions that can legally be performed in the world. Such a sequence
is called a \emph{legal execution} of the Golog program.

Two predicates $Trans$ and $Final$ define the semantics for each
operator. $Trans(\delta,s,\delta',s')$ holds when executing a step
of program $\delta$ can cause the world to move from situation $s$
to situation $s'$, after which $\delta'$ remains to be executed.
It thus characterises single steps of computation. $Final(\delta,s)$
holds when program $\delta$ may legally terminate its execution in
situation $s$. We base our work on the semantics of IndiGolog, which
builds on ConGolog and is the most feature-full of the standard Golog
variants. The full semantics are available in the references, but
as an example consider equation (\ref{eqn:trans_conc_orig}), which
specifies the concurrent-execution operator as an \emph{interleaving}
of computation steps. It states that it is possible to single-step
the concurrent execution of $\delta_{1}$ and $\delta_{2}$ by performing
either a step from $\delta_{1}$ or a step from $\delta_{2}$, with
the remainder $\gamma$ left to execute concurrently with the other
program:\begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\\
\shoveright{\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\vee\,\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\label{eqn:trans_conc_orig}\end{multline}
 Clearly there are two notions of concurrency to be considered: the
possibility of performing several actions at the same instant (\emph{true
concurrency}), and the possibility of interleaving the execution of
several programs (\emph{interleaved concurrency}). These were combined
in \citet{pinto99tcongolog} by modifying Golog to incorporate sets
of concurrent actions. However, they give a semantics which may call
for actions to be performed that are not possible and which can result
in unintuitive program behaviour. A key aspect of our work is a more
robust integration of these two notions of concurrency.

If the theory of action $\mathcal{D}$ is enriched with $Trans$ and
$Final$, planning an execution of a Golog program $\delta$ is basically
a theorem proving task as shown in equation (\ref{eqn:golog_execution}).
Here $Trans*$ indicates reflexive transitive closure. The situation
$s$ gives a sequence of actions forming a legal execution of the
program.\begin{equation}
\mathcal{D}\models\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]\label{eqn:golog_execution}\end{equation}
 In IndiGolog agents can also proceed without planning a full terminating
execution of their program, by searching for a legal {}``next step''
action $a$ such that $\mathcal{D}\models\exists a\,.\, Trans*(\delta,s,\delta',do(a,s))$.
The search operator ($\Sigma$) controls which parts of the program
are subject to full execution planning, providing fine-grained control
over nondeterminism and the amount of planning work required.

As an example of a multi-agent task specification in Golog, consider
a program $MakeSalad$ that instructs a team of agents to prepare
a simple salad:\begin{multline}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right]\,\,\mathbf{end}\label{eqn:MakeSalad}\end{multline}
 The sub-procedure $ChopTypeInto$ (not shown) picks an object of
the given type and an available chopping board, chops the object using
the board, then transfers it into the destination container. $MakeSalad$
tells the agents to do this for a lettuce, a carrot and a tomato,
then mix the ingredients together for 1 minute. Note the nondeterminism
in this program - the agent assigned to handling each ingredient is
not specified ($\pi$ construct), nor is the order in which they should
be added ($||$ construct). There is thus considerable scope for cooperation
between agents to effectively carry out this task.

While this is a valid program in standard IndiGolog, executing it
using the existing semantics would be far from ideal. The explicit
temporal component described above must to added to IndiGolog to accommodate
the $mix(dest,1)$ task. The lack of true concurrency would mean only
one agent could act at a time, while others would remain idle. And
since there is no support for natural actions, IndiGolog would fail
to find a legal execution of this program: it would find that the
final action $release$ cannot be performed after doing $beginTask$,
as our theory of action ensures agents can only be doing one thing
at a time. But it would not determine that the natural action $endTask$
will occur after one minute and enable to program to finish.

TODO: other Gologs: (DTGolog, HTNGolog, GTGolog). highlight rich cross-pollination,
hope to be a part of it


\section{Epistemic Reasoning\label{sec:Background:Epistemic-Reasoning}}

TODO: general intro to epistemic reasoning \citet{halpern90knowledge_distrib,fagin95}

Epistemic reasoning was first introduced to the situation calculus
by \citet{moore80know_act}, and formalised extensively by \citet{scherl03sc_knowledge}
whose paper is now the canonical reference for these techniques. Their
work has been extended to include concurrent actions \citet{scherl03conc_knowledge}
and multiple agents \citet{shapiro98specifying_ma_systems}. We further
extend this family of techniques in this paper.

The semantics of knowledge are based on a reification of the {}``possible
worlds'' semantics of modal logic, using situation terms rather than
abstract worlds. A special fluent $K(agt,s',s)$ is used to indicate
that {}``in situation $s$, the agent $agt$ considers the alternate
situation $s'$ to be possible''. The macro $\Knows$ is then defined
as a shorthand for the standard possible-worlds definition of knowledge,
stating that an agent knows $\phi$ when $\phi$ is true in all situations
considered possible: \begin{equation}
\Knows(agt,\phi,s)\isdef\forall s':\, K(agt,s',s)\rightarrow\phi[s']\label{eqn:knows_def}\end{equation}


Readers familiar with modal logic will recognise $K(agt,s',s)$ as
the situation calculus analogue of the modal reachability relation
$K_{agt}$, and the macro $\Knows(agt,\phi,s)$ as the equivalent
of the modal box operator $[K_{agt}]\phi$.

The foundational axioms $\Sigma$ define a special fluent $K_{0}(agt,s',s)$
that is used to model the initial epistemic uncertainty of the agents,
with $\Dt_{S_{0}}$ containing sentences of the form $\KnowsZ(agt,\phi,S_{0})$
to specify what is initially known%
\footnote{The standard account does not require a separate $K_{0}$ fluent,
as evidenced by equation \eqref{eq:k_s0_standard}. It is required
when incorporating hidden actions, so we introduce it now to maintain
consistency. %
}:\begin{gather*}
K_{0}(agt,s',s)\,\rightarrow Init(s)\wedge Init(s')\\
\KnowsZ(agt,\phi,s)\isdef\forall s':\, K_{0}(agt,s',s')\rightarrow\phi[s']\end{gather*}


The action description function $SR(a,s)$ specifies the sensing result
returned by action $a$ when executed in situation $s$. For non-sensing
actions the value of $SR$ is set to an arbitrary constant.

The dynamics of knowledge are then specified by an additional set
of axioms, which we will denote $\Dt_{K}$. In the standard account
of knowledge $\Dt_{K}$ contains the following axioms:\begin{equation}
Init(s)\rightarrow\left(K(agt,s',s)\,\equiv\, K_{0}(agt,s',s)\right)\label{eq:k_s0_standard}\end{equation}
 \begin{align}
K(agt,s'',do(c,s))\equiv\exists s': & \, s''=do(c,s')\,\wedge K(agt,s',s)\wedge Poss(c,s')\nonumber \\
 & \wedge\,\forall a\in c:\,\left(actor(a)=agt\,\rightarrow\, SR(a,s)=SR(a,s')\right)\label{eq:k_ssa_standard}\end{align}


Equation \eqref{eq:k_s0_standard} ensures that the agents begin with
their knowledge as specified by $\Dt_{S_{0}}$. Equation \eqref{eq:k_ssa_standard}
takes the form of a standard successor state axiom for the $K$ fluent.
It ensures that $s''$ is considered a possible alternative to $do(c,s)$
when $s''$ is the result of doing the same actions $c$ in a situation
$s'$ that is considered a possible alternative to $s$. It must furthermore
have been possible to perform those actions in $s'$, and the sensing
results must match for each action that was carried out by the agent
in question. Thus an agent's knowledge after the occurrence of an
action is completely determined by the combination of its knowledge
before the action, and the sensing results from the action.

\medskip{}


\begin{defn}
We will denote by $\Dt_{K}^{std}$ the axioms of the standard account
of knowledge due to \citet{scherl03sc_knowledge}, as detailed in
equations (\ref{eq:k_s0_standard},\ref{eq:k_ssa_standard}) above. 
\end{defn}
We can now present the complete definition of a uniform formula, which
may include both action description predicates%
\footnote{This differs from the standard definition, which does not permit action
description predicates \citet{pirri99contributions_sitcalc}. We include
them to simplify notation throughout the paper. This is purely a cosmetic
change, since we assume that action description predicates can always
be expanded into a finite combination of primitive fluents.%
} and knowledge expressions.

\begin{defnL}
[{{[}{{[}{{[}{{[}{{[}{{[}{{[}{Uniform~Formulae}]}]}]}]}]}]}]}] Let
$s$ be a fixed situation term, $F$ a primitive fluent, $\alpha$
an action description predicate, $\vars{x}$ a vector of terms mentioning
no situation term other than $s$, and $y$ a variable that is not
of sort \noun{Situation}. Then the formulae uniform in $s$ are the
smallest set of syntactically-valid formulae satisfying:\[
\phi::=F(\vars{x},s)\,|\,\alpha(\vars{x},s)\,|\,\phi_{1}\wedge\phi_{2}\,|\,\phi_{1}\vee\phi_{2}\,|\,\neg\phi\,|\,\exists y:\phi\,|\,\forall y:\phi\,|\,\Knows(agt,\phi,s)\]

\end{defnL}
While powerful, this knowledge-representation formalism has an important
limitation: it is fundamentally \emph{synchronous.} Each agent is
assumed to have full knowledge of all actions that have occurred -
in other words, all actions are public. While suitable for some domains,
there are clearly many multi-agent domains where achieving total awareness
of actions would be infeasible. A major contribution of this paper
is a more flexible formalism for knowledge that can be applied to
a much wider range of domains.

A key contribution of \citet{scherl03sc_knowledge} was showing how
to apply the regression operator to formulae containing the $\mathbf{Knows}$
macro, allowing it to be treated syntactically as if it were a primitive
fluent. This means that epistemic queries can be approached using
standard reasoning techniques of the situation calculus. Although
we have changed the notation somewhat to foreshadow the techniques
we will develop in Section \ref{sec:Obs-Knowledge}, their definition
operates as follows. First, define the \emph{results} of a concurrent
action to be the set of $action\#result$ pairs for all primitive
actions perform by the agent in question:\[
\mathbf{res}(agt,c,s)\isdef\{a\#SR(a,s)\,\,|\,\, a\in c\,\wedge\, actor(a)=agt\}\]


This definition is then used to formulate a regression rule as follows:\begin{multline}
\Reg(\Knows(agt,\phi,do(c,s))\isdef\\
\exists y:\, y=\mathbf{res}(agt,c,s)\,\wedge\Knows(agt,\left[Poss(c)\wedge\mathbf{res}(agt,c)=y\right]\rightarrow\Reg(\phi[do(c,s)]),s)\label{eq:reg_k_std}\end{multline}


This works by collecting the sensing results from each action performed
by the agent into the set $y$, then ensuring matching sensing results
in every situation considered possible. It expresses the knowledge
of the agent after a concurrent action in terms of what it knew before
the action, along with the information returned by the action. This
technique relies heavily on the fact that all actions are public,
since it requires every agent's knowledge to be updated in response
to every action.

Repeated applications of $\Reg$ can thus transform a knowledge query
into one that is uniform in the initial situation. While it would
be valid to then expand the $\Knows$ macros and handle the query
using first-order logic, in practice the reasoning procedure would
leave $\Knows$ intact and use a specialised prover based on modal
logic.

It is possible to formulate an alternate successor state axiom for
knowledge that does not assume all actions are public, such as that
of \citet{Lesperance99sitcalc_approach}. Such formulations invariably
require universal quantification over situation terms, to account
for arbitrarily-long sequences of hidden actions. This is incompatible
with regression rules like the above, and these formulations offer
no reasoning procedure other than general second-order theorem proving.
By utilising a new reasoning technique called the {}``persistence
condition'' to reason about universal quantification over situation
terms, our work is the first to provide an account of knowledge with
hidden actions while maintaining regression in the style presented
above as an effective reasoning tool.

TODO: shortcomings of multi-agent extensions, decidability/weakening
\citet{demolombe00tractable_sc_belief} \citet{petrick02knowledge_equivalence}

TODO: group-level knowledge, important of common knowledge, inability
to do regression

TODO: epistemic feasibility of plans? \citet{giacomo04sem_delib_indigolog,Lesperance01epi_feas_casl}


\section{Mozart/Oz\label{sec:Background:Mozart/Oz}}

\begin{itemize}
\item Basic introduction \citet{vanroy99mozart} 
\item Oz for Logic Programming \citet{vanroy03mozart_logic} 
\item Distributed Logi Programming: Parallel Search \citet{schulte00oz_parallel} 
\item include some simple example programs 
\end{itemize}
