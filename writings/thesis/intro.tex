


\chapter{Introduction}

The situation calculus, and the programming language Golog that is
built upon it, is a powerful formalism for reasoning about dynamic
worlds and specifying the behavior of autonomous agents. Among its
advantages are: straightforward representations of rich domain features
such as concurrent actions and continuous time; effective reasoning
procedures based on regression; flexible task specification using
familiar programming constructs; a mature formalism for epistemic
reasoning; and a straightforward implementation by encoding as a logic
program. But while powerful, existing formalisms based on the situation
calculus suffer several major limitations that make them unsuitable
for use in rich, asynchronous multi-agent domains.

First, the situation calculus lacks a comprehensive treatment of group-level
epistemic modalities. Simple group-level modalities such as {}``everyone
knows $\phi$'' can be expressed as finite combinations of individual-level
knowledge operators, but more complex modalities such as {}``it is
common knowledge that $\phi$'' cannot be handled in this way. Instead,
common knowledge is typically introduced via a separate second-order
axiom \citep{davis05fo_ma_theory,ghaderi07sc_joint_ability}. This
approach is logically sound, but means regression can no longer be
used for effective automated reasoning. Given the deep connections
between common knowledge and coordination, this is a serious shortcoming
in multi-agent domains.

Second, it requires that whenever an action occurs, all agents \emph{know}
that an action has occurred. This demands a level of synchronicity
that is unreasonable in many multi-agent domains. But if the restriction
is lifted, each agent's knowledge must account for arbitrarily-long
sequences of hidden actions \citep{Lesperance99sitcalc_approach}.
Such a formulation must utilise a second-order induction axiom, again
precluding the use of regression for effective automated reasoning.

Third, planning in the situation calculus involves building situation
terms representing the actions to be performed. Situations inherently
impose a total ordering on actions, and cannot represent the independent
execution of actions by different agents. Again, performing a plan
built using situation terms requires a degree of synchronicity that
is unreasonable in many multi-agent domains. Even if this synchronicity
is achievable, it is often not desirable.\\


In this thesis we overcome these limitations, extending the standard
accounts of knowledge and planning in the situation calculus with
three main technical results:

\begin{itemize}
\item A formal account of \emph{Common Knowledge} and other group-level
epistemic modalities, including a regression rule for reasoning about
common knowledge; 
\item support for \emph{Hidden Actions} and actions that are partially observable,
including a reasoning technique to deal with arbitrarily-long sequences
of hidden actions; and 
\item a partially-ordered representation of actions which we call a \emph{Joint
Execution}, which can replace raw situation terms in the Golog execution
planning process to allow agents to perform independent actions without
synchronisation. 
\end{itemize}
Moreover, each of these extensions is provided with an effective reasoning
procedure based on standard regression techniques. The result is a
rich account of knowledge and planning for asynchronous multi-agent
domains.

To make things more concrete, consider a small motivating example
which will be used throughout the thesis:

\begin{quote}
You have just taken possession of a team of robotic chefs. It is your
task to program the chefs to prepare a delicious meal. 
\end{quote}
A natural way to approach this problem is to specify a program detailing
the preparation of each dish to be served, and have the agents cooperate
to plan and perform the concurrent execution of these programs. We
have developed a variant of the Golog programming language suitable
for representing and reasoning about such cooperative execution. This
example will be used to simultaneously motivate and demonstrate our
techniques.

The implementation of these techniques is done using the Mozart programming
platform, rather than the more traditional use of Prolog. Mozart provides
excellent support for distributed logic programming, and in particular
provides the ability to automatically distribute the search for solutions
in a logic program between a group of networked computers. Coupled
with the straightforward encoding of the situation calculus as a logic
program, this allows the agents to easily share the workload of planning
their program execution.\newpage{}

The thesis proceeds as follows:

\begin{itemize}
\item Chapter \ref{ch:background} presents the necessary background material
on the situation calculus, Golog, epistemic reasoning, and the Mozart
programming system which will be used to implement our techniques. 
\item Chapter \ref{ch:mindigolog} introduces a variant of Golog with semantics
suitable for planning the cooperative execution of a shared task,
which we call \emph{MIndiGolog.} We demonstrate an implementation
using the distributed logic programming capabilities of Mozart to
share the planning workload among agents. We also highlight the limitations
of the situation calculus that restrict this technique to synchronous
domains. 
\item Chapter \ref{ch:persistence} develops a new reasoning technique for
effectively handling queries that universally quantify over situation
terms, which we call the \emph{Persistence Condition} operator. It
uses a restricted fixpoint calculation to replace a second-order induction
axiom. 
\item Chapter \ref{ch:knowledge} develops a formalism for individual knowledge
in the face of hidden actions, by explicitly reifying the \emph{observations}
made by each agent as the world evolves, and specifying an agent's
knowledge in terms of what it has observed. The persistence condition
operator is used to augment the traditional regression rule for knowledge
to account for arbitrarily-long sequences of hidden actions. 
\item Chapter \ref{ch:cknowledge} introduces common knowledge by using
the syntax of dynamic logic to formulate a more expressive epistemic
language than existing situation calculus theories. We formulate a
regression rule for these complex epistemic modalities and formally
relate them to our account of individual knowledge. 
\item Chapter \ref{ch:jointexec} develops joint executions as a restricted
kind of prime event structure, and shows how to use them as a data
structure in planning the execution of a shared MIndiGolog program. 
\item Chapter \ref{ch:implementation} discusses our implementation in more
detail, including a novel representation of formulae based on Shannon
Graphs to allow the kind of open-world reasoning required for dealing
with knowledge queries. 
\item Chapter \ref{ch:conclusion} concludes with a summary of our achievements
and suggestions for future work. 
\end{itemize}
