

\chapter{Introduction}

\label{ch:intro}

The situation calculus, along with the programming language Golog
that is built upon it, is a powerful formalism for reasoning about
dynamic worlds and specifying the behaviour of autonomous agents.
It combines a rich language for expressing domain features with techniques
for effective reasoning and a straightforward implementation using
logic programming. But while powerful, the situation calculus currently
suffers some major limitations that make it unsuitable for reasoning
about asynchronous multi-agent domains.

We begin by noting that there is a significant body of work on modelling
and implementing multi-agent systems in the situation calculus, including:
the cognitive agent specification language and verification environment
\citep{shapiro02casl}; theories of coordination and ability \citep{ghaderi07sc_joint_ability};
artificial intelligence competitions such as robot soccer \citep{Ferrein2005readylog}
and robot rescue \citep{farinelli07team_golog}; reasoning about the
epistemic feasibility of plans \citep{Lesperance01epi_feas_casl};
analysing multi-player games \citep{delgrande01sitcalc_cleudo}; and
the cooperative execution of Golog programs \citep{Ferrein2005readylog,kelly06hlp_dps}.
This literature shows the power and flexibility of the situation calculus,
but also highlights three current weaknesses when working with rich
multi-agent domains.

First, each of these works has been limited to \emph{synchronous}
domains -- domains in which each agent's local perspective on the
world is updated in lock-step with the global perspective available
to the system designer. This restriction ensures that, while an agent
may not know the full state of the world, it will always know precisely
how many actions have been performed. In many cases the restriction
is enforced using a blanket assumption that that all actions are publicly
observable.

The motivation for this restriction is clear and compelling: regression.
Regression is the standard technique for effective reasoning in the
situation calculus and the core of the Golog execution planning procedure.
It operates by systematically removing actions from a query until
it is in a form that is easy to answer. In synchronous domains, all
agents know the number of actions performed and can directly use existing
regression-based techniques for reasoning and planning from their
local perspective. While the situation calculus makes is straightforward
to \emph{model} domains in which synchronicity cannot be guaranteed
\citep{Lesperance99sitcalc_approach}, it offers no tools for effective
reasoning from the local perspective of an individual agent.

Second, the fundamental unit of reasoning, and the output of the Golog
execution planning process, is the \emph{situation}: a complete, ordered
history of all actions that are to be performed. Having to executing
a totally-ordered sequence of actions is far from ideal in a multi-agent
setting, as it requires constant synchronization between the agents.
While this may be acceptable for systems that are already limited
to synchronous domains, it severely limits their ability to exploit
the concurrency inherant in a multi-agent team. In asynchronous domains
the required synchronisation of actions may be impossible to achieve,
and a partially-ordered representation must be used instead. But there
have been no formal acctions of such a representation in the existing
situation calculus literature.

Third, the situation calculus lacks a comprehensive treatment of group-level
epistemic modalities such as \emph{common knowledge}, which are fundamental
to coordination in multi-agent domains. While common knowledge can
easily be modelled using an explicit second-order axiom \citep{delgrande01sitcalc_cleudo,davis05fo_ma_theory,ghaderi07sc_joint_ability},
this again precludes the use of regression for effective automated
reasoning. In synchronous domains agents can often coordinate their
activities without reasoning explicitly about common knowledge, but
in more general multi-agent domains the lack of an effective reasoning
procedure can be a serious shortcoming.\\


This thesis overcomes these limitations by extending the situation
calculus with reasoning and planning techniques for \emph{asynchronous}
domains -- domains in which the state of the world can change without
updating the local perspective of each agent. We begin by explicitly
representing that local perspective: whenever an action occurs, each
agent makes a corresponding set \emph{observations} that are local
to that agent. We allow this set of observations to be empty, formalising
the case where asynchronicity means some actions are completely hidden
from some agents.

On top of this seemingly simple extension, we construct a planning
process based on partially-ordered action sequences, a new technique
for effective inductive reasoning to augment standard regression,
and a principled axiomatisation of multi-agent knowledge coupled with
an effective reasoning procedure. These new extensions allow the situation
calculus to be used to much greater effect in asynchronous multi-agent
domains.\newpage{}


\section{Motivation}

To make things more concrete, let us introduce two motivating examples
that will be used throughout the thesis, along with an overview of
the challenges they pose to existing techniques from the situation
calculus literature.


\subsection*{Example 1: The Cooking Agents}

Cathy is hosting a dinner party. A brilliant engineer but a mediocre
cook, she has built a team of robotic cooking agents to help her prepare
the meal, and must now program them to carry out their duties. She
needs a powerful formalism with which the agents can plan their actions,
and a programming language flexible enough to specify the major steps
in each recipe while leaving the precise details of execution for
the agents to plan amongst themselves. Moreover, she wants to specify
the tasks to be performed as a single shared program, and have the
agents automatically distribute the work amongst themselves.\\


The situation calculus offers a compelling approach for this example
domain: each recpie can be represented as a Golog program, and the
team of agents cooperate to plan and perform the shared execution
of these programs. However, existing Golog implementations generate
raw situation terms as the output of their planning process. These
are linear, fully-ordered sequences of the actions to be performed,
and require constant synchronisation if the agents are to perform
them cooperatively.

In synchronous domains this is not a problem, as the agents will always
know how far the execution has progressed and thus what actions should
be performed next. But it is still desirable to take advantage of
the natural concurrency present when planning for a team of agents.
The Golog planning process must be modified to reason about and allow
such \emph{true concurrency}.

In asynchronous domains, an agent may not necessarily know how far
execution has progressed, and may thus be unsure when or if to perform
its next action. The planning process should account for this by only
calling for agents to perform an action if they will know, based on
their local information, that the action should be performed. But
the situation calculus currently has no means to represent this kind
of partially-ordered action action structure.\\


Rather than demand that Cathy equip her robots with a global synchronisation
mechanism of some kind, we will extend the situation calculus and
the semantics of Golog execution planning to better handle inter-agent
synchronisation in asynchronous, partially-observable domains.


\subsection*{Example 2: The Party Invitation}

Alice and Bob have heard about Cathy's party but don't know where
it is, and have just received an invitation telling them the location.
Having suffered decades of trouble with their communications, they
like to reason about each other's knowledge by directly observing
each other's actions. If Alice reads the invitation, she will know
the location of the party. But will Bob know that she knows this?
What if he temporarily leaves the room, meaning Alice is able to read
the invitation in secret? And most importantly, can they achieve common
knowledge of the party's location in order to coordinate their travel
plans for the evening?\\


The situation calculus permits an elegant axiomatisation of this domain.
But its standard account of knowledge uses regression for effective
reasoning and so cannot handle two important aspects of this example
without resorting to general second-order theorem proving, hardly
an attractive prospect for automated reasoning.

First, the standard account of knowledge requires that whenever an
action occurs, all agents \emph{know} that an action has occurred.
If this restriction is lifted then each agent's knowledge must account
for arbitrarily-long sequences of hidden actions. This requires a
second-order induction axiom which precludes the use of regression
for effective automated reasoning.

Second, the situation calculus lacks a comprehensive treatment of
group-level epistemic modalities such as common knowledge. Common
knowledge is typically introduced using an explicit second-order definition,
again precluding the use of regression for effective automated reasoning.\\


Rather than demand that Alice and Bob perform open-ended second-order
theorem proving, we will develop a new technique for inductive reasoning
in the situation calculus and a new formulation of group-level modalities
which can capture a regression rule for common knowledge.

\newpage{}


\section{Scope}

This thesis aims to provide a foundational account of reasoning with
the situation calculus in asyncrhonous domains. However, the term
{}``asynchronous domain'' is potentially quite confusing -- precisely
what aspects of the domain are asynchronous? Is it a property of the
environment, the agents themselves, or their communication mechanisms?
Many of the foundational papers on epistemic reasoning define asynchronicity
as a property of inter-agent communication, such as having unbounded
message delivery times \citep{fischer85distributed_consensus}, or
delivery times bounded by some constant \citep{halpern90knowledge_distrib}.
TODO: more here.

Our notion of asyncrhonicity is more primitive, and is similar to
the definition given in \citep{vanBentham06tree_of_knowledge}: asyncrhonous
domains are those in which the local perspective of each agent is
not updated in lock-step with the global world state. Existing models
of multi-agent systems in the situation calculus do not meet even
this simple requirement.

In particular, our focus on common knowledge in chapter TODO may seem
at odds with our stated intention of modelling asynchronous domains;
based on the results of \citep{halpern90knowledge_distrib}, it is
a generally accepted fact that common knowledge cannot be obtained
in asynchronous systems.

Common knowledge requires not synchronicity, but \emph{simultenaiety},
and this is precisely what is offered by our approach - an explicit
axiomatisation of when events will be simultaneously observed and
can therefore contribute to common knowledge. It is straightforward
to model systems wity no simultaneous events in our framework, and
correspondingly straightforward to demonstrate that the agents cannot
obtain common knowlege of such events. Thus, we

\citep{halpern90knowledge_distrib}: copresent with the occurrence
of the fact.

This thesis thus provides a foundational account of asynchronicity
in the situation calculus, upon which more complex models of communication
may be built and studied. TODO: refer to studying more limited forms
of agreement in future work.


\section{Contributions}

Our contributions hinge on extending the situation calculus to explicitly
represent the local \emph{observations} made by each agent when an
action is performed. We introduce a function $Obs(agt,a,s)$ that
returns the set of observations made by agent $agt$ when action $a$
is performed in situation $s$. From this, we associate with each
situation $s$ an agent-local view, denoted $View(agt,s)$, which
is the sequence of observations made by the agent but excluding cases
where $Obs(agt,a,s)$ is empty.\\


With a principled axiomatisation of the local perspective of each
agent in hand, we construct new formalisms and techniques for effective
use of the situation calculus in asynchronous multi-agent domains.
Specifically, we provide:

\begin{itemize}
\item A new multi-agent variant of Golog, with semantics suitable for cooperative
execution by a team of agents, and a planning procedure that builds
a partially-ordered sequence of actions rather than a raw situation
term. The planning process ensures synchronisation is always possible
based on the local view of each agent. 
\item A new procedure for effective inductive reasoning about a restricted
form of query, using a meta-level fixpoint calculation on top of the
standard regression operator. This allows the second-order aspects
of our axiomatisation to be {}``factored out'' of the reasoning
process so that proper regression rules can be formulated. 
\item A new formalism for individual-level knowledge based explicitly on
the agent's local view, with accompanying regression rules that use
our new technique for inductive reasoning to handle arbitrarily-long
sequences of hidden actions. 
\item A comprehensive treatment of group-level epistemic modalities such
as common knowledge, using an epistemic language based on dynamic
logic to capture a proper regression rule for common knowledge. 
\end{itemize}
\newpage{}


\section{Thesis Outline}

The thesis proceeds as follows:

\begin{itemize}
\item Chapter \ref{ch:background} presents the necessary background material
on the situation calculus, Golog, and the Mozart programming system.
More detailed reviews of the relevant literature are included in each
subsequent chapter. 
\item Chapter \ref{ch:mindigolog} introduces \emph{MIndiGolog}, a variant
of Golog with semantics suitable for planning the cooperative execution
of a shared task\emph{.} We demonstrate an implementation using the
distributed logic programming capabilities of Mozart to share the
planning workload among agents, and highlight the limitations of the
situation calculus that restrict this technique to synchronous domains. 
\item Chapter \ref{ch:observations} formalises the agent-local perspective
by reifying the \emph{observations} made by each agent as the world
evolves. We show that this formalism generalises the existing techniques
in which the local perspective is modelled implicitly.
\item Chapter \ref{ch:jointexec} develops \emph{joint executions} as a
restricted kind of prime event structure where synchronisation is based on
observations, and show how to use them as a data structure in planning the
execution of a shared MIndiGolog program. 
\item Chapter \ref{ch:persistence} develops a new technique for effective
inductive reasoning, capable of handling a limited form of query that
universally quantifies over situation terms. Dubbed the \emph{Persistence
Condition} operator, it uses a restricted fixpoint calculation to
replace a second-order induction axiom. 
\item Chapter \ref{ch:knowledge} develops a formalism for individual knowledge
in the face of hidden actions, by specifying an agent's knowledge
in terms of its local perspective. The persistence condition operator
is used to augment the traditional regression rule for knowledge to
account for arbitrarily-long sequences of hidden actions. 
\item Chapter \ref{ch:cknowledge} introduces common knowledge by using
the syntax of dynamic logic to formulate a more expressive epistemic
language than existing situation calculus theories. We formulate a
regression rule for these complex epistemic modalities and formally
relate them to our account of individual knowledge. 
\item Chapter \ref{ch:conclusion} concludes with a summary of our achievements
and suggestions for future work. 
\item Appendix \ref{ch:implementation} discusses our implementation in
more detail. 
\item Appendix \ref{ch:proofs} provides full proofs for all theorems in
the thesis. 
\end{itemize}
