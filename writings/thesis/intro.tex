
\chapter{Introduction}

The situation calculus, along with the programming language Golog
that is built upon it, is a powerful formalism for reasoning about
dynamic worlds and specifying the behaviour of autonomous agents.
Among its advantages are: straightforward representations of rich
domain features such as concurrent actions and continuous time; effective
reasoning procedures based on regression; flexible task specification
using familiar programming constructs; a mature formalism for epistemic
reasoning; and a straightforward implementation by translation into
a logic program. But while powerful, existing situation calculus techniques
suffer several major limitations that make them unsuitable for reasoning
about asynchronous multi-agent domains.

First, existing accounts of knowledge in the situation calculus require
that whenever an action occurs, all agents \emph{know} that an action
has occurred. This demands a level of synchronicity that is unreasonable
in many multi-agent domains. But if the restriction is lifted, each
agent's knowledge must account for arbitrarily-long sequences of hidden
actions. This requires a second-order induction axiom which precludes
the use of regression for effective automated reasoning. It also means
that agents cannot reason about their own knowledge, as they may not
have enough information to formulate an appropriate query.

Second, the situation calculus lacks a comprehensive treatment of
group-level epistemic modalities. Simple group-level modalities such
as {}``everyone knows $\phi$'' can be expressed as finite combinations
of individual-level knowledge operators, but more complex modalities
such as {}``it is common knowledge that $\phi$'' cannot be handled
in this way. Common knowledge is typically introduced via a separate
second-order axiom, which is logically sound but again means regression
cannot be used for effective automated reasoning. Given the deep connections
between common knowledge and coordination, this is a serious shortcoming
in multi-agent domains.

Third, planning in the situation calculus involves building situation
terms representing the sequence of actions to be performed. Situations
inherently impose a total ordering on actions, and cannot represent
the independent execution of actions by different agents. Executing
a plan built using situation terms therefore requires constant synchronisation
among the agents. Even if such synchronicity is achievable, it is
usually not desirable.\\


This thesis overcomes each of these limitations. Our approach is built
on an explicit representation of the \emph{observations} made by each
agent when an action occurs, which facilitates reasoning from the
local perspective of an individual agent. We extend the standard accounts
of knowledge and planning in the situation calculus with three main
technical results:

\begin{itemize}
\item Support for \emph{Hidden Actions} and actions that are partially observable,
including a new technique for inductive reasoning to deal with arbitrarily-long
sequences of hidden actions; 
\item a formal account of \emph{Common Knowledge} and other group-level
epistemic modalities, including a regression rule for reasoning about
common knowledge; and 
\item a new data structure for representing action sequences during Golog
execution planning, allowing independent actions to be executed independently
while automatically managing inter-agent synchronisation based on
their local observations. 
\end{itemize}
Each of these extensions is accompanied by an effective reasoning
procedure based on standard regression techniques. The result is a
rich account of knowledge and planning for asynchronous multi-agent
domains.\\


As both a motivation for and a demonstration of our techniques, we
have developed a variant of Golog designed for cooperative execution
by a team of agents. We provide an implementation using the Mozart
programming system rather than the traditional use of Prolog. By taking
advantage of Mozart's strong support for distributed logic programming,
the execution planning workload can be distributed amongst all members
of the team\emph{.} Using our implementation, a team of agents can
cooperate to plan and perform the execution of a shared Golog program
in asynchronous, partially-observable domains.

\newpage{}

The thesis proceeds as follows:

\begin{itemize}
\item Chapter \ref{ch:background} provides a brief literature review and
presents the necessary background material on the situation calculus,
Golog, epistemic reasoning, and the Mozart programming system. 
\item Chapter \ref{ch:mindigolog} introduces a variant of Golog with semantics
suitable for planning the cooperative execution of a shared task,
which we call \emph{MIndiGolog.} We demonstrate an implementation
using the distributed logic programming capabilities of Mozart to
share the planning workload among agents. We also highlight the limitations
of the situation calculus that restrict this technique to synchronous
domains. 
\item Chapter \ref{ch:persistence} develops a new reasoning technique for
effectively handling queries that universally quantify over situation
terms, which we call the \emph{Persistence Condition} operator. It
uses a restricted fixpoint calculation to replace a second-order induction
axiom. 
\item Chapter \ref{ch:knowledge} develops a formalism for individual knowledge
in the face of hidden actions, by explicitly reifying the \emph{observations}
made by each agent as the world evolves, and specifying an agent's
knowledge in terms of what it has observed. The persistence condition
operator is used to augment the traditional regression rule for knowledge
to account for arbitrarily-long sequences of hidden actions. 
\item Chapter \ref{ch:cknowledge} introduces common knowledge by using
the syntax of dynamic logic to formulate a more expressive epistemic
language than existing situation calculus theories. We formulate a
regression rule for these complex epistemic modalities and formally
relate them to our account of individual knowledge. 
\item Chapter \ref{ch:jointexec} develops joint executions as a restricted
kind of prime event structure, and shows how to use them as a data
structure in planning the execution of a shared MIndiGolog program. 
\item Chapter \ref{ch:implementation} discusses our implementation in more
detail, including a novel representation of formulae based on Shannon
Graphs to allow the kind of open-world reasoning required for dealing
with knowledge queries. 
\item Chapter \ref{ch:conclusion} concludes with a summary of our achievements
and suggestions for future work. 
\end{itemize}
