

\chapter{MIndiGolog}

\label{ch:mindigolog}

This chapter develops a Golog variant specifically designed for cooperative
execution in multi-agent domains. Motivated by the {}``cooking agents''
example domain, we want to allow a team of agents to cooperatively
plan and perform the execution of a shared Golog program. As this
chapter will demonstrate, the existing features of the situation calculus
go a long way towards achieving this goal, but are ultimately limited
to execution in synchronous domains.

We begin by integrating three existing extensions to the situation
calculus into the semantics of Golog to better represent the dynamics
of a multi-agent team. Key among these is true concurrency of actions,
which is combined with the standard interleaved concurrency of ConGolog
to give a flexible account of concurrent execution. An explicit notion
of time is incorporated to enrich the world model and to assist in
coordination between agents. Finally, the concept of natural actions
is tightly integrated into the language, allowing agents to predict
the behaviour of their teammates and environment. We name the resulting
language {}``MIndiGolog'' for {}``Multi-Agent IndiGolog''.

In addition to these new Golog semantics, we develop an innovative
implementation of our language using the distributed logic programming
features of the Mozart platform. Utilising the parallel search facility
as described in Section \ref{sec:Background:Mozart/Oz}, the agents
can transparently share the workload of planning a program execution.
The ability to utilise off-the-shelf techniques such as parallel search
highlights the advantage of building our system on the situation calculus
-- that it has a straightforward encoding as a logic program.

Concluding the chapter is a discussion of the limitations of this
first incarnation of MIndiGolog, which derive from the effective reasoning
procedures of the situation calculus: it can only operate in fully-observable,
synchronous domains. Subsequent chapters of this thesis develop new
extensions to the situation calculus that can help overcome this limitation.
So while the semantics and initial implementation of MIndiGolog are
of independent interest, this chapter should also be seen as motivating
the use of the situation calculus in rich multi-agent domains, and
therefore the techniques developed later in this thesis.

The chapter proceeds as follows: Section \ref{sec:MIndiGolog:Background}
provides some more detailed background material; Section \ref{sec:MIndiGolog:Motivation}
uses the example of the cooking agents to motivate the changes we
will make to the standard Golog semantics; Section \ref{sec:MIndiGolog:Semantics}
introduces the MIndiGolog semantics incorporating time, true concurrency
of actions, and natural actions, and proves the legality of our modifications;
Section \ref{sec:MIndiGolog:Implementation} discusses our implementation
in Mozart/Oz and shows an example execution produced using the MIndiGolog
semantics; Section \ref{sec:MIndiGolog:Distributed-Planning} discusses
the use of Mozart's parallel search functionality to share the planning
workload; and finally Section \ref{sec:MIndiGolog:Discussion} discusses
both the achievements and limitations of this first incarnation of
the language.


\section{Background\label{sec:MIndiGolog:Background}}

There are two basic approaches to the use of Golog in a multi-agent
setting. The first, and most common, is to assign each agent its own
individual Golog program. The behaviour of the overall system is then
defined as the concurrent execution of the individual agent's programs:\[
\delta=\delta_{agt1}\,||\,\delta_{agt2}\,||\,\dots\,||\,\delta_{agtN}\]


This is the approach followed by TeamGolog \citep{farinelli07team_golog},
the Cognitive Agents Specification Language \citep{shapiro02casl}
and earlier work in a similar vein \citep{lesperance99modeling}.
In such a setting, the agents do not necessarily cooperate or coordinate
their actions, and it is assumed that any legal execution of the combined
agent programs is a possible evolution of the entire system.

The second approach, and the one we follow here, is to have all agents
cooperate to plan and perform the joint execution of a single, shared
program. This program would typically be the concurrent execution
of several shared tasks:\[
\delta=\delta_{task1}\,||\,\delta_{task2}\,||\,\dots\,||\,\delta_{taskN}\]


This is the approach taken by the Golog variant {}``ReadyLog'' developed
by \citet{Ferrein2005readylog} to control the behaviour of a RoboCup
soccer team.

The one-program-per-agent approach can be considered a special case
of the shared-task approach, one which does not require coordination
or cooperation between team members. So while we focus exclusively
the on cooperative execution of a shared task in this and subsequent
chapters, the techniques we develop are likely to have application
in the case of multiple individual control programs as well.

While \citeauthor{Ferrein2005readylog} focus on decision-theoretic
planning rather than the rich domain extensions we consider below,
the execution algorithm they have developed for ReadyLog provides
an excellent introduction to the cooperative execution of Golog programs.
It is presented in Algorithm \ref{alg:readylog_exec}.

The aim of the ReadyLog execution algorithm is to allow agents to
coordinate their actions without the need for explicit communication.
Each agent is given their own individual copy of the shared program,
and they each independently execute the IndiGolog planning process
to determine the next step of execution. When an agent finds a next
step where the action is to be performed by the agent itself, it executes
the action immediately. When the next action is to be performed by
another agent, it waits for its teammate to execute the action before
proceeding to the next step.

%
\begin{algorithm}[t]
\caption{The ReadyLog Execution Algorithm for program $\delta$}


\label{alg:readylog_exec} \begin{algorithmic}

\STATE $\sigma\ \Leftarrow\ S_{0}$

\WHILE{$\Dt\cup\Dt_{golog}\not\models Final(\delta,s)$}

\STATE Find an action $a$ and program $\delta'$ such that:\[
\Dt\cup\Dt_{golog}\models Trans^{*}(\delta,\sigma,\delta',do(a,\sigma))\]


\IF{the action is to be performed by me}

\STATE Execute the action $a$

\ELSE

\STATE Wait for the action to be executed

\ENDIF

\STATE $\sigma\ \Leftarrow\ do(a,\sigma)$

\STATE $\delta\ \Leftarrow\ \delta'$

\ENDWHILE

\end{algorithmic} 
\end{algorithm}


Coordination arises in this setting by ensuring that the agents use
identical theorem provers (in the case of \citep{Ferrein2005readylog},
identical Prolog interpreters) to determine each program step, which
will generate candidate solutions in the same order for each agent.
So although each agent plans the program execution steps independently,
they are guaranteed to plan the \emph{same} execution steps and their
actions will therefore be coordinated without needing to communicate.

However, the semantics of ReadyLog remain largely single-agent and
do not address concerns such as the possibility of performing actions
concurrently, sharing the computational workload of planning, or predicting
the behaviour of team members and the environment in the face of many
concurrently-executing tasks.

The semantics of MIndiGolog that we develop in this chapter follow
a similar approach to ReadyLog, but we focus on incorporating rich
domain features such as concurrency and continuous time. While these
features have been added to Golog individually in existing works \citep{Reiter98seq_temp_golog,pinto99tcongolog,pirri00planning_nat_acts,reiter01kia},
our work is the first to provide a combined integration. We also rectify
some subtle problems with the semantics presented in existing approaches
to provide a more robust combination of rich domain features.


\section{Motivation\label{sec:MIndiGolog:Motivation}}

Recall the {}``cooking agents'' example domain from Chapter \ref{ch:intro}
-- several agents inhabit a kitchen along with various ingredients
and utensils, and they must cooperate to prepare a meal. Specifying
tasks in this domain requires an interesting combination of features.
There is much procedural knowledge about recipes that should be encoded
as precisely as possible, while at the same time there are a lot of
details of precisely who performs which steps, or precisely when they
are performed, that should not be explicitly specified by the programmer.

The Golog family of languages provide a compelling formalism for specifying
tasks in this domain, as the controlled nondeterminism they provide
can be used to elide certain details from the program while keeping
its procedural nature intact. Consider how we might specify the task
of making a simple salad, shown in Figure \ref{fig:MIndiGolog:MakeSalad}.
Using the high-level nondeterministic operators of Golog, this program
says, in essence, {}``somebody chop a lettuce, somebody chop a carrot,
and somebody chop a tomato. Then, somebody mix them together''.

%
\begin{figure}
\begin{centering}
\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\begin{gather*}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt,ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt,ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt,ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt,\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
endTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right])\,\,\mathbf{end}\end{gather*}
 %
}} 
\par\end{centering}

\caption{A Golog program for making a salad\label{fig:MIndiGolog:MakeSalad}}

\end{figure}


Note that the explicit concurrency operators allow the three ingredients
to be chopped independently, while the nondeterministic {}``pick''
operators allow any available agent to perform each sub-task. Expanding
on this example, the procedure $ChopTypeInto$ could be specified
as shown in Figure \ref{fig:MIndiGolog:ChopTypeInto}. Here the agent
must select and acquire an object of the specified type, as well as
an available chopping board. He then places the object on the board,
chops it, and transfers it to the destination container.

%
\begin{figure}
\begin{centering}
\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\begin{gather*}
\mathbf{proc}\, ChopTypeInto(agt,type,dest)\\
\left[\pi(board,\, IsType(board,Board)?\,;\right.\\
\pi(obj,\, IsType(obj,type)?\,;\,\,\,\\
acquire(agt,board)\,;\\
acquire(agt,obj)\,;\\
placeIn(agt,obj,board)\,;\\
beginTask(agt,chop(board))\,;\\
endTask(agt,chop(board))\,;\\
acquire(agt,dest)\,;\\
transfer(agt,board,dest)\,;\\
release(agt,board)\,;\\
\left.\, release(agt,dest)))\right]\,\,\mathbf{end}\end{gather*}
 %
}} 
\par\end{centering}

\caption{A Golog program for chopping an ingredient\label{fig:MIndiGolog:ChopTypeInto}}

\end{figure}


Notice that the programs do no specify which agent is to perform which
task -- in fact they make no assertions at all about the particular
agents operating in the world. A library of procedures such as this
can be combined very flexibly to specify the behaviour of the cooking
agents, and the resulting program could be given to any team of agents
for execution. The agents can prepare several dishes concurrently:

\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\[
MakeSalad()\,||\, MakePasta()\,||\, MakeCake()\]
 %
}}\\


They can even plan to have different dishes ready at different times:

\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\begin{multline*}
\left(\left[MakeSalad()\,||\, MakePasta()\right]\,;\,?(time<7:30)\right)\\
||\,\left(MakeCake()\,;\,?(8:15<time<8:30)\right)\end{multline*}
 %
}}\\


A legal execution of these programs must select appropriate ingredients
and utensils, and ensure that are acquired in an appropriate order,
so that it can proceed to completion without the agent's actions interfering
with each other or coming into conflict over shared resources. Following
the ReadyLog execution algorithm, each agent plans to avoid such conflict
by virtue of finding a legal execution.

In short, the situation calculus and Golog provide an extremely powerful
formalism for specifying cooperative agent behaviour in domains such
as this.

However, executing these kinds of program using a standard Golog variant
is far from ideal in a multi-agent setting. To illustrate this we
have executed the $MakeSalad$ program using the standard semantics
of IndiGolog \citep{giacomo99indigolog}, augmented with an explicit
temporal component in the style of \citep{Reiter98seq_temp_golog}.
The resulting execution is shown in Figure \ref{fig:MIndiGolog:MakeSalad-in-IndiGolog}.

%
\begin{figure}[t]
 \framebox{%
\parbox[t][1\totalheight]{1\columnwidth}{%
\begin{center}
{\footnotesize \verbatiminput{listings/mindigolog/output_MakeSalad_I.txt}} 
\par\end{center}%
}}

\caption{Execution of $MakeSalad$ program using IndiGolog semantics\label{fig:MIndiGolog:MakeSalad-in-IndiGolog}}

\end{figure}


In this domain there are three agents $Joe$, $Jon$ and $Jim$. While
the resulting execution is legal, it is suboptimal in several ways.
The most obvious problem is that it does not take advantage of the
concurrency inherent in a team of agents. Only a single agent acts
at any one time, while the other agents are idle. Ideally the execution
planner should exploit \emph{true concurrency} where possible, by
calling for multiple actions to be performed at each timestep.

Another shortcoming of the standard semantics in this setting is that
they have no support for predicting natural actions. This means we
must specify unnecessary details in our programs, such as including
the $endTask$ action in the definition of $MakeSalad$. Since these
actions are predictable, the planner should incorporate them automatically
-- particularly in a multi-agent setting where there may be many natural
actions associated with long-running tasks.

The remainder of this chapter is dedicated to developing a robustly
multi-agent Golog semantics to overcome these issues, as well as an
implementation that can highlight the benefits of this approach.


\section{Semantics of MIndiGolog\label{sec:MIndiGolog:Semantics}}

We have integrated three extensions to the situation calculus with
the existing semantics of IndiGolog to better model the dynamics of
a multi-agent team. These extensions allow agents to represent time,
concurrently-occurring actions, and natural actions in a robust way.
We use the extensions to the situation calculus discussed in Chapter
\ref{ch:background} to model concurrent actions (Section \ref{sec:Background:Concurrent-Actions})
and explicit time (Section \ref{sec:Background:Time}). The arguments
to $do$, $Legal,$ etc will therefore be \noun{Concurrent\#Timepoint}
pairs rather than individual actions.

Why do we focus on these three extensions in particular? We consider
the ability to reason about true concurrency of actions to be fundamental
in planning for multi-agent domains, if only to ensure that actions
cannot come into conflict if performed concurrently. Once concurrent
actions are being considered, it makes sense to then take advantage
of them where possible for concurrent program execution.

Natural actions form an important part of rich multi-agent domains
with many long-running tasks, as the $endTask$ action is a natural
action. As we shall see in the next chapter, they are also useful
for modelling delayed communication between agents. Since they are
entirely predictable based on the theory of action, we contend that
Golog should provide support for them at the semantic level to relieve
the programmer from having to specify them explicitly.

An explicit temporal component is a prerequisite for supporting natural
actions, and also provides for a much more convincing domain model,
particularly with the cooking agents example domain.


\subsection{Time}

The semantics of IndiGolog are straightforwardly modified to accommodate
an explicit temporal component. We follow the approach of \citep{Reiter98seq_temp_golog,reiter01kia},
in which the transition rule for a single-action program is modified
to use $Legal$ instead of $Poss$. Recall that the original transition
rule for this case is:\[
Trans(a,s,\delta',s')\,\equiv\, Poss(a,s)\wedge\delta'=Nil\wedge s'=do(a,s)\]


Modifying this to use concurrent actions and explicit time, and using
$Legal$ instead of $Poss$, we obtain:\begin{equation}
Trans(a,s,\delta',s')\,\equiv\,\exists t:\, Legal(\{a\}\#t,s)\wedge\delta'=Nil\wedge s'=do(\{a\}\#t,s)\label{eq:MIndiGolog:temp_trans_a}\end{equation}


This basically ensures that the temporal component respects the ordering
between predecessor and successor situations. The key aspect here
is not the new transition rule, but the use of a linear constraint
solver to reason about time. The situations produced by the Golog
execution process are not fixed situation terms, but contain timepoint
variables that are constrained relative to each other \citep{Reiter98seq_temp_golog}.

For example, consider the following simple program:\[
placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Sugar,Bowl)\]


One output from a temporal Golog execution planner for this program
would be:\[
do(\{placeIn(Jim,Sugar,Bowl)\}\#t_{2},do(\{placeIn(Jim,Flour,Bowl)\}\#t_{1},S_{0}))\]


Where $t_{1}$ and $t_{2}$ are variables giving the execution times
of each action. It would also output the following constraint on this
solution:\[
t_{2}>t_{1}\]


This solution thus represents a family of possible legal executions
that respect the temporal ordering on situations. Since we intend
for these executions to be performed cooperatively, the agents must
agree in advance on a convention for grounding these variables, for
example by setting them to their smallest possible value. To simplify
the presentation, we have done this in the example executions shown
throughout the chapter.


\subsection{Concurrency}

To take advantage of true concurrency, we must first allow sets of
concurrent actions to appear in a MIndiGolog execution. The modified
$Trans$ clause for primitive actions shown in equation \ref{eq:MIndiGolog:temp_trans_a}
already ensures that sets of concurrent actions are performed rather
than raw action terms.

However, this is clearly not enough to truly exploit the potential
for concurrency in a multi-agent team. As noted by \citet{pinto99tcongolog},
the concurrency operator should be modified to accept a concurrent
transition from both programs. The concurrency semantics they propose
for their variant {}``TConGolog'' are shown below:\begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\:\,\,\,\,\,\,\,\,\,\shoveright{\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2}:\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},s))}\\
\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},s)\end{multline*}


The first two lines are the standard rules for the concurrency operator,
encoding the interleaving of steps from programs $\delta_{1}$ and
$\delta_{2}$. The remaining lines permit the concurrent execution
of a transition from both programs. While this modification will take
advantage of the true concurrency of actions present in multi-agent
domains, it introduces several complications that \citep{pinto99tcongolog}
does not address.

First, precondition interaction means that $c_{1}\cup c_{2}$ may
not be possible even if the individual actions are. The transition
clause must ensure that the combination of the two sets of actions
is possible. Another issue arises when two programs can legitimately
be transitioned by executing the same action. Consider the following
programs which add ingredients to a bowl:\begin{gather*}
\delta_{1}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Sugar,Bowl)\\
\delta_{2}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Egg,Bowl)\end{gather*}
 Executing $\delta_{1}||\delta_{2}$ should result in the bowl containing
two units of flour, one unit of sugar and an egg. However, an individual
transition for both programs is $c_{1}=c_{2}=\{placeIn(Jim,Flour,Bowl)\}$.
Naively executing $c_{1}\cup c_{2}$ to transition both programs would
result in only one unit of flour being added. If this were a program
in a banking domain, concurrently transferring money between different
accounts, the implications of such an error would be even more significant.

Alternately, consider two programs waiting for a timer to ring:\begin{gather*}
\delta_{1}=ringTimer\,;\, acquire(Jim,Bowl)\\
\delta_{2}=ringTimer\,;\, acquire(Joe,Board)\end{gather*}
 Both programs should be allowed to proceed using the same occurrence
of $ringTimer$, because it is an environmental effect rather than
a purposeful agent-initiated action.

In simple cases like these, it is easy for the programmer to see the
potential for such undesirable interaction and adjust their programs
accordingly. But in more complex cases with liberal use of nondeterminism,
it may not be possible to predict what actions can potentially be
executed concurrently. To avoid unintuitive (and potentially dangerous)
behaviour, concurrent execution must not be allowed to transition
both programs using the same \emph{agent-initiated} action. Natural
actions can safely transition two concurrent programs.

Taking these factors into account, and including an explicit temporal
component, we develop the improved transition rule for concurrency
in equation (\ref{eqn:trans_conc_new}). The first two lines are the
original interleaved concurrency clause from ConGolog, while the remainder
characterises the above considerations to take advantage of true concurrency.\begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\shoveright{\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t:\, Trans(\delta_{1},s,\gamma_{1},do(c_{1}\#t,s))\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2}\#t,s))}\\
\shoveright{\wedge Legal((c_{1}\cup c_{2})\#t,s)\wedge\forall a:\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Natural(a)\right]}\\
\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do((c_{1}\cup c_{2})\#t,s)\label{eqn:trans_conc_new}\end{multline}


There are two other Golog operators that relate to concurrency: the
prioritised concurrency operator $\delta_{1}\ll\delta_{2}$, and the
concurrent iteration operator $\delta^{||}$. MIndiGolog leaves both
of these operators unmodified. For the concurrent iteration operator
this is clearly the right thing to do, since its standard semantics
are defined in terms of the base concurrency operator and will automatically
inherit our new ability to take advantage of true concurrency.

For the prioritised concurrency operator, we note that it is mainly
used to implement interrupt-handling by blocking the execution of
the higher-priority program until a test condition is satisfied, at
which point the lower-priority program is blocked until the interrupt
handler is complete. It makes no sense to allow concurrent execution
of both programs in this case, which would destroy these blocking
semantics.

Our robust integration of concurrent actions thus allows the language
to more accurately reflect the concurrency present in multi-agent
teams. Note that, like existing Golog variants, our semantics make
no attempt to maximise concurrency during program execution. $Trans$
and $Final$ do not differentiate between potential executions, but
simple state which transitions can be legally performed.


\subsection{Natural Actions}

While planning with natural actions has previously been done in Golog
\citep{pirri00planning_nat_acts}, the programmer was required to
explicitly check for any possible natural actions and ensure that
they appear in the execution. We significantly lower the burden on
the programmer by guaranteeing that all legal program executions result
in legal situations, inserting natural actions into the execution
when they are predicted to occur. MIndiGolog agents will thus plan
for the occurrence of natural actions without having them explicitly
mentioned in the program. They may optionally be included in the program
as a synchronisation device, instructing the agents to wait for the
action to occur before proceeding.

This is achieved using a new $Trans$ clause for the case of a single
action $a$, as shown in equation (\ref{eqn:trans_prim_new}). If
$s$ has an LNTP $t_{n}$ and corresponding set of pending natural
actions $c_{n}$, a transition can be made in one of three ways: perform
$a$ at a time before $t_{n}$ (fourth line), perform it along with
the natural actions at $t_{n}$ (fifth line), or wait for the natural
actions to occur (sixth line). If there is no LNTP, then $c$ may
be performed at any legal time.\begin{multline}
Trans(a,s,\delta',s')\equiv\\
\exists t,t_{n},c_{n}:\,\LNTP(s,t_{n})\wedge\PNA(s,c_{n})\wedge\\
\left[t<t_{n}\wedge Legal(\{a\}\#t,s)\wedge s'=do(\{a\}\#t,s)\wedge\delta'=Nil\right.\\
\vee Legal((\{a\}\cup c_{n})\#t_{n},s)\wedge s'=do((\{a\}\cup c_{n})\#t_{n},s)\wedge\delta'=Nil\\
\vee\left.s'=do(c_{n}\#t_{n},s)\wedge\delta'=a\right]\\
\vee\,\neg\exists t_{n}:\,\LNTP(s,t_{n})\wedge\exists t:\, Legal(\{a\}\#t,s)\wedge s'=do(\{a\}\#t,s)\wedge\delta'=Nil\label{eqn:trans_prim_new}\end{multline}


The occurrence of natural actions may also cause test conditions within
the program to become satisfied, so a new $Trans$ clause for the
test operator is also required as shown in equation (\ref{eqn:trans_cond_new}).
This permits a program consisting of a single test condition to make
a transition if the test is satisfied, or a natural action occurs:
\begin{multline}
Trans(\phi?,s,\delta',s')\,\,\equiv\,\,\phi[s]\wedge\delta'=Nil\wedge s'=s\\
\vee\,\exists t_{n},c_{n}:\,\LNTP(s,t_{n})\wedge\PNA(s,c_{n})\wedge\delta'=\phi?\wedge s'=do(c_{n}\#t_{n}s)\label{eqn:trans_cond_new}\end{multline}


A MIndiGolog execution will thus contain all natural actions that
will occur, regardless of whether they were considered explicitly
by the programmer. Contrast this with the standard handling of exogenous
events in Golog, which is achieved by executing a concurrent program
that generates exogenous actions:\[
\delta_{main}\,||\,\left(\pi(a)(Exog(a)?\,;\, a)\right)^{*}\]
 This allows the program to make legal transitions that contain exogenous
actions, but does nothing to \emph{predict} what exogenous actions
will occur. Our approach allows the agents to directly predict the
natural actions that will occur and automatically include them in
a planned execution. Of course, the standard Golog approach is still
required if there are also unpredictable exogenous actions to be accounted
for.


\subsection{Legality of the Semantics}

Let us denote by $\Dt_{mgolog}$ the standard Golog axioms $\Dt_{golog}$,
modified according to equations \eqref{eqn:trans_conc_new}, \eqref{eqn:trans_prim_new}
and \eqref{eqn:trans_cond_new}. All legal executions of a MIndiGolog
program derived from such a theory of action produce legal situations.

\begin{lemma}
The semantics of MIndiGolog entail:\label{lem:MIndiGolog:trans_legal}\[
\Dt\cup\Dt_{mgolog}\models\forall s,s',\delta,\delta':\, Legal(s)\wedge Trans(\delta,s,\delta',s')\rightarrow Legal(s')\]

\end{lemma}
\begin{proofsketch}
By induction on the structure of $\delta$. That the theorem holds
for the modified clauses of equations \eqref{eqn:trans_conc_new},
\eqref{eqn:trans_prim_new} and \eqref{eqn:trans_cond_new} is straightforward,
and no other clause constructs new situation terms. 
\end{proofsketch}
\begin{thm}
The semantics of MIndiGolog entail: \[
\Dt\cup\Dt_{mgolog}\models\forall s',\delta,\delta':\, Trans^{*}(\delta,S_{0},\delta',s')\rightarrow Legal(s')\]
 Thus, all legal executions of a MIndiGolog program produce legal
situations. 
\end{thm}
\begin{proof}
By induction on situation terms. For the base case, $S_{0}$ is always
legal by definition. Lemma \ref{lem:MIndiGolog:trans_legal} proves
legality for the inductive case. 
\end{proof}
The MIndiGolog semantics are thus a powerful but robust extension
to the standard semantics of the Golog language family.


\section{Implementation\label{sec:MIndiGolog:Implementation}}

With these new semantics in place, it is now possible to build a multi-agent
execution planning system utilising MIndiGolog to specify the tasks
to be performed. We have followed the style of \citep{giacomo99indigolog,giacomo00congolog}
to build an interpreter for our language in Oz on the Mozart programming
platform \citep{vanroy03mozart_logic}. We summarise our implementation
below; details on obtaining the full source code are available in
Appendix \ref{ch:implementation}.

Programs and actions are represented in Oz as record terms in a similar
way to Prolog data terms. For example, the program:\[
\pi(agt,\left[acquire(agt,Bowl1);acquire(agt,Lettuce1)\right])\]


is represented as follows:

\programinput{listings/mindigolog/goloz_ex_prog.oz}

Since {}``do'' is a reserved keyword in Oz, we represent situation
terms as records of the form $res(C\,\, T\,\, S)$. $Trans$ and $Final$
have a straightforward encoding as Oz procedures, using the \textbf{case}
statement to encode each individual clause using pattern matching,
and the \textbf{choice} statement to explicitly introduce choice points.
The following are a selection of the operators as they appear in our
implementation:

\programinput{listings/mindigolog/goloz_trans.oz}

\programinput{listings/mindigolog/goloz_final.oz}

Of particular interest is our implementation of the concurrency operator,
reflecting the new semantics from equation \eqref{eqn:trans_conc_new}.
First, we introduce a procedure \emph{Step} which calculates a series
of transitions to produce a single next action:

\programinput{listings/mindigolog/goloz_step.oz}

Then we can encode the semantics of concurrency using the following
case:

\programinput{listings/mindigolog/goloz_trans_conc.oz}

The first option presented by the choicepoint is the case for true
concurrency of actions, while the two other choices represent interleaved
concurrency. By putting the true-concurrency case first, a depth-first
search for executions will try to find a concurrent step before looking
for a step from only one of the programs. Using $Step$ instead of
$Trans$ allows this search to consume empty transitions of each program,
such as test conditions, to find a valid concurrent step. This is
semantically valid since the empty transitions consumed by $Step$
would all eventually be generated by the standard interleaved concurrency
cases.

These simple implementation details are enough to ensure a high degree
of concurrency in the generated executions, as we shall demonstrate
in the next section.

A procedure $Do(\delta,s,s')\equiv Trans^{*}(\delta,s,\delta',s')\wedge Final(\delta',s')$
is defined that determines a complete legal execution $Sp$ for a
given program $D$. As discussed in Section \ref{sec:Background:Golog-Exec-Planning},
this is used to define the semantics of the search operator.

\programinput{listings/mindigolog/goloz_do.oz}

Our implementation of the search operator uses a simple trick to avoid
recalculating the complete legal execution - it translates the found
situation into a list of actions to be performed. More sophisticated
implementations can further instrument this case to perform failure
detection and re-planning \citep{Lesperance00improved_indigolog},
but we do not include these techniques in our work.

\programinput{listings/mindigolog/goloz_trans_search1.oz}

Using this implementation, a team of agents can plan and perform the
execution of a shared MIndiGolog program by following the ReadyLog
execution algorithm from Algorithm \ref{alg:readylog_exec}. The code
for the main control loop is shown below.

\programinput{listings/mindigolog/goloz_control.oz}

As in ReadyLog, each agent individually executes this control loop.
When the next step contains an action that is to be performed be the
agent, they execute it at the indicated time. Otherwise, they wait
for the actions to be executed by their teammates before proceeding
to the next iteration.

The effect of our new semantics can be seen in Figure \ref{fig:MIndiGolog:MakeSalad-in-MIndiGolog}.
This shows the execution generated by our implementation for the $MakeSalad$
program from Figure \ref{fig:MIndiGolog:MakeSalad}, using the new
semantics of MIndiGolog in a domain with three agents. Note the execution
of several actions at each timestep, demonstrating the integration
of true concurrency into the language.

%
\begin{figure}[t]
 \framebox{%
\parbox[t][1\totalheight]{1\columnwidth}{%
\begin{center}
{\footnotesize \verbatiminput{listings/mindigolog/output_MakeSalad_M.txt}} 
\par\end{center}%
}}

\caption{Execution of $MakeSalad$ program using MIndiGolog semantics\label{fig:MIndiGolog:MakeSalad-in-MIndiGolog}}

\end{figure}


Compared to the non-concurrent execution generated by the standard
IndiGolog semantics (Figure \ref{fig:MIndiGolog:MakeSalad-in-IndiGolog}),
our semantics clearly provide advantages for planning cooperative
execution in a multi-agent setting.


\section{Distributed Execution Planning\label{sec:MIndiGolog:Distributed-Planning}}

One powerful feature of Mozart is the ability to use several networked
computers to search for solutions to a logic program in parallel.
Since the task of planning a MIndiGolog execution is encoded as a
logic program, this immediately allows a team of agents to distribute
the execution planning workload.

However, there is a certain amount of computational and communication
overhead involved in such a search, so it must be used judiciously.
We argue as follows: parts of the program appearing outside the scope
of a search operator are intended for on-line execution, and so will
tend to require little deliberation by the agent. By contrast, program
components enclosed in a search operator are intended to require significant
planning to generate a legal execution. We therefore modify our implementation
of the the search operator to perform distributed execution planning,
but leave the rest of the code intact.

To coordinate the parallel search, we designate one agent to be the
\emph{team leader}, who will be responsible for managing the search
process. This position does not confer any additional capabilities
on the agent, and is merely a coordination device.

The code below shows the modified implementation of the search operator
using parallel search. If the executing agent is the team leader,
it initiates the parallel search using the procedure $ParallelDo$
and, when a plan is found, sends the details to the other members
of the team. Subordinate team members simply wait for the message
to be received before continuing.

\programinput{listings/mindigolog/goloz_trans_search2.oz}

Note that this modification is completely transparent to the rest
of the implementation. While some details of sending messages are
not shown, the core implementation of the ParallelDo procedure is
shown below.

This code packages up the task to be performed as a \emph{functor},
a portable piece of code that can be shared across the network by
all team members. Input terms are serialised to a textual representation
since variables cannot be exported in functor definitions. It is then
a simple matter of creating a new $ParallelSearch$ object that spans
all team members, and asking it for a solution to the functor. When
this code is executed by the team leader, it will utilise the computational
resources of all team members to plan the execution of the enclosed
MIndiGolog program.

\programinput{listings/mindigolog/goloz_paralleldo.oz}

As a brief demonstration of the advantages provided by this technique,
consider the suggestively-named program {}``HardToPlan'' shown in
Figure \ref{fig:MIndiGolog:HardToPlan}. This program asks the agents
to nondeterministically select and acquire objects of a variety of
types, and then tests whether certain specific objects have been acquired.
It has been constructed so that a single bad choice in the early stages
of execution planning - for example, having $Joe$ acquire $Carrot1$
instead of $Carrot3$ - can invalidate all choices subsequently made.
Planning a legal execution of this program thus requires a significant
amount of backtracking and should benefit greatly from parallelisation.

%
\begin{figure}
\begin{centering}
\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\begin{gather*}
\mathbf{proc}\, HardToPlan()\\
\left[AcquireType(Joe,Carrot)\,;\right.\\
AcquireType(Jon,Sugar)\,;\\
AcquireType(Jim,Lettuce)\,;\\
AcquireType(Joe,Flour)\,;\\
AcquireType(Jon,Flour)\,;\\
HasObject(Jon,Carrot3)?\,;\\
HasObject(Joe,Flour5)?\,;\\
\left.\, HasObject(Jon,Sugar4)?\right]\,\,\mathbf{end}\\
\\\mathbf{proc}\, AcquireType(Agt,Type)\\
\pi(obj,\, IsType(obj,Type)?\,;\\
\left.\, acquire(Agt,obj)))\right]\,\,\mathbf{end}\end{gather*}
 %
}} 
\par\end{centering}

\caption{A Golog program for which execution planning is difficult\label{fig:MIndiGolog:HardToPlan}}

\end{figure}


We used our MIndiGolog implementation to execute $\Sigma(HardToPlan)$
in two different ways - using parallel search as described above,
and having the team leader search for a legal execution on its own.
The program for team leader $Jon$ was executed on an AMD Althon 64
3000+, while the subordinate team members $Jim$ and $Joe$ each executed
on one core an Intel Core2 Duo 1.8 GHz. Three test runs were performed
for both parallel and individual search. The times required to find
a legal execution are shown in Table \ref{tab:MIndiGolog:Execution-planning-times}
along with the speedup factor achieved by using parallel search.

%
\begin{table}
\begin{centering}
\begin{tabular}{|c|c|c|c|}
\hline 
 & \textbf{Individual Search}  & \textbf{Parallel Search}  & \textbf{Ratio Indiv/Para}\tabularnewline
\hline
\hline 
\textbf{Run 1}  & 29.30  & 13.67  & 2.14\tabularnewline
\hline 
\textbf{Run 2}  & 29.21  & 11.25  & 2.59\tabularnewline
\hline 
\textbf{Run 3}  & 29.08  & 11.61  & 2.50\tabularnewline
\hline
\hline 
\textbf{Average}  & 29.19  & 12.17  & 2.39\tabularnewline
\hline
\end{tabular}
\par\end{centering}

\caption{Execution planning times for $HardToPlan$, in seconds\label{tab:MIndiGolog:Execution-planning-times}}

\end{table}


These results shown an impressive decrease in execution planning time
with the use of parallel search - close to a factor of three speedup
using the computational resources of three agents. Of course, on programs
where execution planning is less difficult this advantage will be
reduced, but on difficult problems it can clearly provide a significant
benefit.

The ability to implement this distributed execution planning with
so little code, and in a way that is completely transparent to the
rest of the implementation, highlights one of the major advantages
of using the situation calculus and Golog -- the ability to encode
both the domain and the execution planning problem as a simple logic
program, which is then amenable to off-the-shelf techniques for distributed
logic programming.


\section{Discussion\label{sec:MIndiGolog:Discussion}}

Our work in this chapter has integrated several important extensions
to the situation calculus and Golog to better model the dynamics of
multi-agent teams. Specifically, MIndiGolog combines true and interleaved
concurrency, an explicit account of time, and seamless integration
of natural actions. As we have shown by comparison to IndiGolog, it
defines legal executions of Golog programs that are much more suitable
for cooperative execution by a multi-agent team.

We have also demonstrated a powerful new implementation of MIndiGolog
using Mozart/Oz instead of the traditional use of Prolog. Since the
situation calculus and Golog have a straightforward encoding as a
logic program, the off-the-shelf techniques for distributed logic
programming provided by the Mozart platform can be used to transparently
share the execution planning workload between team members.

There are, of course, a variety of other systems and formalisms that
could be used to model and implement our example domain. One popular
choice is to represent tasks using a variant of the Hierarchical Task
Networks formalism, which has been employed in systems such as STEAM
\citep{tambe97flexible_teamwork}, SharedPlans \citep{grosz96sharedplans},
and TAEMS \citep{decker95designing_coordination}.

The potential advantages of Golog over HTN-based approaches are discussed
in \citep{son00htn_golog}, where HTN-like constructs are added as
operators to the Golog language. They identify the following advantages:
powerful control over and composition of nondeterministic operators;
a more natural representation of many tasks thanks to common programming
constructs; and a more sophisticated logic of action.

Unlike some of the systems mentioned above, our approach pre-supposes
the existence of a fixed team of agents and their mutual commitment
to executing a shared task. Our implementation thus focuses entirely
on planning and performing the execution of such a task, without explicit
notions of cooperation or commitment. However, these techniques could
easily form a component of a higher-level multi-agent system based
on the situation calculus, such as the CASL framework \citep{shapiro02casl,lesperance05ecasl}.

The purpose of this chapter, then, is not to propose the MIndiGolog
approach as the ultimate solution for programming cooperative behaviour.
Rather, it serves to highlight the \emph{potential} of the situation
calculus and Golog for both modelling and implementing rich multi-agent
systems. Unfortunately, this potential has traditionally been limited
by some restrictions on the effective reasoning procedures of the
situation calculus, and this first incarnation of MIndiGolog has inherited
these limitations.

Most fundamentally, the output of our execution planning process assumes
that the domain is synchronous and that all actions are publicly observable.
As discussed in Chapter \ref{ch:intro}, this assumption is necessary
to allow agents to reason using standard regression techniques. It
also means that simple situation terms suffice as the output of the
planning process -- agents have all the information they need to coordinate
the performance of concurrent actions, and to ensure that actions
are performed in the correct order. For example, the execution in
Figure \ref{fig:MIndiGolog:MakeSalad-in-MIndiGolog} calls for $Jim$
to release $Bowl1$ and then for $Joe$ to acquire it in the next
timestep, implicitly assuming that the two agents are able to coordinate
these actions.

Consider, by contrast, an asynchronous domain in which some actions
are not public. If $Joe$ is not be able to observe the occurrence
of $Jim$ releasing the bowl, he would not know when to proceed with
acquiring it and execution of the plan would fail. To be sure that
the plans produced by our system can be executed in the real world,
we must assume that the agents execute their actions in lock-step
and always know the current state of execution -- in other words,
that there is constant synchronisation between the agents.

Another limitation is that MIndiGolog does only \emph{linear} planning,
and has no support for sensing actions. In the single-agent case the
execution of Golog programs that include sensing actions is well understood
\citep{giacomo99indigolog,lakemeyer99golog_cats}, but there is no
straightforward way to adopt these techniques to the implicit coordination
scheme used by this first incarnation of MIndiGolog -- it depends
crucially on the assumption that all agents have access to the same
information. Introducing sensing actions to MIndiGolog will require
more explicit reasoning about coordination based on the local information
available to each agent.

Existing situation calculus techniques for reasoning about the local
perspective of each agent are based on explicit notions of knowledge,
as described in Section \ref{sec:Background:Epistemic}. But even
these formalisms demand that the domain is synchronous, requiring
agents to always know how many actions have occurred, to allow reasoning
based on standard regression techniques. The situation calculus currently
offers no tools for reasoning about the local perspective of an agent
in asynchronous domains, where some action occurrences may be completely
hidden. To extend the reach of MIndiGolog - and the situation calculus
in general - to richer multi-agent settings, we must construct a principled
account of the local perspective of each agent, which can then be
used to reason explicitly about knowledge and coordination in asynchronous
domains.

