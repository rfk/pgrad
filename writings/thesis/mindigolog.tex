

\chapter{MIndiGolog}

\label{ch:mindigolog}

This chapter develops a Golog variant specifically designed for execution
in multi-agent domains. Motivated by the {}``cooking agents'' example
domain, we want to allow a team of agents to cooperatively plan and
perform the execution of a shared Golog program. As this chapter will
demonstrate, the existing features of the situation calculus go a
long way towards achieving this goal, but are ultimately limited to
execution in synchronous domains. 

We begin by integrating three existing extensions to the situation
calculus into the semantics of Golog to better represent the dynamics
of a multi-agent team. Key among these is true concurrency of actions,
which is combined with the standard interleaved concurrency of ConGolog
to give a flexible account of concurrent execution. An explicit notion
of time is incorporated to enrich the world model and to assist in
coordination between agents. Finally, the concept of natural actions
is tightly integrated into the language, allowing agents to predict
the behaviour of their teammates and environment. We name the resulting
language {}``MIndiGolog'' for {}``Multi-Agent IndiGolog''.

In addition to these new Golog semantics, we develop an innovative
implementation of our language using the distributed logic programming
features of the Mozart platform. Utilising the parallel search facility
as described in section \ref{sec:Background:Mozart/Oz}, the agents
can transparently share the workload of planning a program execution.
The ability to utilise off-the-shelf techniques such a parallel search
highlights the advantage of building a programming language on the
situation calculus, which allows the semantics to be straightforwardly
encoded as a logic program.

Concluding the chapter is a discussion of the limitations of this
first incarnation of MIndiGolog - specifically, that it can only operate
in fully-observable, synchronous domains. Subsequent chapters of this
thesis develop new extensions to the situation calculus which will
allow us to overcome these limitations.

Some of the material in this chapter has previously been published
as \citep{kelly06hlp_dps}.

The chapter proceeds as follows: section \ref{sec:MIndiGolog:Background}
provides some more detailed background material; section \ref{sec:MIndiGolog:Motivation}
uses the example of the cooking agents to motivate the changes we
will make to the standard Golog semantics; section \ref{sec:MIndiGolog:Semantics}
introduces the MIndiGolog semantics incorporating time, true concurrency
of actions, and natural actions, and proves the legality of our modifications;
section \ref{sec:MIndiGolog:Implementation} discusses our implementation
in Mozart including distributed execution planning; section \ref{sec:MIndiGolog:Example-Execution}
shows some example output produced by MIndiGolog and highlights the
improvement over existing Golog semantics; and finally section \ref{sec:MIndiGolog:Discussion}
discusses both the achievements and limitations of this first incarnation
of the language.


\section{Background: ReadyLog\label{sec:MIndiGolog:Background}}

The cooperative execution of a shared Golog program has been used
to great effect by \citet{Ferrein2005readylog} to control a RoboCup
soccer team. While their Golog variant {}``ReadyLog'' focuses on
decision-theoretic planning rather than the rich domain extensions
we consider below, their execution algorithm provides an excellent
introduction to the cooperative execution of Golog programs.

The aim of the ReadyLog execution algorithm is to allow agents to
coordinate their actions without needing to communicate. Each agent
is given their own individual copy of the shared program, and each
independently executes the IndiGolog planning process. When the planning
process generates a next action step that is to be performed by the
agent itself, it performs the action immediately. When the next step
is to be performed by another agent, it waits for its teammate to
perform the action before proceeding to the next step. The ReadyLog
execution algorithm is presented in Algorithm \ref{alg:readylog_exec}.

%
\begin{algorithm}[t]
 

\caption{The ReadyLog Execution Algorithm for program $\delta$}


\label{alg:readylog_exec} \begin{algorithmic} \STATE $s\ \Leftarrow\ S_{0}$
\WHILE{$\Dt\cup\Dt_{golog}\not\models Final(\delta,s)$} \STATE
Find an action $a$ and program $\delta'$ such that:\\
 $\Dt\cup\Dt_{golog}\models Trans^{*}(\delta,s,\delta',do(a,s))$
\IF{the action is to be performed by me} \STATE Execute the action
$a$ \ELSE \STATE Wait for the action to be executed \ENDIF \STATE
$s\ \Leftarrow\ do(a,s)$ \STATE $\delta\ \Leftarrow\ \delta'$ \ENDWHILE
\end{algorithmic} 
\end{algorithm}


Coordination arises in this setting by ensuring that the agents use
identical prolog interpreters, which will generate solutions in the
same order for each agent. So although each agents plans the program
execution independently, they are guaranteed to plan the \emph{same}
execution and their actions will therefore be coordinated without
needing to communicate.

However, the semantics of ReadyLog remain largely single-agent and
do not address concerns such as: the possibility of performing actions
concurrently and the coordination of concurrent actions; differing
knowledge or beliefs between team members; sharing the computational
workload of planning; and predicting the behaviour of teams members
and the environment in the face of many concurrently-executing tasks.
The semantics of MIndiGolog developed in this chapter answer some
of these challenges, while developments later in the thesis will be
used for others.


\section{Motivation\label{sec:MIndiGolog:Motivation}}

Recall the {}``cooking agents'' example domain from chapter \ref{ch:introduction}
-- several agents inhabit a kitchen along with various ingredients
and utensils, and they must cooperate to prepare a meal. Specifying
tasks in this domain requires an interesting combination of features.
There is much procedural knowledge about recipes that should be encoded
as precisely as possible, while at the same time there are a lot of
details of precisely who performs which steps when that do not need
to be specified by the programmer.

The Golog family of languages provide a compelling formalism for specifying
tasks in this domain, as the controlled nondeterminism they provide
can be used to elide certain details from the program while keeping
its procedural nature intact. Consider how we might specify the task
of making a simple salad, shown in figure \ref{fig:MIndiGolog:MakeSalad}.
Using the high-level nondeterministic operators of Golog, this program
says, in essence, {}``somebody chop a lettuce, somebody chop a carrot,
and somebody chop a tomato. Then, somebody mix them together''.

%
\begin{figure}
\begin{centering}
\framebox{%
\begin{minipage}[t][1\totalheight]{0.85\columnwidth}%
\begin{gather*}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt,ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt,ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt,ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt,\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right])\,\,\mathbf{end}\end{gather*}
 %
\end{minipage}} 
\par\end{centering}

\caption{A Golog program for making a salad\label{fig:MIndiGolog:MakeSalad}}

\end{figure}


Note that the explicit concurrency operators allow the three ingredients
to be chopped independently. Expanding on this example, the procedure
$ChopTypeInto$ could be specified as shown in figure \ref{fig:MIndiGolog:ChopTypeInto}.
Here the agent must select and acquire an object of the specified
type, as well as an available chopping board. He then places the object
on the board, chops it, and transfers it to the destination container.

%
\begin{figure}
\begin{centering}
\framebox{%
\begin{minipage}[t][1\totalheight]{0.85\columnwidth}%
\begin{gather*}
\mathbf{proc}\, ChopTypeInto(agt,type,dest)\\
\left[\pi(board,\, IsType(board,Board)?\,;\right.\\
\pi(obj,\, IsType(obj,type)?\,;\,\,\,\\
acquire(agt,board)\,;\\
acquire(agt,obj)\,;\\
place\_in(agt,obj,board)\,;\\
chop(agt,obj)\,;\\
acquire(agt,dest)\,;\\
transfer(agt,board,dest)\,;\\
release(agt,board)\,;\\
\left.\, release(agt,dest)))\right]\,\,\mathbf{end}\end{gather*}
 %
\end{minipage}} 
\par\end{centering}

\caption{A Golog program chopping an ingredient\label{fig:MIndiGolog:ChopTypeInto}}

\end{figure}


Notice that the programs do no specify which agent is to perform which
task - in fact they make no assertions about the particular agents
operating in the world at all. A library of procedures such as this
can be combined very flexibly to specify the behaviour of the cooking
agents, and the program could be given to any team of agents for execution.\\


These examples are all valid programs in an existing Golog variant
such as IndiGolog. However, executing them using the standard semantics
of IndiGolog would be far from ideal in a multi-agent setting. An
explicit temporal component would have to be added to accommodate
the $mix(dest,1)$ task. The lack of true concurrency would mean only
one agent could act at a time, while others would remain idle. And
since there is no support for natural actions, IndiGolog would fail
to find a legal execution of this program: it would find that the
final action $release$ cannot be performed after doing $beginTask$,
as our theory of action ensures agents can only be doing one thing
at a time. But it would not determine that the natural action $endTask$
will occur after one minute and enable to program to finish. In short,
the shared execution of programs such as this requires a robustly
multi-agent Golog semantics.


\section{MIndiGolog Semantics\label{sec:MIndiGolog:Semantics}}

We have integrated three extensions to the situation calculus with
the semantics of IndiGolog to better model the dynamics of a multi-agent
team. These extensions allow agents to represent time, concurrently-occurring
actions, and natural actions in a robust way. We use the extensions
of the situation calculus discussed in Chapter \ref{ch:background}
to model concurrent actions (Section \ref{sec:Background:Concurrency})
and explicit time (Section \ref{sec:Background:Time}).


\subsection{Time}

The semantics of IndiGolog are straightforwardly modified to accommodate
an explicit temporal component. We follow the approach of \citep{Reiter98seq_temp_golog,reiter01kia},
in which the transition rule for a single-action program is modified
to use $Legal$ instead of $Poss$:\[
Trans(a,s,\delta',s')\,\equiv\,\exists t:\, Legal(\{a\}\#t,s)\wedge\delta'=Nil\wedge s'=do(\{a\}\#t,s)\]


This basically ensures that the temporal components respect the ordering
between predecessor and successor situations. The key aspect here
is not the new transition rule, but the use of a linear constraint
solver to reason about time. The situations produced by the Golog
execution process are not fixed situation terms, but contain timepoint
variables that are constrained relative to each other.

For example, consider the following simple program:\[
placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Sugar,Bowl)\]


One output from a temporal Golog execution planner for this program
would be:\[
do(\{placeIn(Jim,Sugar,Bowl)\}\#t_{2},do(\{placeIn(Jim,Flour,Bowl)\}\#t_{1},S_{0}))\]


Where $t_{1}$ and $t_{2}$ are free variables giving the execution
times of each action. It would also output the following constraint
on this solution:\[
t_{2}>t_{1}\]


This solution that represents a family of possible legal executions
that respect the temporal ordering on situations. It is a simple matter
for the agents to instantiate these free variables by, for example,
grounding them to their smallest possible value.


\subsection{Concurrency}

To take advantage of true concurrency, we must first allow sets of
concurrent actions to appear in a MIndiGolog execution. The modified
$Trans$ clause for primitive actions shown in the previous section
already ensures that sets of concurrent actions are performed rather
than raw action terms.

However, this is clearly not enough to truly exploit the potential
for concurrency in a multi-agent team. As noted by \citet{pinto99tcongolog},
the concurrency operator should be modified to accept a concurrent
transition from both programs. The concurrency semantics they propose
for their variant {}``TConGolog'' are shown below:\begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\shoveright{\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2}:\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},s))}\\
\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},s)\end{multline*}


The first two lines are the standard rules for the concurrency operator,
encoding the interleaving of steps from programs $\delta_{1}$ and
$\delta_{2}$. The remaining lines permit the concurrent execution
of a transition from both programs. While this modification will take
advantage of the true concurrency of actions present in multi-agent
domains, it introduces several complications that \citep{pinto99tcongolog}
does not address.

First, precondition interaction means that $c_{1}\cup c_{2}$ may
not be possible even if the individual actions are. The transition
clause must ensure that the combination of the two sets of actions
is possible. Another issue arises when two programs can legitimately
be transitioned by executing the same action. Consider the following
programs which add ingredients to a bowl:\begin{gather*}
\delta_{1}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Sugar,Bowl)\\
\delta_{2}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Egg,Bowl)\end{gather*}
 Executing $\delta_{1}||\delta_{2}$ should result in the bowl containing
two units of flour, one unit of sugar and an egg. However, an individual
transition for both programs is $c_{1}=c_{2}=placeIn(Jim,Flour,Bowl)$.
Naively executing $c_{1}\cup c_{2}$ to transition both programs would
result in only one unit of flour being added.

Alternately, consider two programs waiting for a timer to ring:\begin{gather*}
\delta_{1}=ringTimer\,;\, acquire(Jim,Bowl)\\
\delta_{2}=ringTimer\,;\, acquire(Joe,Board)\end{gather*}
 Both programs should be allowed to proceed with a single occurrence
of the $ringTimer$ action, because it is an aspect of the environment
rather than a purposeful agent-initiated action.

In simple cases like these, it is easy for the programmer to see the
potential for such undesirable interaction and adjust their programs
accordingly. But in more complex cases with liberal use of nondeterminism,
it may not be possible to predict what actions can potentially be
executed concurrently. To avoid unintuitive (and potentially dangerous)
behaviour, concurrent execution must not be allowed to transition
both programs using the same \emph{agent-initiated} action. Exogenous
actions can safely transition two concurrent programs.

Taking these factors into account, and including an explicit temporal
component, we develop the improved transition rule for concurrency
in equation (\ref{eqn:trans_conc_new}). The first two lines are the
original interleaved concurrency clause from ConGolog, while the remainder
characterises the above considerations for true concurrency.\begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\shoveright{\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t:\, Trans(\delta_{1},s,\gamma_{1},do(c_{1}\#t,s))\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2}\#t,s))}\\
\shoveright{\wedge Legal((c_{1}\cup c_{2})\#t,s)\wedge\forall a:\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Exog(a)\right]}\\
\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do((c_{1}\cup c_{2})\#t,s)\label{eqn:trans_conc_new}\end{multline}


This robust combination allows the language to more accurately reflect
the concurrency present in multi-agent teams. As with ConGolog and
IndiGolog, our semantics make no attempt to maximise concurrency or
otherwise differentiate between potential executions, they only state
which transitions can be legally performed.


\subsection{Natural Actions}

While planning with natural actions has previously been done in Golog
\citep{pirri00planning_nat_acts}, the programmer was required to
explicitly check for any possible natural actions and ensure that
they appear in the execution. We significantly lower the burden on
the programmer by guaranteeing that all legal program executions result
in legal situations. MIndiGolog agents will plan for the occurrence
of natural actions without having them explicitly mentioned in the
program. They may optionally be included in the program, instructing
the agents to wait for the action to occur before proceeding.

This is achieved using a new $Trans$ clause for the case of a single
action $a$, as shown in equation (\ref{eqn:trans_prim_new}). If
$s$ has an LNTP $t_{n}$ and corresponding set of natural actions
$c_{n}$, a transition can be made in one of three ways: perform $a$
at a time before $t_{n}$ (fourth line), perform it along with the
natural actions at $t_{n}$ (fifth line), or wait for the natural
actions to occur (sixth line). If there is no LNTP, then $c$ may
be performed at any legal time.\begin{multline}
Trans(a,s,\delta',s')\equiv\\
\exists t,t_{n},c_{n}:\,\LNTP(s,t_{n})\wedge\PNA(s,c_{n})\wedge t\geq start(s)\wedge\\
\left[t<t_{n}\wedge Legal(\{a\}\#t,s)\wedge s'=do(\{a\}\#t,s)\wedge\delta'=Nil\right.\\
\vee Legal((\{a\}\cup c_{n})\#t_{n},s)\wedge s'=do((\{a\}\cup c_{n})\#t_{n},s)\wedge\delta'=Nil\\
\vee\left.s'=do(c_{n}\#t_{n},s)\wedge\delta'=a\right]\\
\vee\,\neg\exists t_{n}:\,\LNTP(s,t_{n})\wedge\exists t:\, Legal(\{a\}\#t,s)\wedge s'=do(\{a\}\#t,s)\wedge\delta'=Nil\label{eqn:trans_prim_new}\end{multline}


The occurrence of natural actions may also cause test conditions within
the program to become satisfied, so a new $Trans$ clause for the
test operator is also required as shown in equation (\ref{eqn:trans_cond_new}).
This permits a program consisting of a single test condition to make
a transition if the condition is satisfied, or if a natural action
occurs: \begin{multline}
Trans(\phi?,s,\delta',s')\,\,\equiv\,\,\phi[s]\wedge\delta'=Nil\wedge s'=s\\
\vee\,\exists t_{n},c_{n}:\,\LNTP(s,t_{n})\wedge\PNA(s,c_{n})\wedge\delta'=\phi?\wedge s'=do(c_{n}\#t_{n}s)\label{eqn:trans_cond_new}\end{multline}


A MIndiGolog execution will thus contain all natural actions that
will occur, regardless of whether they were considered explicitly
by the programmer.

Contrast this with the standard handling of exogenous events in IndiGolog,
which is achieved by executing the main program concurrently with
a program that generates exogenous actions:\[
\delta_{main}\,||\,\left(\pi(a)(Exog(a)?\,;\, a)\right)^{*}\]
 This allows the program to make a legal transition regardless of
what exogenous actions occur - an approach suitable for dealing with
arbitrary exogenous actions which may occur at any time, but suboptimal
for handling \emph{predictable} exogenous actions. Our approach allows
the agents to directly predict the natural actions that will occur
and automatically include them in a planned execution.


\subsection{Legality of the Semantics}

Let us denote by $\Dt_{mgolog}$ the standard Golog axioms $\Dt_{golog}$,
modified according to equations \eqref{eqn:trans_conc_new}, \eqref{eqn:trans_prim_new}
and \eqref{eqn:trans_cond_new}. All legal executions of a MIndiGolog
program derived from such a theory of action produce legal situations.

\begin{lemma}
The semantics of MIndiGolog entail:\label{lem:MIndiGolog:trans_legal}\[
\mathcal{D}\models\forall s,s',\delta,\delta':\, Legal(s)\wedge Trans(\delta,s,\delta',s')\rightarrow Legal(s')\]

\end{lemma}
\begin{proofsketch}
By induction on the structure of $\delta$. That the theorem holds
for the modified $Trans$ clauses of equations \eqref{eqn:trans_conc_new},
\eqref{eqn:trans_prim_new} and \eqref{eqn:trans_cond_new} is straightforward,
and no other clause constructs new situation terms. 
\end{proofsketch}
\begin{thm}
The semantics of MIndiGolog entail: \[
\mathcal{D}\models\forall s',\delta,\delta':\, Trans^{*}(\delta,S_{0},\delta',s')\rightarrow Legal(s')\]
 Thus, all legal executions of a MIndiGolog program produce legal
situations. 
\end{thm}
\begin{proof}
Immediate from lemma \ref{lem:MIndiGolog:trans_legal}, the legality
of $S_{0}$, and the properties of transitive closure. 
\end{proof}
Like standard IndiGolog, MIndiGolog will only call for actions to
be performed if it is actually possible to perform them. MIndiGolog
has the added advantage of effortlessly incorporating any natural
actions that may occur.


\section{Implementation\label{sec:MIndiGolog:Implementation}}

With these new semantics in place, it is now possible to build a multi-agent
planning system utilising MIndiGolog to specify the tasks to be performed.
As the existing languages based on Golog have demonstrated, an interpreter
can be conveniently constructed using a logic programming language
such a Prolog. We have followed the style of \citep{giacomo00congolog,giacomo99indigolog}
to build an interpreter for our language in Oz on the Mozart platform
\citep{vanroy03mozart_logic}.

One powerful feature of Mozart/Oz is the ability to use several networked
computers to search for solutions to a logic program in parallel.
Since the task of planning a MIndiGolog execution is encoded as a
logic program, this immediately allows a team of agents to distribute
the execution planning workload. Below we briefly summarise our implementation.

MIndiGolog programs are represented in Oz as record terms (which are
similar to Prolog data terms) with the name of the record representing
an operator and its features representing the arguments. Actions are
also encoded as records. For example, the program:\[
\pi(agt,\left[acquire(agt,Bowl);acquire(agt,Knife)\right])\]


is represented as follows:

\programinput{listings/mindigolog/goloz_ex_prog.oz}

$Trans$ and $Final$ have a straightforward encoding as Oz procedures,
using the \textbf{case} statement to encode each individual clause
using pattern matching, and the \textbf{choice} statement to explicitly
introduce choice points:

\programinput{listings/mindigolog/goloz_trans.oz}

A procedure $Do(\delta,s,s')\equiv Trans^{*}(\delta,s,\delta',s')\wedge Final(\delta',s')$
is defined that determines a legal execution \textbf{\emph{Sp}} for
a given program \textbf{\emph{D}}:

\programinput{listings/mindigolog/goloz_do.oz}

Using this implementation, a team of agents can perform an on-line
execution of a shared MIndiGolog program by following the Readylog
execution algorithm (TODO: ref). This approach requires no communication
between agents, but assumes they operate syncrhonously in order to
coordinate their concurrent actions. In such a setting, the semantics
for the search operator are implemented as follows:

TODO: original, non-parallel search implementation

However, the availability of Mozart's built-in parallel search facility
offers a compelling alternative for implementing the search operator.
While program components that appear outside the scope of a search
operator are expected to be executable on-line, and so will require
little deliberation on behalf of the agent. However, program components
enclosed within a search operator are likely to be quite computationally
demanding, potentially involving lots of computation effort to find
a solution. In particular, lots of backtracking. It therefore makes
sense to share the planning workload amongst the team.

The figure below shows the implementation of the search operator using
parallel search. If the executing agent is the team leader, it initiates
the parallel search procedure and, when a plan is found, sends the
details to the other members of the team. Subordinate team members
simply wait for the message to be recieved before continuing.

The ParallelDo procedure is shown below:

\programinput{listings/mindigolog/goloz_do_parallel.oz}

When this code is run, it will utilise the computational resources
of all team members to plan the execution of the enclosed MIndiGolog
program. Naturally, this technique will only work correctly if all
agents have access to the same information, which restricts the technique
to fully-observable domains.

TODO: this highlights the greatness of our approach, yadda yadda


\section{Example Execution\label{sec:MIndiGolog:Example-Execution}}

The effect of our new semantics can be seen in figure \ref{cap:example_trace},
which shows one possible legal execution of the $MakeSalad$ program
using the new semantics of MIndiGolog in a domain with thee agents.
Note the occurrence of several actions within each \textbf{do} statement,
demonstrating the integration of true concurrency into the language.
Note also the incorporation of natural $endTask$ actions into the
program, and the explicit occurrence time for each action. (in this
trace the occurrence times have been instantiated to their earliest
possible value).

%
\begin{figure*}[t]
 \centering \subfigure[One possible execution of the $MakeSalad$ program with three agents,
using MIndiGolog. Note the occurrence of multiple
actions within each do statement.]{ \label{cap:example_trace} \framebox{\makebox[1\textwidth]{%
\begin{minipage}[t][1\totalheight]{0.5\textwidth}%
{\small \verbatiminput{listings/mindigolog/output_makeSalad_1.txt}}%
\end{minipage}%
\begin{minipage}[t][1\totalheight]{0.45\textwidth}%
{\small \verbatiminput{listings/mindigolog/output_makeSalad_2.txt}}%
\end{minipage}}} } \subfigure[One possible execution of the $MakeSalad$ program with three
agents, using IndiGolog. Note that only one agent acts at
each step.]{ \label{cap:indigolog_trace} \framebox{\makebox[1\textwidth]{%
\begin{minipage}[t][1\totalheight]{0.5\textwidth}%
{\small \verbatiminput{listings/mindigolog/output_makeSalad_ig_1.txt}}%
\end{minipage}%
\begin{minipage}[t][1\totalheight]{0.45\textwidth}%
{\small \verbatiminput{listings/mindigolog/output_makeSalad_ig_2.txt}}%
\end{minipage}}} }

\caption{Example executions of the $MakeSalad$ program}

\end{figure*}


TODO: rename these agents in accordance with our new examples

For comparison purposes, we added a temporal element and inserted
explicit $endTask$ actions into $MakeSalad$ to allow a legal execution
to be found using the standard IndiGolog semantics. Such an execution
is shown in figure \ref{cap:indigolog_trace}. Note that the lack
of true concurrency means only a single agent can act at each step,
leaving the other two agents completely idle. The ability to reduce
idle time by performing actions concurrency is clearly an advantage
for distributed problem solving applications.


\section{Discussion\label{sec:MIndiGolog:Discussion}}

Our work in this chapter has integrated several important extensions
to the situation calculus and Golog to better model the dynamics of
multi-agent teams. Specifically, MIndiGolog combines true and interleaved
concurrency, an explicit account of time, and seamless integration
of natural actions. As we have shown by comparison to IndiGolog, it
defines legal executions of high-level programs that are much more
suitable for cooperative execution by a multi-agent team.

Since the semantics of MIndiGolog are based on first-order logic,
existing techniques for distributed logic programming can be used
to share the execution-planning workload between agents. In fully-observable
domains, the parallel search capabilities of Oz can be used directly.
This chapter thus represents a first step towards providing the advantages
of Golog (such as controlled nondeterminism, powerful programming
constructs, and a rich logic of action) for task specification for
multi-agent teams. However, the technique has some limitations that
restrict the domains in which it is applicable.

First, MIndiGolog does only linear planning -- there is no support
for sensing actions and the attendant branching based on sensing results.
There has been some work on branching planners in the situation calculus
{[}TODO:ref] and we will revisit the issue in the next chapter.

More fundamentally, the output of the execution planning process assumes
that all actions are known to all agents. For example, it calls for
Jim to release the bowl and Joe to then acquire it. To be sure that
these plans could be executed in the real world, we must assume that
the agents execute their actions in lock-step and always know the
current state of execution -- in other words, that there is constant
synchronisation between the agents.

Consider what would happen, by contrast, if the action of Jim releasing
the bowl was hidden from Joe. He would not know when it has been released
and so would not know when to acquire it. The plan could not then
be executed in the world.

TODO: concluding paragraph

