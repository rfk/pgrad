

\chapter{MIndiGolog}

\label{ch:mindigolog}

This chapter develops a Golog variant specifically designed for cooperative
execution in multi-agent domains. Motivated by the {}``cooking agents''
example domain, we want to allow a team of agents to cooperatively
plan and perform the execution of a shared Golog program. As this
chapter will demonstrate, the existing features of the situation calculus
go a long way towards achieving this goal, but are ultimately limited
to execution in synchronous domains.

We begin by integrating three existing extensions to the situation
calculus into the semantics of Golog to better represent the dynamics
of a multi-agent team. Key among these is true concurrency of actions,
which is combined with the standard interleaved concurrency of ConGolog
to give a flexible account of concurrent execution. An explicit notion
of time is incorporated to enrich the world model and to assist in
coordination between agents. Finally, the concept of natural actions
is tightly integrated into the language, allowing agents to predict
the behaviour of their teammates and environment. We name the resulting
language {}``MIndiGolog'' for {}``Multi-Agent IndiGolog''.

In addition to these new Golog semantics, we develop an innovative
implementation of our language using the distributed logic programming
features of the Mozart platform. Utilising the parallel search facility
as described in section \ref{sec:Background:Mozart/Oz}, the agents
can transparently share the workload of planning a program execution.
The ability to utilise off-the-shelf techniques such a parallel search
highlights the advantage of building a programming language on the
situation calculus, which allows the semantics to be straightforwardly
encoded as a logic program.

Concluding the chapter is a discussion of the limitations of this
first incarnation of MIndiGolog -- specifically, that it can only
operate in fully-observable, synchronous domains. Subsequent chapters
of this thesis develop new extensions to the situation calculus that
can help overcome this limitation.

The chapter proceeds as follows: section \ref{sec:MIndiGolog:Background}
provides some more detailed background material; section \ref{sec:MIndiGolog:Motivation}
uses the example of the cooking agents to motivate the changes we
will make to the standard Golog semantics; section \ref{sec:MIndiGolog:Semantics}
introduces the MIndiGolog semantics incorporating time, true concurrency
of actions, and natural actions, and proves the legality of our modifications;
section \ref{sec:MIndiGolog:Implementation} discusses our implementation
in Mozart and shows an example execution produced using the MIndiGolog
semantics; section \ref{sec:MIndiGolog:Distributed-Planning} discusses
the use of Mozart's parallel search functionality to share the planning
workload; and finally section \ref{sec:MIndiGolog:Discussion} discusses
both the achievements and limitations of this first incarnation of
the language.


\section{Background\label{sec:MIndiGolog:Background}}

There are two basic approaches to the use of Golog in a multi-agent
setting. The first, and most common, is to assign each agent its own
individual Golog program. The behaviour of the overall system is then
defined as the concurrent execution of the individual agent's programs:\[
\delta=\delta_{agt1}\,||\,\delta_{agt2}\,||\,\dots\,||\,\delta_{agtN}\]


This is the approach followed by the Cognitive Agents Specification
Language \citep{shapiro02casl} and {[}TODO more refs]. In such a
setting, the agents to not necessarily cooperate or coordinate their
actions, and it is assumed that \emph{any} legal execution of the
combined agent programs is a possible evolution of the entire system.

The second approach, and the one we follow here, is to have all agents
cooperate to plan and perform the joint execution of a single, shared
program. This program would typically be the concurrent execution
of several shared tasks:\[
\delta=\delta_{task1}\,||\,\delta_{task2}\,||\,\dots\,||\,\delta_{taskN}\]


This is the approach taken by the Golog variant {}``ReadyLog'' developed
by \citet{Ferrein2005readylog} to control the behaviour of a RoboCup
soccer team.

The one-program-per-agent approach can be considered a special case
of the shared-task approach, one which does not require coordination
or cooperative between team members. So while we focus exclusively
the on cooperative execution of a shared task in this and subsequent
chapters, the techniques we develop are likely to have application
in the case of multiple individual control programs as well.

While \citeauthor{Ferrein2005readylog} focus on decision-theoretic
planning rather than the rich domain extensions we consider below,
the execution algorithm they have developed for ReadyLog provides
an excellent introduction to the cooperative execution of Golog programs.

The aim of the ReadyLog execution algorithm is to allow agents to
coordinate their actions without needing to communicate. Each agent
is given their own individual copy of the shared program, and they
each independently execute the IndiGolog planning process to determine
the next step of execution. When an agent finds a next step where
the action is to be performed by the agent itself, it executes the
action immediately. When the next action is to be performed by another
agent, it waits for its teammate to execute the action before proceeding
to the next step. The ReadyLog execution algorithm is presented in
Algorithm \ref{alg:readylog_exec}.

%
\begin{algorithm}[t]
\caption{The ReadyLog Execution Algorithm for program $\delta$}


\label{alg:readylog_exec} \begin{algorithmic}

\STATE $s\ \Leftarrow\ S_{0}$

\WHILE{$\Dt\cup\Dt_{golog}\not\models Final(\delta,s)$}

\STATE Find an action $a$ and program $\delta'$ such that:\[
\Dt\cup\Dt_{golog}\models Trans^{*}(\delta,s,\delta',do(a,s))\]


\IF{the action is to be performed by me}

\STATE Execute the action $a$

\ELSE

\STATE Wait for the action to be executed

\ENDIF

\STATE $s\ \Leftarrow\ do(a,s)$

\STATE $\delta\ \Leftarrow\ \delta'$

\ENDWHILE

\end{algorithmic} 
\end{algorithm}


Coordination arises in this setting by ensuring that the agents use
identical prolog interpreters to determine each program step, which
will generate and test solutions in the same order for each agent.
So although each agent plans the program execution steps independently,
they are guaranteed to plan the \emph{same} execution steps and their
actions will therefore be coordinated without needing to communicate.

However, the semantics of ReadyLog remain largely single-agent and
do not address concerns such as the possibility of performing actions
concurrently, sharing the computational workload of planning, or predicting
the behaviour of team members and the environment in the face of many
concurrently-executing tasks.

The semantics of MIndiGolog that we develop in this chapter follow
a similar approach to ReadyLog, but we focus on incorporating rich
domain features such as concurrency and continuous time. While these
features have been added to Golog individually in existing works \citep{Reiter98seq_temp_golog,pinto99tcongolog,pirri00planning_nat_acts,reiter01kia},
our work is the first to provide a combined integration. We also rectify
some subtle problems with the semantics presented in existing approaches
to provide a more robust combination of rich domain features.


\section{Motivation\label{sec:MIndiGolog:Motivation}}

Recall the {}``cooking agents'' example domain from chapter \ref{ch:intro}
-- several agents inhabit a kitchen along with various ingredients
and utensils, and they must cooperate to prepare a meal. Specifying
tasks in this domain requires an interesting combination of features.
There is much procedural knowledge about recipes that should be encoded
as precisely as possible, while at the same time there are a lot of
details of precisely who performs which steps, or precisely when they
are performed, that should not be explicitly specified by the programmer.

The Golog family of languages provide a compelling formalism for specifying
tasks in this domain, as the controlled nondeterminism they provide
can be used to elide certain details from the program while keeping
its procedural nature intact. Consider how we might specify the task
of making a simple salad, shown in figure \ref{fig:MIndiGolog:MakeSalad}.
Using the high-level nondeterministic operators of Golog, this program
says, in essence, {}``somebody chop a lettuce, somebody chop a carrot,
and somebody chop a tomato. Then, somebody mix them together''.

%
\begin{figure}
\begin{centering}
\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\begin{gather*}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt,ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt,ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt,ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt,\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
endTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right])\,\,\mathbf{end}\end{gather*}
 %
}} 
\par\end{centering}

\caption{A Golog program for making a salad\label{fig:MIndiGolog:MakeSalad}}

\end{figure}


Note that the explicit concurrency operators allow the three ingredients
to be chopped independently, while the nondeterministic {}``pick''
operators allow any available agent to perform each sub-task. Expanding
on this example, the procedure $ChopTypeInto$ could be specified
as shown in figure \ref{fig:MIndiGolog:ChopTypeInto}. Here the agent
must select and acquire an object of the specified type, as well as
an available chopping board. He then places the object on the board,
chops it, and transfers it to the destination container.

%
\begin{figure}
\begin{centering}
\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\begin{gather*}
\mathbf{proc}\, ChopTypeInto(agt,type,dest)\\
\left[\pi(board,\, IsType(board,Board)?\,;\right.\\
\pi(obj,\, IsType(obj,type)?\,;\,\,\,\\
acquire(agt,board)\,;\\
acquire(agt,obj)\,;\\
placeIn(agt,obj,board)\,;\\
beginTask(agt,chop(board))\,;\\
endTask(agt,chop(board))\,;\\
acquire(agt,dest)\,;\\
transfer(agt,board,dest)\,;\\
release(agt,board)\,;\\
\left.\, release(agt,dest)))\right]\,\,\mathbf{end}\end{gather*}
 %
}} 
\par\end{centering}

\caption{A Golog program for chopping an ingredient\label{fig:MIndiGolog:ChopTypeInto}}

\end{figure}


Notice that the programs do no specify which agent is to perform which
task - in fact they make no assertions about the particular agents
operating in the world at all. A library of procedures such as this
can be combined very flexibly to specify the behaviour of the cooking
agents, and the resulting program could be given to any team of agents
for execution. For example, the agents can prepare several dishes
concurrently:

\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\[
MakeSalad()\,||\, MakePasta()\,||\, MakeCake()\]
 %
}}\\


One may even specify that different dishes need to be ready at different
times:

\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\begin{multline*}
\left(\left[MakeSalad()\,||\, MakePasta()\right]\,;\,?(time<7:30)\right)\\
||\,\left(MakeCake()\,;\,?(8:15<time<8:30)\right)\end{multline*}
 %
}}\\


In short, the situation calculus and Golog provide an extremely powerful
formalism for specifying cooperative agent behaviour domains such
as this.

However, executing these kinds of program using a standard Golog variant
is far from ideal in a multi-agent setting. To illustrate this we
have executed the $MakeSalad$ program using the standard semantics
of IndiGolog \citep{giacomo99indigolog}, augmented with an explicit
temporal component in the style of \citep{Reiter98seq_temp_golog}.
The resulting execution is shown in Figure \ref{fig:MIndiGolog:MakeSalad-in-IndiGolog}.

%
\begin{figure}
\framebox{%
\parbox[t][1\totalheight]{1\columnwidth}{%
\begin{center}
{\footnotesize \verbatiminput{listings/mindigolog/output_MakeSalad_I.txt}} 
\par\end{center}%
}}

\caption{Execution of $MakeSalad$ program using IndiGolog semantics\label{fig:MIndiGolog:MakeSalad-in-IndiGolog}}

\end{figure}


In this domain there are three agents $Joe$, $Jon$ and $Jim$. While
the resulting execution is legal, it is suboptimal in several ways.
The most obvious problem is that it does not take advantage of the
concurrency inherent in a team of agents. Only a single agent acts
at any one time, while the other agents are idle. Ideally the execution
planner should, where possible, exploit \emph{true concurrency} by
calling for multiple actions to be performed at each timestep.

Another shortcoming of the standard semantics are that they have no
support for predicting natural actions. This means we must specifying
unnecessary details in our programs, such as including the $endTask$
action in the definition of $MakeSalad$. Since these actions are
predictable, the planner should incorporate them automatically --
particularly in a multi-agent setting where there may be many natural
actions associate with long-running tasks.

The remainder of this chapter is dedicated to developing a robustly
multi-agent Golog semantics to overcome these issues, as well as an
implementation that can take advantage of them.


\section{MIndiGolog Semantics\label{sec:MIndiGolog:Semantics}}

We have integrated three extensions to the situation calculus with
the existing semantics of IndiGolog to better model the dynamics of
a multi-agent team. These extensions allow agents to represent time,
concurrently-occurring actions, and natural actions in a robust way.
We use the extensions of the situation calculus discussed in Chapter
\ref{ch:background} to model concurrent actions (Section \ref{sec:Background:Concurrency})
and explicit time (Section \ref{sec:Background:Time}). The arguments
to $do$, $Poss,$ etc will therefore be \noun{Concurrent\#Timepoint}
pairs rather than individual actions.

Why do we focus on these three extensions in particular? We consider
the ability to reason about true concurrency of actions to be fundamental
in planning for multi-agent domains, if only to ensure that actions
cannot come into conflict if performed concurrently. Once concurrent
actions are being considered, it makes sense to take advantage of
them where possible for concurrent program execution.

Natural actions form an important part of rich multi-agent domains
with many long-running tasks, as the $endTask$ action is a natural
action. As we shall see in the next chapter, they are also useful
for modelling delayed communication between agents. Since they are
entirely predictable based on the theory of action, we contend that
Golog should provide support for them at the semantic level to relieve
the programmer from having to specify them explicitly.

An explicit temporal component is a prerequisite for supporting natural
actions, and also provides for a much more convincing domain model,
particularly with the cooking agents example.


\subsection{Time}

The semantics of IndiGolog are straightforwardly modified to accommodate
an explicit temporal component. We follow the approach of \citep{Reiter98seq_temp_golog,reiter01kia},
in which the transition rule for a single-action program is modified
to use $Legal$ instead of $Poss$. Recall that the original transition
rule for this case is:\[
Trans(a,s,\delta',s')\,\equiv\, Poss(a,s)\wedge\delta'=Nil\wedge s'=do(a,s)\]


Modifying this to use concurrent actions and explicit time, and using
$Legal$ instead of $Poss$, we obtain:\begin{equation}
Trans(a,s,\delta',s')\,\equiv\,\exists t:\, Legal(\{a\}\#t,s)\wedge\delta'=Nil\wedge s'=do(\{a\}\#t,s)\label{eq:MIndiGolog:temp_trans_a}\end{equation}


This basically ensures that the temporal component respects the ordering
between predecessor and successor situations. The key aspect here
is not the new transition rule, but the use of a linear constraint
solver to reason about time. The situations produced by the Golog
execution process are not fixed situation terms, but contain timepoint
variables that are constrained relative to each other.

For example, consider the following simple program:\[
placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Sugar,Bowl)\]


One output from a temporal Golog execution planner for this program
would be:\[
do(\{placeIn(Jim,Sugar,Bowl)\}\#t_{2},do(\{placeIn(Jim,Flour,Bowl)\}\#t_{1},S_{0}))\]


Where $t_{1}$ and $t_{2}$ are free variables giving the execution
times of each action. It would also output the following constraint
on this solution:\[
t_{2}>t_{1}\]


This solution thus represents a family of possible legal executions
that respect the temporal ordering on situations. It is a simple matter
for the agents to instantiate these free variables by, for example,
grounding them to their smallest possible value.


\subsection{Concurrency}

To take advantage of true concurrency, we must first allow sets of
concurrent actions to appear in a MIndiGolog execution. The modified
$Trans$ clause for primitive actions shown in equation \ref{eq:MIndiGolog:temp_trans_a}
already ensures that sets of concurrent actions are performed rather
than raw action terms.

However, this is clearly not enough to truly exploit the potential
for concurrency in a multi-agent team. As noted by \citet{pinto99tcongolog},
the concurrency operator should be modified to accept a concurrent
transition from both programs. The concurrency semantics they propose
for their variant {}``TConGolog'' are shown below:\begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\:\,\,\,\,\,\,\,\,\,\shoveright{\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2}:\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},s))}\\
\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},s)\end{multline*}


The first two lines are the standard rules for the concurrency operator,
encoding the interleaving of steps from programs $\delta_{1}$ and
$\delta_{2}$. The remaining lines permit the concurrent execution
of a transition from both programs. While this modification will take
advantage of the true concurrency of actions present in multi-agent
domains, it introduces several complications that \citep{pinto99tcongolog}
does not address.

First, precondition interaction means that $c_{1}\cup c_{2}$ may
not be possible even if the individual actions are. The transition
clause must ensure that the combination of the two sets of actions
is possible. Another issue arises when two programs can legitimately
be transitioned by executing the same action. Consider the following
programs which add ingredients to a bowl:\begin{gather*}
\delta_{1}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Sugar,Bowl)\\
\delta_{2}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Egg,Bowl)\end{gather*}
 Executing $\delta_{1}||\delta_{2}$ should result in the bowl containing
two units of flour, one unit of sugar and an egg. However, an individual
transition for both programs is $c_{1}=c_{2}=\{placeIn(Jim,Flour,Bowl)\}$.
Naively executing $c_{1}\cup c_{2}$ to transition both programs would
result in only one unit of flour being added.

Alternately, consider two programs waiting for a timer to ring:\begin{gather*}
\delta_{1}=ringTimer\,;\, acquire(Jim,Bowl)\\
\delta_{2}=ringTimer\,;\, acquire(Joe,Board)\end{gather*}
 Both programs should be allowed to proceed with a single occurrence
of the $ringTimer$ action, because it is an aspect of the environment
rather than a purposeful agent-initiated action.

In simple cases like these, it is easy for the programmer to see the
potential for such undesirable interaction and adjust their programs
accordingly. But in more complex cases with liberal use of nondeterminism,
it may not be possible to predict what actions can potentially be
executed concurrently. To avoid unintuitive (and potentially dangerous)
behaviour, concurrent execution must not be allowed to transition
both programs using the same \emph{agent-initiated} action. Exogenous
actions can safely transition two concurrent programs.

Taking these factors into account, and including an explicit temporal
component, we develop the improved transition rule for concurrency
in equation (\ref{eqn:trans_conc_new}). The first two lines are the
original interleaved concurrency clause from ConGolog, while the remainder
characterises the above considerations to take advantage of true concurrency.\begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\shoveright{\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t:\, Trans(\delta_{1},s,\gamma_{1},do(c_{1}\#t,s))\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2}\#t,s))}\\
\shoveright{\wedge Legal((c_{1}\cup c_{2})\#t,s)\wedge\forall a:\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Exog(a)\right]}\\
\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do((c_{1}\cup c_{2})\#t,s)\label{eqn:trans_conc_new}\end{multline}


This robust integration of concurrent actions allows the language
to more accurately reflect the concurrency present in multi-agent
teams. Note that, like existing Golog variants such as ConGolog and
IndiGolog, our semantics make no attempt to maximise concurrency.
They do not differentiate between potential executions, but simple
state which transitions can be legally performed.


\subsection{Natural Actions}

While planning with natural actions has previously been done in Golog
\citep{pirri00planning_nat_acts}, the programmer was required to
explicitly check for any possible natural actions and ensure that
they appear in the execution. We significantly lower the burden on
the programmer by guaranteeing that all legal program executions result
in legal situations, inserting natural actions into the execution
when they are predicted to occur. MIndiGolog agents will thus plan
for the occurrence of natural actions without having them explicitly
mentioned in the program. They may optionally be included in the program,
instructing the agents to wait for the action to occur before proceeding.

This is achieved using a new $Trans$ clause for the case of a single
action $a$, as shown in equation (\ref{eqn:trans_prim_new}). If
$s$ has an LNTP $t_{n}$ and corresponding set of pending natural
actions $c_{n}$, a transition can be made in one of three ways: perform
$a$ at a time before $t_{n}$ (fourth line), perform it along with
the natural actions at $t_{n}$ (fifth line), or wait for the natural
actions to occur (sixth line). If there is no LNTP, then $c$ may
be performed at any legal time.\begin{multline}
Trans(a,s,\delta',s')\equiv\\
\exists t,t_{n},c_{n}:\,\LNTP(s,t_{n})\wedge\PNA(s,c_{n})\wedge t\geq start(s)\wedge\\
\left[t<t_{n}\wedge Legal(\{a\}\#t,s)\wedge s'=do(\{a\}\#t,s)\wedge\delta'=Nil\right.\\
\vee Legal((\{a\}\cup c_{n})\#t_{n},s)\wedge s'=do((\{a\}\cup c_{n})\#t_{n},s)\wedge\delta'=Nil\\
\vee\left.s'=do(c_{n}\#t_{n},s)\wedge\delta'=a\right]\\
\vee\,\neg\exists t_{n}:\,\LNTP(s,t_{n})\wedge\exists t:\, Legal(\{a\}\#t,s)\wedge s'=do(\{a\}\#t,s)\wedge\delta'=Nil\label{eqn:trans_prim_new}\end{multline}


The occurrence of natural actions may also cause test conditions within
the program to become satisfied, so a new $Trans$ clause for the
test operator is also required as shown in equation (\ref{eqn:trans_cond_new}).
This permits a program consisting of a single test condition to make
a transition if the condition is satisfied, or if a natural action
occurs: \begin{multline}
Trans(\phi?,s,\delta',s')\,\,\equiv\,\,\phi[s]\wedge\delta'=Nil\wedge s'=s\\
\vee\,\exists t_{n},c_{n}:\,\LNTP(s,t_{n})\wedge\PNA(s,c_{n})\wedge\delta'=\phi?\wedge s'=do(c_{n}\#t_{n}s)\label{eqn:trans_cond_new}\end{multline}


A MIndiGolog execution will thus contain all natural actions that
will occur, regardless of whether they were considered explicitly
by the programmer.

Contrast this with the standard handling of exogenous events in IndiGolog,
which is achieved by executing the main program concurrently with
a program that generates exogenous actions:\[
\delta_{main}\,||\,\left(\pi(a)(Exog(a)?\,;\, a)\right)^{*}\]
 This allows the program to make a legal transition regardless of
what exogenous actions occur - an approach suitable for dealing with
arbitrary exogenous actions which may occur at any time, but suboptimal
for handling \emph{predictable} exogenous actions. Our approach allows
the agents to directly predict the natural actions that will occur
and automatically include them in a planned execution.


\subsection{Legality of the Semantics}

Let us denote by $\Dt_{mgolog}$ the standard Golog axioms $\Dt_{golog}$,
modified according to equations \eqref{eqn:trans_conc_new}, \eqref{eqn:trans_prim_new}
and \eqref{eqn:trans_cond_new}. All legal executions of a MIndiGolog
program derived from such a theory of action produce legal situations.

\begin{lemma}
The semantics of MIndiGolog entail:\label{lem:MIndiGolog:trans_legal}\[
\mathcal{D}\cup\Dt_{mgolog}\models\forall s,s',\delta,\delta':\, Legal(s)\wedge Trans(\delta,s,\delta',s')\rightarrow Legal(s')\]

\end{lemma}
\begin{proofsketch}
By induction on the structure of $\delta$. That the theorem holds
for the modified $Trans$ clauses of equations \eqref{eqn:trans_conc_new},
\eqref{eqn:trans_prim_new} and \eqref{eqn:trans_cond_new} is straightforward,
and no other clause constructs new situation terms. 
\end{proofsketch}
\begin{thm}
The semantics of MIndiGolog entail: \[
\mathcal{D}\cup\Dt_{mgolog}\models\forall s',\delta,\delta':\, Trans^{*}(\delta,S_{0},\delta',s')\rightarrow Legal(s')\]
 Thus, all legal executions of a MIndiGolog program produce legal
situations. 
\end{thm}
\begin{proof}
Immediate from lemma \ref{lem:MIndiGolog:trans_legal}, the legality
of $S_{0}$, and the properties of transitive closure. 
\end{proof}
Like standard IndiGolog, MIndiGolog will only call for actions to
be performed if it is actually possible to perform them. MIndiGolog
has the added advantage of effortlessly incorporating any natural
actions that may occur.


\section{Implementation\label{sec:MIndiGolog:Implementation}}

With these new semantics in place, it is now possible to build a multi-agent
planning system utilising MIndiGolog to specify the tasks to be performed.
As the existing languages based on Golog have demonstrated, an interpreter
can be conveniently constructed using a logic programming language
such a Prolog. We have followed the style of \citep{giacomo00congolog,giacomo99indigolog}
to build an interpreter for our language using the Mozart programming
platform \citep{vanroy03mozart_logic}. Below we briefly summarise
our implementation.

MIndiGolog programs are represented in Mozart as record terms, with
the name of the record representing an operator and its features representing
the arguments. Actions are also encoded as records. For example, the
program:\[
\pi(agt,\left[acquire(agt,Bowl);acquire(agt,Knife)\right])\]


is represented as follows:

\programinput{listings/mindigolog/goloz_ex_prog.oz}

$Trans$ and $Final$ have a straightforward encoding as Mozart procedures,
using the \textbf{case} statement to encode each individual clause
using pattern matching, and the \textbf{choice} statement to explicitly
introduce choice points. The following are a selection of the operators
as they appear in our implementation:

\programinput{listings/mindigolog/goloz_trans.oz}

\programinput{listings/mindigolog/goloz_final.oz}

Of particular interest is our implementation of the concurrency operator,
reflecting the new semantics from equation \eqref{eqn:trans_conc_new}.
First, we introduce a subsidiary procedure \emph{Step} which calculates
a series of transitions to produce a single next action:

\programinput{listings/mindigolog/goloz_step.oz}

Then we can encode the semantics of concurrency using the following
case:

\programinput{listings/mindigolog/goloz_trans_conc.oz}

The first option presented by the choicepoint is the case for true
concurrency of actions. By putting this case first, a depth-first
search for executions will try to find a concurrent step before looking
for a step from only one of the programs. This simple detail is sufficient
to ensure a high degree of concurrency in the generated executions,
as we shall demonstrate in the next section.

A procedure $Do(\delta,s,s')\equiv Trans^{*}(\delta,s,\delta',s')\wedge Final(\delta',s')$
is defined that determines a legal execution $Sp$ for a given program
$D$:

\programinput{listings/mindigolog/goloz_do.oz}

This can then be used to define the semantics of the offline search
operator:

\programinput{listings/mindigolog/goloz_trans_search1.oz}

Using this implementation, a team of agents can plan and perform the
execution of a shared MIndiGolog program by following the ReadyLog
execution algorithm from Algorithm \ref{alg:readylog_exec}. The code
for the main control loop is shown below:

\programinput{listings/mindigolog/goloz_control.oz}

As in ReadyLog, each agent individually executes this control loop.
When the next step contains an action that is to be performed be the
agent, it execute it. Otherwise, it waits for the actions to be executed
before proceeding to the next iteration.

The effect of our new semantics can be seen in figure \ref{fig:MIndiGolog:MakeSalad-in-MIndiGolog}.
This shows the execution generated by our implementation for the $MakeSalad$
program from figure \ref{fig:MIndiGolog:MakeSalad}, using the new
semantics of MIndiGolog in a domain with thee agents. Note the execution
of several actions at each timestep, demonstrating the integration
of true concurrency into the language.

%
\begin{figure}
\framebox{%
\parbox[t][1\totalheight]{1\columnwidth}{%
\begin{center}
{\footnotesize \verbatiminput{listings/mindigolog/output_MakeSalad_M.txt}} 
\par\end{center}%
}}

\caption{Execution of $MakeSalad$ program using MIndiGolog semantics\label{fig:MIndiGolog:MakeSalad-in-MIndiGolog}}

\end{figure}


Compared to the non-concurrent execution generated by the standard
IndiGolog semantics (figure \ref{fig:MIndiGolog:MakeSalad-in-IndiGolog}),
our semantics clearly provide advantages of planning cooperative execution
in a multi-agent setting.


\section{Distributed Execution Planning\label{sec:MIndiGolog:Distributed-Planning}}

One powerful feature of Mozart is the ability to use several networked
computers to search for solutions to a logic program in parallel.
Since the task of planning a MIndiGolog execution is encoded as a
logic program, this immediately allows a team of agents to distribute
the execution planning workload.

However, there is a certain amount of computational and communication
overhead involved in such a search, so it must be used judiciously.
We argue as follows: parts of the program appearing outside the scope
of a search operator are intended for on-line execution, and so will
tend to require little deliberation by the agent. By contrast, program
components enclosed in a search operator are intended to require significant
planning to generate a legal execution. We therefore modify the case
for the search operator to perform distributed execution planning,
but leave the rest of the code intact.

The figure below shows the implementation of the search operator using
parallel search. If the executing agent is the team leader, it initiates
the parallel search procedure and, when a plan is found, sends the
details to the other members of the team. Subordinate team members
simply wait for the message to be received before continuing.

\programinput{listings/mindigolog/goloz_trans_search2.oz}

Note that this modification is completely transparent to the rest
of the implementation. While the details of sending messages are not
shown, the core implementation of the ParallelDo procedure is shown
below:

\programinput{listings/mindigolog/goloz_paralleldo.oz}

This packages up the task to be performed as a \emph{functor}, a portable
piece of code that can be shared across the network by all team members.
Input terms are serialised to a textual representation since variables
cannot be exported in functor definitions. It is then a simple matter
of creating a new $ParallelSearch$ object that spans all team members,
and asking it for a solution to the functor. When this code is run,
it will utilise the computational resources of all team members to
plan the execution of the enclosed MIndiGolog program.

As a brief demonstration of the advantages provided by this technique,
consider the suggestively-named program {}``HardToPlan'' shown in
Figure \ref{fig:MIndiGolog:HardToPlan}. This program asks the agents
to nondeterministically select and acquire objects of a variety of
types, and then tests whether certain specific objects have been acquired.
It has been constructed so that a single bad choice in the early stages
of execution planning - for example, having $Joe$ acquire $Carrot1$
instead of $Carrot3$ - can invalidate all choices subseuently made.
Planning a legal execution of this program thus requires a significant
amount of backtracking and should benefit greatly from parallelisation.

%
\begin{figure}
\begin{centering}
\framebox{%
\parbox[t][1\totalheight]{0.85\columnwidth}{%
\begin{gather*}
\mathbf{proc}\, HardToPlan()\\
\left[AcquireType(Joe,Carrot)\,;\right.\\
AcquireType(Jon,Sugar)\,;\\
AcquireType(Jim,Lettuce)\,;\\
AcquireType(Joe,Flour)\,;\\
AcquireType(Jon,Flour)\,;\\
HasObject(Jon,Carrot3)?\,;\\
HasObject(Joe,Flour5)?\,;\\
\left.\, HasObject(Jon,Sugar4)?\right]\,\,\mathbf{end}\\
\\\mathbf{proc}\, AcquireType(Agt,Type)\\
\pi(obj,\, IsType(obj,Type)?\,;\\
\left.\, acquire(Agt,obj)))\right]\,\,\mathbf{end}\end{gather*}
%
}} 
\par\end{centering}

\caption{A Golog program for which execution planning is difficult\label{fig:MIndiGolog:HardToPlan}}

\end{figure}


We used our MIndiGolog implementation to execute the program $\Sigma(HardToPlan)$
in two different ways - using parallel search as described above,
and having the team leader search for a legal execution on its own.
The program for team leader $Jon$ was executed on an AMD Althon 64
3000+, while the subordinate team members $Jim$ and $Joe$ each executed
on one core a TODO. Three test runs were performed for both parallel
and individual search. The times required to find a legal execution
are shown in Table \ref{tab:MIndiGolog:Execution-planning-times}
along with the speedup factor achieved by using parallel search.

%
\begin{table}
\begin{centering}
\begin{tabular}{|c|c|c|c|}
\hline 
 & \textbf{Individal Search} & \textbf{Parallel Search} & \textbf{Ratio Indiv/Para}\tabularnewline
\hline
\hline 
\textbf{Run 1} & 29.30 & 13.67 & 2.14\tabularnewline
\hline 
\textbf{Run 2} & 29.21 & 11.25 & 2.59\tabularnewline
\hline 
\textbf{Run 3} & 29.08 & 11.61 & 2.50\tabularnewline
\hline
\hline 
\textbf{Average} & 29.19 & 12.17 & 2.39\tabularnewline
\hline
\end{tabular}
\par\end{centering}

\caption{Execution planning times for $HardToPlan$, in seconds\label{tab:MIndiGolog:Execution-planning-times}}



\end{table}


These results shown an impressive decrease in execution planning time
with the use of parallel search - close to a factor of three speedup
using the computational resources of three agents. Of course, on programs
where execution planning is less difficult this advantage will be
reduced, but on difficult problems it can clearly provide significant
benefit.

The ability to implement this distributed execution planning with
so little code, and in a way that is completely transparent to the
rest of the program, highlights one of the major advantages of using
the situation calculus and Golog -- the ability to encode both the
domain and the execution planning problem as a simple logic program,
which is then amenable to off-the-shelf techniques for distributed
logic programming.


\section{Discussion\label{sec:MIndiGolog:Discussion}}

Our work in this chapter has integrated several important extensions
to the situation calculus and Golog to better model the dynamics of
multi-agent teams. Specifically, MIndiGolog combines true and interleaved
concurrency, an explicit account of time, and seamless integration
of natural actions. As we have shown by comparison to IndiGolog, it
defines legal executions of high-level programs that are much more
suitable for cooperative execution by a multi-agent team.

Since the semantics of MIndiGolog are based on first-order logic,
existing techniques for distributed logic programming can be used
to share the execution-planning workload between agents. In fully-observable
domains, the parallel search capabilities of Oz can be used directly.
This chapter thus represents a first step towards providing the advantages
of Golog (such as controlled nondeterminism, powerful programming
constructs, and a rich logic of action) for task specification for
multi-agent teams. However, the technique has some limitations that
restrict the domains in which it is applicable.

First, MIndiGolog does only linear planning and has no support for
sensing actions. In the single-agent case, IndiGolog uses the results
of sensing actions performed during on-line execution by planning
based on a history of action\#result pairs rather than a raw situation
term \citep{giacomo99indigolog}. To include sensing actions during
offline execution planning, a branching action structure is required.
This has been introduced in the single-agent case by the sGolog language
\citep{lakemeyer99golog_cats} and also in the IndiGolog planner implemented
by \citep{giacomo04sem_delib_indigolog}. There is no straightforward
way to adopt these techniques to this first MIndiGolog implementation,
as it depends on the assumption that all agents have access to the
same information. Since the results of a sensing action will only
be available to the agent that performed it, and hence cannot inform
the planning done by other team members, incorporating them would
violate this assumption.

More fundamentally, the output of the execution planning process assumes
that all actions are known to all agents. For example, it calls for
Jim to release the bowl and Joe to then acquire it. To be sure that
these plans could be executed in the real world, we must assume that
the agents execute their actions in lock-step and always know the
current state of execution -- in other words, that there is constant
synchronisation between the agents.

Consider what would happen, by contrast, if the action of Jim releasing
the bowl was hidden from Joe. He would not know when it has been released
and so would not know when to acquire it. The plan could not then
be executed in the world.

To account for both sensing actions and hidden actions will require
a more sophisticated action representation than raw situation terms
- a representation that can explicitly represent branching based on
different sensing results as well as ensuring that agents will always
know what action to perform next. Developing such a structure will
be the focus of chapter \ref{ch:jointexec}.

This first implementation of MIndiGolog thus demonstrates the potential
of the situation calculus for specifying and planning agent behaviour
in domains such as the cooking agents, but also shows that existing
techniques limit its applicability to synchronous domains.

