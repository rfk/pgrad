

\chapter{MIndiGolog}

\label{ch:mindigolog}

This chapter develops a Golog variant specifically designed for execution
in multi-agent domains. Motivated by the {}``cooking agents'' example
domain, we want to allow a team of agents to cooperatively plan and
perform the execution of a shared Golog program. As this chapter will
demonstrate, the existing features of the situation calculus go a
long way towards achieving this goal, but are ultimately limited to
execution in synchronous domains.

We begin by integrating three existing extensions to the situation
calculus into the semantics of Golog to better represent the dynamics
of a multi-agent team. Key among these is true concurrency of actions,
which is combined with the standard interleaved concurrency of ConGolog
to give a flexible account of concurrent execution. An explicit notion
of time is incorporated to enrich the world model and to assist in
coordination between agents. Finally, the concept of natural actions
is tightly integrated into the language, allowing agents to predict
the behaviour of their teammates and environment. We name the resulting
language {}``MIndiGolog'' for {}``Multi-Agent IndiGolog''.

In addition to these new Golog semantics, we develop an innovative
implementation of our language using the distributed logic programming
features of the Mozart platform. Utilising the parallel search facility
as described in section \ref{sec:Background:Mozart/Oz}, the agents
can transparently share the workload of planning a program execution.
The ability to utilise off-the-shelf techniques such a parallel search
highlights the advantage of building a programming language on the
situation calculus, which allows the semantics to be straightforwardly
encoded as a logic program.

Concluding the chapter is a discussion of the limitations of this
first incarnation of MIndiGolog - specifically, that it can only operate
in fully-observable, synchronous domains. Subsequent chapters of this
thesis develop new extensions to the situation calculus which will
allow us to overcome these limitations, and we will revisit MIndiGolog
in chapter \ref{ch:jointexec}.

The chapter proceeds as follows: section \ref{sec:MIndiGolog:Background}
provides some more detailed background material; section \ref{sec:MIndiGolog:Motivation}
uses the example of the cooking agents to motivate the changes we
will make to the standard Golog semantics; section \ref{sec:MIndiGolog:Semantics}
introduces the MIndiGolog semantics incorporating time, true concurrency
of actions, and natural actions, and proves the legality of our modifications;
section \ref{sec:MIndiGolog:Implementation} discusses our implementation
in Mozart including distributed execution planning; section \ref{sec:MIndiGolog:Example-Execution}
shows some example output produced by MIndiGolog and highlights the
improvement over existing Golog semantics; and finally section \ref{sec:MIndiGolog:Discussion}
discusses both the achievements and limitations of this first incarnation
of the language.


\section{Background\label{sec:MIndiGolog:Background}}

The cooperative execution of a shared Golog program has been used
to great effect by \citet{Ferrein2005readylog} to control a RoboCup
soccer team. While their Golog variant {}``ReadyLog'' focuses on
decision-theoretic planning rather than the rich domain extensions
we consider below, their execution algorithm provides an excellent
introduction to the cooperative execution of Golog programs.

The aim of the ReadyLog execution algorithm is to allow agents to
coordinate their actions without needing to communicate. Each agent
is given their own individual copy of the shared program, and each
independently executes the IndiGolog planning process. When the planning
process generates a next action step that is to be performed by the
agent itself, it performs the action immediately. When the next step
is to be performed by another agent, it waits for its teammate to
perform the action before proceeding to the next step.

%
\begin{algorithm}[t]
 

\caption{ReadyLog Execution Algorithm}


\label{alg:readylog_exec} \begin{algorithmic} \STATE $s\ \Leftarrow\ S_{0}$
\WHILE{$\Dt\cup\Dt_{golog}\not\models Final(\delta,s)$} \STATE
Find an action $a$ and program $\delta'$ such that:\\
$\Dt\cup\Dt_{golog}\models Trans^{*}(\delta,s,\delta',do(a,s))$ \IF{the
action is to be performed by me} \STATE Execute the action $a$
\ELSE \STATE Wait for the action to be executed \ENDIF \STATE
$s\ \Leftarrow\ do(a,s)$ \STATE $\delta\ \Leftarrow\ \delta'$ \ENDWHILE
\end{algorithmic} 
\end{algorithm}


Coordination arises by ensuring that the agents use identical prolog
interpreters, which will generate solutions in the same order for
each agent. So although each agents plans the program execution independently,
they are guaranteed to plan the \emph{same} execution and their actions
will therefore be coordinated without needing to communicate.

However, the semantics of ReadyLog remain largely single-agent and
do not address concerns such as: the possibility of performing actions
concurrently and the coordination of concurrent actions; differing
knowledge or beliefs between team members; sharing the computational
workload of planning; and predicting the behaviour of teams members
and the environment in the face of many concurrently-executing tasks.
The semantics of MIndiGolog developed in this chapter answer some
of these challenges, while developments later in the thesis will be
used for others.


\section{Motivation\label{sec:MIndiGolog:Motivation}}

Recall the {}``cooking agents'' example domain from chapter \ref{ch:introduction}
-- several agents inhabit a kitchen along with various ingredients
and utensils, and they must cooperate to prepare a meal. Specifying
tasks in this domain requires an interesting combination of features.
There is much procedural knowledge about recipes that should be encoded
as precisely as possible, while at the same time there are a lot of
details of precisely who performs which steps when that do not need
to be specified by the programmer.

The Golog family of languages provide a compelling formalism for specifying
tasks in this domain, as the controlled nondeterminism they provide
can be used to elide certain details from the program while keeping
its procedural nature intact. Consider how we might specify the task
of making a simple salad, shown in figure \ref{fig:MIndiGolog:MakeSalad}.
Using the high-level nondeterministic operators of Golog, this program
says, in essence, {}``somebody chop a lettuce, somebody chop a carrot,
and somebody chop a tomato. Then, somebody mix them together''.

%
\begin{figure}
\begin{centering}
\framebox{%
\begin{minipage}[t][1\totalheight]{0.85\columnwidth}%
\begin{multline*}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right]\,\,\mathbf{end}\end{multline*}
 %
\end{minipage}} 
\par\end{centering}

\caption{A Golog program for making a salad\label{fig:MIndiGolog:MakeSalad}}

\end{figure}


Note that the explicit concurrency operators allow the three ingredients
to be chopped independently. Expanding on this example, the procedure
$ChopTypeInto$ could be specified as shown in figure \ref{fig:MIndiGolog:ChopTypeInto}.
Here the agent must select and acquire an object of the specified
type, as well as an available chopping board. He then places the object
on the board, chops it, and transfers it to the destination container.

%
\begin{figure}
\begin{centering}
\framebox{%
\begin{minipage}[t][1\totalheight]{0.85\columnwidth}%
\begin{multline*}
\mathbf{proc}\, ChopTypeInto(agt,type,dest)\\
\left[\pi(board),\, IsType(board,Board)?\,;\right.\\
\pi(obj,\, IsType(obj,type)?\,;\,\,\,\\
acquire(agt,board)\,;\\
acquire(agt,obj)\,;\\
place\_in(agt,obj,board)\,;\\
chop(agt,obj)\,;\\
acquire(agt,dest)\,;\\
transfer(agt,board,dest)\,;\\
release(agt,board)\,;\\
\left.\, release(agt,dest)\right]\,\,\mathbf{end}\end{multline*}
 %
\end{minipage}} 
\par\end{centering}

\caption{A Golog program chopping an ingredient\label{fig:MIndiGolog:ChopTypeInto}}

\end{figure}


Notice that the programs do no specify which agent is to perform which
task - in fact they make no assertions about the particular agents
operating in the world at all. A library of procedures such as this
can be combined very flexibly to specify the behaviour of the cooking
agents, and the program could be given to any team of agents for execution.\\


These examples are all valid programs in an existing Golog variant
such as IndiGolog. However, executing them using the standard semantics
of IndiGolog would be far from ideal in a multi-agent setting. An
explicit temporal component would have to be added to accommodate
the $mix(dest,1)$ task. The lack of true concurrency would mean only
one agent could act at a time, while others would remain idle. And
since there is no support for natural actions, IndiGolog would fail
to find a legal execution of this program: it would find that the
final action $release$ cannot be performed after doing $beginTask$,
as our theory of action ensures agents can only be doing one thing
at a time. But it would not determine that the natural action $endTask$
will occur after one minute and enable to program to finish. In short,
the shared execution of programs such as this requires a robustly
multi-agent Golog semantics.


\section{MIndiGolog Semantics\label{sec:MIndiGolog:Semantics}}

We have integrated three extensions to the situation calculus with
the semantics of IndiGolog to better model the dynamics of a multi-agent
team. These extensions allow agents to represent time, concurrently-occurring
actions, and natural actions in a robust way.


\subsection{Concurrency}

To take advantage of true concurrency, we must first allow sets of
concurrent actions to appear in a MIndiGolog execution. This involves
modifying the the $Trans$ clause for primitive actions to insert
an action set into the output situation. This is quite a trivial change,
as shown below:\[
Trans(a,s,\delta',s')\equiv Poss(\{a\},s)\wedge\delta'=Nil\wedge s'=do(\{a\},s)\]


However, this is clearly not enough to truly exploit the potential
for concurrency in a multi-agent team. As noted by \citep{pinto99tcongolog}
the concurrency operator can be modified to accept a concurrent transition
from both programs. Their semantics are shown below:\begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\exists\gamma\,.\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})\\
\shoveright{\vee\exists\gamma\,.\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1}\#t,s))}\\
\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2}\#t,s))\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\end{multline*}


The first two lines are the standard rules for the concurrency operator,
encoding the interleaving of steps from programs $\delta_{1}$ and
$\delta_{2}$. The remaining lines permit the concurrent execution
of a transition from both programs. While this modification will take
advantage of the true concurrency of actions present in multi-agent
domains, it introduces several complications that \citep{pinto99tcongolog}
does not address.

First, precondition interaction means that $c_{1}\cup c_{2}$ may
not be possible even if the individual actions are. The transition
clause must ensure that the combination of the two sets of actions
is possible. Another issue arises when two programs can legitimately
be transitioned by executing the same action. Consider the following
programs which add ingredients to a bowl:\begin{gather*}
\delta_{1}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Sugar,Bowl)\\
\delta_{2}=placeIn(Jim,Flour,Bowl)\,;\, placeIn(Jim,Egg,Bowl)\end{gather*}
 Executing $\delta_{1}||\delta_{2}$ should result in the bowl containing
two units of flour, one unit of sugar and an egg. However, an individual
transition for both programs is $c_{1}=c_{2}=placeIn(Jim,Flour,Bowl)$.
Naively executing $c_{1}\cup c_{2}$ to transition both programs would
result in only one unit of flour being added. Alternately, consider
two programs waiting for a timer to ring:\begin{gather*}
\delta_{1}=ringTimer\,;\, acquire(Jim,Bowl)\\
\delta_{2}=ringTimer\,;\, acquire(Joe,Board)\end{gather*}
 Both programs should be allowed to proceed with a single occurrence
of the $ringTimer$ action, because it is an aspect of the environment
rather than a purposeful agent-initiated action.

In simple cases like these, it is easy for the programmer to see the
potential for such undesirable interaction and adjust their programs
accordingly. But in more complex cases with liberal use of nondeterminism,
it may not be possible to predict what actions can potentially be
executed concurrently. To avoid unintuitive (and potentially dangerous)
behaviour, concurrent execution must not be allowed to transition
both programs using the same \emph{agent-initiated} action. Exogenous
actions can safely transition two concurrent programs.

Taking these factors into account, we develop the improved transition
rule for concurrency in equation (\ref{eqn:trans_conc_new}). The
first two lines are the original interleaved concurrency clause from
ConGolog, while the remainder characterises the above considerations
for true concurrency.\begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\shoveright{\exists\gamma:\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma:\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t:\, Trans(\delta_{1},s,\gamma_{1},do(c_{1}\#t,s))\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2}\#t,s))}\\
\shoveright{\wedge Legal(c_{1}\cup c_{2}\#t,s)\wedge\forall a.\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Exog(a)\right]}\\
\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\label{eqn:trans_conc_new}\end{multline}


This robust combination allows the language to more accurately reflect
the concurrency present in multi-agent teams. As with ConGolog and
IndiGolog, our semantics make no attempt to maximise concurrency or
otherwise differentiate between potential executions, they only state
which transitions can be legally performed.


\subsection{Time}

The semantics of IndiGolog are trivially modified to accommodate an
explicit temporal component. We follow the approach of \citep{Reiter98seq_temp_golog,reiter01kia},
in which the transition rule for a single-action program is modified
to use $Legal$ instead of $Poss$:\[
Trans(a,s,\delta',s')\,\equiv\,\exists t:\, Legal(\{a\}\#t,s)\wedge\delta'=Nil\wedge s'=do(\{a\}\#t,s)\]


This basically ensures that the temporal components respect the ordering
present in the situation. The key aspect here is not the new transition
rule, but the use of a linear constraint solver to reason about time.
The situations produced by the Golog execution process are not fixed
situation terms, but contain timepoint variables that are constrained
relative to each other.

TODO: example here to illustrate this


\subsection{Natural Actions}

While planning with natural actions has previously been done in Golog
\citep{pirri00planning_nat_acts}, the programmer was required to
explicitly check for any possible natural actions and ensure that
they appear in the execution. We significantly lower the burden on
the programmer by guaranteeing that all legal program executions result
in legal situations. MIndiGolog agents will plan for the occurrence
of natural actions without having them explicitly mentioned in the
program. They may optionally be included in the program, instructing
the agents to wait for the action to occur before proceeding.

This is achieved using a new $Trans$ clause for the case of a single
action $a$, as shown in equation (\ref{eqn:trans_prim_new}). If
$s$ has an LNTP $t_{n}$ and corresponding set of natural actions
$c_{n}$, a transition can be made in three ways: perform $a$ at
a time before $t_{n}$ (fourth line), perform it along with the natural
actions at $t_{n}$ (fifth line), or wait for the natural actions
to occur (sixth line). If there is no LNTP, then $c$ may be performed
at any time greater than $start(s)$.\begin{multline}
Trans(a,s,\delta',s')\equiv\\
\exists t,t_{n},c_{n}\,.\,\LNTP(s,t_{n})\wedge\PNA(s,c_{n})\wedge t\geq start(s)\wedge\\
\left[t<t_{n}\wedge Legal(\{a\}\#t,s)\wedge s'=do(\{a\}\#t,s)\wedge\delta'=Nil\right.\\
\vee Legal(\{a\}\cup c_{n}\#t_{n},s)\wedge s'=do(\{a\}\cup c_{n}\#t,s)\wedge\delta'=Nil\\
\vee\left.s'=do(c_{n},\#t_{n},s)\wedge\delta'=a\right]\\
\vee\,\neg\exists t_{n}:\,\LNTP(s,t_{n})\wedge\exists t:\, Legal(\{a\}\#t,s)\wedge\\
do(\{a\}\#t,s)\wedge\delta'=Nil\label{eqn:trans_prim_new}\end{multline}


The occurrence of natural actions may also cause test conditions within
the program to become satisfied, so a new $Trans$ clause for $\phi?$
is also required as shown in equation (\ref{eqn:trans_cond_new}).
This permits a program consisting of a single test condition to make
a transition if the condition is satisfied, or if a natural action
occurs: \begin{multline}
Trans(\phi?,s,\delta',s')\,\,\equiv\,\,\phi[s]\wedge\delta'=Nil\wedge s'=s\\
\vee\,\exists t_{n},c_{n}:\,\LNTP(s,t_{n})\wedge\PNA(s,c_{n})\wedge\delta'=\phi?\wedge s'=do(c_{n}\#t_{n}s)\label{eqn:trans_cond_new}\end{multline}


A MIndiGolog execution will thus contain all natural actions that
will occur, regardless of whether they were considered explicitly
by the programmer.

Contrast this with the standard handling of exogenous events in IndiGolog,
which is achieved by executing the main program concurrently with
a program that generates exogenous actions:\[
\delta_{main}\,||\,\left(\pi(a)(Exog(a)?\,;\, a)\right)^{*}\]
 This allows the program to make a legal transition regardless of
what exogenous actions occur - an approach suitable for dealing with
arbitrary exogenous actions which may occur at any time, but suboptimal
for handling \emph{predictable} exogenous actions. Our approach allows
the agents to directly predict the natural actions that will occur
and automatically include them in a planned execution.


\subsection{Legality of the Semantics}

Let us denote by $\Dt_{mgolog}$ be the standard Golog axioms modified
according to equations \eqref{eqn:trans_conc_new}, \eqref{eqn:trans_prim_new}
and \eqref{eqn:trans_cond_new}. All legal executions of a MIndiGolog
program derived from such a theory of action produce legal situations.

\begin{lemma}
The semantics of MIndiGolog entail:\label{lem:MIndiGolog:trans_legal}\[
\mathcal{D}\models\forall s,s',\delta,\delta':\, Legal(s)\wedge Trans(\delta,s,\delta',s')\rightarrow Legal(s')\]

\end{lemma}
\begin{proofsketch}
By induction on the structure of $\delta$. That the theorem holds
for the modified $Trans$ clauses of equations \eqref{eqn:trans_conc_new},
\eqref{eqn:trans_prim_new} and \eqref{eqn:trans_cond_new} is straightforward,
and no other clause constructs new situation terms. 
\end{proofsketch}
\begin{thm}
The semantics of MIndiGolog entail: \[
\mathcal{D}\models\forall s',\delta,\delta':\, Trans^{*}(\delta,S_{0},\delta',s')\rightarrow Legal(s')\]
 Thus, all legal executions of a MIndiGolog program produce legal
situations. 
\end{thm}
\begin{proof}
Immediate from lemma \ref{lem:MIndiGolog:trans_legal}, the legality
of $S_{0}$, and the properties of transitive closure. 
\end{proof}
Like standard IndiGolog, MIndiGolog will only call for actions to
be performed if it is actually possible to perform them. MIndiGolog
has the added advantage of effortlessly incorporating any natural
actions that may occur.


\section{Implementation\label{sec:MIndiGolog:Implementation}}

With these new semantics in place, it is now possible to build a multi-agent
planning system utilising MIndiGolog to specify the tasks to be performed.
As the existing languages based on Golog have demonstrated, an interpreter
can be conveniently constructed using a logic programming language
such a Prolog. We have followed the style of \citep{giacomo00congolog,giacomo99indigolog}
to build an interpreter for our language in Oz on the Mozart platform
\citep{vanroy03mozart_logic}.

One powerful feature of Mozart/Oz is the ability to use several networked
computers to search for solutions to a logic program in parallel.
Since the task of planning a MIndiGolog execution is encoded as a
logic program, this immediately allows a team of agents to distribute
the execution planning workload. Below we briefly summarise our implementation.

MIndiGolog programs are represented in Oz as record terms (which are
similar to Prolog data terms) with the name of the record representing
an operator and its features representing the arguments. Actions are
also encoded as records. For example, the program:\[
\pi(agt)\left[acquire(agt,Bowl);acquire(agt,Knife)\right]\]


is represented as follows:

\programinput{listings/mindigolog/goloz_ex_prog.oz}
The predicates $Trans$ and $Final$ have a straightforward encoding
as Oz procedures, using the \textbf{case} statement to encode each
individual clause using pattern matching, and the \textbf{choice}
statement to explicitly introduce choice points:

\programinput{listings/mindigolog/goloz_trans.oz}
\programinput{listings/mindigolog/goloz_final.oz}
A procedure $Do(\delta,s,s')\equiv Trans^{*}(\delta,s,\delta',s')\wedge Final(\delta',s')$
is defined that determines a legal execution \textbf{\emph{Sp}} for
a given program \textbf{\emph{D}}:

\programinput{listings/mindigolog/goloz_do.oz}
This \textbf{\emph{Do}} procedure can then be passed to the parallel
search functionality to plan a program execution. Here {}``agent1''
and {}``agent2'' are the DNS names of agents in the team, and {}``Goloz''
is an Oz functor that exports the \textbf{\emph{Do}} procedure defined
above:

\programinput{listings/mindigolog/goloz_do_parallel.oz}
When this code is run, it will utilise the computational resources
of both agents to plan a legal execution of a given MIndiGolog program.
This requires that the same information is available to each agent,
which restricts the technique to fully-observable domains. For more
details on our implementation, see Appendix TODO.

%
\begin{algorithm}[t]
 

\caption{MIndiGolog Execution Algorithm}


\label{alg:mindigolog_exec} \begin{algorithmic} \STATE $s\ \Leftarrow\ S_{0}$
\WHILE{$\Dt\cup\Dt_{golog}\not\models Final(\delta,s)$} \STATE
Find an action $a$ and program $\delta'$ such that: $\Dt\cup\Dt_{golog}\models Trans^{*}(\delta,s,\delta',do(a,s))$
\IF{the action is to be performed by me} \STATE Execute the action
$a$ \ELSE \STATE Wait for the action to be executed \ENDIF \STATE
$s\ \Leftarrow\ do(a,s)$ \STATE $\delta\ \Leftarrow\ \delta'$ \ENDWHILE
\end{algorithmic} 
\end{algorithm}



\section{Example Execution\label{sec:MIndiGolog:Example-Execution}}

The effect of our new semantics can be seen in figure \ref{cap:example_trace},
which shows one possible legal execution of the $MakeSalad$ program
using the new semantics of MIndiGolog in a domain with thee agents.
Note the occurrence of several actions within each \textbf{do} statement,
demonstrating the integration of true concurrency into the language.
Note also the incorporation of natural $endTask$ actions into the
program, and the explicit occurrence time for each action. (in this
trace the occurrence times have been instantiated to their earliest
possible value).

%
\begin{figure*}[t]
 \centering \subfigure[One possible execution of the $MakeSalad$ program with three agents,
using MIndiGolog. Note the occurrence of multiple
actions within each do statement.]{ \label{cap:example_trace} \framebox{\makebox[1\textwidth]{%
\begin{minipage}[t][1\totalheight]{0.5\textwidth}%
{\small \verbatiminput{listings/mindigolog/output_makeSalad_1.txt}}%
\end{minipage}%
\begin{minipage}[t][1\totalheight]{0.45\textwidth}%
{\small \verbatiminput{listings/mindigolog/output_makeSalad_2.txt}}%
\end{minipage}}} } \subfigure[One possible execution of the $MakeSalad$ program with three
agents, using IndiGolog. Note that only one agent acts at
each step.]{ \label{cap:indigolog_trace} \framebox{\makebox[1\textwidth]{%
\begin{minipage}[t][1\totalheight]{0.5\textwidth}%
{\small \verbatiminput{listings/mindigolog/output_makeSalad_ig_1.txt}}%
\end{minipage}%
\begin{minipage}[t][1\totalheight]{0.45\textwidth}%
{\small \verbatiminput{listings/mindigolog/output_makeSalad_ig_2.txt}}%
\end{minipage}}} }

\caption{Example executions of the $MakeSalad$ program}

\end{figure*}


TODO: rename these agents in accordance with our new examples

For comparison purposes, we added a temporal element and inserted
explicit $endTask$ actions into $MakeSalad$ to allow a legal execution
to be found using the standard IndiGolog semantics. Such an execution
is shown in figure \ref{cap:indigolog_trace}. Note that the lack
of true concurrency means only a single agent can act at each step,
leaving the other two agents completely idle. The ability to reduce
idle time by performing actions concurrency is clearly an advantage
for distributed problem solving applications.


\section{Discussion\label{sec:MIndiGolog:Discussion}}

Our work in this chapter has integrated several important extensions
to the situation calculus and Golog to better model the dynamics of
multi-agent teams. Specifically, MIndiGolog combines true and interleaved
concurrency, an explicit account of time, and seamless integration
of natural actions. As we have shown by comparison to IndiGolog, it
defines legal executions of high-level programs that are much more
suitable for cooperative execution by a multi-agent team.

Since the semantics of MIndiGolog are based on first-order logic,
existing techniques for distributed logic programming can be used
to share the execution-planning workload between agents. In fully-observable
domains, the parallel search capabilities of Oz can be used directly.
This chapter thus represents a first step towards providing the advantages
of Golog (such as controlled nondeterminism, powerful programming
constructs, and a rich logic of action) for task specification for
multi-agent teams. However, the technique has some limitations that
restrict the domains in which it is applicable.

First, MIndiGolog does only linear planning -- there is no support
for sensing actions and the attendant branching based on sensing results.
There has been some work on branching planners in the situation calculus
{[}TODO:ref] and we will revisit the issue in the next chapter.

More fundamentally, the output of the execution planning process assumes
that all actions are known to all agents. For example, it calls for
Jim to release the bowl and Joe to then acquire it. To be sure that
these plans could be executed in the real world, we must assume that
the agents execute their actions in lock-step and always know the
current state of execution -- in other words, that there is constant
synchronisation between the agents.

Consider what would happen, by contrast, if the action of Jim releasing
the bowl was hidden from Joe. He would not know when it has been released
and so would not know when to acquire it. The plan could not then
be executed in the world.

TODO: concluding paragraph

