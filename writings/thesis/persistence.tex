

\chapter{Property Persistence}

\label{ch:persistence}

This chapter develops a new reasoning technique for the situation
calculus that can handle certain types of universally-quantified query.
As discussed briefly at the end of Chapter \ref{ch:observations},
for an agent in an asynchronous domain to reason about the world based
on its local information, it needs to pose queries that universally
quantify over situation terms. Unfortunately such queries cannot be
handled using the regression operator, and have thus far been beyond
the reach of automated reasoning systems for the situation calculus.

In this chapter we study a subset of universally-quantified queries
that we refer to as \emph{property persistence queries}. We introduce
an approach to reasoning that is similar in spirit to the standard
regression operator: transform the query into a form more amenable
to automated reasoning. A new meta-operator $\Pst_{\Dt}$ is defined
such that $\phi$ persists in $s$ if and only if $\Pst_{\Dt}(\phi)$
holds in $s$. We term the formulae generated by this operator the
\emph{persistence condition} of $\phi$.

The persistence condition is shown to be a fixpoint of applications
of the regression operator, which can be calculated using an iterative
approximation algorithm. The resulting formula can then be used in
combination with standard regression-based reasoning techniques.

The chapter proceeds as follows: after some more detailed background
material on inductive reasoning in the situation calculus in Section
\ref{sec:Persistence:Background}, we formally define the class of
property persistence queries in Section \ref{sec:Persistence:Definitions},
along with several examples of practical queries that are of this
form. Section \ref{sec:Persistence:Condition} defines the persistence
condition operator and demonstrates that it is the equivalent to the
result of a meta-level fixpoint calculation. Section \ref{sec:Persistence:Calculating}
presents a simple iterative algorithm for calculating the persistence
condition, and disucsses its correctness, completeness, and effectiveness.
We conclude with a brief discussion in Section \ref{sec:Persistence:Discussion}.


\section{Background\label{sec:Persistence:Background}}

While there is a rich and diverse literature base for the situation
calculus, there appears to have been little work dealing with universally
quantified queries. The work of \citet{Reiter93proving} shows how
to handle such queries manually using an appropriate instantiation
of the second-order induction axiom, but makes no mention of automating
this reasoning.

Other work considering queries that universally quantify over situations
seems to focus exclusively on verifying state constraints. These are
uniform formulae that must hold in every possible situation, a highly
specialized form of the more general persistence queries we define
in this chapter. The work of \citet{Lin94-StateConstraints} shows
that the induction axiom can be {}``compiles away'' when verifying
a state constraint, by means of the following equivalence:\begin{gather*}
\Dt\,\models\,\phi[S_{0}]\rightarrow\left(\forall s:\, S_{0}\leq s\rightarrow\phi[s]\right)\\
\mathit{iff}\\
\Dt_{una}\models\forall s,a:\,\phi[s]\wedge\Reg_{\Dt}(Poss(a,s))\,\rightarrow\,\Reg_{\Dt}[\phi[do(a,s)]]\end{gather*}
 Here the background theory contains only the unique names axioms
for action and is written $\Dt_{una}$/ Verification of a state constraint
can thus be reduced to reasoning about a universally quantified uniform
formula using only the background theory, a comparatively straightforward
reasoning task which we call \emph{static domain reasoning}. Verification
of state constraints was also approached by \citet{bertossi96automating},
with an automatic constraint verification system that uses an induction theorem prover.


However, there are many issues that are not addressed work specific
to staet constraints. What if we are interested in the future of some
arbitrariy situation $\sigma$, rather than only $S_{0}$? What if
want to restrict future actions according to an arbitrary action description
predicate? Can we integrate a method for handling universally-quantified
queries with existing regression techniques? Our treatment of property
persistence can provide a concrete basis for these considerations,
and is hence significantly more general than this existing work.

Another field that deals with induction over situations is the verification
of ConGolog programs. \citet{ternovska97congolog_fixpoint} show how
to formulate various safety, liveness, and starvation properties of
a ConGolog program as fixpoint queries in second-order logic. A preliminary
model-checker capable of verifying these properties is described in
\citep{ternovska02congolog_model_checker}. \citet{classen08golog_properties}
develop a logic of ConGolog programs in $\mathcal{ES}$, a variant
of the situation calculus based on modal logic. They demonstrate that
properties of a program can be verified using an iterative fixpoint
computation similar to the one we propose in this chapter.

As we shall see, property persistence queries are equivalent to a
particular kind of safety property of a ConGolog program, so our work
is in some ways less general than that described above. This allows
us to be more specific in our algorithm and approach. Also, these
ConGolog verifiers are designed to operate in isolation, while we
seek a method of handling universally-quantified queries that can
integrate directly with the existing meta-theorical reasoning machinery
of the situation calculus, in particular with the regression operator.


\section{Property Persistence Queries\label{sec:Persistence:Definitions}}

To begin, let us formally define the kinds of query that will be approached
in this chapter. Given some property $\phi$ and situation $\sigma$,
a \emph{property persistence query} asks whether $\phi$ will hold
in all situations in the future of $\sigma$: \[
\Dt\models\forall s:\,\sigma\sqsubseteq s\,\rightarrow\,\phi[s]\]


More generally, one may wish to limit the futures under consideration
to those brought about by actions satisfying a certain action description
predicate $\alpha$, which is easily accomplished using the $\leq_{\alpha}$
macro. We thus have the following definition of a persistence query:

\begin{defnL}
[{Property~Persistence~Query}] Let $\phi$ be a uniform
formula, $\alpha$ an action description predicate, and $\sigma$
a situation term. Then a property persistence query is a query of
the form:\[
\Dt\models\forall s:\,\sigma\le_{\alpha}s\rightarrow\phi[s]\]

\end{defnL}
In words, a persistence query states that {}``$\phi$ holds in $\sigma$,
and given that all subsequent actions satisfy $\alpha$, $\phi$ will
continue to hold''. For succinctness we will hencefore describe this
as {}``$\phi$ persists under $\alpha$''. Queries of this form
are involved in many useful reasoning tasks, of which the following
are a small selection:\\


\textbf{Goal Impossibility:} Given a goal $G$, establish that there
is no legal situation in which that goal is satisfied:\[
\Dt\models\forall s:\, S_{0}\leq_{Legal}s\rightarrow\neg G[s]\]
\\


\textbf{Goal Futility:} Given a goal $G$ and situation $\sigma$,
establish that the goal cannot be satisfied in any legal future of
$\sigma$:\[
\Dt\models\forall s:\,\sigma\leq_{Legal}s\rightarrow\neg G[s]\]


Note how this differs from goal impossibility: while the agent may
have initially been able to achieve its goal, the actions that have
subsequently been performed have rendered the goal unachievable. Agents
would be well advised to avoid such situations.\\


\textbf{Checking State Constraints:} Given a state constraint $SC$,
show that the constraint holds in every legal situation:\[
\Dt\models\forall s:\, S_{0}\leq_{Legal}s\rightarrow SC[s]\]
This can be seen as a variant of goal impossibility, by showing that
the constraint can never be violated.\\


\textbf{Need for Cooperation:} Given an agent $agt$, goal $G$ and
situation $\sigma$, establish that no sequence of actions performed
by that agent can achieve the goal:\[
\Dt\models\forall s:\,\sigma\leq_{actor=agt}s\rightarrow\neg G[s]\]
 If this is the case, the agent will need to seek cooperation from
another agent in order to achieve its goal.\\


\textbf{Knowledge with Hidden Actions:} An agent reasoning about its
own knowledge in asynchronous domains must account for arbitrarily-long
sequences of hidden actions. To establish that it knows $\phi$, it
must establish that $\phi$ cannot become false through a sequence
of hidden actions:\[
\Dt\models\forall s:\,\sigma\leq_{Hidden}s\rightarrow\phi[s]\]


This last case is our main motivation for the developments in this
chapter, and we will explore the use of property persistence in this
context in detail in Chapter \ref{ch:knowledge}. The other examples
are designed to show that persistence queries are quite a general
form of query, and the techniques developed in this chapter thus have
application beyond our specific use of them in the remainder of this
thesis.

Unfortunately, persistence queries do not meet the criteria for regressable
formulae found in Definition \ref{def:Background:Regressable-Formulae},
since they quantify over situation terms. Such queries therefore cannot
be handled using the standard regression operator. Indeed, since universal
quantification over situation terms requires the use of a second order
induction axiom, current systems needing to answer such queries must
resort to second-order theorem proving. This is hardly an attractive
propsect for effective automated reasoning.


\section{The Persistence Condition\label{sec:Persistence:Condition}}

To implement practical systems that can perform persistence queries,
we clearly need to transform the query into a form suitable for effective
automated reasoning. Our approach is to transform a property persistence
query at $\sigma$ into the evaluation of a uniform formula at $\sigma$.
This transformed query can then be handled effectively using the standard
regression operator.

To achieve this we need some transformation of a property $\phi$
and action description predicate $\alpha$ into a uniform formula
$\Pst_{\Dt}(\phi,\alpha)$ that is true at precisely
the situations in which $\phi$ persists under $\alpha$. We call
such a formula the \emph{persistence condition} of $\phi$ under $\alpha$.

\begin{defnL}
[{Persistence~Condition}] The persistence condition of $\phi$
under $\alpha$, denoted $\Pst_{\Dt}(\phi,\alpha)$,
is a uniform formula that is equivalent to the persistence of $\phi$
under $\alpha$ with respect to a basic action theory $\Dt$
without the initial situation axioms. Formally:\label{def:persistence-condition}\[
\Dt-\Dt_{S_{0}}\models\forall s:\,\left(\Pst_\Dt(\phi,\alpha)[s]\,\equiv\,\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\]

\end{defnL}
Defining $\Pst_{\Dt}$ to be independent of the initial
world state allows an agent to calculate it regardless of what (if
anything) is known about the actual state of the world -- after all,
an agent may not know all the details of $\Dt_{S_{0}}$, and we still
want to agent to be able to use this technique.

This definition alone clearly does not make the task of answering
a persistence query any easier, since it gives no indication of how
the persistence condition might be calculated in practise. Indeed,
we have not yet even shown whether the persistence condition actually
exists. In order to establish these results, we first need to define
the weaker notion of a formula \emph{persisting to depth $n$} in
a situation:

\begin{defnL}
[{Persistence~to~Depth}] A uniform formula $\phi$ persists
to depth 1 under $\alpha$ in situation $s$ when the formula $\Pst_{\Dt}^{1}(\phi,\alpha)[s]$
holds, as defined by:\label{def:persists-depth-n}\[
\Pst_{\Dt}^{1}(\phi,\alpha)\,\isdef\,\phi^{-1}\,\wedge\,\forall a:\,\Reg_\Dt(\alpha[a,s])^{-1}\rightarrow\Reg_{\Dt}(\phi[do(a,s)])^{-1}\]
 More generally, for any $n\geq0$, a uniform formula $\phi$ persists
to depth $n$ under $\alpha$ in situation $s$ when the formula $\Pst_{\Dt}^{n}(\phi,\alpha)[s]$
holds, as defined by:\begin{gather*}
\Pst_{\Dt}^{0}(\phi,\alpha)\,\isdef\,\phi\\
\Pst_{\Dt}^{n}(\phi,\alpha)\,\isdef\,\Pst_{\Dt}^{1}(\Pst_{D}^{n-1}(\phi,\alpha),\alpha)\end{gather*}

\end{defnL}
Note that $\Pst_{\Dt}^{1}$ is a literal encoding of
the requirement {}``$\phi$ holds in $s$ and in all its direct successors'',
using the standard regression operator $\Reg_{\Dt}$ and the situation-suppression
operator $\phi^{-1}$ to produce a situation-suppressed uniform formula.
Since $\alpha$ is an action description predicate and $\phi$ is
a uniform formula, the expressions $\Reg_\Dt(\alpha[a,s])^{-1}$
and $\Reg(\phi[do(a,s)])^{-1}$ are always defined and produce uniform
formulae. Successive applications of $\Pst_{\Dt}^{1}$
assert persistence to greater depths.

Intuitively, one would expect $\Pst_{\Dt}[\phi,\alpha]$
to be a fixpoint of $\Pst_{\Dt}^{1}[\phi,\alpha]$,
since $\Pst_{\Dt}[\phi,\alpha]$ must imply persistence
up to any depth. Such a fixpoint could then be calculated using standard
iterative approximation techniques. The remainder of this section
is devoted to verifying this intuition.

We begin by adapting two existing results involving induction to operate
with our generalized $\leq_{\alpha}$ notation, and be based at situations
other than $S_{0}$:

\begin{prop}
For any action description predicate $\alpha$, the foundational axioms
of the situation calculus entail the following induction principle:\label{prop:a-order-induction}\begin{multline*}
\forall W,s:\,\, W(s)\wedge\left[\forall a,s':\,\alpha[a,s']\wedge s\leq_{\alpha}s'\wedge W(s')\rightarrow W(do(a,s'))\right]\\
\rightarrow\forall s':\, s\leq_{\alpha}s'\rightarrow W(s')\end{multline*}

\end{prop}
\begin{proof}
A trivial adaptation of Theorem 1 in \citep{Reiter93proving}. 
\end{proof}
\begin{prop}
For any basic action theory $\Dt$, uniform formula $\phi$
and action description predicate $\alpha$:\label{prop:a-order-reduction}\begin{gather*}
\Dt-\Dt_{S_{0}}\models\forall s:\,\phi[s]\rightarrow\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\\
\mathit{iff}\\
\Dt_{bg}\models\forall s,a:\,\phi[s]\wedge\Reg_{\Dt}(\alpha[a,s])\rightarrow\Reg_{\Dt}(\phi[do(a,s)])\end{gather*}

\end{prop}
\begin{proof}
A straightforward generalization of the model-construction proof of
Lemma 5 in \citep{Lin94-StateConstraints}, utilizing Proposition
\ref{prop:a-order-induction}. We have also developed a shorter proof
using recent results from \citep{savelli06sc_quantum_levels}, which
is available in Appendix \ref{ch:proofs}. 
\end{proof}
Proposition \ref{prop:a-order-reduction} will be key in our algorithm
for calculating the persistence condition. It allows one to establish
the result {}``if $\phi$ holds in $s$, then $\phi$ persists in
$s$'' by using static domain reasoning, a comparatively straightforward
reasoning task.

We next formalize some basic relationships between $\Pst_{\Dt}$
and $\Pst_{\Dt}^{n}$.

\begin{lemma}
Given a basic action theory $\Dt$, uniform formula $\phi$
and action description predicate $\alpha$, then for any $n$:\label{lem:p-equiv-p(pn)}\[
\Dt-\Dt_{S_{0}}\models\forall s:\,\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\phi[s']\right)\,\equiv\,\left(\forall s':\, s\leq_{\alpha}s'\rightarrow\Pst_{D}^{n}(\phi,\alpha)[s']\right)\]
 That is, $\phi$ persists under $\alpha$ iff $\,\Pst_{\Dt}^{n}[\phi,\alpha]$
persists under $\alpha$. 
\end{lemma}
\begin{proof}
Since $\Pst_{\Dt}^{n}[\phi,\alpha]$ implies $\phi$ by definition,
the \emph{if} direction is trivial. For the \emph{only-if} direction
we proceed by induction on $n$.

For the base case, assume that $\phi$ persists but $\Pst_{\Dt}^{1}(\phi,\alpha)$
does not, then we must have some $s'$ with $s\leq_{\alpha}s'$ and
$\neg\Pst_{\Dt}^{1}[\phi,\alpha][s']$. By the definition of $\Pst_{\Dt}^{1}$,
this means that:\[
\neg\left(\phi[s']\,\wedge\,\forall a:\,\alpha[a,s']\rightarrow\phi[do(a,s')]\right)\]


Since $\phi$ persists it must hold at $s'$, so there must be some
$a$ such that $\alpha[a,s']$ and $\neg\phi[do(a,s')]$. But $s\leq_{\alpha}do(a,s')$
and so $\phi[do(a,s')]$ must hold by our assumption that $\phi$
persists, and we have a contradiction.

For the inductive case, assume that $\Pst_{\Dt}^{n-1}(\phi,\alpha)$
persists but $\Pst_{\Dt}^{n}(\phi,\alpha)$ does not. By definition
we have $\Pst_{\Dt}^{n}(\phi,\alpha)=\Pst_{\Dt}^{1}(\Pst_{\Dt}^{n-1}(\phi,\alpha),\phi)$,
and we repeat the base case proof using $\phi'=\Pst_{\Dt}^{n-1}(\phi,\alpha)$
in place of $\phi$ to obtain a contradiction. 
\end{proof}
\begin{lemma}
Given a basic action theory $\Dt$, uniform formula $\phi$
and action description predicate $\alpha$, then for any $n$:\label{lem:p-implies-pn}\[
\Dt-\Dt_{S_{0}}\models\forall s:\,\left(\Pst_\Dt(\phi,\alpha)[s]\rightarrow\Pst_{\Dt}^{n}(\phi,\alpha)[s]\right)\]

\end{lemma}
\begin{proof}
$\Pst_\Dt(\phi,\alpha)$ implies the persistence of $\phi$
by definition. If $\phi$ persists at $s$, then by Lemma \ref{lem:p-equiv-p(pn)}
we have that $\Pst_{\Dt}^{n}(\phi,\alpha)$ persists at $s$ . Since
the persistence of $\Pst_{\Dt}^{n}(\phi,\alpha)$ at
$s$ implies that $\Pst_{\Dt}^{n}(\phi,\alpha)$ holds
at $s$ by definition, we have the lemma as desired. 
\end{proof}
We are now equipped to prove the major theorem of this chapter: that
if $\Pst_{\Dt}^{n}(\phi,\alpha)$ implies $\Pst_{\Dt}^{n+1}(\phi,\alpha)$,
then $\Pst_{\Dt}^{n}(\phi,\alpha)$ is equivalent to
the persistence condition for $\phi$ under $\alpha$.\newpage{}

\begin{thm}
Given a basic action theory $\Dt$, uniform formula $\phi$
and action description predicate $\alpha$, then for any $n$:\label{thm:p(pn)-equiv-p}\begin{gather}
\Dt_{bg}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\Pst_{\Dt}^{n+1}(\phi,\alpha)[s]\label{eqn:pn_persists}\\
\mathit{iff}\nonumber \\
\Dt-\Dt_{s_{0}}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\equiv\Pst_\Dt(\phi,\alpha)[s]\label{eqn:pn_equiv_persists}\end{gather}

\end{thm}
\begin{proof}
For the \emph{if} direction, we begin by expanding equation \eqref{eqn:pn_persists}
using the definition of $\Pst_{\Dt}^{1}$ to get the
equivalent form:\begin{gather*}
\Dt_{bg}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\Pst_{\Dt}^{1}(\Pst_{\Dt}^{n}(\phi,\alpha),\alpha)[s]\\
\Dt_{bg}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\left(\Pst_{\Dt}^{n}(\phi,\alpha)[s]\wedge\forall a:\,\Reg_{\Dt}(\alpha[a,s])\rightarrow\Reg_{\Dt}(\phi[do(a,s)])\right)\\
\Dt_{bg}\models\forall s,a:\,\Pst_{\Dt}^{n}(\phi,\alpha)\wedge\forall a:\,\Reg_{\Dt}(\alpha[a,s])\rightarrow\Reg_{\Dt}(\phi[do(a,s)])[s]\end{gather*}
 By Proposition \ref{prop:a-order-reduction}, equation \eqref{eqn:pn_persists}
thus lets us conclude that $\Pst_{\Dt}^{n}(\phi,\alpha)$
persists under $\alpha$. By Lemma \ref{lem:p-equiv-p(pn)} this is
equivalent to the persistence of $\phi$ under $\alpha$, which is
equivalent to $\Pst_\Dt[\phi,\alpha]$ by definition, giving:\[
\Dt-\Dt_{s_{0}}\models\forall s:\,\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\Pst_\Dt(\phi,\alpha)[s]\]
 By Lemma \ref{lem:p-implies-pn} this implication is an equivalence,
yielding equation (\ref{eqn:pn_equiv_persists}) as required.

The \emph{only if} direction is a straightforward reversal of this
reasoning: $\Pst_\Dt(\phi,\alpha)$ implies the persistence
of $\phi$, which implies the persistence of $\Pst_{\Dt}^{n}(\phi,\alpha)$,
which yields equation (\ref{eqn:pn_persists}) by Proposition \ref{prop:a-order-reduction}. 
\end{proof}
Since $\Dt_{bg}\models\Pst_{\Dt}^{n+1}(\phi,\alpha)\rightarrow\Pst_{\Dt}^{n}(\phi,\alpha)$
by definition, equation (\ref{eqn:pn_persists}) identifies $\Pst_{\Dt}^{n}(\phi,\alpha)$
as a fixpoint of the $\Pst_{\Dt}^{1}$ operator, as
our initial intuition suggested. In fact, we can use the constructive
proof of Tarski's fixpoint theorem \citep{cousot79constructive_tarski}
to establish that the persistence condition always exists for a given
$\phi$ and $\alpha$.

\begin{thm}
Given a uniform formula $\phi$ and action description predicate $\alpha$,
the persistence condition $\Pst_{\Dt}(\phi,\alpha)$ always exists,
and is unique up to equivalence under the static background theory
$\Dt_{bg}$. \label{thm:p-always-exists} 
\end{thm}
\begin{proof}
Let $L$ be the subset of the Lindenbaum algebra of the static background
theory $\Dt_{bg}$ containing only sentences uniform in $s$. $L$
is thus a boolean lattice in which each element is a set of sentences
uniform in $s$ that are equivalent under $\Dt_{bg}$. $L$ is a complete
lattice with minimal element the equivalence class of $\bot$ and
maximal element the equivalence class of $\top$. Fixing $\alpha$,
$\PstDI$ is a function whose domain and range are the elements of
$L$.

By definition, we have that $\PstDI(\phi,\alpha)\,\rightarrow\,\phi$,
and $\PstDI$ is thus a \emph{monotone decreasing} function over $L$.
By the constructive proof of Tarski's fixpoint theorem, $\PstDI$
must have a unique greatest fixpoint less than the equivalence class
of $\phi$, which can be determined by transfinite iteration of the
application of $\PstDI$. By Theorem \ref{thm:p(pn)-equiv-p}, this
fixpoint is the equivalence class of $\Pst_{\Dt}(\phi,\alpha)$ under
$\Dt_{bg}$. 
\end{proof}
This theorem legitimates the use of the persistence condition for
reasoning about property persistence queries -- for any persistence
query at situation $\sigma$, there is a unique (up to equivalence)
corresponding query that is uniform in $\sigma$ and is thus amenable
to standard effective reasoning techniques of the situation calculus.

The definition of $\Pst(\phi,\alpha)$ as a fixpoint also suggests
that it can be calculated by iterative approximation, which we discuss
in the next section.


\section{Calculating $\Pst$\label{sec:Persistence:Calculating}}

Since we can easily calculate $\Pst_{\Dt}^{n}(\phi,\alpha)$
for any $n$, we have a straightforward algorithm for determining
$\Pst_\Dt(\phi,\alpha)$: search for an $n$ such that\[
\Dt_{bg}\models\forall s:\,\left(\Pst_{\Dt}^{n}(\phi,\alpha)[s]\rightarrow\Pst_{\Dt}^{n+1}(\phi,\alpha)[s]\right)\]
 Since we expect $\Pst_{\Dt}^{n}(\phi,\alpha)$ to
be simpler than $\Pst_{\Dt}^{n+1}(\phi,\alpha)$, we
should look for the smallest such $n$. Algorithm \ref{alg:calc_p}
presents an iterative procedure for doing just that.

%
\begin{algorithm}
\caption{Calculate $\Pst_{\Dt}[\phi,\alpha]$}


\label{alg:calc_p} \begin{algorithmic} \STATE $\mathtt{pn}\Leftarrow\phi$
\STATE $\mathtt{pn1}\Leftarrow\Pst_{\Dt}^{1}(\mathtt{pn},\alpha)$
\WHILE{$\Dt_{bg}\not\models\forall s:\,\mathtt{pn}[s]\rightarrow\mathtt{pn1}[s]$}
\STATE $\mathtt{pn}\Leftarrow\mathtt{pn1}$ \STATE $\mathtt{pn1}\Leftarrow\Pst_{\Dt}^{1}[\mathtt{pn},\alpha]$
\ENDWHILE \RETURN $\mathtt{pn}$ \end{algorithmic} 
\end{algorithm}


Note that the calculation of $\Pst_{\Dt}^{1}(\phi,\alpha)$
is a straightforward syntactic transformation, so we do not present
an algorithm for it.


\subsection{Correctness}

If Algorithm \ref{alg:calc_p} terminates, it terminates returning
a value of $pn$ for which equation (\ref{eqn:pn_persists}) holds.
By Theorem \ref{thm:p(pn)-equiv-p} this value of $pn$ is equivalent
to the persistence condition for $\phi$ under $\alpha$. The algorithm
therefore correctly calculates the persistence condition.

Note that equation (\ref{eqn:pn_persists}) holds when $\Pst_{\Dt}^{n}[\phi,\alpha]$
is unsatisfiable for any situation, as it appears in the antecedent
of the implication. The algorithm thus correctly returns an unsatisfiable
condition (equivalent to $\bot$) when $\phi$ can never persist under
$\alpha$.


\subsection{Completeness}

Since Theorem \ref{thm:p(pn)-equiv-p} is an equivalence, the persistence
condition is always the fixpoint of $\PstDI$. From Theorem \ref{thm:p-always-exists}
this fixpoint always exists and can be calculated by transfinite iteration.
Therefore, the only source of incompleteness in our algorithm will
be failure to terminate. Algorithm \ref{alg:calc_p} may fail to terminate
for two reasons: the loop condition may never be satisfied, or the
first-order logical inference in the loop condition may be undecidable
and fail to terminate.

The later case indicates that the basic action theory $\Dt$
is undecidable. While this is a concern, it affects more than just
our algorithm - any system implemented around such an action theory
will be incomplete. Thus, with respect to this source of incompleteness,
our algorithm is no more incomplete than any larger system it would
form a part of.

The former case is of more direct consequence to our work. Unfortunately,
there is no guarantee in general that the fixpoint can be reached
via \emph{finite} iteration, which is required for termination of
Algorithm \ref{alg:calc_p}.

Indeed, it is straightforward to construct a fluent for which the
algorithm never terminates: consider a fluent $F(x,s)$ that is affected
by a single action that makes it false whenever $F(suc(x),s)$ is
false. Letting $\alpha$ be vacuously true, the sequence of iterations
produced by our algorithm would be:\begin{gather*}
\Pst_{\Dt}^{1}(F(x,s))\equiv F(x,s)\wedge F(suc(x),s)\\
\Pst_{\Dt}^{2}(F(x,s))\equiv F(x,s)\wedge F(suc(x),s)\wedge F(suc(suc(x)),s)\\
\vdots\\
\Pst_{\Dt}^{n}(F(x,s))\equiv\bigwedge_{i=0}^{i=n}F(suc^{i}(x),s)\end{gather*}
 The persistence condition in this case is clearly: \[
\Pst_{\Dt}(F(x,s))\equiv\forall y:\, x\leq y\rightarrow F(y,s)\]
 While this is equivalent to the infinite conjunction produced as
the limit of iteration in our algorithm, it will not be found after
any finite number of steps.

As discussed in the proof of Theorem \ref{thm:p-always-exists}, $\Pst_{\Dt}^{1}$
operates over the boolean lattice of equivalence classes of formulae
uniform in $s$, and the theory of fixpoints requires that this lattice
be \emph{well-founded} to guarantee termination of an iterative approximation
algorithm such as Algorithm \ref{alg:calc_p}. We must therefore identify
restricted kinds of basic action theory for which this well-foundedness
can be guaranteed.

The most obvious case is theories in which the action and object sorts
are finite. In such theories the lattice of equivalence classes of
formulae uniform in $s$ is finite, and any finite lattice is well-founded.
These theories also have the advantage that the static domain reasoning
performed by Algorithm \ref{alg:calc_p} can be done using proposition
logic, meaning it is decidable and thus providing a very strong termination
guarantee.

TODO: more discussion here -- well-founded successor-state axioms

It may also be the case that more sophisticated fixpoint algorithms
can achieve termination in more complex basic action theories. Investigating
such algorithms would be a promising avenue for future research, but
would take us too far afield in this thesis.


\subsection{Effectiveness}

Our algorithm replaces a single reasoning task based on the full action
theory $\Dt$ with a series of reasoning tasks based on the
static background theory $\Dt_{bg}$. Is this a worthwhile trade-off
in practice? The following points weigh strongly in favor of our approach.

First and foremost, we avoid the need for the second-order induction
axiom. All the reasoning tasks can be performed using standard first-order
reasoning, for which there are high-quality automated provers. Second,
the calculation of $\Pst_\Dt$ performs only \emph{static doing
reasoning}, which as discussed in Chapter \ref{ch:background} is
a comparatively straightforward task which can be made decidable under
certain conditions. Third, $\Pst_{\Dt}(\phi,\alpha)[s]$
is in a form amenable to regression, a standard tool for effective
reasoning in the situation calculus. Fourth, the persistence condition
for a given $\phi$ and $\alpha$ can be cached and re-used for a
series of related queries about different situations, a significant
gain in amortized efficiency. Finally, in realistic domains we expect
many properties to fail to persist beyond a few situations into the
future, meaning that our algorithm will require few iterations in
a large number of cases.

Of course, we also inherit the potential disadvantage of the regression
operator: the length of $\Pst_\Dt(\phi,\alpha)$ may be exponential
in the length of $\phi$. As with regression, our experience has been
that this is rarely a problem in practice, and is more than compensated
for by the reduced complexity of the resulting reasoning task.


\subsection{Applications}

The persistence condition is readily applicable to the example persistence
query problems given in Section \ref{sec:Persistence:Definitions}.
All of the transformed queries can then be answered using standard
regression.\\


\textbf{Goal Impossibility:} Given a goal $G$, establish that there
is no legal situation in which that goal is satisfied:\[
\Dt\,\models\,\Pst_\Dt(\neg G,Legal)[S_{0}]\]
 The persistence condition of $\neg G$ with respect to action legality
allows goal impossibility to be checked easily.\\


\textbf{Goal Futility:} Given a goal $G$ and situation $\sigma$,
establish that the goal cannot be satisfied in any legal future situation
from $\sigma$:\[
\Dt\,\models\,\Pst_\Dt(\neg G,Legal)[\sigma]\]
 Precisely the same formula is required for checking goal impossibility
and goal futility. This highlights the advantage of re-using the persistence
condition at multiple situations. Our approach makes it feasible for
an agent to check for goal futility each time it considers performing
an action, and avoid situations that would make its goals unachievable.\\


\textbf{Checking State Constraints:} Given a state constraint $SC$,
show that the constraint holds in every legal situation:\[
\Dt\,\models\,\Pst_\Dt(SC,Legal)[S_{0}]\]


However, since we want a state constrint to \emph{always} persist,
it must satisfy the following equivalence:

\[
\Dt_{bg}\models\phi\equiv\Pst_{\Dt}(\phi,Legal)\]


If this equivalence does not hold then $\Pst_{\Dt}(\phi,Poss)$
indicates the additional conditions that are necessary to ensure that
$\phi$ persists, which may be used to adjust the action theory to
enforce the constraint. The approach to state-constraints developed
by \citet{Lin94-StateConstraints} can be seen as a variant of this
technique.\\


\textbf{Need for Cooperation:} Given an agent $agt$, goal $G$ and
situation $\sigma$, establish that no sequence of actions performed
by that agent can achieve the goal:\[
\Dt\models\Pst_\Dt(\neg G,actor=agt)[\sigma]\]


\textbf{Knowledge with Hidden Actions:} In the next chapter we will
develop a regression rule for knowledge that uses the persistence
condition to account for arbitrarily-long sequences of hidden actios.
While we defer the details to that chapter, the general form of the
rule is:\[
\Reg_{\Dt}(\Knows(\phi,do(a,s)))\isdef\Knows(\Reg_{\Dt}(\Pst_{\Dt}(\phi,Hidden),a),s)\]



\section{Discussion\label{sec:Persistence:Discussion}}

In this chapter we have developed an algorithm that transforms property
persistence queries, a very general and useful class of situation
calculus query, to a form that is amenable to standard techniques
for effective reasoning in the situation calculus. The algorithm replaces
a second-order induction axiom with a meta-level fixpoint calculation
based on iterative application of the standard regression operator.
It is shown to be correct, and complete given some basic restrictions
on $\Dt$.

Our approach generalizes previous work on universally-quantified queries
in several important ways. It can consider sequences of actions satisfying
a range of conditions, not just the standard ordering over action
possibility, enabling us to treat problems such as need for cooperation
and knowledge with hidden actions. It can establish that properties
persist in the future of an arbitrary situation, not necessarily the
initial situation, enabling us to answer the question of goal futility.
The results of calculating the persistence condition can be cached,
allowing for example the goal futility question to be efficiently
posed on a large number of situations once the persistence condition
has been calculated.

Most importantly for the remainder of this thesis, we have \emph{factored
out} the inductive reasoning required to answer these queries. We
will henceforth use $\PstD$ as a kind of {}``black box'' operator
to formulate regression rules within out framework. Work on increasing
the effectiveness of this inductive reasoning, and on guaranteeing
termination of this reasoning in stronger classes of action theory,
can now proceed independently from the development of formalisms that
utilise persistence queries.

Our use of fixpoints in this chapter has much in common with the study
of properties of ConGolog programs of \citep{ternovska97congolog_fixpoint,classen08golog_properties}.
Indeed, a property persistence query is equivalent to a safety query
stating that the property $\phi$ never becomes false during execution
of the following program:\[
\delta_{P\alpha}\isdef\left(\pi(a,\,\alpha[a]?\,;\, a)\right)^{*}\]


Formally:\begin{gather*}
\Dt\,\models\,\forall s:\,\sigma\leq_{\alpha}s\,\rightarrow\,\phi[s]\\
\mathrm{iff}\\
\Dt\cup\Dt_{golog}\,\models\,\forall s,\delta:\, Trans^{*}(\delta_{P\alpha},\sigma,\delta,s)\,\rightarrow\,\phi[s]\end{gather*}


Since we intend to use persistence queries as part of a larger reasoning
apparatus, rather than as a stand-alone query, we cannot directly
leverage the existing work on verifying ConGolog programs. However,
given the similarity between the approaches, we are confident that
advances in reasoning effectively about ConGolog programs will also
advance our ability to effectively calculate the persistence condition.

This chapter has thus significantly increased the scope of queries
that can be posed when building systems upon the situation calculus,
and allowed us to treat the inductive aspects of reasoning as a separate
component of the overall reasoning machinery.

