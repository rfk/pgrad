

\chapter{Complex Epistemic Modalities}

\label{ch:cknowledge}

This chapter develops an explicit formal treatment of group-level
epistemic modalities in the situation calculus. The primary motivation
for this work is a formal treatment of common knowledge that permits
effective reasoning with a regression rule, but as we shall see, this
requires significant technical machinery capable of handling much
more general epistemic modalities.

Attempts to reason about common knowledge are bound by a fundamental
expressivity limitation: the regression of common knowledge cannot
be expressed in terms of common knowledge alone \citep{baltag98pa_ck}.
To overcome this limitation we take our cue from recent promising
work in dynamic epistemic logic, with the main idea due to \citet{vanBenthem06lcc}:
increase the expressiveness of the epistemic language so it is strong
enough to formulate a proper regression rule. They have developed
the Logic of Communication and Change (henceforth {}``LCC'') using
propositional dynamic logic to express epistemic modalities, and have
shown that it allows reasoning about common knowledge using techniques
akin to regression. We follow a similar approach in this chapter and
introduce complex epistemic modalities to the situation calculus.

While this chapter naturally parallels the development of LCC, there
are also substantial differences. LCC is built on modal logic and
so handles only propositional, synchronous domains. The richer ontology
of the situation calculus means our formalism must support first-order
preconditions and effects, quantifying-in and de-dicto/de-re, and
arbitrary sets of concurrent actions. It must also incorporate our
new technique for handling hidden actions while remaining compatible
with other extensions to the situation calculus. By building on our
rigorous observation-based semantics for individual knowledge, and
using a macro-expansion approach to construct group-level modalities,
our formalism is able to neatly fulfil all these requirements.

The language of first-order dynamic logic is adopted to construct
complex epistemic paths, with the macro $\PKnows(\pi,\phi,s)$ expressing
knowledge using such a path. Since common knowledge is defined as
the transitive closure of the union of the agents' base knowledge
operators, it can be expressed as $\PKnows((A\cup B)^{*},\phi,s)$.
Regression is then modified to treat $\PKnows(\pi,\phi,do(c,s))$
as a primitive fluent, producing an equivalent formula $\PKnows(\Trn(\pi),\Reg(\phi),s)$.
Here $\Trn$ is a new meta-level operator called the epistemic path
regressor.

After some more detailed background material in Section \ref{sec:CKnowledge:Background},
the chapter proceeds as follows. Section \ref{sec:CKnowledge:Epistemic-Paths}
defines a variant of first-order dynamic logic for use as an epistemic
path language, which is encoded in the situation calculus using the
macro $\KDoZ(\pi,s,s')$. This macro is analogous to the fluent $K(agt,s',s)$
from Chapter \ref{ch:knowledge} but expresses more complex epistemic
relationships between situations.

Section \ref{sec:CKnowledge:Synchronous} develops a \emph{synchronous}
account of complex epistemic modalities. The macro $\PKnowsZ(\pi,\phi,s)$
expresses knowledge using an epistemic path $\pi$ under the assumption
that there have been no hidden actions. We develop a regression rule
by the synchronous case by encoding the effects of an action inside
the epistemic path as well as the enclosed formula, transforming $\PKnowsZ(\pi,\phi,do(c,s))$
into an equivalent expression $\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)$.

Section \ref{sec:CKnowledge:Asynchronous} introduces hidden actions
by explicitly representing them with the empty action set. We simulate
agents reasoning about arbitrarily-long sequences of hidden actions
by inserting arbitrarily many empty action setts between each real
action in a situation term. A regression rule is formulated for this
infinitary construction using the persistence condition meta-operator
in a similar way to the previous chapter. Section \ref{sec:CKnowledge:Correctness}
then demonstrates the correctness of this construction by showing
that in the case of a single agent, it precisely matches the definition
of individual knowledge presented in Chapter \ref{ch:knowledge}.

The effectiveness of our new technique is demonstrated in Section
\ref{sec:CKnowledge:Example} by reasoning about common knowledge
in an asynchronous, partially observable domain, a first for the situation
calculus. Section \ref{sec:CKnowledge:Comparison} compares the resulting
formalism with LCC, highlighting both similarities and differences,
while. Section \ref{sec:CKnowledge:Reasoning} discusses the implications
of our more powerful epistemic language for answering the regressed
knowledge query. Finally, Section \ref{sec:CKnowledge:Encoding-KDoZ}
presents some additional details of the macro $\KDoZ$ and Section
\ref{sec:CKnowledge:Discussion} concludes with some general discussion.

The end result is a powerful account of complex epistemic modalities
constructed almost entirely in the meta-level reasoning machinery
of the situation calculus, and a regression-based effective reasoning
procedure for common knowledge.


\section{Background\label{sec:CKnowledge:Background}}

Let us begin by recalling the definitions of $\EKnows$ and $\CKnows$
from Section \ref{sec:Background:Epistemic}:\begin{gather*}
\mathbf{EKnows}(G,\phi,s)\,\isdef\,\bigwedge_{agt\in G}\,\mathbf{Knows}(agt,\phi,s)\\
\mathbf{EKnows}^{1}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\phi,s)\\
\mathbf{EKnows}^{n}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\mathbf{EKnows}^{n-1}(G,\phi),s)\\
\mathbf{CKnows}(G,\phi,s)\,\isdef\,\bigwedge_{n\in\mathbb{N}}\mathbf{EKnows}^{n}(G,\phi,s)\end{gather*}


Finite group-level knowledge operators such as $\EKnows$ can be reasoned
about using existing techniques by simply expanding out the definitions
into individual-level knowledge operators, and applying the regression
rules developed in the previous chapter. But since the definition
of common knowledge is second-order or infinitary, it cannot be handled
in this way.

Existing treatments of common knowledge in the situation calculus
and related literature specify it as the transitive closure of $\EKnows$
using an explicit second-order axiom \citep{davis05fo_ma_theory,ghaderi07sc_joint_ability}.
While logically sound, this approach forgoes the use of regression
as an effective reasoning technique. Indeed, reasoning in such formalisms
requires a second-order theorem prover.

This difficulty in effectively handling common knowledge can be attributed
to a famous expressivity result from \citet{baltag98pa_ck} in the
related field of dynamic epistemic logic:

\begin{quote}
Epistemic logic with actions and common knowledge is more expressive
than epistemic logic with common knowledge alone 
\end{quote}
In our terminology: given a formula $\CKnows(G,\phi,do(c,s))$, it
is impossible in general to find an equivalent formula $\CKnows(G,\psi,s)$.
We therefore cannot formulate a regression rule for common knowledge
in terms of $\Knows$ and $\CKnows$.

Given the deep similarities between the situation calculus and dynamic
epistemic logic \citep{vanbentham07ml_sitcalc}, we can be confident
that this expressivity limitation also holds in the situation calculus.
Rather than attempting to formally establish it, we present a short
summary of the intuitions behind the result and why it should be expected
to hold in the situation calculus, then proceed directly with a technique
to circumvent it.

Consider again the standard successor state axiom for the $K$ fluent,
which has the simplified general form:\[
K(do(c',s'),do(c,s))\,\equiv\, K(s',s)\wedge\Phi_{K}(c',s')\]


We could construct an analogous fluent $E$ that captures the $\EKnows$
relation, with a successor state axiom of the general form:\[
E(do(c',s'),do(c,s))\,\equiv\, E(s',s)\wedge\Phi_{E}(c',s')\]


Now consider constructing such a fluent for the $\EKnows^{2}$ relation.
The general form for its successor state axiom must hypothesise an
intermediate situation:\begin{align*}
E^{2}(do(c',s'),do(c,s)) & \equiv\exists c'',s'':\, E(do(c'',s''),do(c,s))\wedge E(do(c',s'),do(c'',s''))\\
 & \Rightarrow\exists c'',s'':\, E(s'',s)\wedge E(s',s'')\wedge\Phi_{E}(c',s')\wedge\Phi_{E}(c'',s'')\\
 & \Rightarrow\exists c'',s'':\, E^{2}(s',s)\wedge\Phi_{E}(c',s')\wedge\Phi_{E}(c'',s'')\end{align*}


This axiom must make assertions not only about $s$ and $s'$, but
also about the hypothesised intermediate situation $s''$. Extending
this reasoning, a successor state axiom for common knowledge would
be required make assertions not only about $s$ and $s'$, but all
of the intermediate situations in the transitive closure. However,
the macro $\CKnows$ can only make assertions about the final situation
reached in the transitive closure, not about the path leading to it.
It is thus not expressive enough to formulate a proper regression
rule.

To overcome this expressiveness limitation, we follow the recent promising
work of \citet{vanBenthem06lcc}, who use two important new ideas
to produce a regression rule for common knowledge in their logic LCC:

\begin{itemize}
\item Form more expressive epistemic modalities using the syntax of dynamic
logic, interpreted over the epistemic frame of the agents. 
\item Apply regression within the modality as well as to the enclosed formula. 
\end{itemize}
While the full details of LCC would take us too far afield in this
thesis, let us demonstrate the basic idea. LCC uses explicit \emph{update
models} to model partially-observable actions. These are finite Kripke
structures in which each world represents a possible action that was
performed. To represent that $\phi$ holds after performing event
$e$ from update frame $U$, LCC uses the standard box modality of
dynamic logic:\[
[U,e]\phi\]


To express the agent's knowledge, the language of Propositional Dynamic
Logic (henceforth {}``PDL'') is adopted with standard semantics
\citep{harel00dynamic_logic}, but interpreted over the epistemic
frame of the agents instead of over actions. Individual-level knowledge
is expressed as in standard modal logic:\[
[Bob]\phi\]


But these base knowledge operators can be combined using the dynamic
logic operators choice ($\cup$), sequence ($;$), test ($?\phi$)
and iteration ($*$). Common knowledge between $Alice$ and $Bob$
is expressed in LCC as:\[
[(Alice\cup Bob)^{*}]\phi\]


This modality is the transitive closure of the union of the agents'
individual knowledge operators, which is one of the common semantic
definitions of common knowledge. To perform reasoning, {}``reduction
rules'' are used that are similar in spirit to the regression operator
of the situation calculus. Let $\pi$ be an arbitrary epistemic modality
and $U$ an update model with $n$ possible actions, then the reduction
rule for knowledge in LCC is:\[
[U,e_{i}][\pi]\phi\,\,\Rightarrow\,\,\bigwedge_{j=0}^{n-1}[T_{ij}^{U}(\pi)][U,e_{j}]\phi\]


This definition enumerates all $n$ possible actions that could be
mistaken for the real action $e_{i}$ according to update model $U$,
then uses a special \emph{program transformer} $T_{ij}^{U}$ to encode
the information from $U$ into the epistemic modality $\pi$. We shall
discuss some of the details of $T_{ij}^{U}$ later in this chapter.

Our work applies these ideas to perform group-level epistemic reasoning
in the situation calculus, allowing common knowledge to be handled
using regression. While the development naturally parallels that of
LCC, the much richer ontology of the situation calculus means there
are also substantial differences. In particular:

\begin{itemize}
\item LCC is \emph{propositional}: actions do not take arguments, there
are finitely many actions, and no quantification is required. 
\item LCC is \emph{synchronous}: reasoning is performed by regressing one
action at a time, without the {}``all possible futures'' approach
needed to handle hidden actions. 
\end{itemize}
By contrast, our formalism must capture first-order preconditions
and effects, quant\-ifying-into and de-dicto/de-re, and arbitrary
sets of concurrent actions, while accounting for arbitrarily-long
sequences of hidden actions and remaining compatible with other extensions
to the situation calculus.

As we shall see throughout the development, the extra expressiveness
of the situation calculus also provides some advantages for our formalism.
We do not need to manipulate explicit update models, since we have
a complete axiomatisation of the agent's epistemic uncertainly. The
definition of our regression rules will also turn out to be much simpler
than the analogous rules in \citep{vanBenthem06lcc}.


\section{Epistemic Paths\label{sec:CKnowledge:Epistemic-Paths}}

We will be approaching our formalism in two steps: first defining
complex epistemic modalities in synchronous domains, and then building
support for hidden actions on top of that foundation. So to begin,
we must define the synchronous knowledge of an individual agent in
an arbitrary situation $s$. This is the agent's knowledge when it
assumes that no hidden actions have occurred, and so it is not required
to do any {}``all possible futures'' style reasoning. We extend
the fluent $K_{0}(agt,s',s)$ which is already used to represent synchronous
knowledge in the initial situation. The axiom set $\Dt_{K}^{obs}$
gains the following successor state axiom for $K_{0}$:\begin{align}
K_{0}(agt,s'',do(c,s))\,\equiv\,\, & \exists s',c':\, K_{0}(agt,s',s)\wedge Obs(agt,c,s)=Obs(agt,c',s')\nonumber \\
 & \wedge\left(s''=do(c',s')\wedge Legal(c',s')\,\,\vee\,\, s''=s'\wedge c'=\{\}\right)\label{eq:K0_ssa}\end{align}


Given synchronicity, this axiom is a simple modification of the standard
successor state axiom for knowledge from equation \eqref{eq:k_ssa_standard}.
The only complication is that when $Obs(agt,c,s)=\{\}$, the agent
considers it possible that no actions were actually performed, so
$s'=s''$ and $c'=\{\}$. Thus the number of actions in $s$ puts
an upper bound on the number of actions that the agent thinks might
actually have occurred.

While we hope this definition is intuitively plausible, we will not
formally relate it to the definitions given in the previous chapter
until Section \eqref{sec:CKnowledge:Correctness}. Beginning with
the assumption of synchronicity allows us to focus first on increasing
the expressiveness of the epistemic language. Once this have been
achieved, we will generalise the formalism to asynchronous domains.

The first step is to adopt the language of dynamic logic to express
complex \emph{epistemic} modalities rather than modalities regarding
action. To deal gracefully with the many first-order aspects of the
situation calculus we use a variant of \emph{first-order dynamic logic}
(henceforth {}``FODL''), which we adapt with some simplifications
from the dynamic term-modal logic of \citet{kooi07dyn_termmodal_logic}.

First, we must specify the syntax of our epistemic path language.
We will use $\pi$ to denote an arbitrary epistemic path expression.

\begin{defnL}
[{Epistemic~Path}] Let $agt$ be an \noun{Agent }term, $\phi$
a uniform formula and $x$ a variable name, then the epistemic path
terms $\pi$ are the smallest set matching the following structural
rules:\[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end{defnL}
The test ($?$), sequence ($;$), choice ($\cup$) and transitive
closure ($^{*}$) operators are standard in dynamic logic, although
test formulae may now contain variables that must be interpreted.
The operator $\exists x$ allows the value of a variable to change
during path traversal, by non-deterministically re-binding $x$ to
some value.

The semantics of this epistemic path language are defined at the meta-level
as a series of macro expansions. Formulae of first-order dynamic logic
are interpreted relative to both a {}``current world'' and a {}``current
variable binding'' \citep{kooi07dyn_termmodal_logic}. We begin with
a simplified presentation that treats variable bindings as concrete
terms in the logic, represented as a finite first-order substitution
$\mu$. The notation $\mu(\phi)$ applies the substitution to the
variables in $\phi$ and $\mu[x/z]$ sets the value of variable $x$
to the term $z$. The semantics operate over pairs $(\mu,s)$.

\begin{defnL}
[{Epistemic~Path~Semantics}] A situation $s'$ is reachable
from situation $s$ via epistemic path $\pi$, denoted $\KDoZ(\pi,s,s')$,
according to the following definitions:\label{def:KDoZ}\[
\KDoZ(\pi,s,s')\,\,\equiv\,\,\exists\mu,\mu':\,\KDoZ(\pi,\mu,s,\mu',s')\]
 \begin{gather*}
\KDoZ(agt,\mu,s,\mu',s')\,\equiv\,\mu'=\mu\,\wedge\, K_{0}(agt,s',s)\\
\KDoZ(?\phi,\mu,s,\mu',s')\,\equiv\, s'=s\,\wedge\,\mu'=\mu\,\wedge\,\mu(\phi)[s]\\
\KDoZ(\pi_{1};\pi_{2},\mu,s,\mu',s')\,\equiv\,\exists\mu'',s'':\,\KDoZ(\pi_{1},\mu,s,\mu'',s'')\,\wedge\,\KDoZ(\pi_{2},\mu'',s'',\mu',s')\\
\KDoZ(\pi_{1}\cup\pi_{2},\mu,s,\mu',s')\,\equiv\,\KDoZ(\pi_{1},\mu,s,\mu',s')\,\vee\,\KDoZ(\pi_{2},\mu,s,\mu',s')\\
\KDoZ(\exists x,\mu,s,\mu',s')\,\equiv\,\exists z:\, s'=s\,\wedge\,\mu'=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu,s,\mu',s')\rightarrow\KDoZ(\pi^{*},\mu,s,\mu',s')\right]\end{gather*}

\end{defnL}
Where we use the following abbreviations (standing for {}``reflexive'',
{}``transitive'' and {}``contains'' respectively) to specify that
$\pi^{*}$ is the reflexive transitive closure of $\pi$:\begin{align*}
\mathbf{refl}\isdef & \,\, P(\mu,s,\mu,s)\\
\mathbf{tran\isdef} & \,\,\forall\mu_{1},s_{1},\mu_{2},s_{2}:\, P(\mu_{1},s_{1},\mu,s)\wedge\KDoZ(\pi,\mu_{2},s_{2},\mu_{1},s_{1})\,\rightarrow\, P(\mu_{2},s_{2},\mu,s)\\
\mathbf{cont}\isdef & \,\,\forall\mu',s':\,\KDoZ(\pi,\mu',s',\mu,s)\,\rightarrow\, P(\mu',s',\mu,s)\end{align*}


In order to keep the semantics clear, we will continue to represent
variable-bindings $\mu$ as concrete terms in the logic. While we
could formally settle for such an approach and add sorts to $\Lsit$
and axioms to $\Dt$ that reify path-variables and variable-bindings,
we agree with \citet{levesque97golog} that axioms should not be added
unless necessary. In Section \ref{sec:CKnowledge:Encoding-KDoZ} we
construct a definition of $\KDoZ$ that does not require variable-bindings
as terms in the logic, using macro-expansion into a set of mutually-recursive
Golog procedures that respect the above semantics. For this reason,
Definition \ref{def:KDoZ} presents as a series of equivalences rather
than macro definitions.

Let us re-iterate: paths are not terms in $\Lsit$, but rather are
handled by macro-expansion of $\KDoZ(\pi,s,s')$ into second-order
sentences of the situation calculus. In particular, this means that
the variables used in epistemic paths are not actual terms and cannot
appear outside of a $\KDoZ$ macro. We assume that the symbols used
for path variables are all distinct from the symbols of $\Lsit$.

For notational convenience, we also introduce an explicit assignment
operator:\[
\KDoZ(x\Leftarrow\tau,\mu,s,\mu',s')\isdef\KDoZ(\exists x\,;\,?x=\tau,\mu,s,\mu',s')\]


This operator non-deterministically rebinds $x$ to any value, then
immediately asserts that it is equal to the specific value $\tau$.
Since this expands to a test formula, $\tau$ can potentially be a
functional fluent that is interpreted at the current situation. It
cannot, however, depend on the current value of $x$.


\section{A Synchronous Epistemic Fluent\label{sec:CKnowledge:Synchronous}}

At this point it's worth reviewing again the purpose of this path
language. Despite utilising the syntax of dynamic logic, it is \emph{not}
related to actions in any way. Rather it expresses complex \emph{epistemic}
paths, and is interpreted over the epistemic frame generated by the
agents' knowledge relations. We will be introducing a new macro $\PKnows(\pi,\phi,s)$
(read this as {}``Path-Knows'') to express knowledge using these
epistemic paths. To make this clear, here is how some different kinds
of knowledge would be expressed using the standard account of knowledge,
and how we intend to express them using epistemic paths:\begin{align}
\Knows(A,\phi,s) & \,\,\equiv\,\,\PKnows(A,\phi,s)\nonumber \\
\Knows(A,\Knows(B,\phi),s) & \,\,\equiv\,\,\PKnows(A;B,\phi,s)\nonumber \\
\Knows(A,\phi,s)\wedge\Knows(B,\phi,s) & \,\,\equiv\,\,\PKnows(A\cup B,\phi,s)\nonumber \\
\EKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows(\bigcup_{a\in G}a,\phi,s)\nonumber \\
\CKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)\label{eq:pknows_identities}\end{align}


In this section, we develop a synchronous version $\PKnowsZ(\pi,\phi,s)$
of our path-knowledge operator, since the semantics of $\KDoZ$ reference
the synchronous knowledge fluent $K_{0}$ defined earlier. The definition
of $\PKnowsZ$ is a straightforward analogue of the individual-level
$\Knows$ macro:\[
\PKnowsZ(\pi,\phi,s)\isdef\forall s':\,\KDoZ(\pi,s,s')\,\rightarrow\,\phi[s']\]


By virtue of $\KDoZ$ this macro expands to a complicated second-order
formula in the base language of the situation calculus. As with the
case of the basic $\Knows$ macro, we need to treat $\PKnowsZ$ syntactically
as a primitive fluent. This means we need a regression rule for such
expressions. It is here that we incorporate the second key idea from
LCC -- use of a syntactic transform to encode the effects of actions
within epistemic paths as well as in primitive formulae. Mirroring
LCC, we introduce the meta-operator $\Trn_{\Dt}$ for this purpose.
As with regression and the persistence condition, we assume a fixed
action theory and write $\Trn$ rather than $\Trn_{\Dt}$.

Let us consider the required operation of $\Trn$ by analogy with
the standard regression operator $\Reg$. One can think of regression
as a {}``pre-encoding'' of the effects of an action: $\phi$ will
hold in $do(c,s)$ if and only if $\Reg(\phi,c)$ holds in $s$. The
path regressor $\Trn$ needs to lift this idea to epistemic paths
as follows: there is a $\pi$-path from $do(c,s)$ to $do(c',s')$
if and only if there is a $\Trn(\pi,c,c')$-path from $s$ to $s'$.

In order to accomplish this task of pre-encoding the effects of actions,
the path regressor will need to make various assertions about the
action that is to be performed in each situation traversed by the
regressed path. It uses a fresh variable to keep track of this {}``current
action''. The basic operation of $\Trn$ is as follows:

\begin{itemize}
\item Introduce a fresh variable $x$ to hold the action that was performed
in the current situation; 
\item at the beginning of the path, bind $x$ to the known action $c$; 
\item at the end of the path, assert that $x$ is the known action $c'$;
and 
\item when the path moves to a new situation, select a new action using
$\exists x$. 
\end{itemize}
This is accomplished with an auxiliary operator $\TrnA(\pi,x)$, which
translates $\pi$ under the assumption that $x$ contains the action
to be performed in the current situation.

\begin{defnL}
[{Epistemic~Path~Regressor}] The epistemic path regressor
$\Trn(\pi,c,c')$ operates according to the definitions below, where
$x$ and $z$ are fresh path variables not appearing in $\pi$:\label{def:EpistemicPathRegression}\[
\Trn(\pi,c,c')\,\isdef\,\, x\Leftarrow c\,;\,\TrnA(\pi,x)\,;\,?x=c'\]
 \begin{align*}
\TrnA(agt,x)\,\isdef\,\, & z\,\Leftarrow Obs(agt,x)\,;\, agt\,;\,\exists x\,;\,?Legal(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\\
\TrnA(?\phi,x)\isdef\,\, & ?\Reg(\phi,x)\\
\TrnA(\exists y,x)\isdef\,\, & \exists y\\
\begin{array}{c}
\TrnA(\pi_{1};\pi_{2},x)\isdef\,\,\end{array} & \TrnA(\pi_{1},x)\,;\,\TrnA(\pi_{2},x)\\
\TrnA(\pi_{1}\cup\pi_{2},x)\isdef\,\, & \TrnA(\pi_{1},x)\cup\TrnA(\pi_{2},x)\\
\TrnA(\pi^{*},x)\isdef\,\, & \TrnA(\pi,x)^{*}\end{align*}

\end{defnL}
Most of these rules are straightforward, but note how the clause for
an individual agent term encodes the successor-state axiom for $K_{0}$
from equation \eqref{eq:K0_ssa}. In order to capture the requirement
that $Obs(agt,c,s)=Obs(agt,c',s')$ it uses a new variable $z$ which
is bound to the agent's observations in the current situation. It
then moves to a new situation by making an $agt$ path step, and selects
a new value for the current action $x$; this corresponds to the $\exists c',s'$
in equation \eqref{eq:K0_ssa}. Finally, it asserts that the observations
in the new situation match those recorded in $z$.

Also note that $c$ and $c'$ are proper situation calculus variables,
not path variables, and are being introduced from outside the scope
of the $\KDoZ$ and $\PKnowsZ$ macros.

The following theorem states that these definitions behave has desired,
respecting the semantics of epistemic paths:

\begin{thm}
\label{thm:Trn-respects-epi-paths}For any epistemic path $\pi$:\begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models\,\KDoZ(\pi,do(c,s),s'')\,\equiv\\
\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDoZ(\Trn(\pi,c,c'),s,s')\end{multline*}

\end{thm}
\begin{proofsketch}
The proof proceeds by cases, covering each path operator in turn.
The base cases $agt$, $?\phi$ and $\exists y$ follow from Definition
\ref{def:KDoZ} and the successor state axiom for $K_{0}$ in equation
\eqref{eq:K0_ssa}. The inductive cases are straightforward as $\Trn_{a}$
is simply pushed inside each operator. 
\end{proofsketch}
Note that the situations reachable by $\KDoZ(\pi,do(c,s),s'')$ are
not necessarily all successors of the situations reachable by $\KDoZ(\Trn(\pi,c,c'),s,s')$
-- if one of the agents mentioned in $\pi$ does not make any observations,
$c'$ is permitted to be empty and the situation $s'$ itself is still
reachable from $do(c,s)$. This mirrors the handling of empty observations
by the successor state axiom for $K_{0}$.

Given that $\Trn$ correctly regresses our epistemic path language,
we are free to use it to define the regression of a complex epistemic
modality. We define the regression of a $\PKnowsZ$ expression as
follows:\[
\Reg(\PKnowsZ(\pi,\phi,do(c,s)))\isdef\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\]


Note that this rule must universally quantify over action terms $c'$
in order to account for different actions producing the same observation.
Such quantification is also found in the rule for individual knowledge
from equation \eqref{eqn:R_do_c_s}, although here it has been taken
outside the scope of the knowledge macro.

\begin{thm}
\label{thm:Reg_PKnowsZ}For any epistemic path $\pi$, uniform formula
$\phi$ and action $c$:\begin{gather*}
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{gather*}

\end{thm}
\begin{proofsketch}
The mechanics of this proof mirror that of Theorem \ref{thm:Reg_PKnows}:
we expand the $\PKnowsZ$ macro, apply Theorem \ref{thm:Trn-respects-epi-paths}
as a successor state axiom for $\KDoZ$, re-arrange to eliminate existential
quantifiers, then collect terms back into forms that match $\PKnowsZ$. 
\end{proofsketch}

\section{Introducing Hidden Actions\label{sec:CKnowledge:Asynchronous}}

We now have a powerful account of group-level knowledge for \emph{synchronous}
domains, but it remains to generalise this to \emph{asynchronous}
domains by incorporating support for arbitrarily-long sequences of
hidden actions. We continue to operate at the meta-level, developing
support for hidden actions directly in the rules governing the regression
operator.

The idea is to use the empty action set to explicitly represent the
notion that {}``nothing happens''. We simulate agents reasoning
about hypothetical futures in which they make no more observations
by inserting these empty actions between each regular action in a
situation term.

\begin{defn}
Let $\mathcal{E}^{n}(s)$ be $s$ with $n$ empty actions inserted
between each action:\begin{align*}
\mathcal{E}^{0}(s)\,\isdef\,\, & s\\
\mathcal{E}^{1}(S_{0})\,\isdef\,\, & do(\{\},S_{0})\\
\mathcal{E}^{1}(do(c,s))\,\isdef\,\, & do(\{\},do(c,\mathcal{E}^{1}(s)))\\
\mathcal{E}^{n}(s)\,\isdef\,\, & \mathcal{E}^{1}(\mathcal{E}^{n-1}(s))\end{align*}

\end{defn}
The intuition here is that we want $\PKnows(\pi,\phi)$ to hold if
$\PKnowsZ(\pi,\phi)$ holds after allowing for any number of empty
actions. Formally, we define $\PKnows(\pi,\phi,s)$ to be the following
infinite conjunction:\[
\PKnows(\pi,\phi,s)\isdef\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\]


To avoid an infinite set of sentences we could also use an equivalent
second-order definition. The choice is immaterial, since we do not
intend to actually expend this definition during reasoning. As before,
we will formulate a regression rule allowing it to be treated as a
primitive fluent. First, let us demonstrate this this definition is
intuitively plausible with the following theorem:

\begin{thm}
\label{thm:En_impl_En-1}For any epistemic path $\pi$: \[
\Dt\cup\Dt_{K}^{obs}\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\PKnowsZ(\pi,\phi,s)\]

\end{thm}
\begin{proofsketch}
By a case analysis on the definition of $\Trn$, we determine that
that path $\Trn(\pi,\{\},\{\})$ always contains the path $\pi$.
Thus any situations reachable by $\pi$ are also reachable by $\Trn(\pi,\{\},\{\})$.
Since $\Trn(\pi,\{\},\{\})$ is always in the regression of $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
and $\Reg(\phi,\{\})=\phi$ always, we can conclude that $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
always implies $\PKnowsZ(\Trn(\pi,\{\},\{\}),\phi,s)$, which implies
$\PKnowsZ(\pi,\phi,s)$ as required. 
\end{proofsketch}
The addition of empty actions into a $\PKnowsZ$ expression is thus
\emph{monotone}. It cannot cause the agents to know things that were
not already known, but may cause them to lose knowledge of fluents
that can be falsified by a sequence of hidden actions. By arguments
entirely analogous to those used in Chapter \eqref{ch:persistence},
the addition of empty actions must eventually reach a well-defined
fixpoint, and it may be helpful to think of $\PKnows$ as a fixpoint
definition with the suggestive notation:\[
\PKnows(\pi,\phi,s)\,\isdef\,\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(s))\]


It is this fixpoint nature that will allow us to construct a regression
rule using the persistence condition operator. First, let us define
an auxiliary meta-level operator $\UnZ$ that replaces instances of
$\PKnowsZ$ with $\PKnows$:\begin{gather*}
\UnZ(\phi_{1}\wedge\phi_{2})\isdef\UnZ(\phi_{1})\wedge\UnZ(\phi_{2})\\
\UnZ(\forall x:\,\phi(x))\isdef\forall x:\,\UnZ(\phi(x))\\
\UnZ(\neg\phi)\isdef\neg\UnZ(\phi)\\
\UnZ(\PKnowsZ(\pi,\phi,\sigma))\isdef\UnZ(\PKnows(\pi,\phi,\sigma))\\
\UnZ(\phi)\isdef\phi\,,\,\,\mathrm{otherwise}\end{gather*}


We then propose the following regression rules for the macro $\PKnows$:\begin{gather}
\Reg(\PKnows(\pi,\phi,do(c,s)))\,\isdef\,\UnZ(\Reg(\Pst(\PKnowsZ(\pi,\phi),\lambda c:\, c=\{\})[do(c,s)]))\label{eq:Reg_PKnows_do}\\
\Reg(\PKnows(\pi,\phi,S_{0}))\,\isdef\,\Pst(\PKnowsZ(\pi,\phi),\lambda c:\, c=\{\})[S_{0}]\label{eq:Reg_PKnows_S0}\end{gather}


Here we are using $\Pst$ with a very restrictive action description
predicate to account for an arbitrary number of empty actions. By
using $\UnZ$ to switch from $\PKnowsZ$ back to $\PKnows$ once $\Pst$
and $\Reg$ have been applied, we effectively insert an arbitrary
number of empty actions between each real action $c$ in the situation
term.

Note that, as in the case of individual-level knowledge, regressing
$\PKnows$ at $do(c,s)$ produces an expression using $\PKnows$ at
$s$, while regressing $\PKnows$ at $S_{0}$ produces an expression
involving $\PKnowsZ$ at $S_{0}$. Repeated applications of these
rules will thus reduces a path-knowledge query to a synchronous path-knowledge
query in the initial situation.

\begin{thm}
\label{thm:Reg_PKnows}Given a basic action theory $\Dt$ and a uniform
formula $\phi$:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows(\pi,\phi,s)\equiv\Reg(\PKnows(\pi,\phi,s))\]

\end{thm}
\begin{proofsketch}
Proceed by induction on situation terms. For the base case we demonstrate
that $\Pst(\PKnowsZ(\pi,\phi),\lambda c:\, c=\{\})[S_{0}]$ is equivalent
to the infinite conjunction $\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(S_{0}))$,
from which the validity of \eqref{eq:Reg_PKnows_S0} is immediate.
To validate \eqref{eq:Reg_PKnows_do} in the inductive case $\mathcal{E}^{n}(do(c,s))$,
we demonstrate that the use of $\Pst$ accounts for the hidden actions
inserted \emph{after} $c$, the use of $\Reg$ accounts for $c$ itself,
and the use of $\UnZ$ lets the inductive hypothesis account for the
hidden actions before $c$. 
\end{proofsketch}
These rules for $\PKnows$ operate in a very similar way to the regression
rule for $\Knows$ from equation \eqref{eqn:R_do_c_s}, using a fixpoint
calculation to account for arbitrarily long sequences of hidden actions.
In the following section we formalism the precise relationship between
$\Knows$ and $\PKnows$.

We note that, as in the previous chapter, our regression rules for
knowledge are no longer simple syntactic manipulations but require
a meta-level fixpoint calculation to deal with hidden actions. In
synchronous domains this fixpoint is unnecessary and $\PKnows$ is
equivalent to $\PKnowsZ$, which can be regressed using purely syntactic
manipulation. We thus provide an effective reasoning procedure for
common knowledge in synchronous domains that is comparable with techniques
for handling individual-level knowledge, while also extending the
reach of our formalism into richer domains where some inductive reasoning
is required.

\begin{thm}
Let $\Dt_{sync}$ be a synchronous basic action theory, then:\[
\Dt_{sync}\cup\Dt_{K}^{obs}\models\forall s:\,\PKnows(\pi,\phi,s)\,\equiv\,\PKnowsZ(\pi,\phi,s)\]

\end{thm}
\begin{proof}
It suffices to show that:\[
\Dt_{sync}\cup\Dt_{K}^{obs}\models\PKnowsZ(\pi,\phi,s)\,\rightarrow\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\]


Then by Theorem \ref{thm:En_impl_En-1} we have that $\PKnowsZ(\pi,\phi,s)$
is enough to establish $\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))$ for
any $n$, which establishes the infinite conjunction in the definition
of $\PKnows(\pi,\phi,s)$ as required. Regressing $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$:\[
\Reg(\PKnowsZ(\pi,\phi,do(\{\},s)))\,\Rightarrow\,\forall c:\,\PKnowsZ(\Trn(\pi,\{\},c),\Reg(\phi,c),s)\]


$\Trn(\pi,\{\},c)$ will have the following form:\[
\Trn(\pi,\{\},c)\,\Rightarrow\, x\Leftarrow\{\}\,;\,\TrnA(\pi,x)\,;\,?x=c\]


For $x$ to take on a new value while traversing this path, it will
have to cross one of the regressed $agt$ steps in $\TrnA(\pi,x)$,
which have the following form:\[
z\,\Leftarrow Obs(agt,x)\,;\, agt\,;\,\exists x\,;\,?Legal(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\]


Entering this path with $x$ set to $\{\}$ will bind $z$ to $\{\}$.
$x$ can then take on any new value that is legal and has $Obs(agt,x)=z=\{\}$.
But the domain is synchronous, so by definition there are no such
legal actions. $x$ therefore remains set to $\{\}$ along the entire
path.

For any value of $c$ other than $\{\}$, there will be no situations
reachable by this regressed path and $\PKnowsZ$ will be vacuously
true. We can thus simply away the quantification over $c$ to get:\[
\PKnowsZ(\Trn(\pi,\{\},\{\}),\Reg(\phi,\{\}),s)\]


Since $x$ is aways bound to $\{\}$, the tests in the regressed $agt$
steps in $\TrnA(\pi,x)$ are always satisfied. Likewise, the regressed
$?\phi$ steps in $\TrnA(\pi,x)$ always have the form $?\Reg(\phi,x)$.
Since $\Reg(\phi,\{\})$ is always equivalent to $\phi$, we conclude
that in synchronous domains the path $\Trn(\pi,\{\},\{\})$ is precisely
equivalent the path $\pi$. This gives us the equivalence between
$\PKnows$ and $\PKnowsZ$ as required. 
\end{proof}

\section{The Link with Individual Knowledge\label{sec:CKnowledge:Correctness}}

The last remaining link is the most important of all: showing that
this new path-based account of knowledge actually captures the knowledge
of the agents, according to the semantics of individual knowledge
developed in Chapter \ref{ch:knowledge}. The following series of
theorems establish this important link. First, we produce special
cases of the regression rule for $\PKnows(\pi,\phi)$ for the case
of a single agent:

\begin{lemma}
\label{lem:Pknows_LbU_S0}For any $agt$ and $\phi$:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows(agt,\phi,S_{0})\,\equiv\,\PKnowsZ(agt,\Pst(\phi,LbU(agt)),S_{0})\]

\end{lemma}
\begin{proofsketch}
Begin by applying equation \eqref{eq:Reg_PKnows_S0} to the LHS to
get an expression in $\PKnowsZ$. By stepping through the regression
of $\PKnowsZ(agt,\phi,do(\{\},S_{0}))$ we show that for any $n$,
$\Pst^{n}(\PKnowsZ(agt,\phi,),\lambda c:c=\{\})[S_{0}]$ is equivalent
to $\PKnowsZ(agt,\Pst^{n}(\phi,\LbU(agt)),S_{0})$. The fixpoint calculation
for $\Pst$ thus terminates at the same value of $n$ in both cases,
giving the required equivalence. 
\end{proofsketch}
\begin{lemma}
\label{lem:Pknows_LbU_do}For any $agt$, $\phi$, $c$ and $s$:\begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\left[z=\{\}\,\rightarrow\,\PKnows(agt,\Pst(\phi,\LbU(agt)),s)\right]\\
\left[z\neq\{\}\,\rightarrow\,\PKnows(agt,\forall c':\,\left(Legal(c')\wedge Obs(agt,c')=z\right)\right.\\
\left.\rightarrow\Reg(\Pst(\phi,\LbU(agt)),c),s)\right]\end{multline*}

\end{lemma}
\begin{proofsketch}
We apply equation \eqref{eq:Reg_PKnows_S0} to get an expression in
$\PKnowsZ$. Repeating the calculations from Lemma \ref{lem:Pknows_LbU_S0}
gives us the required $\Pst$ expression, and regressing this over
$c$ gives us the required $\Reg$ expression. Using $\UnZ$ then
allows us to transform from $\PKnowsZ$ back to $\PKnows$ to obtain
the desired result. 
\end{proofsketch}
We will also need the following result for individual knowledge:

\begin{lemma}
\label{lem:Knows_impl_KnowsLbU}For any $agt$, $\phi$ and $s$:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\equiv\,\Knows(agt,\Pst(\phi,LbU(agt)),s)\]

\end{lemma}
\begin{proofsketch}
By induction on the regression rules for knowledge, and using the
following property of the persistence condition ({}``if $\phi$ persists,
then $\Pst(\phi,\alpha)$ persists''):\[
\forall s':\,\Pst(\phi,\alpha)[s]\,\wedge\, s\leq_{\alpha}s'\,\rightarrow\,\Pst(\phi,\alpha)[s']\]


We consider three cases: $s=S_{0}$, and $s=do(c,s)$ with $c$ both
observable and unobservable. Each case requires only a simple re-arrangement
of the relevant regression rule. 
\end{proofsketch}
\medskip{}


Finally, we are in a position to state the major theorem of this section:
that $\PKnows$ for a single agent is equivalent to the standard $\Knows$
macro.

\begin{thm}
For any $agt$, $\phi$ and $s$:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\,\equiv\,\,\PKnows(agt,\phi,s)\]

\end{thm}
\begin{proof}
By induction on the regression rules for each expression. For the
$S_{0}$ case, we require the following result which is true by the
definition of $\KDoZ$:\[
\KnowsZ(agt,\phi,S_{0})\equiv\PKnowsZ(agt,\phi,S_{0})\]
 The regression rule for $\Knows$ from equation \eqref{eqn:R_s0}
then precisely matches the result of Lemma \ref{lem:Pknows_LbU_S0}
and we have the required equivalence. For the $do(c,s)$ case, we
can substitute the result of Lemma \ref{lem:Knows_impl_KnowsLbU}
into the regression rule for $\Knows$ from equation \eqref{eqn:R_do_c_s}
to produce an expression precisely matching the result of Lemma \ref{lem:Pknows_LbU_do}.
Using $\Knows(agt,\phi,s)\equiv\PKnows(agt,\phi,s)$ from the inductive
hypothesis renders the two equivalent. 
\end{proof}
\medskip{}


Thus the expressions $\Knows(agt,\phi,s)$ and $\PKnows(agt,\phi,s)$
are equivalent under our formulation. This link is all that is required
to validate the additional complex modalities shown in equation \eqref{eq:pknows_identities},
repeated below for convenience.

\begin{thm}
The following identities hold under the theory of action $\Dt\cup\Dt_{K}^{obs}$:\begin{align*}
\Knows(A,\phi,s) & \,\,\equiv\,\,\PKnows(A,\phi,s)\\
\Knows(A,\Knows(B,\phi),s) & \,\,\equiv\,\,\PKnows(A;B,\phi,s)\\
\Knows(A,\phi,s)\wedge\Knows(B,\phi,s) & \,\,\equiv\,\,\PKnows(A\cup B,\phi,s)\\
\EKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows(\bigcup_{a\in G}a,\phi,s)\\
\CKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)\end{align*}

\end{thm}
\begin{proof}
Each follows from equivalence of $\Knows(agt,\phi,s)$ and $\PKnows(agt,\phi,s)$,
using the semantics of first-order dynamic logic as defined by $\KDoZ$.
For example, in the $\CKnows$ case we argue as follows: By definition,
$\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)$ is the transitive closure
of the union of $\PKnows(a,\phi,s)$ for $a\in G$. Also by definition,
$\CKnows(G,\phi,s)$ is the transitive closure of the union of $\Knows(a,\phi,s)$
for $a\in G$. Since $\PKnows(a,\phi,s)$ and $\Knows(a,\phi,s)$
are the same relation, their transitive closures are also the same
and the identity is entailed. 
\end{proof}

\section{An Illustrative Example\label{sec:CKnowledge:Example}}

With this technical machinery in place, we are now able to reason
about the group-level epistemic modalities of a team of agents. To
demonstrate we revisit our example domain from the previous chapter,
in which Alice and Bob have received an invitation to a party. We
add the the following initial knowledge axiom to $\Dt_{S_{0}}$:\begin{gather*}
\PKnowsZ((A\cup B)^{*},InRoom(A)\wedge InRoom(B),S_{0})\end{gather*}


The preconditions and effects of actions in this domain are relatively
simple, such that there is nothing that can be accomplished by a sequence
of hidden actions that cannot be accomplished by a single hidden action.
More formally, it is possible to show that:\[
\bigwedge_{n\in\mathbb{N}}\phi[\mathcal{E}^{n}(s)]\,\equiv\,\phi[\mathcal{E}^{1}(s)]\]
 In other words, the fixpoint calculation required for reasoning about
$\PKnows$ will always terminate after a single iteration. We will
therefore use the following identity to simplify presentation of the
example:\begin{align*}
\Reg(\PKnows(\pi,\phi,do(c,s))\,\Rightarrow & \UnZ(\Reg(\Pst(\PKnowsZ(\pi,\phi),\lambda c:\, c=\{\})[do(c,s)]))\\
\equiv\,\,\, & \UnZ(\Reg(\Reg(\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(do(c,s))))))\\
\equiv\,\,\,\forall c',c'': & \,\PKnows(\Trn(\Trn(\pi,\{\},c'),c,c''),\Reg(\Reg(\phi,c'),c''),s)\end{align*}


To keep the presentation compact, we abbreviate the fluent $InRoom$
to $IR$.

\begin{example}
After Bob reads the invitation, it is common knowledge that he knows
where the party is:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((A\cup B)^{*},\exists x:\Knows(B,loc=x),do(\{read(B)\},S_{0}))\]

\end{example}
This example hinges on the fact that initially, it is common knowledge
that both agents are in the room. It is thus common knowledge that
the occurrence of $read(Bob)$ will be observed by both agents. Suppressing
the inner expression for the moment, regressing using the above-mentioned
identity gives:\begin{multline*}
\Reg(\PKnows((A\cup B)^{*},\phi,do(read(B),S_{0})))\\
\Rightarrow\,\,\forall c,c':\,\PKnows(\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c'),\Reg(\Reg(\phi,c),c'),S_{0})\\
\Rightarrow\,\,\forall c,c',c'':\,\PKnowsZ(\Trn(\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c'),\{\},c''),\\
\Reg(\Reg(\Reg(\phi,c),c'),c''),S_{0})\end{multline*}
 We begin by evaluating $\Trn(\pi,\{\},c)$ :\[
\Trn((A\cup B)^{*},\{\},c)\,\Rightarrow\,\exists x\,;\,?x=\{\}\,;\,(\TrnA(A,x)\cup\TrnA(B,x))^{*}\,;\,?x=c\]
 With the cases for $\TrnA(agt,x)$ both evaluating to:\[
\TrnA(agt,x)\,\Rightarrow\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\,\exists x\,;\,?Legal(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\]
 Since we know all possible observations that Alice could make, let
us expand the path $\TrnA(A,x)$ by enumerating the possible values
for $z$. The first line in the result gives the case where $Obs(Alice,x)=\{\}$,
and the last line is the case where $Obs(Alice,x)=read(Alice)\#r$.
All other lines are where Alice simply observes the action $x$. \begin{gather*}
\TrnA(A,x)\,\Rightarrow\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\\
?\, x=\{\}\vee(x=read(B)\wedge\neg IR(A)))\,;\, A\,;\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\exists x\,;\,?\, x=\{\}\vee(x=read(B)\wedge IR(B)\wedge\neg IR(A))\\
\cup\,\,?x=enter(A)\,;\, A\,;\,\exists x\,;\,?x=enter(A)\wedge IR(A)\\
\cup\,\,?x=enter(B)\,;\, A\,;\,\exists x\,;\,?x=enter(B)\wedge IR(B)\\
\cup\,\,?x=leave(A)\,;\, A\,;\,\exists x\,;\,?x=leave(A)\wedge\neg IR(A)\\
\cup\,\,?x=leave(B)\,;\, A\,;\,\exists x\,;\,?x=leave(B)\wedge\neg IR(B)\\
\cup\,\,?\, x=read(B)\wedge IR(A)\,;\, A\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x=read(A)\wedge loc(r)\,;\, A\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(A)\wedge loc(r)\end{gather*}
 Now consider starting with $x$ set to $\{\}$ and following this
path some number of times. On the first iteration, $x$ may get rebound
to either $\{\}$ or $read(B)$. Subsequent iterations may alternate
between these values, but can never bind $x$ to any other action.
An analogous argument for $\TrnA(B,x)$ shows that the path $\Trn((A\cup B)^{*},\{\},c)$
can be simplified to consider only the actions $\{\}$, $read(A)$
and $read(B)$, with any other binding of $x$ being unreachable:\begin{multline*}
\Trn((A\cup B)^{*},\{\},c)\,\Rightarrow\,\exists x\,;\,?x=\{\}\,;\,(\\
?\, x=\{\}\vee(x=read(B)\wedge\neg IR(A)))\,;\, A\,;\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\exists x\,;\,?\, x=\{\}\vee(x=read(B)\wedge IR(B)\wedge\neg IR(A))\\
\cup\,\,?\, x=\{\}\vee(x=read(A)\wedge\neg IR(B)))\,;\, B\,;\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\exists x\,;\,?\, x=\{\}\vee(x=read(A)\wedge IR(A)\wedge\neg IR(B))\\
\cup\,\,?\, x=read(B)\wedge IR(A)\,;\, A\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x=read(A)\wedge loc(r)\,;\, A\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(A)\wedge loc(r)\\
\cup\,\,?\, x=read(A)\wedge IR(B)\,;\, B\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(B)\wedge IR(A)\\
\cup\,\,\exists r\,;\,?\, x=read(B)\wedge loc(r)\,;\, B\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(B)\wedge loc(r)\\
)^{*}\,;\,?x=c\end{multline*}
 This path matches with our intuitions about the observability of
actions. Since the $enter$ and $leave$ actions are always public,
they can never be mistaken for the empty action and are irrelevant
in the path $\Trn(\pi,\{\},c)$. Moreover, the binding of $x$ may
only switch from $\{\}$ to $read(B)$ if there is a possible world
in which Alice is not in the room, reflecting the conditions under
which that action would be hidden.

Next we evaluate the $\Trn(\pi,read(B),c')$ portion, which will produce:\begin{multline*}
\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c')\,\Rightarrow\,\exists x'\,;\,?x'=read(B)\,;\,\exists x\,;\,?x=\{\}\,;\\
(\TrnA(\TrnA(A,x),x')\cup\TrnA(\TrnA(B,x),x'))^{*}\,;\,?x=c\,;\,?x'=c'\end{multline*}
 As before, the only possible values of $x'$ are $\{\}$, $read(A)$
and $read(B)$. None of these actions affect any of the tests present
in $\Trn((A\cup B)^{*},\{\},c)$, so we can safely leave them unchanged
in the resulting path:\begin{multline*}
\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c')\,\Rightarrow\,\exists x'\,;\,?x'=read(B)\,;\,\exists x\,;\,?x=\{\}\,;\,(\\
?x=\{\}\vee(x=read(B)\wedge\neg IR(A)));\TrnA(A,x');\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\exists x;?x=\{\}\vee(x=read(B)\wedge IR(B)\wedge\neg IR(A))\\
\cup\,?x=\{\}\vee(x=read(A)\wedge\neg IR(B)));\TrnA(B,x');\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\exists x;?x=\{\}\vee(x=read(A)\wedge IR(A)\wedge\neg IR(B))\\
\cup\,\,?\, x=read(B)\wedge IR(A)\,;\,\TrnA(A,x')\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x=read(A)\wedge loc(r)\,;\,\TrnA(A,x')\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(A)\wedge loc(r)\\
\cup\,\,?\, x=read(A)\wedge IR(B)\,;\,\TrnA(B,x')\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(B)\wedge IR(A)\\
\cup\,\,\exists r\,;\,?\, x=read(B)\wedge loc(r)\,;\,\TrnA(B,x')\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(B)\wedge loc(r)\\
)^{*}\,;\,?x=c\,;\, x'=c'\end{multline*}
 We can complete this expansion using the previously calculated result
for $\TrnA(A,x)$, but will proceed leaving this implicit. Finally,
we must apply $\Trn$ again for the $\Trn(\pi,\{\},c'')$ portion.
The process is identical and we will not repeat it here.

We next evaluate this path over the initial epistemic relation of
the agents, about which we know:\[
\PKnowsZ((A\cup B)^{*},IR(A)\wedge IR(B),S_{0})\]


Consider how this restricts the possible bindings of $x$, $x'$ etc.
For $x$ to switch from its initial value of $\{\}$ to $read(A)$
(resp. $read(B)$) the path must traverse a test for $\neg IR(B)$
(resp. $\neg IR(A)$). Since we know that these tests will never succeed
on the initial epistemic frame, we can conclude that $x$ will always
be bound to $\{\}$. Since the path insists that $x=c$ at termination,
this is the only interesting value for $c$ - any value of $c$ other
than $\{\}$ will result in no worlds being reachable by the regressed
path and will thus have $\PKnowsZ$ vacuously true. By a similar argument,
we find that the only interesting values of $c'$ and $c''$ are $read(B)$
and $\{\}$ respectively.

Turning now to the regression of the inner formula, we have:\begin{gather*}
\Reg(\Reg(\Reg(\exists x:\,\Knows(B,loc=x),c),c'),c'')\\
\Rightarrow\Reg(\Reg(\Reg(\exists x:\,\Knows(B,loc=x),\{\}),read(B)),\{\})\\
\Rightarrow\Reg(\Reg(\exists x:\,\Knows(B,loc=x),read(B),\{\})\\
\Rightarrow true\end{gather*}


Thus for $c=\{\}$, $c'=read(B)$, $c''=\{\}$ the known formula is
a tautology, while for any other values the regressed epistemic path
has no reachable worlds. The example is therefore entailed by the
domain.

~

\begin{example}
After Bob reads the invitation, the location is not common knowledge\[
\Dt\cup\Dt_{K}^{obs}\,\not\models\,\PKnows((Alice\cup Bob)^{*},loc=C,do(read(Bob),S_{0}))\]

\end{example}
Regression of the epistemic path proceeds as with the previous example,
but regression of the inner formula no longer produces a tautology.
If we ignore the path components dealing with $c$ and $c''$, which
from the previous example we know to be redundant, regressing this
expression produces the following:

\begin{multline*}
\PKnowsZ(\dots\\
\cup\,\,?\, x'=read(B)\wedge IR(A)\,;\, A\,;\,\exists x'\,;\,?\, x'=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x'=read(B)\wedge loc(r)\,;\, B\,;\,\exists x'\,;\,?\, x'=read(B)\wedge IR(B)\wedge loc(r)\\
\cup\dots,loc=C,S_{0})\end{multline*}


This means, very roughly, that $read(B)$ could result in common knowledge
that $loc=C$ if it was commonly known that the preconditions of $read(B)$
implied $loc=C$. Since $read(B)$ is commonly observed, this would
be enough to obtain common knowledge of the location. Since no such
information is not given in the domain description, the example is
not entailed.

~

\begin{example}
After Alice also reads the invitation, the location becomes common
knowledge:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((Alice\cup Bob)^{*},loc=C,do(read(Alice),do(read(Bob),S_{0})))\]

\end{example}
The additional action here can be handled in the same manner as the
previous example. We will not repeat the working, but simply state
that this indeed is a consequence of our theory.


\section{Comparison with LCC\label{sec:CKnowledge:Comparison}}

Having constructed our account of complex epistemic modalities in
the situation calculus, let us now reflect on some of the similarities
and differences between our approach and the Logic of Communication
and Change of \citet{vanBenthem06lcc}.

The most obvious difference is that our formalism supports - indeed,
\emph{must} support - first-order preconditions and effects and is
not limited to finite domains. By contrast, LCC is propositional and
actions must be explicitly specified in terms of a finite update model.
This is for the most part simply reflective of the different traditions
from which these formalisms emerge -- of the underlying differences
between modal logics of action and the situation calculus \citep{vanbentham07ml_sitcalc}.
It is likely that LCC could be expanded into a first-order modal formalism
without significant modification. We note, however, that the macro-based
approach of the situation calculus automatically settles the semantic
issues that can complicate first-order modal logics: quantifying into
modalities; de-dicto vs de-re; rigid vs monotonic vs arbitrary domains;
etc \citep{fitting98fo_ml}.

Another important difference is that in the situation calculus, actions
are concrete terms in the logic that can be manipulated and quantified
over. In LCC, the update modes responsible for changing the world
come from outside the world itself, and must be specified as an explicit
structure whenever they are used. They cannot be quantified over.
This difference is key to our handling of asynchronous domains, by
allowing agents to consider arbitrarily-long sequences of hidden actions.
While LCC is capable of representing hidden actions, the agents cannot
account for them and they cause knowledge to degenerate into belief
\citep[section 5.2]{vanBenthem06lcc}.

Our formalism also has the advantage that it can be used by a situated
agent to reason about its own knowledge using its local view $v$,
including reasoning about common knowledge using a query such as:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\PKnows((\bigcup_{a\in G}a)^{*},\phi)),v)\]


This ability comes from having views reified as first-order terms.
While LCC provides powerful mechanisms for reasoning \emph{about}
multi-agent knowledge, it does not appear to be suitable for reasoning
\emph{in} multi-agent domains.

For a more detailed comparison, consider the operation of the program
transformer $T_{ij}^{U}$ of LCC. First, we have the reduction rule
for epistemic programs:\[
[U,e_{i}][\pi]\phi\,\,\Rightarrow\,\,\bigwedge_{j=0}^{n-1}[T_{ij}^{U}(\pi)][U,e_{j}]\phi\]


Since the update model $U$ is finite, this rule can construct a finite
conjunction of the possible actions $j=0$ through $j=n-1$, and separately
consider the conditions under which action $i$ would be mistaken
for action $j$. Our regression rule lifts this to the first-order
case by quantifying over all possible actions:\[
\Reg(\PKnowsZ(\pi,\phi,do(c,s)))\isdef\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\]


If the \noun{Action }sort were finite, we could replace this quantifier
with a conjunction to get essentially the same rule as LCC. Next,
consider the definition of the $T_{ij}^{U}$ transformer:

\begin{align*}
T_{ij}^{U}(agt)\isdef & \begin{cases}
?pre(e_{i});a & if\, e_{i}R(agt)e_{j}\\
?\bot & otherwise\end{cases}\\
T_{ij}^{U}(?\phi)\isdef & \begin{cases}
?pre(e_{i})\wedge[U,e_{i}]\phi & if\, i=j\\
?\bot & otherwise\end{cases}\\
T_{ij}^{U}(\pi_{1};\pi_{2})\isdef & \bigcup_{k=0}^{n-1}(T_{ik}^{U}(\pi_{1});T_{kj}^{U}(\pi_{2}))\\
T_{ij}^{U}(\pi_{1}\cup\pi_{2})\isdef & T_{ij}^{U}(\pi_{1})\cup T_{ij}^{U}(\pi_{1})\\
T_{ij}^{U}(\pi^{*})\isdef & K_{ijn}^{U}(\pi)\end{align*}


Apart from the $\pi^{*}$ case, which we will separately, these definitions
are broadly similar to the rules for our epistemic path regressor
from Definition \ref{def:EpistemicPathRegression}. Where our rules
use a fresh variable to track the {}``current action'' being performed
in each situation, these rules use external indices $i$ and $j$
and depend on the restriction to finitely-many possible actions. The
case for a base $agt$ modality encodes the possibility of that agent
mistaking event $e_{i}$ for event $e_{j}$, which is represented
explicitly by the relation $R(agt)$ from the update model. The case
for $\pi_{1};\pi_{2}$ uses a finite disjunction to permit any intermediate
event $k$.

The $\pi^{*}$ case is handled by appealing to a variant of Kleene's
construction on finite automata, whereby all paths through the automata
are enumerated by progressively including more and more states \citep[ Theorem 2.5.1]{lewis81theory_of_computation}.
The auxiliary operator $K_{ijk}^{U}(\pi)$ represents all the paths
from $i$ to $j$ through the update model $U$ that can be generated
by following $\pi$ zero or more times, but without using intermediate
events numbered greater than $k$:\begin{align*}
K_{ij0}^{U}(\pi)\isdef & \begin{cases}
?\top\cup T_{ij}^{U} & if\, i=j\\
?T_{ij}^{U} & otherwise\end{cases}\\
K_{ij(k+1)}^{U}(\pi)\isdef & \begin{cases}
(K_{kkk}^{U}(\pi))^{*} & if\, i=j=k\\
(K_{kkk}^{U}(\pi)^{*});K_{kjk}^{U}(\pi) & if\, i=j\neq k\\
K_{ikk}^{U}(\pi);(K_{kkk}^{U}(\pi))^{*} & if\, i\neq k=j\\
K_{ijk}^{U}(\pi)\cup(K_{ikk}^{U}(\pi);(K_{kkk}^{U}(\pi))^{*};K{}_{kjk}^{U}(\pi)) & otherwise\end{cases}\end{align*}


The definition $T_{ij}^{U}(\pi^{*})\isdef K_{ijn}^{U}(\pi)$ thus
permits paths using any of the $n$ possible intermediate events.
The proof that $T_{ij}^{U}$ works as required then requires several
lemmas that establish the validity of this $K_{ijk}^{U}$ construction.

Contrast this construction with our own rule for handling the $\pi^{*}$
case:\[
\TrnA(\pi^{*},x)\,\isdef\,\TrnA(\pi,x)^{*}\]


Since we are using first-order dynamic logic, we do not need to explicitly
enumerate all possible intermediate states reached by following $\pi^{*}$.
We argue that our formulation, using a variable to keep track of the
{}``current action'' in a regressed epistemic path, is a more natural
expression of the intended operation of the path regression operator.
Our correctness proofs are correspondingly simpler. The more complicated
Kleene-style operator of LCC is required in order to render epistemic
path regression in a propositional formalism.

In synchronous domains with a finite state-space the situation calculus
may not offer a gain in expressiveness, but it can certainly provide
a more succinct axiomatisation. Moving beyond such domains, our formalism
offers the potential to incorporate other rich domain features that
have been developed for the situation calculus, such as continuous
time and actions with duration \citep{reiter96sc_nat_conc}.


\section{Answering the Regressed Query\label{sec:CKnowledge:Reasoning}}

We are now in a position to reduce an epistemic query $\PKnows(\pi,\phi,\sigma)$
at some future situation to an epistemic query $\PKnowsZ(\Trn^{*}(\pi),\Reg^{*}(\phi),S_{0})$
at the initial situation. While this is a significant gain for effective
automated reasoning, it still remains to calculate and answer the
regressed query.

As with individual knowledge, we assume that queries will be handled
by a special-purpose modal theorem prover rather than by expanding
the macros. In order to calculate the persistence conditions in regression
rules (\ref{eq:Reg_PKnows_do},\ref{eq:Reg_PKnows_S0}), we require
s\emph{tatic domain reasoning} about $\PKnowsZ$ modalities. Likewise,
to answer the regressed query, one must perform \emph{initial situation
reasoning} about $\PKnowsZ$ modalities. While we have gained the
ability to use proper regression rules, we have moved from the semi-decidable
case of purely first-order reasoning to the undecidable case of reasoning
in FODL, which is known to be $\Pi_{1}^{1}$-hard in general \citep{kooi07dyn_termmodal_logic}.

Facing the potential for undecidability is nothing new for the situation
calculus, and we proceed in the tradition of previous work: by identifying
domain restrictions that enable more effective reasoning.\\


As discussed in Sections \ref{sec:Background:Reasoning} and \ref{sec:Persistence:Effectiveness},
one of the best ways to gain decidability in the situation calculus
is to assume that non-situation sorts such as \noun{Action} and \noun{Object}
are finitely enumerable. This allows the domain to be {}``propositionalised''
and queries to be answered using propositional logic. Will the same
restriction allow us to gain decidability for our complex epistemic
modalities?

Since we do not use \noun{Situation} terms in epistemic paths, it
seems we should be able to translate $\PKnowsZ$ modalities in such
domains from FODL into PDL by enumerating the possible values for
each path variable. This is not straightforward, however, since variable
re-bindings can be performed inside the scope of an iteration. How
does one convert a path like the following into PDL?\[
(?\phi(x);\,\exists x\,;\, A)^{*}\]


Here we close the loop from our first-order formalism back to the
propositional formalism of LCC -- the Kleene-style construction used
to regress $\pi^{*}$ paths in LCC is precisely what is required to
translate FODL into PDL and gain decidability.

Suppose the epistemic path $\pi$ contains $n$ path variables, then
let the \emph{state} of that path be a vector of length $n$ giving
the current value of each variable. Since variable domains are finite,
we can finitely enumerate all possible states of the path. Let them
be labelled $0$ through $m$, and let $\phi^{i}$ represent the formula
obtained from $\phi$ by replacing all path variables with their values
in state $i$. Let $\phi^{\downarrow}$ represent the standard propositionalisation
of first-order formula $\phi$. A FODL modality $\PKnowsZ(\pi,\phi)$
can be translated into a PDL modality $\mathbf{Prop}[\PKnowsZ(\pi,\phi)]$
as follows. $\mathbf{Prop}_{ij}[\pi]$ represents the propositionalisation
of path $\pi$ with start state $i$ and end state $j$:\begin{align*}
\mathbf{Prop}[\PKnowsZ(\pi,\phi)]\isdef & \bigwedge_{i=0}^{m}\bigwedge_{j=0}^{m}\PKnowsZ(\mathbf{Prop}_{ij}[\pi],\phi^{\downarrow})\\
\mathbf{Prop}_{ij}[agt]\isdef & \begin{cases}
agt & \mathrm{if\, i=j}\\
?\bot & \mathrm{otherwise}\end{cases}\\
\mathbf{Prop}_{ij}[?\phi]\isdef & \begin{cases}
?\phi^{i\downarrow} & \mathrm{if\, i=j}\\
?\bot & \mathrm{otherwise}\end{cases}\\
\mathbf{Prop}_{ij}[\exists x_{n}]\isdef & \begin{cases}
?\top & \mathrm{if\,\, i,j\,\, differ\, only\, at\, n}\\
?\bot & \mathrm{otherwise}\end{cases}\\
\mathbf{Prop}_{ij}[\pi_{1};\pi_{2}]\isdef & \bigcup_{k=0}^{m}(\mathbf{Prop}_{ik}[\pi_{1}];\mathbf{Prop}_{kj}[\pi_{2}])\\
\mathbf{Prop}_{ij}[\pi_{1}\cup\pi_{2}]\isdef & \,\,\mathbf{Prop}_{ij}[\pi_{1}]\cup\mathbf{Prop}_{ij}[\pi_{2}]\\
\mathbf{Prop}_{ij}[\pi^{*}]\isdef & \,\,\mathbf{PropK}_{ijm}(\pi)\end{align*}
 \begin{align*}
\mathbf{PropK}_{ij0}[\pi] & \isdef\begin{cases}
?\top\cup\mathbf{Prop}_{ij}[\pi] & \mathrm{if\, i=j}\\
\mathbf{Prop}_{ij}[\pi] & \mathrm{otherwise}\end{cases}\\
\mathbf{PropK}_{ij(k+1)}[\pi]\isdef & \mathbf{PropK}_{ijk}[\pi]\cup(\mathbf{PropK}_{ikk}[\pi];\mathbf{PropK}_{kkk}[\pi]^{*};\mathbf{PropK}_{kjk}[\pi])\end{align*}


To answer the regressed query in the initial situation, we may be
to assume that initial knowledge is specified in a restricted form
that further increases the effectiveness of reasoning. For example,
it may be that the initial situation is completely known and uncertainty
is introduced only due to partial observability of actions. In this
case the initial epistemic frame contains the lone situation $S_{0}$,
and the regressed path can be reduced to a series of tests and variable
re-bindings.

More generally, we have have a specific model to represent the group's
knowledge in the initial situation. In this case the regressed query
can be answered using model-checking rather than satisfiability --
for PDL this reduces the complexity from EXPTIME-complete to PTIME-complete,
a very significant win \citep{lange05pdl_model_checking}.

It may also be possible to identify restricted fragments of FODL that
are sufficient to capture common knowledge in some domains. For example,
\citet{vanBenthem06lcc} show that in domains with public actions
the regression of common knowledge can be expressed using a special
relativised common-knowledge operator, rather than requiring the full
power of PDL. As a first step towards this, we note that when starting
from the expression for common knowledge, our epistemic path regressor
$\Trn$ will not generate nested iteration operators. Formulae in
such \emph{star-normal form} are known to simplify proof search in
PDL \citep{abate07twb_pdl}. Identifying more restricted fragments
that can simplify our epistemic language is a promising avenue for
future research.

We have produced a preliminary reasoning engine based on our technique
for propositional domains, utilising a modified version of the PDL
prover from the Tableaux Workbench suite \citep{abate07twb_pdl},
and have used it to verify some simple examples. This implementation
is available TODO.


\section{Encoding $\KDoZ$\label{sec:CKnowledge:Encoding-KDoZ}}

This section develops an encoding of first-order dynamic logic into
the situation calculus via macro expansion. As discussed briefly in
Section \ref{sec:CKnowledge:Epistemic-Paths}, we want to avoid having
to explicitly axiomatise first-order variable bindings as terms in
the logic. Our encoding is based on embedding FODL into an epistemic
variant of Golog.

This may seem like an unnecessary complication - why not expand FODL
directly into sentences of the situation calculus? We find the embedding
into Golog simpler and clearer, and expect many readers familiar with
the situation calculus will feel likewise. As Golog is well-understood,
it relieves some our burden of proof in establishing that the embedding
works as required. Since the semantics of Golog itself it based on
macro-expansion, the end-result is the the same: sentences of FODL
macro-expand into sentences of the situation calculus. Finally, our
modification to Golog so that it is interpreted over epistemic frames
may further elucidate the intended operation of FODL in this paper.

First, let us introduce the semantics of \emph{epistemic} Golog. In
the following, $\delta$ will represent an arbitrary Golog program.
As discussed in Chapter \ref{ch:background} the semantics of Golog
were originally defined as a macro $\mathbf{Do}(\delta,s,s')$ which
stands for {}``it is possible to execute program $\delta$, starting
in situation $s$, and ending in situation $s'$'' \citep{levesque97golog}.
Since we intend to interpret Golog over epistemic frames, we will
use the macro $\EDo$ to make this distinction clear. This requires
only one modification to the standard Golog - the base operators are
agent terms, rather than actions.

\begin{defnL}
[{Semantics~of~Epistemic~Golog}] The semantics of Golog
over epistemic frames is given by the macro $\EDo$ defined as follows,
where $P$ names a predicate symbol:\[
\delta::=agt\,|\,?\phi\,|\,\delta_{1};\delta_{2}\,|\,\delta_{1}\cup\delta_{2}\,|\,\pi(x)(\delta(x))\,|\,\delta^{*}\,|\,\mathbf{proc}\, P(\vars{x})\,\delta(\vars{x})\,\mathbf{end}\,;\,\delta\,|\, P(\vars{x})\]
 \begin{align*}
\EDo(agt,s,s')\,\isdef\,\, & K_{0}(agt,s',s)\\
\EDo(?\phi,s,s')\,\isdef\,\, & s=s'\wedge\phi[s]\\
\EDo(\delta_{1}\,;\,\delta_{2},s,s')\,\isdef\,\, & \exists s'':\,\EDo(\delta_{1},s,s'')\,\wedge\,\EDo(\delta_{2},s'',s')\\
\EDo(\delta_{1}\,\cup\,\delta_{2},s,s')\,\isdef\,\, & \EDo(\delta_{1},s,s')\vee\EDo(\delta_{2},s,s')\\
\EDo(\pi(x)(\delta(x)),s,s')\,\isdef\,\, & \exists x:\,\EDo(\delta(x),s,s')\\
\EDo(\delta^{*},s,s')\,\isdef\,\, & \mathrm{refl.\, trans.\, closure\, of}\,\,\EDo(\delta,s,s')\\
\EDo(P(\vars{x}),s,s')\,\isdef\,\, & P(\vars{x},s,s')\end{align*}

\end{defnL}
The final clause identifies a procedure call with arguments $\vars{x}$.
Defining procedure calls via macro expansion involves a second-order
definition corresponding to the standard least-fixed-point semantics
for recursive procedures. This operates as follows, taking a list
of $n$ procedure definitions followed by a main program invocation:\begin{multline*}
\EDo(\{\mathbf{proc}\, P_{1}(\vars{v_{1}})\,\delta_{1}\,\mathbf{end}\,;\dots\,;\,\mathbf{proc}\, P_{n}(\vars{v_{n}})\,\delta_{n}\,\mathbf{end}\,;\,\delta_{0}\}\,\isdef\,\\
\forall(P_{1},\dots,P_{n})\left[\bigwedge_{i=1}^{n}\forall s_{1},s_{2},\vars{v_{i}}:\,\EDo(\delta_{i},s_{1},s_{2})\,\rightarrow\,\EDo(P_{i}(\vars{v}_{i}),s_{1},s_{2})\right]\\
\rightarrow\,\,\EDo(\delta_{0},s,s')\end{multline*}


Clearly Golog is a very powerful language, so the question must be
asked: could we use Golog directly for our epistemic path language,
rather than FODL? Unfortunately not, as Golog has no notion of \emph{state}
- while the Golog operator $\pi(x)(\delta(x))$ is similar to the
FODL operator $\exists x$, its effect is localised to the contained
program $\delta(x)$. FODL allows variable assignments to affect the
entire remaining program.

We review the operators and required semantics of FODL for convenience:\[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]
 \[
\KDoZ(\pi,s,s')\,\,\equiv\,\,\exists\mu'\,\KDoZ(\pi,\varepsilon,s,\mu',s')\]
 \begin{gather*}
\KDoZ(agt,\mu'',s'',\mu,s)\,\equiv\,\mu''=\mu\,\wedge\, K_{0}(agt,s'',s)\\
\KDoZ(?\phi,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu\,\wedge\,\mu(\phi)[s]\\
\KDoZ(\pi_{1};\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\exists\mu',s':\,\KDoZ(\pi_{1},\mu',s',\mu,s)\,\wedge\,\KDoZ(\pi_{2},\mu'',s'',\mu',s')\\
\KDoZ(\pi_{1}\cup\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\KDoZ(\pi_{1},\mu'',s'',\mu,s)\,\vee\,\KDoZ(\pi_{2},\mu'',s'',\mu,s)\\
\KDoZ(x:=t,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu[x/t]\\
\KDoZ(\exists x,\mu'',s'',\mu,s)\,\equiv\,\exists z:\, s''=s\,\wedge\,\mu''=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu'',s'',\mu,s)\rightarrow\KDoZ(\pi^{*},\mu'',s'',\mu,s)\right]\end{gather*}


These semantics explicitly use first-order substitutions to manage
stateful variables. In order to simulate this via macro expansion,
we use what is essentially a continuation-passing transformation to
avoid explicitly mentioning substitutions.

First, note that any epistemic path $\pi$ will be contain only a
finite number of path variables. Without loss of generality, suppose
that $\pi$ contains $n$ such variables named $x_{1}$ to $x_{n}$.
The idea is to translate each component of the path into a Golog procedure
with $n$ arguments, where the $i$th argument is used to pass in
the current value of $x_{i}$. After performing the necessary operations
to encode the semantics of that path component, it calls a continuation
procedure containing the next path component. This translation is
based on the macro $\KDoC(\pi,N,C)$ which is passed the name it should
use for the procedure encoding the given path component ($N$) and
the name of the continuation procedure ($C$).

\begin{defnL}
[{Embedding~FODL~into~Golog}] The embedding of FODL into
epistemic Golog is given by the macros $\KDoZ$ and $\KDoC$ defined
as follows, where $P_{i}$ are fresh procedure names and $\vars{v}$
are argument vectors of length $n$:\begin{multline*}
\KDoZ(\pi,s,s')\,\isdef\,\,\ \EDo(\{\KDoC(\pi,P,End)\,;\,\\
\mathbf{proc}\, End(\vars{v})\,?\top\,\mathbf{end}\,;\,\pi(\vars{v})(P(\vars{v}))\},s,s')\end{multline*}

\end{defnL}
\begin{align*}
\KDoC(agt,N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\, agt\,;\, C(\vars{v})\,\mathbf{end}\\
\KDoC(?\phi(\vars{x}),N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,?\phi(\vars{v})\,;\, C(\vars{v})\,\ \mathbf{end}\\
\KDoC(\exists x_{i},N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,\pi(x)(C(\vars{v}[v_{i}/x]))\,\mathbf{end}\\
\KDoC(\pi_{1};\pi_{2},N,C)\,\isdef\,\, & \KDoC(\pi_{1},N,P)\,;\,\KDoC(\pi_{2},P,C)\\
\KDoC(\pi_{1}\cup\pi_{2},N,C)\,\isdef\,\, & \KDoC(\pi_{1},P_{1},C)\,;\,\KDoC(\pi_{2},P_{2},C)\,;\\
 & \,\mathbf{\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, proc}\, N(\vars{v})\, P_{1}(\vars{v})\cup P_{2}(\vars{v})\,\mathbf{end}\\
\KDoC(\pi^{*},N,C)\,\isdef\,\, & \KDoC(\pi,P,N)\,;\,\mathbf{proc}\, N(\vars{v})\, C(\vars{v})\cup P(\vars{v})\,\mathbf{end}\end{align*}


This translation generates one procedure for each operator in the
path, plus the procedure $End$ used to successfully terminate execution.
Most of these definitions are straightforward translations of equivalent
operators in FODL to Golog. One interesting case is $\exists x_{i}$,
which calls the continuation procedure with a fresh variable in position
$i$.

The most complex case is $\pi^{*}$, which simulates iteration using
a pair of mutually recursive procedures $P$ and $N$. Procedure $N$
can either terminate immediately (calling the continuation $C$) or
call $P$. A call to $P$ executes one iteration of $\pi$ before
continuing with another invocation of $N$. The possible executions
for $\pi^{*}$ are thus $nil$, $\pi$, $\pi;\pi$, etc as required
by the semantics of FODL.

It should be clear that the expansion of each operator satisfies the
relevant identity from Definition \ref{def:KDoZ}, and the encoding
thus acts as required.


\section{Discussion\label{sec:CKnowledge:Discussion}}

In this chapter we have introduced a technique for representing and
reasoning about complex epistemic modalities in the situation calculus.
In order to formulate an effective reasoning procedure, we have had
to move beyond just $\Knows$ and $\CKnows$ and introduce a powerful
epistemic path language based on dynamic logic. Mirroring the development
of knowledge for individual agents, group-level modalities are introduced
as macros of the form $\PKnows(\pi,\phi,s)$ where $\pi$ is a complex
epistemic path. To avoid having to expand these macros during reasoning,
we have modified the regression operator to treat them as primitive
fluents.

As with the previous chapter, hidden actions are handled using the
persistence condition meta-operator to perform a fixpoint calculation.
For synchronous domains, we have proven that this fixpoint calculation
is unnecessary and regression can be performed as a purely syntactic
manipulation. Demonstrating the utility of our approach, we have presented
an example of effective reasoning about common knowledge in an asynchronous,
partially observable domain. This powerful new ability is a first
for the situation calculus.

While the expressiveness of our epistemic path language means that
answering a regressed knowledge query can be difficult in the general
case, we have shown that for finite domains we maintain the ability
to propositionalise the queries and answer them in a robustly decidable
manner.

Our development has clear parallels with the development of LCC \citep{vanBenthem06lcc}.
We choose the situation calculus for its much richer ontology, e.g.
preconditions and effects are first order, while actions take arguments
and may be performed concurrently. On one hand, this forces us to
use a more powerful dynamic logic for our epistemic language and run
the risk of undecidability. On the other, it actually simplifies some
aspects of our presentation. We do not need explicit update frames,
and the definition of our path regressor does not require an auxiliary
Kleene-style operator to handle iteration.

