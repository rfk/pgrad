

\chapter{Complex Epistemic Modalities}

\label{ch:cknowledge}

This chapter develops an explicit formal treatment of group-level
epistemic modalities in the situation calculus. The primary motivation
for this work is a formal treatment of common knowledge, but as we
shall see, this requires significant technical machinery capable of
handling much more general epistemic modalities.

In the previous chapter we constructed a powerful new account of \emph{individual}
knowledge in rich multi-agent domains. The examples from Chapter \ref{ch:knowledge}
demonstrate that this formalism can be used to reason about simple
group-level knowledge by nesting individual knowledge operators. But
since common knowledge is infinitary, it cannot be handled in this
way. We must instead develop an explicit regression rule for common
knowledge.

However, we are bound by a fundamental expressivity limitation: the
regression of common knowledge cannot be expressed in terms of common
knowledge alone. To overcome this we take our cue from recent promising
work in dynamic epistemic logic, with the main idea due to \citet{vanBenthem06lcc}:
increase the expressiveness of the epistemic language so it is strong
enough to formulate a proper regression rule. They have developed
the Logic of Communication and Change (henceforth {}``LCC'') using
propositional dynamic logic to express epistemic modalities, and have
shown that it allows reasoning about common knowledge using techniques
akin to regression. We follow a similar approach in this chapter and
introduce complex epistemic modalities to the situation calculus.

Following the tradition of \citet{scherl03sc_knowledge} we develop
our formalism as a series of macro-expansions, with no changes to
the underlying situation calculus theory. The language of first-order
dynamic logic is used to construct complex epistemic paths, with the
macro $\PKnows(\pi,\phi,s)$ expressing knowledge using such a path.
Since common knowledge is defined as the transitive closure of the
union of the agents' base knowledge operators, it can be expressed
as $\PKnows((A\cup B)^{*},\phi,s)$. Regression is then modified to
treat $\PKnows(\pi,\phi,do(c,s))$ as a primitive fluent, producing
an equivalent formula $\PKnows(\Trn(\pi),\Reg(\phi),s)$ where $\Trn$
is a new operator called the epistemic path regressor.

While this chapter naturally parallels the development of LCC in \citep{vanBenthem06lcc},
there are also substantial differences. LCC is built on modal logic
and so handles only propositional, synchronous domains. The richer
ontology of the situation calculus means our formalism must support
first-order preconditions and effects, quantifying-in and de-dicto/de-re,
and arbitrary sets of concurrent actions. It must also incorporate
our new technique for handling hidden actions while remaining compatible
with other extensions to the situation calculus. The macro-expansion
approach, coupled with our rigorous observation-based semantics, allows
our formalism to neatly fulfil all these requirements.

The effectiveness of our technique is demonstrated with an example
of reasoning about common knowledge in a partially-observable domain,
a first for the situation calculus. This chapter thus contributes
a rich multi-agent theory of knowledge and action in which complex
group-level epistemic modalities are amenable to effective automated
reasoning.

We proceed as follows: TODO

The remainder of this section proceeds as follows. In Section \ref{sec:CKnowledge:Epistemic-Paths}
we define a variant of first-order dynamic logic for use as an epistemic
path language, which is encoded in the situation calculus using the
macro $\KDoZ(\pi,s,s')$. This macro is analogous to the fluent $K(agt,s',s)$
from the previous section, but expresses more complex epistemic relationships
between situations.

Section \ref{sub:Synchronous-Epistemic-Fluent} develops a \emph{synchronous}
account of complex epistemic modalities. The macro $\PKnowsZ(\pi,\phi,s)$
expresses knowledge using an epistemic path $\pi$ under the assumption
that there have been no hidden actions. We develop a regression rule
using a new operator $\Trn$ to perform regression inside the epistemic
path, transforming $\PKnowsZ(\pi,\phi,do(c,s))$ into an equivalent
expression $\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)$.

Section \ref{sub:Introducing-Hidden-Actions} introduces hidden actions
by explicitly representing them with an empty action set. We simulate
agents reasoning about arbitrarily-long sequences of hidden actions
by inserting arbitrarily many empty action terms between each real
action in a situation, and show how a fixpoint construction can reason
about such modified situations. Section \ref{sub:The-Link-with-IK}
then relates this fixpoint construction back to the results of Section
\ref{sec:Obs-Knowledge} by showing that in the case of a single agent,
it precisely matches the fixpoint generated by the persistence condition
operator in equation \eqref{eqn:R_do_c_s}.

The end result is a powerful account of complex epistemic modalities
constructed almost entirely in the meta-level reasoning machinery
of the situation calculus. We need only a single new successor state
axiom, given below.


\section{Background\label{sec:CKnowledgwBackground}}

Let us begin by recalling the definitions of $\EKnows$ and $\CKnows$
from Section \ref{ch:Background:Epistemic}:\begin{gather*}
\mathbf{EKnows}(G,\phi,s)\,\isdef\,\bigwedge_{agt\in G}\,\mathbf{Knows}(agt,\phi,s)\\
\mathbf{EKnows}^{1}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\phi,s)\\
\mathbf{EKnows}^{n}(G,\phi,s)\,\isdef\,\mathbf{EKnows}(G,\mathbf{EKnows}^{n-1}(G,\phi),s)\\
\mathbf{CKnows}(G,\phi,s)\,\isdef\,\bigwedge_{n\in\mathbb{N}}\mathbf{EKnows}^{n}(G,\phi,s)\end{gather*}


Finite group-level knowledge operators such as $\EKnows$ can be reasoned
about using existing techniques by simply expanding the definitions
down to individual-level knowledge operators, and applying the regression
rules developed in the previous chapter. But since the definition
of common knowledge is second-order or infinitary, it cannot be handled
in this way.

Existing treatments of common knowledge in the situation calculus
and related literature specify it as the transitive closure of $\EKnows$
using an explicit second-order axiom \citep{davis05fo_ma_theory,ghaderi07sc_joint_ability}.
While logically sound, this approach forgoes the use of regression
as an effective reasoning technique. Indeed, reasoning in such formalisms
requires a second-order theorem prover.

This difficulty in effectively handling common knowledge can be attributed
to a famous expressivity result from the related field of dynamic
epistemic logic:

\begin{quote}
Epistemic logic with actions and common knowledge is more expressive
than epistemic logic with common knowledge alone \citep{baltag98pa_ck} 
\end{quote}
In our terminology: given a formula $\CKnows(G,\phi,do(c,s))$, it
is impossible in general to find an equivalent formula $\CKnows(G,\psi,s)$.
We therefore cannot formulate a regression rule for common knowledge
in terms of $\Knows$ and $\CKnows$.

Given the deep similarities between the situation calculus and dynamic
epistemic logic \citep{vanbentham07ml_sitcalc}, we can be confident
that this expressivity limitation also holds in the situation calculus,
and we make no attempt to establish it formally. To understand the
intuition behind this result, consider again the standard successor
state axiom for the $K$ fluent, which has the simplified general
form:\[
K(do(c',s'),do(c,s))\,\equiv\, K(s',s)\wedge\Phi_{K}(c',s')\]


We could construct an analogous fluent $E$ that captures the $\EKnows$
relation, with a successor state axiom of the general form:\[
E(do(c',s'),do(c,s))\,\equiv\, E(s',s)\wedge\Phi_{E}(c',s')\]


Now consider constructing such a fluent for the $\EKnows^{2}$ relation.
The general form for its successor state axiom would be:\begin{align*}
E^{2}(do(c',s'),do(c,s)) & \equiv\exists c'',s'':\, E(do(c'',s''),do(c,s))\wedge E(do(c',s'),do(c'',s''))\\
 & \Rightarrow\exists c'',s'':\, E(s'',s)\wedge E(s',s'')\wedge\Phi_{E}(c',s')\wedge\Phi_{E}(c'',s'')\\
 & \Rightarrow\exists c'',s'':\, E^{2}(s',s)\wedge\Phi_{E}(c',s')\wedge\Phi_{E}(c'',s'')\end{align*}


This successor state axiom must make assertions not only about $s$
and $s'$, but also about the hypothesised intermediate situation
$s''$. Extending this reasoning, a successor state axiom for common
knowledge would be required make assertions not only about $s$ and
$s'$, but all of the intermediate situations in the transitive closure.
However, the macro $\CKnows$ can only make assertions about the final
situation reached in the transitive closure, not about the path leading
to it. It is thus not expressive enough to formulate a proper regression
rule.\\


To overcome this expressiveness limitation, we follow the recent promising
work of \citet{vanBenthem06lcc}, who use two important new ideas
to produce a regression rule for common knowledge in their logic LCC:

\begin{itemize}
\item Form more expressive epistemic modalities using the syntax of dynamic
logic, interpreted over the epistemic frame of the agents. 
\item Apply regression within the modality as well as to the enclosed formula. 
\end{itemize}
While the details of LCC would take us too far afield in this thesis,
let us demonstrate the basic idea. LCC uses explicit \emph{update
models} to model partially-observable actions. These are finite Kripke
structures in which each world represents a possible action that was
performed. To represent that $\phi$ holds after performing event
$e$ from update frame $U$, LCC uses the standard box modality of
dynamic logic:\[
[U,e]\phi\]


To express the agent's knowledge, the language of Propositional Dynamic
Logic (henceforth {}``PDL'') is adopted with standard semantics
\citep{harel00dynamic_logic}, but interpreted over the eipstemic
frame of the agents instead of over a dynamic frame. Individual-level
knowledge is expressed as in standard modal logic:\[
[Bob]\phi\]


But these base knowledge operators can be combined using the dynamic
logic operators choice ($\cup$), sequence ($;$), test ($?\phi$)
and iteration ($*$). Common knowledge between $Alice$ and $Bob$
is expressed in LCC as:\[
[(Alice\cup Bob)^{*}]\phi\]


This modalitiy is the transitive closure of the union of the agents'
individual knowledge operators, which is one of the common semantic
definitions of common knowledge. To perform reasoning, {}``reduction
rules'' are used that are similar in spirit to the regression operator
of the situation caluclus. Let $\pi$ be an arbitrary epistemic modality
and $U$ an update model with $n$ possibel actions, then the reduction
rule for knowledge in LCC is:\[
[U,e_{i}][\pi]\phi\,\,\Rightarrow\,\,\bigwedge_{j=0}^{n-1}[T_{ij}^{U}(\pi)][U,e_{j}]\phi\]


This definition enumerates all $n$ possible actions that could be
mistaken for the real action $e_{i}$, and uses a special \emph{program
transformer} $T_{ij}^{U}$ to encode the information from $U$ into
the epistemic modality $\pi$. We shall discuss some of the details
of $T_{ij}^{U}$ later in this chapter. \\


Our work applies these ideas to perform group-level epistemic reasoning
in the situation calculus, allowing common knowledge to be handled
using regression. While the development naturally parallels that of
LCC, the much richer ontology of the situation calculus means there
are also substantial differences. In particular:

\begin{itemize}
\item LCC is \emph{propositional}: actions do not take arguments, there
are finitely many actions, and no quantification is required. 
\item LCC is \emph{synchronous}: reasoning is performed by regressing one
action at a time, without the {}``all possible futures'' approach
needed to handle hidden actions. 
\end{itemize}
By contrast, our formalism must capture first-order preconditions
and effects, quant\-ifying-into and de-dicto/de-re, and arbitrary
sets of concurrent actions, while incorporating our new technique
for handling hidden actions and remaining compatible with other extensions
to the situation calculus.

As we shall see throughout the development, the extra expressiveness
of the situation calculus also provides some advantages for our formalism,
and the definition of our regression rules is much simpler than the
analogous rules in \citep{vanBenthem06lcc}.


\section{Synchronous Knowledge\label{sec:CKnowledge:Synchronous}}

We will be approaching our formalism in two steps: first defining
comlex epistemic modalities in synchronous domains, and then building
support for hidden actions on top of that foundation. So to begain,
we must define the \emph{synchronous} knowledge of an individual agent
in an arbitrary situation $s$. This is the agent's knowledge when
it assumes that no hidden actions have occurred, and so it is not
required to do any {}``all possible futures'' style reasoning. We
extend the fluent $K_{0}(agt,s',s)$ which is already used to represent
synchronous knowledge in the initial situation. The axiom set $\Dt_{K}^{obs}$
gains the following successor state axiom for $K_{0}$:\begin{align}
K_{0}(agt,s'',do(c,s))\,\equiv\,\, & \exists s',c':\, K_{0}(agt,s',s)\wedge Obs(agt,c,s)=Obs(agt,c',s')\nonumber \\
 & \wedge\left(s''=do(c',s')\wedge Legal(c',s')\,\,\vee\,\, s''=s'\wedge c'=\{\}\right)\label{eq:K0_ssa}\end{align}


Given synchronicity, this axiom is a simple modification of the standard
successor state axiom for knowledge from equation \eqref{eq:k_ssa_standard}.
The only complication is is that we add an explicit case to handle
the empty action $\{\}$. When \textbf{$Obs(agt,c,s)=\{\}$} then
$c'$ is allowed to be $\{\}$, and the agent considers it possible
that no actions were actually performed (i.e. $s''=s'$). Thus the
number of actions in $s$ puts an upper bound on the number of actions
that the agent thinks might actually have occurred.

The addition is made purposely to support queries of the following
form, which will allow us to add support for hidden actions by simulating
them with occurrences of the empty action set:\[
\KnowsZ(agt,\phi,do(\{\},s))\]


Beginning with the assumption of synchronicity allows us to focus
first on increasing the expressiveness of the epistemic language.
Once this have been achieved, we will generalise the formalism to
asynchronous domains.


\section{Epistemic Paths\label{sec:CKnowledge:Epistemic-Paths}}

In this section, we adopt the language of dynamic logic to express
complex epistemic modalities. To deal gracefully with the many first-order
aspects of the situation calculus we use a variant of \emph{first-order
dynamic logic} (henceforth {}``FODL''), which we adapt with some
simplifcations from the dynamic term-modal logic of \citet{kooi07dyn_termmodal_logic}.

First, we must specify the syntax of our epistemic path language.
We will use $\pi$ to denote an arbitrary epistemic path expression.

\begin{defnL}
[{Epistemic~Path}] Let $agt$ be an \noun{Agent }term, $\phi$
a uniform formula and $x$ a variable name, then the epistemic path
terms $\pi$ are the smallest set matching the following structural
rules:\[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]

\end{defnL}
The test ($?$), sequence ($;$), choice ($\cup$) and transitive
closure ($^{*}$) operators are standard in dynamic logic, although
test formulae may now contain variables that must be interpreted.
The operator $\exists x$ allows the value of a variable to change
during path traversal, by non-deterministically re-binding $x$ to
some value.

The semantics of this epistemic path language are defined at the meta-level
as a series of macro expansions. Formulae of first-order dynamic logic
are interpreted relative to both a {}``current world'' and a {}``current
variable binding'' \citep{kooi07dyn_termmodal_logic}. We begin with
a simplified presentation that treats variable bindings as concrete
terms in the logic, represented as a finite first-order substitution
$\mu$. The notation $\mu(\phi)$ applies the substitution to the
variables in $\phi$ and $\mu[x/z]$ sets the value of variable $x$
to the term $z$. The semantics operate over pairs $(\mu,s)$.

\begin{defnL}
[{Epistemic~Path~Semantics}] A situation $s'$ is reachable
from situation $s$ via epistemic path $\pi$, denoted $\KDoZ(\pi,s,s')$,
according to the following definitions:\label{def:KDoZ}\[
\KDoZ(\pi,s,s')\,\,\equiv\,\,\exists\mu,\mu':\,\KDoZ(\pi,\mu,s,\mu',s')\]
 \begin{gather*}
\KDoZ(agt,\mu,s,\mu',s')\,\equiv\,\mu'=\mu\,\wedge\, K_{0}(agt,s',s)\\
\KDoZ(?\phi,\mu,s,\mu',s')\,\equiv\, s'=s\,\wedge\,\mu'=\mu\,\wedge\,\mu(\phi)[s]\\
\KDoZ(\pi_{1};\pi_{2},\mu,s,\mu',s')\,\equiv\,\exists\mu'',s'':\,\KDoZ(\pi_{1},\mu,s,\mu'',s'')\,\wedge\,\KDoZ(\pi_{2},\mu'',s'',\mu',s')\\
\KDoZ(\pi_{1}\cup\pi_{2},\mu,s,\mu',s')\,\equiv\,\KDoZ(\pi_{1},\mu,s,\mu',s')\,\vee\,\KDoZ(\pi_{2},\mu,s,\mu',s')\\
\KDoZ(\exists x,\mu,s,\mu',s')\,\equiv\,\exists z:\, s'=s\,\wedge\,\mu'=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu,s,\mu',s')\rightarrow\KDoZ(\pi^{*},\mu,s,\mu',s')\right]\end{gather*}

\end{defnL}
Where we use the following abbreviations (standing for {}``reflexive'',
{}``transitive'' and {}``contains'' respectively) to specify that
$\pi^{*}$ is the reflexive transitive closure of $\pi$:\begin{align*}
\mathbf{refl}\isdef & \,\, P(\mu,s,\mu,s)\\
\mathbf{tran\isdef} & \,\,\forall\mu_{1},s_{1},\mu_{2},s_{2}:\, P(\mu_{1},s_{1},\mu,s)\wedge\KDoZ(\pi,\mu_{2},s_{2},\mu_{1},s_{1})\,\rightarrow\, P(\mu_{2},s_{2},\mu,s)\\
\mathbf{cont}\isdef & \,\,\forall\mu',s':\,\KDoZ(\pi,\mu',s',\mu,s)\,\rightarrow\, P(\mu',s',\mu,s)\end{align*}


In order to keep the semantics clear, we will continue to represent
variable-bindings $\mu$ as concrete terms in the logic. In Section
\ref{sec:CKnowledge:Encoding-KDoZ} we construct a definition of $\KDoZ$
that removes them from the logic while respecting the above semantics,
using macro-expansion into a set of mutually-recursive Golog procedures.
For this reason, Definition \ref{def:KDoZ} is presented as a series
of equivalences rather than direct macro definitions.

Let us re-iterate: these are \emph{not} axioms to be included in our
basic action theory, but macros. Paths are not terms in $\mathcal{L}_{sitcalc}$,
but rather are handled by macro-expansion of $\KDoZ(\pi,s,s')$ into
second-order sentences of the situation calculus.

For notational convenience, we introduce an explicit variable binding
operator as follows:\[
\KDoZ(x\Leftarrow\tau,\mu,s,\mu',s')\isdef\KDoZ(\exists x\,;\,?x=\tau,\mu,s,\mu',s')\]


This operator non-deterministically rebinds $x$ to any value, then
immediately asserts that it is equal to the specific value $\tau$.
Since this expands to a test formula, $\tau$ can potentially be a
functional fluent.


\section{A Synchronous Epistemic Fluent\label{sub:Synchronous-Epistemic-Fluent}}

At this point it's worth reviewing again the purpose of this path
language. Despite utilising the syntax of dynamic logic, it is \emph{not}
related to actions in any way. Rather it expresses complex \emph{epistemic}
paths, and is interpreted over the epistemic frame generated by the
agents' knowledge relations. We will be introducing a new macro $\PKnows(\pi,\phi,s)$
(read this as {}``Path-Knows'') to express knowledge using these
epistemic paths. To make this clear, here is how some different kinds
of knowledge would be expressed using the standard account of knowledge,
and how we intend to express them using epistemic paths:\begin{align}
\Knows(A,\phi,s) & \,\,\equiv\,\,\PKnows(A,\phi,s)\nonumber \\
\Knows(A,\Knows(B,\phi),s) & \,\,\equiv\,\,\PKnows(A;B,\phi,s)\nonumber \\
\Knows(A,\phi)\wedge\Knows(B,\phi,s) & \,\,\equiv\,\,\PKnows(A\cup B,\phi,s)\nonumber \\
\EKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows(\bigcup_{a\in G}a,\phi,s)\nonumber \\
\CKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)\label{eq:pknows_identities}\end{align}


In this section, we develop a synchronous version $\PKnowsZ(\pi,\phi,s)$
of our path-knowledge operator, building on the synchronous $K_{0}$
relation defined earlier. Its definition is a straightforward analogue
of the individual-level $\Knows$ macro:\[
\PKnowsZ(\pi,\phi,s)\isdef\forall s':\,\KDoZ(\pi,s,s')\,\rightarrow\,\phi[s']\]


But this macro expands to a complicated second-order formula in the
base language of the situation calculus. As with the case of the basic
$\Knows$ macro, we need to treat $\PKnowsZ$ syntactically as a primitive
fluent. This means we need a regression rule for such expressions.
It is here that we incorporate the second key idea from LCC -- use
of a syntactic transform to encode the effects of actions within epistemic
paths as well as in primitive formulae. Mirroring LCC, we introduce
the meta-operator $\Trn$ for this purpose.

Let us consider the required operation of $\Trn$ by analogy with
the standard regression operator $\Reg$. One can think of regression
as a {}``pre-encoding'' of the effects of an action: $\phi$ will
hold in $do(c,s)$ if and only if $\Reg(\phi,c)$ holds in $s$. The
path regressor $\Trn$ needs to lift this idea to epistemic paths
as follows: there is a $\pi$-path from $do(c,s)$ to $do(c',s')$
if and only if there is a $\Trn(\pi,c,c')$-path from $s$ to $s'$.

In order to accomplish this task of pre-encoding the effects of actions,
the path regressor will need to make various assertions about the
action that is to be performed in each situation traversed by the
path. It uses a fresh variable to track this {}``current action''
in the regressed path. The basic operation of $\Trn$ is as follows:

\begin{itemize}
\item Introduce a fresh variable $x$ to hold the action to be performed
in the current situation; 
\item at the beginning of the path, bind $x$ to the known action $c$; 
\item at the end of the path, assert that $x$ is the known action $c'$;
and 
\item when the path moves to a new situation, select a new action using
$\exists x$. 
\end{itemize}
This is accomplished with an auxiliary operator $\TrnA(\pi,x)$, which
translates $\pi$ under the assumption that variable $x$ contains
the action to be performed in the current situation.

\begin{defnL}
[{Epistemic~Path~Regressor}] The epistemic path regressor
$\Trn(\pi,c,c')$ operates according to the definitions below, where
$x$ and $z$ are fresh variables not appearing in $\pi$:\label{def:EpistemicPathRegression}\begin{align*}
\Trn(\pi,c,c')\,\isdef\,\, & x\Leftarrow c\,;\,\TrnA(\pi,x)\,;\,?x=c'\\
\\\TrnA(agt,x)\,\isdef\,\, & z\,\Leftarrow Obs(agt,x)\,;\, agt\,;\,\exists x\,;\,?Legal(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\\
\TrnA(?\phi,x)\isdef\,\, & ?\Reg(\phi,x)\\
\TrnA(\exists y,x)\isdef\,\, & \exists y\\
\begin{array}{c}
\TrnA(\pi_{1};\pi_{2},x)\isdef\,\,\end{array} & \TrnA(\pi_{1},x)\,;\,\TrnA(\pi_{2},x)\\
\TrnA(\pi_{1}\cup\pi_{2},x)\isdef\,\, & \TrnA(\pi_{1},x)\cup\TrnA(\pi_{2},x)\\
\TrnA(\pi^{*},x)\isdef\,\, & \TrnA(\pi,x)^{*}\end{align*}

\end{defnL}
Most of these clauses are straightforward, but note how the clause
for an individual agent term encodes the successor-state axiom for
$K_{0}$. The following theorem states that these definitions behave
has desired, respecting the semantics of epistemic paths:

\begin{thm}
\label{thm:Trn-respects-epi-paths}For any epistemic path $\pi$:\begin{multline*}
\Dt\cup\Dt_{K}^{obs}\models\,\KDoZ(\pi,do(c,s),s'')\,\equiv\\
\exists c',s':\,\left(s''=do(c',s')\,\vee\, s''=s'\wedge c'=\{\}\right)\wedge\KDoZ(\Trn(\pi,c,c'),s,s')\end{multline*}

\end{thm}
\begin{proofsketch}
The proof proceeds by cases, covering each path operator in turn.
The base cases $agt$, $?\phi$ and $\exists y$ follow from Definition
\ref{def:KDoZ} and the successor state axiom for $K_{0}$ in equation
\eqref{eq:K0_ssa}. The inductive cases are straightforward as $\Trn_{a}$
is simply pushed inside each operator. 
\end{proofsketch}
Given that $\Trn$ correctly regresses our epistemic path language,
we are free to use it to define the regression of a complex epistemic
modality. We define the regression of a $\PKnowsZ$ expression as
follows:\[
\Reg(\PKnowsZ(\pi,\phi,do(c,s)))\isdef\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\]


Note that this rule must universally quantify over action terms $c'$
in order to account for different actions producing the same observation.
Such quantification is also found in the rule for individual knowledge
from equation \eqref{eqn:R_do_c_s}, although here it has been taken
outside the scope of the knowledge macro.

\begin{thm}
\label{thm:Reg_PKnowsZ}For any epistemic path $\pi$, uniform formula
$\phi$ and action $c$:\begin{gather*}
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnowsZ(\pi,\phi,do(c,s))\,\equiv\,\forall c':\,\PKnowsZ(\Trn(\pi,c,c'),\Reg(\phi,c'),s)\end{gather*}

\end{thm}
\begin{proofsketch}
The mechanics of this proof mirror that of Theorem \ref{thm:Reg_Knows}:
we expand the $\PKnowsZ$ macro, apply Theorem \ref{thm:Trn-respects-epi-paths}
as a successor state axiom for $\KDoZ$, re-arrange to eliminate existential
quantifiers, then collect terms back into forms that match $\PKnowsZ$. 
\end{proofsketch}

\section{Introducing Hidden Actions\label{sub:Introducing-Hidden-Actions}}

We now have a powerful account of group-level knowledge for \emph{synchronous}
domains, but it remains to generalise this to \emph{asynchronous}
domains by incorporating support for arbitrarily-long sequences of
hidden actions. We continue to operate at the meta-level, developing
support for hidden actions directly in the rules governing the regression
operator.

The idea is to use the empty action set to explicitly represent the
notion that {}``nothing happens''. We simulate agents reasoning
about hypothetical futures in which they make no more observations
by inserting these empty actions between each regular action in a
situation term.

\begin{defn}
Let $\mathcal{E}^{n}(s)$ be $s$ with $n$ empty actions inserted
between each action:\begin{align*}
\mathcal{E}^{0}(s)\,\isdef\,\, & s\\
\mathcal{E}^{1}(S_{0})\,\isdef\,\, & do(\{\},S_{0})\\
\mathcal{E}^{1}(do(c,s))\,\isdef\,\, & do(\{\},do(c,\mathcal{E}^{1}(s)))\\
\mathcal{E}^{n}(s)\,\isdef\,\, & \mathcal{E}^{1}(\mathcal{E}^{n-1}(s))\end{align*}

\end{defn}
The intuition here is that we want $\PKnows(\pi,\phi)$ to hold if
$\PKnowsZ(\pi,\phi)$ holds after allowing for any number of empty
actions. Formally, we want a definition of $\PKnows(\pi,\phi,s)$
that is equivalent to the following infinite conjunction:\[
\PKnows(\pi,\phi,s)\equiv\bigwedge_{n\in\mathbb{N}}\PKnowsZ(\pi,\phi,\mathcal{E}^{n}(s))\]


Of course we cannot use this as a direct definition, any more than
we can use an infinitary definition of $\CKnows$. Instead we will
construct a series of definitions that is provably equivalent to this
conjunction using the persistence condition operator.

First, let us define a meta-level operator $\UnZ$ that replaces instances
of $\PKnowsZ$ with $\PKnows$:\begin{gather*}
\UnZ(\phi_{1}\wedge\phi_{2})\isdef\UnZ(\phi_{1})\wedge\UnZ(\phi_{2})\\
\UnZ(\forall x:\,\phi(x))\isdef\forall x:\,\UnZ(\phi(x))\\
\UnZ(\neg\phi)\isdef\neg\UnZ(\phi)\\
\UnZ(\PKnowsZ(\pi,\phi,\sigma))\isdef\UnZ(\PKnows(\pi,\phi,\sigma))\\
\UnZ(\phi)\isdef\phi\,\,\,\mathrm{otherwise}\end{gather*}


We then propose the following definitions for the macro $\PKnows$:

\begin{gather*}
\PKnows(\pi,\phi,S_{0})\,\isdef\,\Pst(\PKnowsZ(\pi,\phi),\lambda c:\, c=\{\})[S_{0}]\\
\PKnows(\pi,\phi,do(c,s))\,\isdef\,\UnZ(\Reg(\Pst(\PKnowsZ(\pi,\phi),\lambda c:\, c=\{\}),c)[s])\end{gather*}


Here we are using $\Pst$ to account for an arbitrary number of empty
actions. By using $\UnZ$ to switch from $\PKnowsZ$ back to $\PKnows$
once $\Pst$ and $\Reg$ have been applied, we allow for an arbitrary
number of empty actions between each real action $c$ in the situation
term.

TODO: proof for this

This definition of $\PKnows$ operates in a very similar way to the
regression rule for $\Knows$ from equation \eqref{eqn:R_do_c_s},
using a fixpoint calculation to account for arbitrarily long sequences
of hidden actions. In the following section we formalism the precise
relationship between $\Knows$ and $\PKnows$.

TODO: what about this theorem, do we still need it?

\begin{thm}
\label{thm:En_impl_En-1}For any epistemic path $\pi$: \[
\Dt\cup\Dt_{K}^{obs}\models\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))\rightarrow\PKnowsZ(\pi,\phi,s)\]

\end{thm}
\begin{proofsketch}
By a case analysis on the definition of $\Trn$, we determine that
that path $\Trn(\pi,\{\},\{\})$ always contains the path $\pi$.
Thus any situations reachable by $\pi$ are also reachable by $\Trn(\pi,\{\},\{\})$.
Since $\Trn(\pi,\{\},\{\})$ is always in the regression of $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
and $\Reg(\phi,\{\})=\phi$ always, we can conclude that $\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(s))$
always implies $\PKnowsZ(\Trn(\pi,\{\},\{\}),\phi,s)$, which implies
$\PKnowsZ(\pi,\phi,s)$ as required. 
\end{proofsketch}

\section{The Link with Individual Knowledge\label{sub:The-Link-with-IK}}

The last remaining link is the most important of all: showing that
this new path-based account of knowledge actually captures the knowledge
of the agents, according to the semantics of individual knowledge
developed in Section \ref{sec:Obs-Knowledge}. The following series
of theorems establish this important link. First, we produce special
cases of the regression rule for $\PKnows(\pi,\phi)$ for the case
of a single agent:

\begin{thm}
\label{thm:Pknows_LbU_S0}For any $agt$ and $\phi$:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows(agt,\phi,S_{0})\,\equiv\,\PKnowsZ(agt,\Pst(\phi,LbU(agt)),S_{0})\]

\end{thm}
\begin{proofsketch}
By stepping through the regression of $\PKnowsZ(agt,\phi,do(\{\},S_{0}))$
we show that for any $n$, $\Pst^{n}(\PKnowsZ(agt,\phi,),\lambda c:c=\{\})[S_{0}]\equiv\PKnowsZ(agt,\Pst^{n}(\phi,\LbU(agt)),S_{0})$.
The fixpoint calculation for $\Pst$ will thus clearly terminate at
the same value of $n$ in both cases, and we can equate the two expressions
as desired. 
\end{proofsketch}
\medskip{}


\begin{thm}
\label{thm:Pknows_LbU_do}For any $agt$, $\phi$, $c$ and $s$:\begin{multline*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\exists z:\, Obs(agt,c,s)=z\\
\wedge\,\left[z=\{\}\,\rightarrow\,\PKnows(agt,\Pst(\phi,\LbU(agt)),s)\right]\\
\wedge\,\left[z\neq\{\}\,\rightarrow\,\PKnows(agt,\forall c':\,\left(Poss(c')\wedge Obs(agt,c')=z\right)\rightarrow\Reg(\Pst(\phi,\LbU(agt)),c),s)\right]\end{multline*}

\end{thm}
\begin{proofsketch}
Repeating the calculations from Lemma \ref{thm:Pknows_LbU_S0} on
$\PKnowsZ(agt,\phi,\mathcal{E}^{1}(do(c,s)))$, and pushing the application
of $\mathcal{E}^{\infty}$ past the actions $c$, we obtain the following:\[
\PKnows(agt,\phi,do(c,s))\,\equiv\,\PKnowsZ(agt,\Pst(\phi,\LbU(agt)),do(c,\mathcal{E}^{\infty}(s)))\]


Regressing the RHS through the action $c$, we obtain:\begin{align*}
\PKnows(agt,\phi,do(c,s))\,\equiv\,\, & \forall c':\,\PKnowsZ(\Trn(agt,c,c'),\Reg(\Pst(\phi,\LbU(agt)),c'),\mathcal{E}^{\infty}(s))\\
\equiv\,\, & \forall c':\,\PKnows(\Trn(agt,c,c'),\Reg(\Pst(\phi,\LbU(agt)),c'),s)\end{align*}


Simplifying $\Trn(agt,c,c')$ and using it to re-arrange the above
expression gives the desired result. 
\end{proofsketch}
We will also need the following result for individual knowledge:

\begin{thm}
\label{thm:Knows_impl_KnowsLbU}For any $agt$, $\phi$ and $s$:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\equiv\,\Knows(agt,\Pst(\phi,LbU(agt)),s)\]

\end{thm}
\begin{proofsketch}
By induction on the regression rules for knowledge, and using the
following property of the persistence condition ({}``if $\phi$ persists,
then $\Pst(\phi,\alpha)$ persists''):\[
\forall s':\,\Pst(\phi,\alpha)[s]\,\wedge\, s\leq_{\alpha}s'\,\rightarrow\,\Pst(\phi,\alpha)[s']\]


We consider three cases: $s=S_{0}$, and $s=do(c,s)$ with $c$ both
observable and unobservable. Each case requires only a simple re-arrangement
of the relevant regression rule. 
\end{proofsketch}
\medskip{}


Finally, we are in a position to state the major theorem of this section:
that $\PKnows$ for a single agent is equivalent to the standard $\Knows$
macro.

\begin{thm}
For any $agt$, $\phi$ and $s$:

\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\Knows(agt,\phi,s)\,\,\equiv\,\,\PKnows(agt,\phi,s)\]

\end{thm}
\begin{proof}
By induction on the regression rules for each expression. For the
$S_{0}$ case, we require the following result which is true by the
definition of $\KDoZ$:\[
\KnowsZ(agt,\phi,S_{0})\equiv\PKnowsZ(agt,\phi,S_{0})\]
 The regression rule for $\Knows$ from equation \eqref{eqn:R_s0}
then precisely matches the result of Theorem \ref{thm:Pknows_LbU_S0}
and we have the required equivalence. For the $do(c,s)$ case, we
can substitute the result of Theorem \ref{thm:Knows_impl_KnowsLbU}
into the regression rule for $\Knows$ from equation \eqref{eqn:R_do_c_s}
to produce an expression precisely matching the result of Theorem
\ref{thm:Pknows_LbU_do}. Using $\Knows(agt,\phi,s)\equiv\PKnows(agt,\phi,s)$
from the inductive hypothesis renders the two equivalent. 
\end{proof}
\medskip{}


Thus the expressions $\Knows(agt,\phi,s)$ and $\PKnows(agt,\phi,s)$
are equivalent under our formulation. This link is all that is required
to validate the additional complex modalities shown in equation \eqref{eq:pknows_identities},
which we will repeat below for convenience.

\begin{thm}
The following identities hold under the theory of action $\Dt\cup\Dt_{K}^{obs}$:\begin{align*}
\Knows(A,\phi,s) & \,\,\equiv\,\,\PKnows(A,\phi,s)\\
\Knows(A,\Knows(B,\phi),s) & \,\,\equiv\,\,\PKnows(A;B,\phi,s)\\
\Knows(A,\phi)\wedge\Knows(B,\phi,s) & \,\,\equiv\,\,\PKnows(A\cup B,\phi,s)\\
\EKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows(\bigcup_{a\in G}a,\phi,s)\\
\CKnows(G,\phi,s) & \,\,\equiv\,\,\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)\end{align*}

\end{thm}
\begin{proof}
Each follows from the equivalence of $\Knows(agt,\phi,s)$ and $\PKnows(agt,\phi,s)$,
using the semantics of first-order dynamic logic as defined by $\KDoZ$.
For example, in the $\CKnows$ case we argue as follows: By definition,
$\PKnows((\bigcup_{a\in G}a)^{*},\phi,s)$ is the transitive closure
of the union of $\PKnows(a,\phi,s)$ for $a\in G$. Also by definition,
$\CKnows(G,\phi,s)$ is the transitive closure of the union of $\Knows(a,\phi,s)$
for $a\in G$. Since $\PKnows(a,\phi,s)$ and $\Knows(a,\phi,s)$
are the same relation, their transitive closures are also the same
and the identity is entailed. 
\end{proof}

\section{Answering the Regressed Query}

We are now in a position to reduce an epistemic query $\PKnows(\pi,\phi,s)$
at some future situation to an epistemic query $\PKnows(\Trn^{*}(\pi),\Reg^{*}(\phi),S_{0})$
at the initial situation. While this is a significant gain for effective
automated reasoning, it still remains to answer the regressed query.

As with individual knowledge, we assume that regressed queries will
be handled by a special-purpose theorem prover rather than by expanding
the macros. However, we should note that validity in first-order dynamic
logic is undecidable; in fact it is $\Pi_{1}^{1}$-hard \citep{kooi07dyn_termmodal_logic}.
As with previous work in the situation calculus, we must assume that
axioms about the initial situation are in a restricted form amenable
to effective reasoning. There are several special cases that can simplify
answering the regressed query.

A common simplifying assumption is that the potential values of each
variable can be finitely enumerated. In this case it is possible to
translate our epistemic paths into propositional dynamic logic, which
is decidable. The only difficulty is the elimination of variable bindings
inside an iteration operator, which can be handled using a Kleene-style
technique similar to the $\mathcal{K}$ translator of \citet{vanBenthem06lcc}.

Alternately, it may be that the initial situation is completely known
and uncertainty is introduced only due to partial observability of
actions. In this case the initial epistemic frame contains the lone
situation $S_{0}$, and the regressed path can be reduced to a series
of tests and variable re-bindings.

We have produced a preliminary implementation for propositional domains
using the PDL prover from the Tableaux Workbench suite \citep{abate07twb_pdl},
and have used it to verify some simple examples. We are also investigating
further techniques for answering the regressed query in a more effective
manner.


\section{An Illustrative Example}

With this technical machinery in place, we are now able to reason
about the group-level epistemic modalities of a team of agents. To
demonstrate, we revisit our example domain from Section \ref{sub:An-Illustrative-Example}.
We add the the following initial knowledge axiom to $\Dt_{S_{0}}$:\begin{gather*}
\PKnowsZ((Alice\cup Bob)^{*},InRoom(Alice)\wedge InRoom(Bob),S_{0})\end{gather*}


The preconditions and effects of actions in this domain are relatively
simple, such that there is nothing that can be accomplished by a sequence
of hidden actions that cannot be accomplished by a single hidden action.
More formally, it is possible to show that:\[
\phi[\mathcal{E}^{\infty}(s)]\,\equiv\,\phi[\mathcal{E}^{1}(s)]\]
 In other words, the fixpoint calculation required for reasoning about
$\PKnows$ will always terminate after a single iteration. We will
therefore use the following identity to simplify presentation of the
example:\begin{align*}
\Reg(\PKnows(\pi,\phi,do(c,s))\,\Rightarrow & \,\,\,\PKnowsZ(\pi,\phi,\mathcal{E}^{\infty}(do(c,s)))\\
\equiv & \,\,\,\PKnowsZ(\pi,\phi,\mathcal{E}^{1}(do(c,s)))\\
\equiv & \,\,\,\PKnowsZ(\pi,\phi,do(\{\},do(c,s)))\\
\equiv & \,\,\,\forall c',c'':\,\PKnows(\Trn(\Trn(\pi,\{\},c'),c,c''),\Reg(\Reg(\phi,c'),c''),s)\end{align*}


To keep the presentation compact, we will abbreviate agent names to
$A$ and $B$ and the fluent $InRoom(agt)$ to $IR(agt)$.

\begin{example}
After Bob reads the invitation, it is common knowledge that he knows
where the party is:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((A\cup B)^{*},\exists x:\Knows(B,loc=x),do(\{read(B)\},S_{0}))\]

\end{example}
This example hinges on the fact that initially, it is common knowledge
that both agents are in the room. It is thus common knowledge that
the occurrence of $read(Bob)$ will be observed by both agents. Suppressing
the inner expression for the moment, regressing using the above-mentioned
identity gives:\begin{multline*}
\Reg(\PKnows((A\cup B)^{*},\phi,do(read(B),S_{0})))\\
\Rightarrow\,\,\forall c,c':\,\PKnows(\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c'),\Reg(\Reg(\phi,c),c'),S_{0})\\
\Rightarrow\,\,\forall c,c',c'':\,\PKnowsZ(\Trn(\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c'),\{\},c''),\Reg(\Reg(\Reg(\phi,c),c'),c''),S_{0})\end{multline*}
 We begin by evaluating $\Trn(\pi,\{\},c)$ :\[
\Trn((A\cup B)^{*},\{\},c)\,\Rightarrow\,\exists x\,;\,?x=\{\}\,;\,(\TrnA(A,x)\cup\TrnA(B,x))^{*}\,;\,?x=c\]
 With the cases for $\TrnA(agt,x)$ both evaluating to:\[
\TrnA(agt,x)\,\Rightarrow\,\exists z\,;\,?Obs(agt,x)=z\,;\, agt\,;\,\exists x\,;\,?Poss(x)\vee x=\{\}\,;\,?Obs(agt,x)=z\]
 Since we know all possible observations that Alice could make, let
us expand the path $\TrnA(A,x)$ by enumerating the possible values
for $z$. The first line in the result gives the case where $Obs(Alice,x)=\{\}$,
and the last line is the case where $Obs(Alice,x)=read(Alice)\#r$.
All other lines are where Alice simply observes the action $x$. \begin{gather*}
\TrnA(A,x)\,\Rightarrow\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\\
?\, x=\{\}\vee(x=read(B)\wedge\neg IR(A)))\,;\, A\,;\,\exists x\,;\,?\, x=\{\}\vee(x=read(B)\wedge IR(B)\wedge\neg IR(A))\\
\cup\,\,?x=enter(A)\,;\, A\,;\,\exists x\,;\,?x=enter(A)\wedge IR(A)\\
\cup\,\,?x=enter(B)\,;\, A\,;\,\exists x\,;\,?x=enter(B)\wedge IR(B)\\
\cup\,\,?x=leave(A)\,;\, A\,;\,\exists x\,;\,?x=leave(A)\wedge\neg IR(A)\\
\cup\,\,?x=leave(B)\,;\, A\,;\,\exists x\,;\,?x=leave(B)\wedge\neg IR(B)\\
\cup\,\,?\, x=read(B)\wedge IR(A)\,;\, A\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x=read(A)\wedge loc(r)\,;\, A\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(A)\wedge loc(r)\end{gather*}
 Now consider starting with $x$ set to $\{\}$ and following this
path some number of times. On the first iteration, $x$ may get rebound
to either $\{\}$ or $read(B)$. Subsequent iterations may alternate
between these values, but can never bind $x$ to any other action.
An analogous argument for $\TrnA(B,x)$ shows that the path $\Trn((A\cup B)^{*},\{\},c)$
can be simplified to consider only the actions $\{\}$, $read(A)$
and $read(B)$, with any other binding of $x$ being unreachable:\begin{multline*}
\Trn((A\cup B)^{*},\{\},c)\,\Rightarrow\,\exists x\,;\,?x=\{\}\,;\,(\\
?\, x=\{\}\vee(x=read(B)\wedge\neg IR(A)))\,;\, A\,;\,\exists x\,;\,?\, x=\{\}\vee(x=read(B)\wedge IR(B)\wedge\neg IR(A))\\
\cup\,\,?\, x=\{\}\vee(x=read(A)\wedge\neg IR(B)))\,;\, B\,;\,\exists x\,;\,?\, x=\{\}\vee(x=read(A)\wedge IR(A)\wedge\neg IR(B))\\
\cup\,\,?\, x=read(B)\wedge IR(A)\,;\, A\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x=read(A)\wedge loc(r)\,;\, A\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(A)\wedge loc(r)\\
\cup\,\,?\, x=read(A)\wedge IR(B)\,;\, B\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(B)\wedge IR(A)\\
\cup\,\,\exists r\,;\,?\, x=read(B)\wedge loc(r)\,;\, B\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(B)\wedge loc(r)\\
)^{*}\,;\,?x=c\end{multline*}
 This path matches with our intuitions about the observability of
actions. Since the $enter$ and $leave$ actions are always public,
they can never be mistaken for the empty action and are irrelevant
in the path $\Trn(\pi,\{\},c)$. Moreover, the binding of $x$ may
only switch from $\{\}$ to $read(B)$ if there is a possible world
in which Alice is not in the room, reflecting the conditions under
which that action would be hidden.

Next we evaluate the $\Trn(\pi,read(B),c')$ portion, which will produce:\begin{multline*}
\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c')\,\Rightarrow\,\exists x'\,;\,?x'=read(B)\,;\,\exists x\,;\,?x=\{\}\,;\\
(\TrnA(\TrnA(A,x),x')\cup\TrnA(\TrnA(B,x),x'))^{*}\,;\,?x=c\,;\,?x'=c'\end{multline*}
 As before, the only possible values of $x'$ are $\{\}$, $read(A)$
and $read(B)$. None of these actions affect any of the tests present
in $\Trn((A\cup B)^{*},\{\},c)$, so we can safely leave them unchanged
in the resulting path:\begin{multline*}
\Trn(\Trn((A\cup B)^{*},\{\},c),read(B),c')\,\Rightarrow\,\exists x'\,;\,?x'=read(B)\,;\,\exists x\,;\,?x=\{\}\,;\,(\\
?x=\{\}\vee(x=read(B)\wedge\neg IR(A)));\TrnA(A,x');\exists x;?x=\{\}\vee(x=read(B)\wedge IR(B)\wedge\neg IR(A))\\
\cup\,?x=\{\}\vee(x=read(A)\wedge\neg IR(B)));\TrnA(B,x');\exists x;?x=\{\}\vee(x=read(A)\wedge IR(A)\wedge\neg IR(B))\\
\cup\,\,?\, x=read(B)\wedge IR(A)\,;\,\TrnA(A,x')\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x=read(A)\wedge loc(r)\,;\,\TrnA(A,x')\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(A)\wedge loc(r)\\
\cup\,\,?\, x=read(A)\wedge IR(B)\,;\,\TrnA(B,x')\,;\,\exists x\,;\,?\, x=read(A)\wedge IR(B)\wedge IR(A)\\
\cup\,\,\exists r\,;\,?\, x=read(B)\wedge loc(r)\,;\,\TrnA(B,x')\,;\,\exists x\,;\,?\, x=read(B)\wedge IR(B)\wedge loc(r)\\
)^{*}\,;\,?x=c\,;\, x'=c'\end{multline*}
 We can complete this expansion using the previously calculated result
for $\TrnA(A,x)$, but will proceed leaving this implicit. Finally,
we must apply $\Trn$ again for the $\Trn(\pi,\{\},c'')$ portion.
The process is identical and we will not repeat it here.

We next evaluate this path over the initial epistemic relation of
the agents, about which we know:\[
\PKnowsZ((A\cup B)^{*},IR(A)\wedge IR(B),S_{0})\]


Consider how this restricts the possible bindings of $x$, $x'$ etc.
For $x$ to switch from its initial value of $\{\}$ to $read(A)$
(resp. $read(B)$) the path must traverse a test for $\neg IR(B)$
(resp. $\neg IR(A)$). Since we know that these tests will never succeed
on the initial epistemic frame, we can conclude that $x$ will always
be bound to $\{\}$. Since the path insists that $x=c$ at termination,
this is the only interesting value for $c$ - any value of $c$ other
than $\{\}$ will result in no worlds being reachable by the regressed
path and will thus have $\PKnowsZ$ vacuously true. By a similar argument,
we find that the only interesting values of $c'$ and $c''$ are $read(B)$
and $\{\}$ respectively.

Turning now to the regression of the inner formula, we have:\begin{gather*}
\Reg(\Reg(\Reg(\exists x:\,\Knows(B,loc=x),c),c'),c'')\\
\Rightarrow\Reg(\Reg(\Reg(\exists x:\,\Knows(B,loc=x),\{\}),read(B)),\{\})\\
\Rightarrow\Reg(\Reg(\exists x:\,\Knows(B,loc=x),read(B),\{\})\\
\Rightarrow true\end{gather*}


Thus for $c=\{\}$, $c'=read(B)$, $c''=\{\}$ the known formula is
a tautology, while for any other values the regressed epistemic path
has no reachable worlds. The example is therefore entailed by the
domain.

~

\begin{example}
After Bob reads the invitation, the location is not common knowledge\[
\Dt\cup\Dt_{K}^{obs}\,\not\models\,\PKnows((Alice\cup Bob)^{*},loc=C,do(read(Bob),S_{0}))\]

\end{example}
Regression of the epistemic path proceeds as with the previous example,
but regression of the inner formula no longer produces a tautology.
If we ignore the path components dealing with $c$ and $c''$, which
from the previous example we know to be redundant, regressing this
expression produces the following:

\begin{multline*}
\PKnowsZ(\dots\\
\cup\,\,?\, x'=read(B)\wedge IR(A)\,;\, A\,;\,\exists x'\,;\,?\, x'=read(B)\wedge IR(A)\wedge IR(B)\\
\cup\,\,\exists r\,;\,?\, x'=read(B)\wedge loc(r)\,;\, B\,;\,\exists x'\,;\,?\, x'=read(B)\wedge IR(B)\wedge loc(r)\\
\cup\dots,loc=C,S_{0})\end{multline*}


This means, very roughly, that $read(B)$ could result in common knowledge
that $loc=C$ if it was commonly known that the preconditions of $read(B)$
implied $loc=C$. Since this is not given in the domain description,
the example is not entailed.

~

\begin{example}
After Alice also reads the invitation, the location becomes common
knowledge:\[
\Dt\cup\Dt_{K}^{obs}\,\models\,\PKnows((Alice\cup Bob)^{*},loc=C,do(read(Alice),do(read(Bob),S_{0})))\]

\end{example}
The additional action here can be handled in the same manner as the
previous example. We will not repeat the working, but simply state
that this indeed is a consequence of our theory.


\section{Encoding $\KDoZ$\label{sec:CKnowledge:Encoding-KDoZ}}

This section develops an encoding of first-order dynamic logic into
the situation calculus via macro expansion. Our encoding is based
on embedding FODL into Golog, a programming language based on the
situation calculus \citep{levesque97golog} that has many similarities
to dynamic logic.

This may seem like an unnecessary complication - why not expand FODL
directly into sentences of the situation calculus? We find the embedding
into Golog simpler and clearer, and expect many readers familiar with
the situation calculus will feel likewise. As Golog is well-understood,
it relieves some our burden of proof in establishing that the embedding
works as required. Since the semantics of Golog itself it based on
macro-expansion, the end-result is the the same: sentences of FODL
macro-expand into sentences of the situation calculus. Finally, our
modification to Golog so that it is interpreted over epistemic frames
may further elucidate the intended operation of FODL in this paper.

First, let us introduce the semantics of Golog. In the following,
$\delta$ will represent an arbitrary Golog program. The semantics
are traditionally defined as a macro $\mathbf{Do}(\delta,s,s')$ which
stands for {}``it is possible to execute program $\delta$, starting
in situation $s$, and ending in situation $s'$'' \citep{levesque97golog}.
Since we intend to interpret Golog over epistemic frames, we will
use the macro $\EDo$ to make this distinction clear. This requires
only one modification to vanilla Golog - the base operators are agent
terms, rather than actions.

\begin{defnL}
[{Semantics~of~Epistemic~Golog}] The semantics of Golog
over epistemic frames is given by the macro $\EDo$ defined as follows,
where $P$ names a predicate symbol:\[
\delta::=agt\,|\,?\phi\,|\,\delta_{1};\delta_{2}\,|\,\delta_{1}\cup\delta_{2}\,|\,\pi(x)(\delta(x))\,|\,\delta^{*}\,|\,\mathbf{proc}\, P(\vars{x})\,\delta(\vars{x})\,\mathbf{end}\,;\,\delta\,|\, P(\vars{x})\]
 \begin{align*}
\EDo(agt,s,s')\,\isdef\,\, & K_{0}(agt,s',s)\\
\EDo(?\phi,s,s')\,\isdef\,\, & s=s'\wedge\phi[s]\\
\EDo(\delta_{1}\,;\,\delta_{2},s,s')\,\isdef\,\, & \exists s'':\,\EDo(\delta_{1},s,s'')\,\wedge\,\EDo(\delta_{2},s'',s')\\
\EDo(\delta_{1}\,\cup\,\delta_{2},s,s')\,\isdef\,\, & \EDo(\delta_{1},s,s')\vee\EDo(\delta_{2},s,s')\\
\EDo(\pi(x)(\delta(x)),s,s')\,\isdef\,\, & \exists x:\,\EDo(\delta(x),s,s')\\
\EDo(\delta^{*},s,s')\,\isdef\,\, & \mathrm{refl.\, trans.\, closure\, of}\,\,\EDo(\delta,s,s')\\
\EDo(P(\vars{x}),s,s')\,\isdef\,\, & P(\vars{x},s,s')\end{align*}

\end{defnL}
The final clause identifies a procedure call with arguments $\vars{x}$.
Defining procedure calls via macro expansion involves a second-order
definition corresponding to the standard least-fixed-point semantics
for recursive procedures. This operates as follows, taking a list
of $n$ procedure definitions followed by a main program invocation:\begin{multline*}
\EDo(\{\mathbf{proc}\, P_{1}(\vars{v_{1}})\,\delta_{1}\,\mathbf{end}\,;\dots\,;\,\mathbf{proc}\, P_{n}(\vars{v_{n}})\,\delta_{n}\,\mathbf{end}\,;\,\delta_{0}\}\,\isdef\,\\
\forall(P_{1},\dots,P_{n})\left[\bigwedge_{i=1}^{n}\forall s_{1},s_{2},\vars{v_{i}}:\,\EDo(\delta_{i},s_{1},s_{2})\,\rightarrow\,\EDo(P_{i}(\vars{v}_{i}),s_{1},s_{2})\right]\\
\rightarrow\,\,\EDo(\delta_{0},s,s')\end{multline*}


Clearly Golog is a very powerful language, so the question must be
asked: could we use Golog as our epistemic path language, rather than
FODL? Unfortunately not, as Golog has no notion of \emph{state} -
while the Golog operator $\pi(x)(\delta(x))$ is similar to the FODL
operator $\exists x$, its effect is localised to the contained program
$\delta(x)$. FODL allows variable assignments to affect the entire
remaining program.

We review the operators and required semantics of FODL for convenience:\[
\pi::=agt\,|\,?\phi\,|\,\pi_{1};\pi_{2}\,|\,\pi_{1}\cup\pi_{2}\,|\,\pi^{*}\,|\,\exists x\]
 \[
\KDoZ(\pi,s,s')\,\,\equiv\,\,\exists\mu'\,\KDoZ(\pi,\varepsilon,s,\mu',s')\]
 \begin{gather*}
\KDoZ(agt,\mu'',s'',\mu,s)\,\equiv\,\mu''=\mu\,\wedge\, K_{0}(agt,s'',s)\\
\KDoZ(?\phi,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu\,\wedge\,\mu(\phi)[s]\\
\KDoZ(\pi_{1};\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\exists\mu',s':\,\KDoZ(\pi_{1},\mu',s',\mu,s)\,\wedge\,\KDoZ(\pi_{2},\mu'',s'',\mu',s')\\
\KDoZ(\pi_{1}\cup\pi_{2},\mu'',s'',\mu,s)\,\equiv\,\KDoZ(\pi_{1},\mu'',s'',\mu,s)\,\vee\,\KDoZ(\pi_{2},\mu'',s'',\mu,s)\\
\KDoZ(x:=t,\mu'',s'',\mu,s)\,\equiv\, s''=s\,\wedge\,\mu''=\mu[x/t]\\
\KDoZ(\exists x,\mu'',s'',\mu,s)\,\equiv\,\exists z:\, s''=s\,\wedge\,\mu''=\mu[x/z]\\
\forall P:\,\left[\mathbf{refl}\,\wedge\,\mathbf{tran}\,\wedge\,\mathbf{cont}\right]\rightarrow\left[P(\mu'',s'',\mu,s)\rightarrow\KDoZ(\pi^{*},\mu'',s'',\mu,s)\right]\end{gather*}


Note that the semantics of FODL explicitly use first-order substitutions
to manage stateful variables. In order to simulate this via macro
expansion, we use what is essentially a continuation-passing transformation
to avoid explicitly mentioning substitutions.

First, note that any epistemic path $\pi$ will be contain only a
finite number of FODL variables. Without loss of generality, suppose
that $\pi$ contains $n$ such variables named $x_{1}$ to $x_{n}$.
The idea is to translate each component of the path into a Golog procedure
with $n$ arguments, where the $i$th argument is used to pass in
the current value of $x_{i}$. After performing the necessary operations
to encode the semantics of that path component, it calls a continuation
procedure containing the next path component. This translation is
based on the macro $\KDoC(\pi,N,C)$ which is passed the name
it should use for the procedure encoding the given path component
($N$) and the name of the continuation procedure ($C$).

\begin{defnL}
[{Embedding~FODL~into~Golog}] The embedding of FODL into
Golog is given by the macros $\KDoZ$ and $\KDoC$ defined as
follows, where $P_{i}$ are fresh procedure names and $\vars{v}$
are argument vectors of length $n$:

[{{[}{\begin{align*}
\KDoZ(\pi,s,s')\,\isdef\,\,\  & \EDo(\{\KDoC(\pi,P,End)\,;\,\mathbf{proc}\, End(\vars{v})\,?\top\,\mathbf{end}\,;\,\pi(\vars{v})(P(\vars{v}))\},s,s')\end{align*}
}] }]~ 
\end{defnL}
\begin{align*}
\KDoC(agt,N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\, agt\,;\, C(\vars{v})\,\mathbf{end}\\
\KDoC(?\phi(\vars{x}),N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,?\phi(\vars{v})\,;\, C(\vars{v})\,\ \mathbf{end}\\
\KDoC(\exists x_{i},N,C)\,\isdef\,\, & \mathbf{proc}\, N(\vars{v})\,\pi(x)(C(\vars{v}[v_{i}/x]))\,\mathbf{end}\\
\KDoC(\pi_{1};\pi_{2},N,C)\,\isdef\,\, & \KDoC(\pi_{1},N,P)\,;\,\KDoC(\pi_{2},P,C)\\
\KDoC(\pi_{1}\cup\pi_{2},N,C)\,\isdef\,\, & \KDoC(\pi_{1},P_{1},C)\,;\,\KDoC(\pi_{2},P_{2},C)\,;\,\mathbf{proc}\, N(\vars{v})\, P_{1}(\vars{v})\cup P_{2}(\vars{v})\,\mathbf{end}\\
\KDoC(\pi^{*},N,C)\,\isdef\,\, & \KDoC(\pi,P,N)\,;\,\mathbf{proc}\, N(\vars{v})\, C(\vars{v})\cup P(\vars{v})\,\mathbf{end}\end{align*}


This translation generates one procedure for each operator in the
path, plus the procedure $End$ used to successfully terminate execution.
Most of these definitions are straightforward translations of equivalent
operators in FODL to Golog. One interesting case is $\exists x_{i}$,
which calls the continuation procedure with a fresh variable in position
$i$.

The most complex case is $\pi^{*}$, which simulates iteration using
a pair of mutually recursive procedures $P$ and $N$. Procedure $N$
can either terminate immediately (calling the continuation $C$) or
call $P$. A call to $P$ executes one iteration of $\pi$ before
continuing with another invocation of $N$. The possible executions
for $\pi^{*}$ are thus $nil$, $\pi$, $\pi;\pi$, etc as required
by the semantics of FODL.

It should be clear that the expansion of each operator satisfies the
relevant identity from Definition \ref{def:KDo}, and thus the encoding
acts as required.


\section{Discussion\label{sub:CEM-Discussion}}

In this section we have introduced a technique for representing and
reasoning about complex epistemic modalities in the situation calculus.
In order to formulate an effective reasoning procedure, we have had
to move beyond just $\Knows$ and $\CKnows$ and introduce a powerful
epistemic path language based on dynamic logic. Mirroring the development
of knowledge for individual agents, group-level modalities are introduced
as macros of the form $\PKnows(\pi,\phi,s)$ where $\pi$ is a complex
epistemic path. To avoid having to expand these macros during reasoning,
we have modified the regression operator to treat them as primitive
fluents.

Demonstrating the utility of our approach, we have presented an example
of effective automated reasoning about common knowledge in an asynchronous,
partially observable domain. This powerful new ability is a first
for the situation calculus.

Our development has clear parallels with the development of LCC \citep{vanBenthem06lcc}.
We choose the situation calculus for its much richer ontology, e.g.
preconditions and effects are first order, while actions take arguments
and may be performed concurrently. On one hand, this forces us to
use a more powerful dynamic logic for our epistemic language and run
the risk of undecidability. On the other, it actually simplifies some
aspects of our presentation. We do not need explicit update frames,
and the definition of our path regressor does not require an auxiliary
Kleene-style operator to handle iteration.

In synchronous domains with a finite state-space the situation calculus
may not offer a gain in expressiveness, but it can certainly provide
a more succinct axiomatisation. Moving beyond such domains, our formalism
offers the potential to incorporate other rich domain features that
have been developed for the situation calculus, such as continuous
time and actions with duration \citep{reiter96sc_nat_conc}.

The expressiveness of our epistemic path language means that answering
a regressed knowledge query can be difficult in the general case.
However, starting from the expression for common knowledge, the epistemic
path regressor $\Trn$ will generate only a fragment of the full epistemic
language. For example, it generates only formulae without nested iteration
operators, a property which is known to simplify proof search in PDL
\citep{abate07twb_pdl}. Restricting the domain can weaken this generated
fragment, as shown in \citep{vanBenthem06lcc} where a relativised
common-knowledge operator is proven sufficient for domains in which
all actions are publicly observable. Identifying restrictions such
as this that can simplify reasoning in the epistemic language is a
promising avenue for future research.

As with our account of individual-level knowledge, hidden actions
are handled using a fixpoint calculation. However, this calculation
is no longer based on objective formulae and the unique names axioms,
but requires reasoning in first-order dynamic logic. The above considerations
must be taken into account not only when answering the final regressed
query, but also when generating the intermediate fixpoints.

