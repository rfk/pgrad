#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass aamas2008
\begin_preamble
\usepackage{tikz}
\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}
\end_preamble
\options letterpaper
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Cooperative Execution in the Situation Calculus
\newline
using Prime Event Structures
\end_layout

\begin_layout Author
Tracking Number: 290
\end_layout

\begin_layout Abstract
We develop a powerful extension to the situation calculus for representing
 and reasoning about the cooperative execution of tasks by a team of agents
 in asynchronous, partially observable domains.
 Existing applications of the situation calculus to multi-agent systems
 utilize totally ordered sequences of actions, requiring constant synchronizatio
n between agents that may be undesirable or even impossible in some settings.
 Our new approach utilizes 
\emph on
joint executions
\emph default
, partially ordered branching action sequences based on a prime event structure.
 By way of demonstration, we show how a team of agents can use these structures
 to cooperatively plan and perform an execution of a shared ConGolog program.
 The agents automatically plan to operate independently where possible,
 and synchronize when necessary, without changing the input program or the
 semantics of ConGolog.
 Our implementation leverages the distributed logic programming capabilities
 of the Mozart system to transparently share the execution planning workload
 between the agents.
\end_layout

\begin_layout Abstract
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
category{I.2.11}{Artificial Intelligence}{Distributed Artificial Intelligence}[Mul
ti-agent systems]
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
terms{Languages, Theory}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
keywords{ConGolog, Event Structure, Multi-agent planning}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

, and programming languages such as ConGolog 
\begin_inset LatexCommand cite
key "giacomo00congolog"

\end_inset

 that are built upon it, has proven an effective formalism for specifying
 and reasoning about the behavior of agents in a dynamic world.
 While mostly used for single-agent domains, it has also found application
 in a variety of multi-agent settings 
\begin_inset LatexCommand cite
key "Ferrein2005readylog,kelly06hlp_dps,shapiro02casl"

\end_inset

.
 Among its advantages are an effective reasoning procedure based on regression,
 a straightforward encoding as a logic program, and a wide range of extensions
 such as concurrent events, time, and natural actions.
\end_layout

\begin_layout Standard
However, some representational limits of the situation calculus make it
 a less-than-satisfying solution for rich multi-agent domains.
 The fundamental unit of reasoning, and the output of the ConGolog execution
 planning process, is the 
\emph on
situation
\emph default
: a complete, ordered history of all actions that have occurred in the world.
 Working with a total ordering over actions is far from ideal in a multi-agent
 setting as it requires constant synchronization between the agents.
 This severely limits the potential for concurrency in the system.
 Moreover, such synchronization may not even be possible if agents are unaware
 of the actions performed by others.
 Multi-agent applications of the situation calculus thus invariably assume
 that all actions performed are public, available to all agents for the
 purposes of reasoning and synchronization.
 This is clearly unrealistic in many domains.
\end_layout

\begin_layout Standard
This paper shows how these limitations can be overcome, by developing a
 formalism for explicitly working with only a partial ordering on actions.
 We take inspiration from a model of concurrent computation known as 
\emph on
prime event
\emph default
 
\emph on
structures
\emph default
 
\begin_inset LatexCommand cite
key "npw79event_structures"

\end_inset

, which are partially-ordered branching sequences of events.

\emph on
 
\emph default
We define a 
\emph on
joint execution
\emph default
 as a particular kind of prime event structure that is rich enough to capture
 the concurrent execution of independent actions, including actions with
 sensing results, but restricted enough that it can be unambiguously reduced
 back to situation terms for the purposes of reasoning.
 To demonstrate the utility of the approach, we show how a team of agents
 can cooperate to plan and perform an execution of a shared ConGolog program
 in an asynchronous, partially observable domain.
\end_layout

\begin_layout Standard
Rather than assuming all actions are public, we leverage recent work by
 Kelly and Pearce 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

 to axiomatize the conditions under which an agent will be aware of the
 occurrence of an action.
 Joint executions are restricted such that whenever action 
\begin_inset Formula $a_{1}$
\end_inset

 must be performed before action 
\begin_inset Formula $a_{2}$
\end_inset

, the agent performing 
\begin_inset Formula $a_{2}$
\end_inset

 is able to observe the occurrence of 
\begin_inset Formula $a_{1}$
\end_inset

.
 Synchronization thus occurs by observing the actions of other agents.
 If this is not possible, yet synchronization is needed to ensure correctness,
 then construction of the joint execution will fail.
 In general, whether an action is enabled at any stage of execution can
 be determined using only the information available to the agent who is
 to perform it.
\end_layout

\begin_layout Standard
Joint executions thus allow us to capture the actions that a team of agents
 is to perform in service of some shared task, without requiring constant
 synchronization between the agents, and without assuming that agents know
 all the actions that have been performed, while still utilizing existing
 reasoning methods based on full situation terms.
 This is a significant increase in expressiveness over existing approaches
 to modeling multi-agent teams in the situation calculus.
 
\end_layout

\begin_layout Standard
The paper is laid out as follows: section 
\begin_inset LatexCommand ref
reference "sec:Background"

\end_inset

 gives the necessary background on the situation calculus, ConGolog and
 prime event structures; section 
\begin_inset LatexCommand ref
reference "sec:Joint-Execs"

\end_inset

 defines the concept of a joint execution and argues for its utility in
 multi-agent settings; section 
\begin_inset LatexCommand ref
reference "sec:Implementation"

\end_inset

 describes our implementation of a ConGolog interpreter using joint executions
 and gives a small example of its output; section 
\begin_inset LatexCommand ref
reference "sec:Related-Work"

\end_inset

 places this work in the context of related work; and section 
\begin_inset LatexCommand ref
reference "sec:Conclusion"

\end_inset

 concludes and offers ideas for future research.
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "sec:Background"

\end_inset


\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

 is a formalism for representing and reasoning about dynamic worlds.
 We use a variant with multiple agents 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

, sensing actions and partial observability of actions 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

.
 A brief review is presented below.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom, with the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting instantaneous events that can cause the state
 of the world to change, with the initiating agent indicated by their first
 argument; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Result
\noun default
 terms represent the sensing results returned by actions; 
\noun on
Object
\noun default
 terms represent other objects in the domain.
 It also distinguishes 
\emph on
fluents
\emph default
 as predicates or functions representing properties of the world that change
 between situations, and so taking a situation as their final argument.
\end_layout

\begin_layout Standard
A 
\emph on
basic action theory
\emph default
 is a set 
\begin_inset Formula $\mathcal{D}$
\end_inset

 of situation calculus sentences (with a specific syntactic form as specified
 in 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

) that describes a particular dynamic world.
 Queries about the behavior of the world are posed as logical entailment
 queries relative to this theory.
 There is a distinguished fluent 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 The functional fluent 
\begin_inset Formula $SR(a,s)=r$
\end_inset

 determines what the sensing result of an action will be, and we assume
 there is a finite set of possible results for each action.
\end_layout

\begin_layout Standard
Rather than assuming all actions are public, the fluent 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 indicates when an agent will be aware of the occurrence of an action.
 Similarly, 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 indicates when an agent will be aware of the result of an action.
 These can be combined into a function 
\begin_inset Formula $Obs(agt,a,s)=o$
\end_inset

 yielding what is 
\emph on
observed
\emph default
 by the agent when an action is performed, defined as the conjunction of:
\begin_inset Formula \begin{gather*}
\neg CanObs(agt,a,s)\,\rightarrow\, o=nil\\
CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\,\rightarrow\, o=a\\
CanObs(agt,a,s)\wedge CanSense(agt,a,s)\,\rightarrow\, o=(a,SR(a,s))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $Obs(agt,a,s)$
\end_inset

 is the special term 
\begin_inset Formula $nil$
\end_inset

, then the agent is completely unaware of the action's occurrence.
 We define the 
\emph on
outcome
\emph default
 of an action 
\begin_inset Formula $Out(a,s)=o$
\end_inset

 to be a mapping from agents to the observations they make from that action.
\end_layout

\begin_layout Standard
The regression meta-operator 
\begin_inset Formula $\mathcal{R}$
\end_inset

 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

 is used to handle reasoning effectively.
 Queries must be posed in the restricted syntactic form 
\begin_inset Formula $D\,\models\,\phi(s)$
\end_inset

.
 Roughly, this reads 
\begin_inset Quotes eld
\end_inset

formula 
\begin_inset Formula $\phi$
\end_inset

 holds in situation 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

, where 
\begin_inset Formula $\phi$
\end_inset

 is some logical combination of fluents and 
\begin_inset Formula $s$
\end_inset

 is a ground situation term.
 
\begin_inset Formula $\mathcal{R}$
\end_inset

 transforms these queries into a form that can be answered based only what
 is known about the initial situation, which can be quite efficient in practice
 (e.g.
 for Prolog-style closed world databases).
 This restriction means that the full situation term is required in order
 to perform reasoning.
\end_layout

\begin_layout Subsection
ConGolog
\end_layout

\begin_layout Standard
ConGolog 
\begin_inset LatexCommand cite
key "giacomo00congolog"

\end_inset

 is a declarative agent programming language based on the situation calculus.
 Testimony to its success are its wide range of applications and many extensions
 to provide additional functionality (
\begin_inset LatexCommand cite
key "giacomo99indigolog,Ferrein2005readylog,kelly06hlp_dps,shapiro02casl"

\end_inset

).
 To program an agent using ConGolog one specifies a situation calculus action
 theory, and a program consisting of actions from the theory connected by
 programming constructs such as if-then-else, while loops, and nondeterministic
 choice.
 Table 
\begin_inset LatexCommand ref
reference "tbl:Golog-Operators"

\end_inset

 lists some of the operators available.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Operator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Meaning
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute action 
\begin_inset Formula $a$
\end_inset

 in the world
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\phi?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Proceed if condition 
\begin_inset Formula $\phi$
\end_inset

 is true
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1};\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta_{1}$
\end_inset

followed by 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}|\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute either 
\begin_inset Formula $\delta_{1}$
\end_inset

 or 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\pi(x)\delta(x)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nondet.
 select arguments for 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 zero or more times
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Exec.
 
\begin_inset Formula $\delta_{1}$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 holds, 
\begin_inset Formula $\delta_{2}$
\end_inset

 otherwise
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{while\,}\phi\mathbf{\, do}\,\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 while 
\begin_inset Formula $\phi$
\end_inset

 holds
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{proc}\, P(\overrightarrow{x})\delta(\overrightarrow{x})\,\mathbf{end}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Procedure definition
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Concurrent execution
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Operators from the ConGolog language
\begin_inset LatexCommand label
name "tbl:Golog-Operators"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the control program may be nondeterministic, it is the task of the
 agent to plan a deterministic instantiation of the program, a sequence
 of actions that can legally be performed in the world.
 We call this the 
\emph on
execution planning process 
\emph default
and the result is a 
\emph on
legal execution
\emph default
 of the program.
\end_layout

\begin_layout Standard
Two predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 define the semantics for each operator.
 
\begin_inset Formula $Trans(\delta,s,\delta',s')$
\end_inset

 holds when executing a step of program 
\begin_inset Formula $\delta$
\end_inset

 can cause the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to situation 
\begin_inset Formula $s'$
\end_inset

, after which 
\begin_inset Formula $\delta'$
\end_inset

 remains to be executed.
 It thus characterizes single steps of computation.
 
\begin_inset Formula $Final(\delta,s)$
\end_inset

 holds when program 
\begin_inset Formula $\delta$
\end_inset

 may legally terminate its execution in situation 
\begin_inset Formula $s$
\end_inset

.
 The full semantics are available in 
\begin_inset LatexCommand cite
key "giacomo00congolog"

\end_inset

, but as an example consider equation (
\begin_inset LatexCommand ref
reference "eqn:trans_conc_orig"

\end_inset

), which specifies the concurrent-execution operator as an interleaving
 of computation steps.
 It states that it is possible to single-step the concurrent execution of
 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

 by performing either a step from 
\begin_inset Formula $\delta_{1}$
\end_inset

 or a step from 
\begin_inset Formula $\delta_{2}$
\end_inset

, with the remainder 
\begin_inset Formula $\gamma$
\end_inset

 left to execute concurrently with the other program:
\begin_inset Formula \begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\\
\shoveright{\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\vee\,\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\label{eqn:trans_conc_orig}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
ConGolog programs are executed in an offline manner: a complete situation
 term constituting a legal execution is determined, and then executed by
 the agent in a purely reactive manner.
 While a variant named IndiGolog 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 allows planning to be interleaved with execution, we do not consider such
 online execution in this paper.
\end_layout

\begin_layout Standard
When actions can have multiple results, such as sensing actions, the output
 of the execution planning process must be a branching structure rather
 than a straight sequence of actions.
 In 
\begin_inset LatexCommand cite
key "lakemeyer99golog_cats"

\end_inset

 
\emph on
conditional action trees
\emph default
 are used as an extension of raw situation terms to capture the necessary
 branching.
 However, these are still totally ordered sequences of actions, and so are
 less than ideal for many multi-agent settings.
\end_layout

\begin_layout Standard
Similarly, planning over sensing actions cannot use situation terms alone
 for reasoning, as they do not include the sensing information.
 We follow the approach of 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 and introduce the concept of a 
\emph on
history
\emph default
, denoted 
\begin_inset Formula $\sigma$
\end_inset

, which is a sequence of pairs 
\begin_inset Formula $(a,Out(a,s))$
\end_inset

 giving the outcome produced at run-time by each action.
 This is strictly a meta-level construct and does not exist in the language
 of the situation calculus.
 Rather, the macro 
\begin_inset Formula $\mathbf{end}[\sigma]$
\end_inset

 gives the situation term corresponding to the history, and 
\begin_inset Formula $\mathbf{sensed}[\sigma]$
\end_inset

 gives a formula of the situation calculus that captures the information
 given by the sensing results.
 To determine whether a formula 
\begin_inset Formula $\phi$
\end_inset

 holds after a given history, the query 
\begin_inset Formula $\mathcal{D}\cup\mathbf{sensed}[\sigma]\models\phi(\mathbf{end}[\sigma])$
\end_inset

 is used; see 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 for the details.
\end_layout

\begin_layout Standard
Since we are dealing with multi-agent domains, we must consider not only
 the global history, but the local view of that history that is available
 to each agent.
 Agents can only be expected to act based on their local history of observations.
 Given a history 
\begin_inset Formula $\sigma$
\end_inset

, it is straightforward to produce the 
\emph on
view 
\emph default
of that history that is available to a given agent: it is the corresponding
 sequence of 
\begin_inset Formula $(a,Obs(agt,a,s))$
\end_inset

 pairs, excluding those where 
\begin_inset Formula $Obs(agt,a,s)$
\end_inset

 is 
\begin_inset Formula $nil$
\end_inset

.
 We will denote this by 
\begin_inset Formula $view(agt,\sigma)$
\end_inset

.
 Note that this is equivalent to the function 
\begin_inset Formula $ObsHist(agt,s)$
\end_inset

 defined in 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

, but is a macro rather than a term in the language of the situation calculus.
\end_layout

\begin_layout Standard
The idea of having a team of agents execute a shared ConGolog program has
 been utilized in 
\begin_inset LatexCommand cite
key "Ferrein2005readylog,kelly06hlp_dps"

\end_inset

.
 The advantages of this approach include the use of nondeterministic operators
 to provide 'dont-care' nondeterminism regarding which team-member carries
 out which task, the use of the concurrency operator to easily compose subtasks,
 and the ability to plan for and resolve interactions between agents such
 as conflict over resources.
 To demonstrate our approach, we adopt the example from 
\begin_inset LatexCommand cite
key "kelly06hlp_dps"

\end_inset

 of a team of robotic chefs cooperating to prepare a simple salad.
 Their shared control program is given in figure 
\begin_inset LatexCommand ref
reference "fig:makesalad-program"

\end_inset

.
 It says, in essence: somebody chop a lettuce, somebody chop a tomato, and
 somebody
\emph on
 
\emph default
chop a carrot into the bowl, then mix.
 In section 
\begin_inset LatexCommand ref
reference "sec:Implementation"

\end_inset

 we will show the joint execution that our system produces for this program.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\mathbf{proc}\,\, MakeSalad(bowl):\\
\left[ChopTypeInto(Lettuce,bowl)||\right.\\
ChopTypeInfo(Tomato,bowl)\\
\left.ChopTypeInto(Carrot,bowl)\right];\\
\pi(agt,acquire(agt,bowl)\,;\, mix(agt,bowl)\,;\\
\, release(agt,bowl))\,\mathbf{end}\\
\\\mathbf{proc}\,\, ChopTypeInto(type,bowl):\\
\pi(obj,\, ObjIsType(obj,type)?\,;\, ChopInto(obj,bowl))\,\mathbf{end}\\
\\\mathbf{proc}\,\, ChopInto(obj,bowl):\\
\pi(agt,\,\pi(k,\, ObjIsType(k,knife)?\,;\\
acquire(agt,obj)\,;\, acquire(agt,k)\,;\, chop(agt,obj)\,;\\
acquire(agt,bowl)\,;\, placeIn(agt,bowl)\,;\\
release(agt,k)\,;\,\left[nil\,|\, release(agt,bowl)\right]\mathbf{end}\end{multline*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Example of a shared ConGolog program
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:makesalad-program"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Event Structures
\end_layout

\begin_layout Standard
Event structures are a model of concurrent computation introduced in 
\begin_inset LatexCommand cite
key "npw79event_structures"

\end_inset

.
 The particular variant we are interested in are 
\emph on
prime event structures
\emph default
, defined as a four-tuple:
\begin_inset Formula \[
(V,\prec,\#,\gamma)\]

\end_inset

 were 
\begin_inset Formula $V$
\end_inset

 is a set of events; 
\begin_inset Formula $\gamma$
\end_inset

 is a function assigning a label to each event; 
\begin_inset Formula $\prec$
\end_inset

 is the 
\emph on
enabling
\emph default
 relation, a strict partial order on events; and 
\begin_inset Formula $\#$
\end_inset

 is the 
\emph on
conflict
\emph default
 relation, a binary symmetric relation that is inherited through enablers:
\begin_inset Formula \[
\forall i,j,k\in V:i\#j\wedge i\prec k\rightarrow k\#j\]

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
configuration
\emph default
 is a sequence of events consistent with 
\begin_inset Formula $\prec$
\end_inset

 in which no pair of events conflict.
 Each configuration represents a potential partial run of execution of the
 system.
\end_layout

\begin_layout Standard
For convenience, we will define our prime event structures using finite
 sets of direct enablers 
\begin_inset Formula $ens(i)$
\end_inset

 and direct alternatives 
\begin_inset Formula $alts(i)$
\end_inset

 for each event 
\begin_inset Formula $i$
\end_inset

.
 To maintain symmetry, 
\begin_inset Formula $i\in alts(j)$
\end_inset

 iff 
\begin_inset Formula $j\in alts(i)$
\end_inset

.
 The enabling relation 
\begin_inset Formula $i\prec j$
\end_inset

 is then the transitive closure of 
\begin_inset Formula $i\in ens(j)$
\end_inset

, and 
\begin_inset Formula $\#$
\end_inset

 is the smallest relation satisfying:
\begin_inset Formula \[
\forall i,j\in V:[\exists i',j'\in V:i'\preceq i\wedge j'\preceq j\wedge i\in alts(j)]\rightarrow i\#j\]

\end_inset

 As shown in 
\begin_inset LatexCommand cite
key "pratt91modeling_conc_with_geom"

\end_inset

, event structures have a deep relationship to various other models of concurren
cy.
 They can be converted into a kind of finite automaton for efficient execution.
\end_layout

\begin_layout Section
Joint Executions
\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "sec:Joint-Execs"

\end_inset


\end_layout

\begin_layout Subsection
Independent Actions
\end_layout

\begin_layout Standard
As discussed in section 
\begin_inset LatexCommand ref
reference "sec:Background"

\end_inset

, posing queries in the situation calculus requires a full situation term.
 The first step towards providing only a partial order on the actions to
 be performed is, therefore, to capture the notion that some actions can
 be performed in either order without affecting what holds in the resulting
 situation.
 Define 
\emph on
independent
\emph default
 actions, identified by 
\begin_inset Formula $indep(a_{1},a_{2})$
\end_inset

, as those satisfying the following restrictions:
\end_layout

\begin_layout Itemize
\begin_inset Formula $Poss(a_{1},s)\equiv Poss(a_{1},do(a_{2},s))$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $Poss(a_{2},s)\equiv Poss(a_{2},do(a_{1}s))$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{P}(do(a_{1},do(a_{2},s)))\equiv\mathcal{P}(do(a_{2},do(a_{1},s)))$
\end_inset


\newline
 for all predicate fluents 
\begin_inset Formula $\mathcal{P}(s)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{F}(do(a_{1},do(a_{2},s)))=r\equiv\mathcal{F}(do(a_{2},do(a_{1},s)))=r$
\end_inset


\newline
 for all functional fluents 
\begin_inset Formula $\mathcal{F}(s)$
\end_inset


\end_layout

\begin_layout Standard
We will say that two situations are 
\emph on
equivalent
\emph default
, denoted by 
\emph on

\begin_inset Formula $equiv(s_{1},s_{2})$
\end_inset

,
\emph default
 if they are identical up to transposition of pairs of adjacent independent
 actions.
 A straightforward (but tedious, and therefore omitted) case analysis on
 the definition of the regression operator shows that if 
\begin_inset Formula $equiv(s_{1},s_{2})$
\end_inset

, then 
\begin_inset Formula $\mathcal{D}\models\phi(s_{1})$
\end_inset

 iff 
\begin_inset Formula $\mathcal{D}\models\phi(s_{2})$
\end_inset

.
\end_layout

\begin_layout Standard
This notion of equivalence can be extended by macro expansion to histories
 in the obvious manner, with the analogous result that if 
\begin_inset Formula $equiv(\sigma_{1},\sigma_{2})$
\end_inset

, then 
\begin_inset Formula $\mathcal{D}\cup\mathbf{sensed}[\sigma_{1}]\models\phi(\mathbf{end}[\sigma_{1}])$
\end_inset

 iff 
\begin_inset Formula $\mathcal{D}\cup\mathbf{sensed}[\sigma_{2}]\models\phi(\mathbf{end}[\sigma_{2}])$
\end_inset

.
\end_layout

\begin_layout Subsection
Joint Executions
\end_layout

\begin_layout Standard
We define a 
\emph on
joint execution
\emph default
 as special kind of prime event structure with the following components:
\begin_inset Formula \[
(A,O,ens,alts,\gamma,<)\]

\end_inset

It contains two disjoint sets of events, 
\emph on
action
\emph default
 events 
\begin_inset Formula $A$
\end_inset

 and 
\emph on
outcome
\emph default
 events 
\begin_inset Formula $O$
\end_inset

.
 For each action event 
\begin_inset Formula $a\in A$
\end_inset

, its enablers 
\begin_inset Formula $ens(a)$
\end_inset

 is a set of outcome events, its alternatives 
\begin_inset Formula $alts(a)$
\end_inset

 is empty, and its label 
\begin_inset Formula $\gamma(a)$
\end_inset

 is the action to be performed.
 For each outcome event 
\begin_inset Formula $o\in O$
\end_inset

, 
\begin_inset Formula $ens(o)$
\end_inset

 is a single action event, 
\begin_inset Formula $alts(o)$
\end_inset

 is the set of all other outcome events 
\begin_inset Formula $o'$
\end_inset

 such that 
\begin_inset Formula $ens(o')=ens(o)$
\end_inset

, and 
\begin_inset Formula $\gamma(o)$
\end_inset

 is an outcome as produced by the 
\begin_inset Formula $Out(a,s)$
\end_inset

 function for the action 
\begin_inset Formula $\gamma(ens(o))$
\end_inset

.
 A simple example of a joint execution is shown in figure 
\begin_inset LatexCommand ref
reference "fig:example-je"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\align center

\family sans
\series bold
\size tiny
\begin_inset Include \include{listings/je_example.tex}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A simple joint execution.
 Elliptical nodes are action events, box nodes are outcome events.
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:example-je"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A joint execution has one additional component over a standard prime event
 structure: a 
\emph on
total 
\emph default
order on events 
\begin_inset Formula $<$
\end_inset

 that is consistent with the partial order 
\begin_inset Formula $\prec$
\end_inset

 induced by the enabling relation.
 This will be used to relate parts of the execution back to a situation
 term in order to perform reasoning using standard techniques.
 In practice, this order will be determined by the order of insertion of
 events into the execution.
\end_layout

\begin_layout Standard
An 
\emph on
outcome set
\emph default
 is a minimal set of non-conflicting outcome events; that is, a set of events
 
\begin_inset Formula $e\subset O$
\end_inset

 satisfying:
\begin_inset Formula \begin{gather*}
\forall o_{1},o_{2}\in e\,:\,\neg(o_{1}\#o_{2})\\
\forall o_{1},o_{2}\in e\,:\, o_{1}\not\prec o_{2}\,\wedge o_{2}\not\prec o_{1}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Recall that a 
\emph on
configuration
\emph default
 is a partial run of execution of the prime event structure.
 Clearly any configuration ending in an outcome event 
\begin_inset Formula $o$
\end_inset

 corresponds to a unique history 
\begin_inset Formula $\sigma$
\end_inset

, as it is a set of alternating actions and their outcomes.
 We call the 
\emph on
histories
\emph default
 of an outcome set, denoted 
\begin_inset Formula $hists(e)$
\end_inset

, the set of all configurations containing all elements of 
\begin_inset Formula $e$
\end_inset

, and ending in an event from 
\begin_inset Formula $e$
\end_inset

.
 The unique history of a branch that is consistent with the total order
 will be denoted 
\begin_inset Formula $hist(e)$
\end_inset

.
\end_layout

\begin_layout Standard
We say that an outcome set 
\begin_inset Formula $e_{1}$
\end_inset

 
\emph on
covers 
\emph default
an outcome set 
\emph on

\begin_inset Formula $e_{2}$
\end_inset

, 
\emph default
denoted by 
\begin_inset Formula $e_{1}\sqsubseteq e_{2}$
\end_inset

, if every event in 
\begin_inset Formula $e_{1}$
\end_inset

 is either also in 
\begin_inset Formula $e_{2}$
\end_inset

, or precedes something in 
\begin_inset Formula $e_{2}$
\end_inset

.
 Every history in 
\begin_inset Formula $hists(e_{2})$
\end_inset

 will have a prefix in 
\begin_inset Formula $hists(e_{1})$
\end_inset

.
 This defines a partial ordering on outcome sets:
\begin_inset Formula \[
e_{1}\sqsubseteq e_{2}\,\equiv\,\forall o_{1}\in e_{1}:\,\,\exists o_{2}\in e_{2}:\,\, o_{1}\preceq o_{2}\]

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $max(e)$
\end_inset

 denote the maximal element of an outcome set with respect to the total
 order
\begin_inset Formula $<$
\end_inset

.
 A 
\emph on
branch
\emph default
, denoted 
\begin_inset Formula $b$
\end_inset

, is a special case of an outcome set that meets the following additional
 requirement:
\begin_inset Formula \[
\forall i<max(b):\,\, i\in b\,\oplus\,(\exists i'\in b:\,\, i\#i'\,\vee\, i\prec i')\]

\end_inset


\end_layout

\begin_layout Standard
That is, every event less than the maximal element of 
\begin_inset Formula $b$
\end_inset

 is either in the branch, conflicts with something in the branch, or precedes
 something in the branch.
 A branch thus identifies a unique outcome for each action event that is
 ordered below 
\begin_inset Formula $max(b)$
\end_inset

.
\end_layout

\begin_layout Subsection
Restrictions on Joint Executions
\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "sub:Restrictions"

\end_inset


\end_layout

\begin_layout Standard
We now impose several restrictions on the structure of a joint execution,
 to ensure they are suitable for representing the actions to be performed
 by a team of agents.
\newline

\end_layout

\begin_layout Standard

\series bold
Independent events have independent actions:
\series default
 Joint executions are restricted such that the following holds for all action
 events 
\begin_inset Formula $a_{1},a_{2}\in A$
\end_inset

:
\begin_inset Formula \begin{equation}
a_{1}<a_{2}\,\rightarrow\, a_{1}\prec a_{2}\,\vee\, a_{1}\#a_{2}\,\vee\, indep(\gamma(a_{1}),\gamma(a_{2}))\label{eq:tord-indep}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In words: if 
\begin_inset Formula $a_{2}$
\end_inset

 is after 
\begin_inset Formula $a_{1}$
\end_inset

 in the total order, but the execution allows them to be performed in either
 order, then the corresponding actions must be independent.
 
\end_layout

\begin_layout Standard
With this restriction, all histories corresponding to a branch are equivalent
 to the history generated by the total order.
 It is thus possible to determine whether a formula holds after the execution
 of a given branch, using the query:
\begin_inset Formula \[
\mathcal{D}\cup\mathbf{sensed}[hist(b)]\models\phi(\mathbf{end}[hist(b)])\]

\end_inset


\end_layout

\begin_layout Standard
This is a key point and is worth re-iterating: regardless of the precise
 order in which events are executed, any history that contains all events
 on a branch 
\begin_inset Formula $b$
\end_inset

, and that ends in an event from 
\begin_inset Formula $b$
\end_inset

, is equivalent to the unique history of 
\begin_inset Formula $b$
\end_inset

 generated by the total order.
 This allows us to work with execution branches rather than histories or
 situation terms during planning.
\newline

\end_layout

\begin_layout Standard

\series bold
Actions are enabled by a unique branch:
\series default
 We restrict the enabling set for each action event to be a branch, rather
 than an arbitrary set of outcome events.
 In practice this means that when inserting a new action into the joint
 execution, one must specify the branch to which it belongs.
 This restriction allows us to determine what holds immediately before an
 event 
\begin_inset Formula $a\in A$
\end_inset

 becomes enabled, using 
\begin_inset Formula $hist(ens(a))$
\end_inset

.
 In combination with the restriction above it ensures that whenever an action
 becomes enabled, it will remain possible until it is performed.
 Moreover, any events that occur after it is enabled but before it is performed
 will not interfere with its effects, as they must be independent.
 
\newline

\end_layout

\begin_layout Standard

\series bold
All possible outcomes are considered:
\series default
 Clearly planning requires that all possible outcomes of an action be considered.
 For each action event 
\begin_inset Formula $a\in A$
\end_inset

, and each possible outcome 
\begin_inset Formula $r$
\end_inset

 of that action, if:
\begin_inset Formula \begin{multline*}
D\cup\mathbf{sensed}[hist(ens(a))]\not\,\models\,\\
Out(\gamma(a),\mathbf{end}[hist(ens(a))])\neq r\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
then there must be a corresponding outcome event:
\begin_inset Formula \[
\exists o\in E:\,\, ens(o)=\{a\}\,\wedge\,\gamma(o)=r\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Actions are enabled by observable events:
\series default
 If an action is to be enabled by an outcome event 
\begin_inset Formula $o$
\end_inset

 produced by another agent, it is clearly necessary that the agent performing
 the action be able to observe the occurrence of 
\begin_inset Formula $o$
\end_inset

.
 Otherwise, it has no way of synchronizing its actions with those of its
 teammate.
 Let 
\begin_inset Formula $actor(a)$
\end_inset

 be the agent responsible for performing an action event 
\begin_inset Formula $a$
\end_inset

, then we require that:
\begin_inset Formula \[
\forall o\in ens(a):\,\,\gamma(o)[actor(a)]\neq nil\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
Overlapping views enable identical actions:
\series default
 To ensure that the joint execution can actually be carried out by the agents,
 there must be no confusion about whether a particular action is enabled.
 Lifting the function 
\begin_inset Formula $view()$
\end_inset

 to operate on sets of histories in the obvious way, then:
\begin_inset Formula \[
view(actor(a),\, hists(ens(a)))\]

\end_inset

 gives the set of all local histories after which 
\begin_inset Formula $actor(a)$
\end_inset

 is required to perform the action 
\begin_inset Formula $\gamma(a)$
\end_inset

.
 However, since the agent has only a local viewpoint, it may be the case
 that some other outcome set can produce an identical local history.
\end_layout

\begin_layout Standard
Say that an outcome set 
\begin_inset Formula $e$
\end_inset

 
\emph on
overlaps
\emph default
 another set 
\begin_inset Formula $e'$
\end_inset

 if they could produce an identical local history from the perspective of
 a given agent:
\begin_inset Formula \begin{multline*}
overlaps(agt,e,e')\,\equiv\\
view(agt,hists(e))\,\cap\, view(agt,hists(e'))\,\neq\varnothing\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Then the 
\emph on
minimal overlapping set
\emph default
 for an outcome set 
\begin_inset Formula $e$
\end_inset

 and agent 
\begin_inset Formula $agt$
\end_inset

 is the set of all 
\begin_inset Formula $e'$
\end_inset

 satisfying:
\begin_inset Formula \[
overlaps(agt,e,e')\wedge\neg\exists e''\left[overlaps(agt,e,e'')\wedge e''\sqsubset e'\right]\]

\end_inset


\end_layout

\begin_layout Standard
The minimality requirement ensures that every member of this set is a proper
 branch.
 This is then the minimal set of branches that the agent could potentially
 confuse for the set 
\begin_inset Formula $e$
\end_inset

.
 To ensure there is no confusion about whether an action is enabled, for
 each 
\begin_inset Formula $a\in A$
\end_inset

, every 
\begin_inset Formula $b$
\end_inset

 in the minimal overlapping set of 
\begin_inset Formula $ens(a)$
\end_inset

 for 
\begin_inset Formula $actor(a)$
\end_inset

 must enable an event 
\begin_inset Formula $a'$
\end_inset

 with identical action 
\begin_inset Formula $\gamma(a')=\gamma(a)$
\end_inset

.
 This ensures that the agent's local information is always enough to know
 when it should perform an action.
 While it may not know precisely which 
\emph on
event
\emph default
 is enabled, it will know enough to determine the specific 
\emph on
action
\emph default
 that it must perform.
\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
In this section we have defined a 
\emph on
joint execution
\emph default
 as a prime event structure with some additional restrictions.
 It is our contention that such a structure is highly suitable for representing
 the actions to be performed by a team in service of some shared task, such
 as executing a shared ConGolog program.
 
\end_layout

\begin_layout Standard
On one hand, joint executions are restricted enough to be practical for
 such use.
 Like the situation terms or conditional action trees used in previous ConGolog
 variants, prime event structures are purely reactive (equivalent to a kind
 of finite automaton 
\begin_inset LatexCommand cite
key "pratt91modeling_conc_with_geom"

\end_inset

) and can be executed without further deliberation.
 It is restricted to ensure that whenever an agent is required to perform
 an action, it is able to determine this using only its local information.
 Each branch of execution can be easily converted into a standard history
 or situation term for the purposes of reasoning.
\end_layout

\begin_layout Standard
On the other, joint executions are significantly more flexible than previous
 approaches.
 They allow independent actions to be performed without synchronization,
 in any order.
 The agents need never know precisely what actions have been executed, only
 those that enable them to perform their next action.
 Where synchronization is required between actions, it is achieved by explicitly
 reasoning about what actions each agent can observe, rather than requiring
 that all actions be public.
\end_layout

\begin_layout Standard
To demonstrate the utility of these structures, we have implemented an interpret
er for ConGolog that produces joint executions as its output.
 In the next section, we highlight the key aspects of our implementation
 and give a small example of the executions it produces.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "sec:Implementation"

\end_inset


\end_layout

\begin_layout Standard
Our implementation
\begin_inset Foot
status collapsed

\begin_layout Standard
available at [identifying information omitted]
\end_layout

\end_inset

 of a ConGolog interpreter utilizes the Mozart programming system 
\begin_inset LatexCommand cite
key "vanroy99mozart"

\end_inset

 rather than the traditional use of Prolog.
 As we shall see, Mozart's strong support for distributed logic programming
 allows the team of agents to share the planning workload with almost no
 additional code.
 While the syntax is quite different from Prolog, care has been taken to
 keep the code samples as clear and readable as possible.
 
\end_layout

\begin_layout Standard
To make things more concrete, figure 
\begin_inset LatexCommand ref
reference "fig:plan-output"

\end_inset

 shows the output of our system when run on the 
\begin_inset Formula $MakeSalad$
\end_inset

 example of figure 
\begin_inset LatexCommand ref
reference "fig:makesalad-program"

\end_inset

.
 Since all actions in this program have a single outcome, the outcome events
 have been suppressed for brevity.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\family sans
\series bold
\size tiny
\begin_inset Include \include{listings/plan.tex}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Resulting plan for 
\begin_inset Formula $MakeSalad(bowl(1))$
\end_inset


\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:plan-output"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this domain there are three agents, but only two knives are available.
 The agents must therefore synchronize their use of these resources.
 Actions are taken to be independent if they deal with different objects.
 As seen in figure 
\begin_inset LatexCommand ref
reference "fig:plan-output"

\end_inset

, the use of a partial order structure facilitates parallelism between the
 agents, with each processing a different ingredient and only synchronizing
 on the availability of the required resources.
 There is no need for processing actions, such as 
\begin_inset Formula $mix$
\end_inset

 and 
\begin_inset Formula $chop$
\end_inset

, to be publicly observable.
 This output is clearly a significant improvement over a totally ordered
 sequence (or conditional tree) of actions as produced by existing ConGolog
 systems.
\end_layout

\begin_layout Standard
In the following subsections, we briefly highlight some key aspects of our
 implementation.
\end_layout

\begin_layout Subsection
Program Steps
\end_layout

\begin_layout Standard
While the ability to determine whether actions are independent is necessary
 in constructing partially-ordered executions of a ConGolog program, it
 is not sufficient.
 Actions might have an order imposed on them directly by the program (for
 example by the sequence construct 
\begin_inset Formula $a_{1};a_{2}$
\end_inset

).
 The execution of the program may require that some additional conditions
 are true immediately prior to executing an action (for example to satisfy
 a test construct 
\begin_inset Formula $\phi?$
\end_inset

), which could be falsified by an otherwise independent action.
\end_layout

\begin_layout Standard
To ensure that the dependencies between actions reflect the needs of the
 program being executed, we augment the implementation of the 
\begin_inset Formula $Trans$
\end_inset

 predicate to keep additional information about what transitions were made.
 A 
\emph on
step 
\emph default
object has the following attributes:
\end_layout

\begin_layout Itemize
action: the action performed in that step, or 
\begin_inset Formula $nil$
\end_inset

 if it is an internal program transition
\end_layout

\begin_layout Itemize
test: an additional fluent formula that must hold immediately before performing
 the step
\end_layout

\begin_layout Itemize
thread: a sequence of 'l' and 'r' characters indicating the concurrent thread
 in which the step is performed
\end_layout

\begin_layout Itemize
outcome: the outcome of performing the action.
\end_layout

\begin_layout Standard
We call a sequence of such steps a 
\emph on
run
\emph default
, which can be converted to a history by taking just the action and outcome
 attributes.
 The procedure implementing 
\begin_inset Formula $Trans$
\end_inset

 takes a program and a run as input, returning a new program and new step
 of execution.
 As an example consider the code in figure 
\begin_inset LatexCommand ref
reference "fig:trans-code"

\end_inset

, implementing the test operator and the concurrency operator from equation
 
\begin_inset LatexCommand ref
reference "eqn:trans_conc_orig"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size scriptsize
\begin_inset Include \verbatiminput{listings/ConGolog.oz}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Code for 
\begin_inset Formula $Trans$
\end_inset

 predicate
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:trans-code"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that whenever the procedure descends through the left side of a concurrency
 operator it pushes an 'l' onto the step's 
\begin_inset Quotes eld
\end_inset

thread
\begin_inset Quotes erd
\end_inset

 attribute, and each descent through the right side pushes an 'r'.
 Two steps can be said to come from different threads as long as neither
 
\begin_inset Quotes eld
\end_inset

thread
\begin_inset Quotes erd
\end_inset

 attribute is a prefix of the other.
\end_layout

\begin_layout Standard
We say that two steps are 
\emph on
ordered
\emph default
 if any of the following holds: their action terms are not independent;
 ones thread is a prefix of the other; ones action falsifies the test condition
 associated with the other.
 When building a joint execution, ordered steps are forced to be executed
 in the order they were generated by the planner, while unordered steps
 may be performed in either order.
\end_layout

\begin_layout Subsection
Joint Execution ADT
\end_layout

\begin_layout Standard
We implement a joint execution as an abstract data type.
 The primary operation is inserting a new action event.
 This requires the branch on which to insert it, and a list of previous
 events that the new action
\emph on
 
\emph default
may be executed independently of.
 It returns a list of new branches, one for each outcome of the action.
 It also ensures that the restrictions listed in section 
\begin_inset LatexCommand ref
reference "sub:Restrictions"

\end_inset

 are maintained, in particular by inserting additional action events on
 other branches to satisfy the restriction on overlapping views.
\end_layout

\begin_layout Subsection
Planning Procedure
\end_layout

\begin_layout Standard
The code for planning a joint execution from a given ConGolog program is
 shown in figure 
\begin_inset LatexCommand ref
reference "fig:planning-code"

\end_inset

.
 The main procedure is 
\begin_inset Formula $MakePlan$
\end_inset

, a recursive procedure that operates on a list of branches-in-progress
 of the form 
\begin_inset Formula $(D,R,B)$
\end_inset

.
 Here 
\begin_inset Formula $B$
\end_inset

 is a branch in the joint execution under construction, 
\begin_inset Formula $D$
\end_inset

 is the program remaining to be executed on that branch, and 
\begin_inset Formula $R$
\end_inset

 is the run of program steps performed on that branch so far.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size scriptsize
\begin_inset Include \verbatiminput{listings/Planner.oz}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Code for main planning loop
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:planning-code"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each iteration of the planning loop proceeds as follows.
 The procedure 
\begin_inset Formula $FindOpenBranch$
\end_inset

 updates each branch to account for events that were added since it was
 last processed (some may have been added automatically in response to a
 new action on anther branch), then searches the list to find a branch for
 which 
\begin_inset Formula $Final(D,R)$
\end_inset

 does not hold.
 If all branches are final, planning can terminate.
 Otherwise, the procedure 
\begin_inset Formula $FindTrans1$
\end_inset

 is called to find a new step of execution for that branch.
 The action is inserted into the joint execution, which returns a list of
 new branches, one for each outcome of the action.
 Each of these outcomes is added to the list of branches, and the loop is
 started again.
\end_layout

\begin_layout Standard
Of particular interest is the procedure 
\begin_inset Formula $FindTrans1$
\end_inset

, which uses the encapsulated search functionality of Mozart to yield possible
 next steps according to an estimate of how good they are.
 The procedure 
\begin_inset Formula $LP.yieldOrdered$
\end_inset

 yields the solutions of the given search context, sorted using the procedure
 
\begin_inset Formula $CompareSteps$
\end_inset

.
 This procedure (not shown) gives preference to steps that can be performed
 concurrently with as many existing actions as possible.
\end_layout

\begin_layout Subsection
Distributing the Planning Workload
\end_layout

\begin_layout Standard
A primary motivation in using Mozart for our implementation is its strong
 support for distributed logic programming.
 Utilizing the parallel search feature 
\begin_inset LatexCommand cite
key "Schulte00constraint_services"

\end_inset

, the planning workload can be transparently distributed between the agents.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size scriptsize
\begin_inset Include \verbatiminput{listings/psearch.oz}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Code to run planning procedure in parallel
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:parallel-search"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:parallel-search"

\end_inset

 shows the necessary code, which should be executed by one of the agents.
 The planning procedure is encapsulated in a 
\emph on
functor
\emph default
, a portable code object.
 A parallel search object is then created, that uses an ssh connection to
 spawn remote computations on each of the three agents (identified by their
 DNS names).
 The object is asked to provide a single solution, which is then written
 to a file in the graphviz 'dot' format for easy display.
\end_layout

\begin_layout Standard
For the simple example shown in this paper, parallel plan search does not
 demonstrate a significant time saving since almost no backtracking is required
 to reach a solution.
 For more difficult problems, significant gains can be expected.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "sec:Related-Work"

\end_inset


\end_layout

\begin_layout Standard
The idea of having a shared ConGolog program that is executed by a team
 of agents is used with considerable success in 
\begin_inset LatexCommand cite
key "Ferrein2005readylog"

\end_inset

, where the variant Readylog is used to coordinate and control a RoboCup
 soccer team.
 Their domain satisfies the assumption that all actions are public, so they
 can afford to produce totally ordered plans.
 The techniques developed in this paper would generalize such an approach
 to a wider variety of domains.
 (although 
\begin_inset LatexCommand cite
key "Ferrein2005readylog"

\end_inset

 includes some decision theoretic aspects that are not present in our work).
\end_layout

\begin_layout Standard
There has also been significant work using ConGolog in settings where each
 agent has its own control program 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

.
 The behavior of the overall system is specified as the concurrent combination
 of each agent's program, 
\begin_inset Formula $\delta_{1}||\delta_{2}||\dots$
\end_inset

, and ConGolog is used to verify that the system satisfies certain constraints
 (e.g.
 safety or liveness properties).
 Again, this cannot handle partial observability of actions since all reasoning
 is based on a full situation term.
 We believe the joint execution formalism could be helpful in such settings,
 by permitting synchronization only when actions are observable by the agents.
\end_layout

\begin_layout Standard
Several authors have introduced operators for expressing partial orderings
 between actions into the ConGolog language itself, for example 
\begin_inset LatexCommand cite
key "son00htn_golog"

\end_inset

.
 While this is unquestionably useful for specifying behavior, the 
\emph on
output
\emph default
 from such systems is still a totally ordered sequence of actions and thus
 maintains the limitations of existing systems in actually performing the
 execution.
\end_layout

\begin_layout Standard
There is, of course, an extensive body of work on partial-order planning
 in the context of goal-based planning.
 Unsurprisingly, the joint execution structure we develop here has deep
 similarities to the structures used in conditional partial-order planners
 such as 
\begin_inset LatexCommand cite
key "peot92conditional_nonlinear"

\end_inset

.
 It is, however, intentionally specific to the situation calculus.
 We make no use of many concepts common in partial-order goal-based planning
 (causal links, threats, conflicts, etc) because we do not deal explicitly
 with goals, but with steps generated by an underlying transition semantics.
 Indeed, our approach can be considered roughly equivalent to 
\emph on
deordering
\emph default
 of a totally-ordered plan as described in 
\begin_inset LatexCommand cite
key "backstrom99reordering"

\end_inset

, except performed during plan construction rather than as a post-processing
 step.
\end_layout

\begin_layout Section
Conclusions and Future Work
\end_layout

\begin_layout Standard
\begin_inset LatexCommand label
name "sec:Conclusion"

\end_inset


\end_layout

\begin_layout Standard
In this paper, we have shown how a team of agents can cooperate to plan
 and perform an execution of a shared ConGolog program.
 The output of the planning process is a special kind of prime event structure
 that we term a joint execution.
 Joint executions are restricted enough that they can be reasoned about
 directly using the underlying situation calculus theory, but are flexible
 enough to represent different branches of execution and partial ordering
 between actions.
 By imposing appropriate restrictions on these structures, we ensure that
 they can be executed in a reactive manner by the agents based only on their
 local information.
\end_layout

\begin_layout Standard
Our immediate plans for future work involve incorporating the idea of online
 execution from IndiGolog 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 to allow the interleaving of planning and execution.
 This is a non-trivial extension in the multi-agent case when the agents
 may have different knowledge about the world.
 We are presently developing an approach based on explicit notions of knowledge
 and common knowledge, leveraging the formalism developed by 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

.
\end_layout

\begin_layout Standard
In the single-agent case, a joint execution reduces to something similar
 to a conditional action tree as introduced by 
\begin_inset LatexCommand cite
key "lakemeyer99golog_cats"

\end_inset

.
 While these kinds of branching structures are powerful, they are not universal
 - specifically, they cannot handle programs requiring unbounded iteration.
 The 
\begin_inset Quotes eld
\end_inset

agent assembly language
\begin_inset Quotes erd
\end_inset

 introduced in 
\begin_inset LatexCommand cite
key "levesque96what_is_planning"

\end_inset

 includes a looping construct and is shown to capture all possible behaviors
 of an agent.
 We are currently investigating ways to lift such capabilities into a properly
 multi-agent setting such as the one detailed in this paper.
\end_layout

\begin_layout Standard
TODO: final summary.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "abbrv"
bibfiles "/storage/uni/pgrad/library/references"

\end_inset


\end_layout

\end_body
\end_document
