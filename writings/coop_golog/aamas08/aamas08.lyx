#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass aamas2008
\begin_preamble
\usepackage{tikz}
\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}
\end_preamble
\options letterpaper
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Cooperative Execution of ConGolog Programs
\end_layout

\begin_layout Author
Tracking Number: 290
\end_layout

\begin_layout Abstract
We show how a team of agents can cooperate to plan and perform the execution
 of a shared ConGolog program in asynchronous, partially observable domains.
 Existing ConGolog variants generate totally ordered sequences of actions,
 requiring constant synchronisation that may be undesirable or even impossible
 in a multi-agent setting.
 Our new approach produces 
\begin_inset Quotes eld
\end_inset

joint executions
\begin_inset Quotes erd
\end_inset

, partially ordered branching action sequences based on a prime event structure.
 Using these structures, agents can automatically plan to operate independently
 where possible, and synchronise when necessary, without changing the input
 program or the semantics of ConGolog.
 Our implementation leverages the distributed logic programming capabilities
 of the Mozart programming system to share the execution planning workload
 between the agents.
\end_layout

\begin_layout Abstract
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
category{I.2.11}{Artificial Intelligence}{Distributed Artificial Intelligence}[Mul
ti-agent systems]
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
terms{Languages, Theory}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
keywords{ConGolog, Event Structure, Multi-agent planning}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The programming language ConGolog 
\begin_inset LatexCommand cite
key "giacomo00congolog"

\end_inset

, based on the situation calculus 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

, has proven an effective formalism for specifying the behavior of agents
 in a dynamic world.
 While mostly used for single-agent domains, it has also found application
 in a variety of multi-agent settings 
\begin_inset LatexCommand cite
key "Ferrein2005readylog,kelly06hlp_dps,shapiro02casl"

\end_inset

.
 
\end_layout

\begin_layout Standard
However, some representational limitations of the situation calculus make
 it a less-than-satisfying solution for multi-agent domains.
 The fundamental unit of reasoning, and the outcome of the execution planning
 process, is the 
\emph on
situation
\emph default
 - a complete, ordered history of all the actions that have ocurred in the
 world.
 Working with a total ordering over actions is far from ideal in a multi-agent
 setting as it requires constant synchronisation between the agents, restricting
 the potential for concurrency.
 Moreover, the required synchronisation may not be possible if agents are
 unaware of the actions performed by others.
 Thus, multi-agent applications of ConGolog invariably make the assumption
 that all actions performed are public, available to all agents for the
 purposes of reasoning and synchronisation.
 This is clearly unrealistic in many domains.
\end_layout

\begin_layout Standard
This paper shows how these limitations can be overcome, by developing a
 technique for the cooperative execution of a shared ConGolog program by
 a team of agents in an asynchronous, partially observable domain.
 Key to our approach is moving away from situation terms as the outcome
 of the execution planning process.
 Instead, we take inspiration from a formalism for modelling concurrency
 known as 
\emph on
prime event
\emph default
 
\emph on
structures
\emph default
 
\begin_inset LatexCommand cite
key "npw79event_structures"

\end_inset

, partially-ordered branching sequences of events.

\emph on
 
\emph default
We define a 
\begin_inset Quotes eld
\end_inset

joint execution
\begin_inset Quotes erd
\end_inset

 as a particular kind of prime event structure that is rich enough to capture
 the concurrent execution of independent actions, including actions with
 sensing results, but restricted enough that it can be unambiguously reduced
 back to situation terms for the purposes of reasoning.
 
\end_layout

\begin_layout Standard
Rather than assuming all actions are public, we leverage recent work by
 Kelly and Pearce 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

 to axiomatize the conditions under which an agent will be aware of the
 occurence of an action.
 Joint executions are restricted to ensure that whenever action 
\begin_inset Formula $a_{1}$
\end_inset

 must be performed before action 
\begin_inset Formula $a_{2}$
\end_inset

, the agent performing 
\begin_inset Formula $a_{2}$
\end_inset

 is able to observe the occurence of 
\begin_inset Formula $a_{1}$
\end_inset

.
 Synchronisation thus occurs by observing the actions of other agents, only
 when possible and necessary to ensure correctness of the execution.
 In general, whether an action is enabled at any stage of execution can
 be determined using only the information available to the agent who is
 to perform it.
\end_layout

\begin_layout Standard
We do 
\emph on
not
\emph default
 change the semantics of the ConGolog language, or require any modifications
 to ConGolog programs.
 Our approach operates at the meta-level, using the situation calculus theory
 of action and the semantics of ConGolog as reasoning tools.
 This is in the spirit of existing extensions to ConGolog, such as 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

.
\end_layout

\begin_layout Standard
The paper is laid out as follows: section 
\begin_inset LatexCommand ref
reference "sec:Background"

\end_inset

 gives the necessary background on the situation calculus, ConGolog and
 prime event structures; section 
\begin_inset LatexCommand ref
reference "sec:Joint-Execs"

\end_inset

 defines the concept of a joint execution and argues for its appropriateness
 as the outcome of the execution planning process; section 
\begin_inset LatexCommand ref
reference "sec:Implementation"

\end_inset

 describes our implementation and gives a small example of its output; section
 
\begin_inset LatexCommand ref
reference "sec:Related-Work"

\end_inset

 places this work in the context of related work; and section 
\begin_inset LatexCommand ref
reference "sec:Conclusion"

\end_inset

 concludes and offers ideas for future research.
\end_layout

\begin_layout Section
Background
\begin_inset LatexCommand label
name "sec:Background"

\end_inset


\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

 is a logic formalism for representing and reasoning about dynamic worlds.
 We use a variant with multiple agents 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

, sensing actions and partial observability of actions 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

.
 For simplicity we do not include concurrent actions as used in 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

.
 A brief review is presented below.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom, with the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting instantaneous events that can cause the state
 of the world to change, with the initiating agent indicated by their first
 argument; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\noun on
Result
\noun default
 terms represent the sensing results returned by actions; 
\noun on
Object
\noun default
 terms represent other objects in the domain.
 It also distinguishes 
\emph on
fluents
\emph default
 as predicates or functions representing properties of the world that change
 between situations, and so taking a situation as their final argument.
\end_layout

\begin_layout Standard
A 
\emph on
basic action theory
\emph default
 is a set 
\begin_inset Formula $\mathcal{D}$
\end_inset

 of situation calculus sentences (with a specific syntactic form as specified
 in 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

) that describes a particular dynamic world.
 Queries about the behavior of the world are posed as logical entailment
 queries relative to this theory.
 There is a distinguished fluent 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 The functional fluent 
\begin_inset Formula $SR(a,s)=r$
\end_inset

 determines what the sensing result of an action will be, and we assume
 there is a finite set of possible results for each action.
\end_layout

\begin_layout Standard
Rather than assuming all actions are public, the fluent 
\begin_inset Formula $CanObs(agt,a,s)$
\end_inset

 indicates when an agent will be aware of the occurence of an action.
 Similarly, 
\begin_inset Formula $CanSense(agt,a,s)$
\end_inset

 indicates when an agent will be aware of the result of an action.
 These can be combined into a function 
\begin_inset Formula $Obs(agt,a,s)=o$
\end_inset

 yielding what is 
\emph on
observed
\emph default
 by the agent when an action is performed, defined as the conjunction of:
\begin_inset Formula \begin{gather*}
\neg CanObs(agt,a,s)\,\rightarrow\, o=nil\\
CanObs(agt,a,s)\wedge\neg CanSense(agt,a,s)\,\rightarrow\, o=a\\
CanObs(agt,a,s)\wedge CanSense(agt,a,s)\,\rightarrow\, o=(a,SR(a,s))\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $Obs(agt,a,s)$
\end_inset

 is the special term 
\begin_inset Formula $nil$
\end_inset

, then the agent is completely unaware of the action's occurence.
 We define the 
\emph on
outcome
\emph default
 of an action 
\begin_inset Formula $Out(a,s)=o$
\end_inset

 to be a mapping from agents to the observations they made when that action
 was performed.
\end_layout

\begin_layout Standard
The regression meta-operator 
\begin_inset Formula $\mathcal{R}$
\end_inset

 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

 is used to handle reasoning effectively.
 Queries must be posed in the restricted syntactic form 
\begin_inset Formula $D\,\models\,\phi(s)$
\end_inset

.
 Roughly, this reads 
\begin_inset Quotes eld
\end_inset

formula 
\begin_inset Formula $\phi$
\end_inset

 holds in situation 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

, where 
\begin_inset Formula $\phi$
\end_inset

 is some logical combination of fluents and 
\begin_inset Formula $s$
\end_inset

 is a ground situation term.
 
\begin_inset Formula $\mathcal{R}$
\end_inset

 transforms these queries into a form that can be answered using only what
 is known about the initial situation, which can be quite efficient in practise
 (e.g.
 for closed world databases).
\end_layout

\begin_layout Subsection
ConGolog
\end_layout

\begin_layout Standard
ConGolog 
\begin_inset LatexCommand cite
key "giacomo00congolog"

\end_inset

 is a declarative agent programming language based on the situation calculus.
 Testimony to its success are its wide range of applications and many extensions
 to provide additional functionality (
\begin_inset LatexCommand cite
key "giacomo99indigolog,Ferrein2005readylog,kelly06hlp_dps,shapiro02casl"

\end_inset

).
 To program an agent using ConGolog one specifies a situation calculus action
 theory, and a program consisting of actions from the theory connected by
 programming constructs such as if-then-else, while loops, and nondeterministic
 choice.
 Table 
\begin_inset LatexCommand ref
reference "tbl:Golog-Operators"

\end_inset

 lists some of the operators available.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Operator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Meaning
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute action 
\begin_inset Formula $a$
\end_inset

 in the world
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\phi?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Proceed if condition 
\begin_inset Formula $\phi$
\end_inset

 is true
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1};\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta_{1}$
\end_inset

followed by 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}|\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute either 
\begin_inset Formula $\delta_{1}$
\end_inset

 or 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\pi(x)\delta(x)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nondet.
 select arguments for 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 zero or more times
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Exec.
 
\begin_inset Formula $\delta_{1}$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 holds, 
\begin_inset Formula $\delta_{2}$
\end_inset

 otherwise
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{while\,}\phi\mathbf{\, do}\,\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 while 
\begin_inset Formula $\phi$
\end_inset

 holds
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{proc}\, P(\overrightarrow{x})\delta(\overrightarrow{x})\,\mathbf{end}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Procedure definition
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Concurrent execution
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Some ConGolog Operators
\begin_inset LatexCommand label
name "tbl:Golog-Operators"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the control program may be nondeterministic, it is the task of the
 agent to plan a deterministic instantiation of the program, a sequence
 of actions that can legally be performed in the world.
 We call this the 
\emph on
execution planning process 
\emph default
and the result is a 
\emph on
legal execution
\emph default
 of the program.
\end_layout

\begin_layout Standard
Two predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 define the semantics for each operator.
 
\begin_inset Formula $Trans(\delta,s,\delta',s')$
\end_inset

 holds when executing a step of program 
\begin_inset Formula $\delta$
\end_inset

 can cause the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to situation 
\begin_inset Formula $s'$
\end_inset

, after which 
\begin_inset Formula $\delta'$
\end_inset

 remains to be executed.
 It thus characterizes single steps of computation.
 
\begin_inset Formula $Final(\delta,s)$
\end_inset

 holds when program 
\begin_inset Formula $\delta$
\end_inset

 may legally terminate its execution in situation 
\begin_inset Formula $s$
\end_inset

.
 The full semantics are available in the references, but as an example consider
 equation (
\begin_inset LatexCommand ref
reference "eqn:trans_conc_orig"

\end_inset

), which specifies the concurrent-execution operator as an interleaving
 of computation steps.
 It states that it is possible to single-step the concurrent execution of
 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

 by performing either a step from 
\begin_inset Formula $\delta_{1}$
\end_inset

 or a step from 
\begin_inset Formula $\delta_{2}$
\end_inset

, with the remainder 
\begin_inset Formula $\gamma$
\end_inset

 left to execute concurrently with the other program:
\begin_inset Formula \begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\\
\shoveright{\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\vee\,\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\label{eqn:trans_conc_orig}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
ConGolog programs are executed in an offline manner: a complete situation
 term constituting a legal execution is determined, and then executed by
 the agent in a purely reactive manner.
 While a variant named IndiGolog 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 allows planning to be interleaved with execution, we do not consider such
 online execution here.
\end_layout

\begin_layout Standard
When actions can have multiple results, such as sensing actions, the output
 of the execution planning process must be a branching structure rather
 than a straight sequence of actions.
 In 
\begin_inset LatexCommand cite
key "lakemeyer99golog_cats"

\end_inset

 
\emph on
conditional action trees
\emph default
 are used to capture the necessary branching structure.
 However, these are still totally ordered sequences of actions, and so are
 less than ideal for many multi-agent settings.
\end_layout

\begin_layout Standard
Similarly, planning over sensing actions cannot use situation terms alone
 for reasoning, as they do not include the sensing information.
 We follow the approach of 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 and introduce the concept of a 
\emph on
history
\emph default
, denoted 
\begin_inset Formula $\sigma$
\end_inset

, which is a sequence of pairs 
\begin_inset Formula $(a,Out(a,s))$
\end_inset

 giving the outcome produced at runtime by each action.
 This is strictly a meta-level construct and does not exist in the language
 of the situation calculus.
 Rather, the macro 
\begin_inset Formula $\mathbf{end}[\sigma]$
\end_inset

 gives the situation term corresponding to the history, and 
\begin_inset Formula $\mathbf{sensed}[\sigma]$
\end_inset

 gives a formula of the situation calculus that captures the information
 given by the action outcomes.
 To determine whether a formula 
\begin_inset Formula $\phi$
\end_inset

 holds after a given history, the situation calculus query 
\begin_inset Formula $\mathcal{D}\cup\mathbf{sensed}[\sigma]\models\phi(\mathbf{end}[\sigma])$
\end_inset

 is used; see 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 for the details.
\end_layout

\begin_layout Standard
Since we are dealing with multi-agent domains, we must consider not only
 the global history, but the local view of that history that is available
 to each agent.
 Agents can only be expected to act based on their local history of observations.
 Given a history 
\begin_inset Formula $\sigma$
\end_inset

, it is straightforward to produce the 
\emph on
view 
\emph default
of that history that is available to a given agent: it is the corresponding
 sequence of 
\begin_inset Formula $(a,Obs(agt,a,s))$
\end_inset

 pairs, exlucding those where 
\begin_inset Formula $Obs(agt,a,s)$
\end_inset

 is 
\begin_inset Formula $nil$
\end_inset

.
 We will denote this by 
\begin_inset Formula $view(agt,\sigma)$
\end_inset

.
 Note that this is equivalent to the function 
\begin_inset Formula $ObsHist(agt,s)$
\end_inset

 defined in 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

.
\end_layout

\begin_layout Standard
The idea of having a team of agents execute a shared ConGolog program has
 been utilised in 
\begin_inset LatexCommand cite
key "Ferrein2005readylog,kelly06hlp_dps"

\end_inset

.
 The advantages of this approach include the use of nondeterministic operators
 to provide 'dont-care' nondeterminism regarding which team-member carries
 out which task, the use of the concurrency operator (
\begin_inset Formula $||$
\end_inset

) to easily compose subtasks, and the ability to plan for and resolve interactio
ns between agents such as conflict over resources.
 To demonstrate the approach, we adopt the example from 
\begin_inset LatexCommand cite
key "kelly06hlp_dps"

\end_inset

 of a team of robotic chefs cooperating to prepare a simple salad.
 Their shared control program is given in figure 
\begin_inset LatexCommand ref
reference "fig:makesalad-program"

\end_inset

.
 It says, in essence: somebody chop a lettuce, somebody chop a tomato, and
 somebody
\emph on
 
\emph default
chop a carrot into the bowl, then mix.
 In section 
\begin_inset LatexCommand ref
reference "sec:Implementation"

\end_inset

 we will show the execution that our system produces for this program.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\mathbf{proc}\,\, MakeSalad(bowl):\\
\left[\pi(agt,\, ChopTypeInto(Lettuce,bowl))||\right.\\
\pi(agt,\, ChopTypeInfo(Tomato,bowl))\\
\left.\pi(agt,\, ChopTypeInto(Carrot,bowl))\right];\\
\pi(agt,acquire(agt,bowl)\,;\, mix(agt,bowl)\,;\\
\, release(agt,dest))\,\mathbf{end}\\
\\\mathbf{proc}\,\, ChopTypeInto(type,bowl):\\
\pi(obj,\, ObjIsType(obj,type)?\,;\, ChopInto(obj,bowl))\,\mathbf{end}\\
\\\mathbf{proc}\,\, ChopInto(obj,bowl):\\
\pi(agt,\,\pi(k,\, ObjIsType(k,knife)?\,;\\
acquire(agt,obj)\,;\, acquire(agt,k)\,;\, chop(agt,obj)\,;\\
acquire(agt,bowl)\,;\, placeIn(agt,bowl)\,;\\
release(agt,k)\,;\,\left[nil\,|\, release(agt,bowl)\right]\mathbf{end}\end{multline*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Example of a shared ConGolog program
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:makesalad-program"

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Event Structures
\end_layout

\begin_layout Standard
Event structures are a model of concurrent computation introduced in 
\begin_inset LatexCommand cite
key "npw79event_structures"

\end_inset

.
 The particular variant we are interested in are 
\emph on
prime event structures
\emph default
, defined as four-tuples 
\begin_inset Formula $(V,\prec,\#,\gamma)$
\end_inset

 where: 
\begin_inset Formula $V$
\end_inset

 is a set of events; 
\begin_inset Formula $\gamma$
\end_inset

 is a function assigning a label to each event; 
\begin_inset Formula $\prec$
\end_inset

 is the 
\emph on
enabling
\emph default
 relation, a strict partial order on events; and 
\begin_inset Formula $\#$
\end_inset

 is the 
\emph on
conflict
\emph default
 relation, a binary symmetric relation that is inherited through enablers:
\begin_inset Formula \[
\forall i,j,k\in V:i\#j\wedge i\prec k\rightarrow k\#j\]

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
configuration
\emph default
 is a sequence of events consistent with 
\begin_inset Formula $\prec$
\end_inset

 in which no pair of events conflict.
 Each configuation represents a potential partial run of execution of the
 system.
 As shown in 
\begin_inset LatexCommand cite
key "pratt91modeling_conc_with_geom"

\end_inset

, event structures have a deep relationship to various other models of concurren
cy, and can be converted into finite automata for efficient execution.
\end_layout

\begin_layout Standard
For convenience, we will define our prime event structures using finite
 sets of direct enablers (
\begin_inset Formula $ens(i)$
\end_inset

) and direct alternatives (
\begin_inset Formula $alts(i)$
\end_inset

) for each event 
\begin_inset Formula $i$
\end_inset

.
 The enabling relation 
\begin_inset Formula $i\prec j$
\end_inset

 is then the transitive closure of 
\begin_inset Formula $i\in ens(j)$
\end_inset

, and 
\begin_inset Formula $\#$
\end_inset

 is the smallest relation satisfying:
\begin_inset Formula \[
\forall i,j\in V:[\exists i',j'\in V:i'\preceq i\wedge j'\preceq j\wedge i\in alts(j)]\rightarrow i\#j\]

\end_inset


\end_layout

\begin_layout Section
Joint Executions
\begin_inset LatexCommand label
name "sec:Joint-Execs"

\end_inset


\end_layout

\begin_layout Subsection
Independent Actions
\end_layout

\begin_layout Standard
As discussed in section 
\begin_inset LatexCommand ref
reference "sec:Background"

\end_inset

, posing queries in the situation calculus requires a full situation term.
 The first step towards providing only a partial order on the actions to
 be performed is, therefore, to capture the notion that some actions can
 be performed in either order without affecting what holds in the resulting
 situation.
 Define 
\emph on
independent
\emph default
 actions, identified by 
\begin_inset Formula $indep(a_{1},a_{2})$
\end_inset

, as those satisfying the following restrictions:
\end_layout

\begin_layout Itemize
\begin_inset Formula $Poss(a_{1},s)\equiv Poss(a_{1},do(a_{2},s))$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $Poss(a_{2},s)\equiv Poss(a_{2},do(a_{1}s))$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{P}(do(a_{1},do(a_{2},s)))\equiv\mathcal{P}(do(a_{2},do(a_{1},s)))$
\end_inset

 for all predicate fluents 
\begin_inset Formula $\mathcal{P}(s)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{F}(do(a_{1},do(a_{2},s)))=r\equiv\mathcal{F}(do(a_{2},do(a_{1},s)))=r$
\end_inset

 for all functional fluents 
\begin_inset Formula $\mathcal{F}(s)$
\end_inset


\end_layout

\begin_layout Standard
We will say that two situations are 
\emph on
equivalent
\emph default
, denoted by 
\emph on

\begin_inset Formula $equiv(s_{1},s_{2})$
\end_inset

,
\emph default
 if they are identical up to transposition of pairs of adjacent independent
 actions.
 A straightforward (but tedious, and therefore omitted) case analysis on
 the definition of the regression operator shows that if 
\begin_inset Formula $equiv(s_{1},s_{2})$
\end_inset

, then 
\begin_inset Formula $\mathcal{D}\models\phi(s_{1})$
\end_inset

 iff 
\begin_inset Formula $\mathcal{D}\models\phi(s_{2})$
\end_inset

.
\end_layout

\begin_layout Standard
This notion of equivalence can be extended by macro expansion to histories
 in the obvious manner, with the analagous result that if 
\begin_inset Formula $equiv(\sigma_{1},\sigma_{2})$
\end_inset

, then 
\begin_inset Formula $\mathcal{D}\cup\mathbf{sensed}[\sigma_{1}]\models\phi(\mathbf{end}[\sigma_{1}])$
\end_inset

 iff 
\begin_inset Formula $\mathcal{D}\cup\mathbf{sensed}[\sigma_{2}]\models\phi(\mathbf{end}[\sigma_{2}])$
\end_inset

.
\end_layout

\begin_layout Subsection
Joint Executions
\end_layout

\begin_layout Standard
To support distributed concurrent execution, we define a 
\emph on
joint execution
\emph default
 as special kind of prime event structure with the following components:
 
\begin_inset Formula $(A,O,ens,alts,\gamma,<)$
\end_inset

.
 It contains two disjoint sets of events, 
\emph on
action
\emph default
 events 
\begin_inset Formula $A$
\end_inset

 and 
\emph on
outcome
\emph default
 events 
\begin_inset Formula $O$
\end_inset

.
 For each action event 
\begin_inset Formula $a\in A$
\end_inset

, its enablers 
\begin_inset Formula $ens(a)$
\end_inset

 is a set of outcome events, its alternatives 
\begin_inset Formula $alts(a)$
\end_inset

 is empty, and its label 
\begin_inset Formula $\gamma(a)$
\end_inset

 is the action to be performed.
 For each outcome event 
\begin_inset Formula $o\in O$
\end_inset

, 
\begin_inset Formula $ens(o)$
\end_inset

 is a single action event, 
\begin_inset Formula $alts(o)$
\end_inset

 is the set of all other outcome events 
\begin_inset Formula $o'$
\end_inset

 such that 
\begin_inset Formula $ens(o')=ens(o)$
\end_inset

, and 
\begin_inset Formula $\gamma(o)$
\end_inset

 is an outcome as produced by the 
\begin_inset Formula $Out(a,s)$
\end_inset

 function for the action 
\begin_inset Formula $\gamma(ens(o))$
\end_inset

.
 A simple example of a joint execution is shown in figure 
\begin_inset LatexCommand ref
reference "fig:example-je"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\align center

\family sans
\series bold
\size tiny
\begin_inset Include \include{listings/je_example.tex}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A simple joint execution
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:example-je"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A joint execution has one additional compnent over a standard prime event
 structure: a 
\emph on
total 
\emph default
order on events 
\begin_inset Formula $<$
\end_inset

 that is consitent with the partial order 
\begin_inset Formula $\prec$
\end_inset

 induced by the enabling relation.
 This will be used to relate parts of the execution back to a situation
 term in order to perform reasoning.
 In practise, this order will be determined by the order of insertion of
 events into the execution.
\end_layout

\begin_layout Standard
An 
\emph on
outcome set
\emph default
 is a minimal set of non-conflicting outcome events; that is, a set of events
 
\begin_inset Formula $e\subset O$
\end_inset

 satisfying:
\begin_inset Formula \begin{gather*}
\forall o_{1},o_{2}\in e\,:\,\neg(o_{1}\#o_{2})\\
\forall o_{1},o_{2}\in e\,:\, o_{1}\not\prec o_{2}\,\wedge o_{2}\not\prec o_{1}\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Recall that a 
\emph on
configuration
\emph default
 is a partial run of execution of the prime event structure.
 Clearly any configuration ending in an outcome event 
\begin_inset Formula $o$
\end_inset

 corresponding to a unique history 
\begin_inset Formula $\sigma$
\end_inset

, as it is a set of alternating actions and outcomes.
 We call the 
\emph on
histories
\emph default
 of an outcome set, denoted 
\begin_inset Formula $hists(e)$
\end_inset

, the set of all configurations containing all elements of 
\begin_inset Formula $e$
\end_inset

, and ending in an event from 
\begin_inset Formula $e$
\end_inset

.
\end_layout

\begin_layout Standard
We say that an outcome set 
\begin_inset Formula $e_{1}$
\end_inset

 
\emph on
covers 
\emph default
an outcome set 
\emph on

\begin_inset Formula $e_{2}$
\end_inset

, 
\emph default
denoted by 
\begin_inset Formula $e_{1}\sqsubseteq e_{2}$
\end_inset

, if every event in 
\begin_inset Formula $e_{1}$
\end_inset

 is either also in 
\begin_inset Formula $e_{2}$
\end_inset

, or preceeds something in 
\begin_inset Formula $e_{2}$
\end_inset

.
 Every history in 
\begin_inset Formula $hists(e_{2})$
\end_inset

 will have a prefix in 
\begin_inset Formula $hists(e_{1})$
\end_inset

.
 This defines a partial ordering on outcome sets:
\begin_inset Formula \[
e_{1}\sqsubseteq e_{2}\,\equiv\,\forall o_{1}\in e_{1}:\,\,\exists o_{2}\in e_{2}:\,\, o_{1}\preceq o_{2}\]

\end_inset


\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $max(e)$
\end_inset

 denote the maximal element of an outcome set with respect to the total
 order
\begin_inset Formula $<$
\end_inset

.
 A 
\emph on
branch
\emph default
, denoted 
\begin_inset Formula $b$
\end_inset

, is a special case of an outcome set that meets the following additional
 requirement:
\begin_inset Formula \[
\forall i<max(b):\,\, i\in b\,\oplus\,(\exists i'\in b\,.\, i\#i'\,\vee\, i\prec i')\]

\end_inset


\end_layout

\begin_layout Standard
That is, every event less than the maximal element of 
\begin_inset Formula $b$
\end_inset

 is either in the branch, conflicts with something in the branch, or preceeds
 something in the branch.
 A branch thus identifies a unique outcome for each action event that below
 
\begin_inset Formula $max(b)$
\end_inset

.
\end_layout

\begin_layout Subsection
Restrictions on Joint Executions
\begin_inset LatexCommand label
name "sub:Restrictions"

\end_inset


\end_layout

\begin_layout Standard
We now impose several restrictions on the structure of a joint execution,
 to ensure they are suitable for representing a plan of execution for a
 team of agents.
\end_layout

\begin_layout Itemize

\series bold
Independent events have independent actions
\end_layout

\begin_layout Standard
We require that the following holds for all action events 
\begin_inset Formula $a_{1},a_{2}\in A$
\end_inset

:
\begin_inset Formula \begin{equation}
a_{1}<a_{2}\,\rightarrow\, a_{1}\prec a_{2}\,\vee\, a_{1}\#a_{2}\,\vee\, indep(\gamma(a_{1}),\gamma(a_{2}))\label{eq:tord-indep}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In words, this states that if 
\begin_inset Formula $a_{2}$
\end_inset

 is after 
\begin_inset Formula $a_{1}$
\end_inset

 in the total order, but the partial order allows them to be performed in
 either order, then the corresponding actions must be independent.
 
\end_layout

\begin_layout Standard
With this restriction, all histories corresponding to a branch are equivalent
 to the unique history generated by the total order.
 Using 
\begin_inset Formula $hist(b)$
\end_inset

 to refer to this particular history, it is then possible to determine whether
 a formula holds after the execution of a given branch:
\begin_inset Formula \[
\mathcal{D}\cup\mathbf{sensed}[hist(b)]\models\phi(\mathbf{end}[hist(b)])\]

\end_inset


\end_layout

\begin_layout Standard
This is a key point and is worth re-iterating: regardless of the precise
 order in which events are executed, any history that contains all events
 on a branch 
\begin_inset Formula $b$
\end_inset

, and that ends in an event from 
\begin_inset Formula $b$
\end_inset

, is equivalent to the unique history of 
\begin_inset Formula $b$
\end_inset

 generated by the total order.
 This allows us to work with execution branches rather than histories or
 situation terms when planning an execution.
\end_layout

\begin_layout Itemize

\series bold
Actions are enabled by a unique branch
\end_layout

\begin_layout Standard
We restrict the enabling set for each action event to be a branch, rather
 than an arbitrary set of outcome events.
 In practice this means that when inserting a new action into the joint
 execution, one must specify the branch to which it belongs.
 This restriction allows us to determine what holds immediately before an
 event 
\begin_inset Formula $a\in A$
\end_inset

 becomes enabled, using 
\begin_inset Formula $hist(ens(a))$
\end_inset

.
 
\end_layout

\begin_layout Itemize

\series bold
All possible outcomes are considered
\end_layout

\begin_layout Standard
Clearly planning requires that all possible outcomes of an action be considered.
 For each action event 
\begin_inset Formula $a\in A$
\end_inset

, and each possible outcome 
\begin_inset Formula $r$
\end_inset

 of that action, if:
\begin_inset Formula \begin{multline*}
D\cup\mathbf{sensed}[hist(ens(a))]\not\,\models\,\\
Out(\gamma(a),\mathbf{end}[hist(ens(a))])\neq r\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
then there will be a corresponding outcome event:
\begin_inset Formula \[
\exists o\in E:\,\, ens(o)=\{a\}\,\wedge\,\gamma(o)=r\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Actions are enabled by observable events
\end_layout

\begin_layout Standard
If an action is to be enabled by an outcome event 
\begin_inset Formula $o$
\end_inset

 produced by another agent, it is clearly necessary that the agent performing
 the action be able to observe the occurence of 
\begin_inset Formula $o$
\end_inset

.
 Otherwise, it has no way of synchronising its actions with those of its
 teammate.
 Let 
\begin_inset Formula $actor(a)$
\end_inset

 be the agent responsible for performing an action event 
\begin_inset Formula $a$
\end_inset

, then we require that:
\begin_inset Formula \[
\forall o\in ens(a):\,\,\gamma(o)[actor(a)]\neq nil\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Overlapping views enable identical actions
\end_layout

\begin_layout Standard
To ensure that the joint execution can actually be carried out by the agents,
 there must be no confusion about whether a particular action is enabled.
 Lifting the function 
\begin_inset Formula $view()$
\end_inset

 to operate on sets of histories in the obvious way, then:
\begin_inset Formula \[
view(actor(a),\, hists(ens(a)))\]

\end_inset

 gives the set of all local histories after which 
\begin_inset Formula $actor(a)$
\end_inset

 is required to perform the action 
\begin_inset Formula $\gamma(a)$
\end_inset

.
 However, since the agent has only a local viewpoint, it may be the case
 that some other outcome set can produce an identical local history.
\end_layout

\begin_layout Standard
Say that an outcome set 
\begin_inset Formula $e$
\end_inset

 
\emph on
overlaps
\emph default
 another set 
\begin_inset Formula $e'$
\end_inset

 if they could produce an identical local history from the perspective of
 a given agent:
\begin_inset Formula \begin{multline*}
overlaps(agt,e,e')\,\equiv\\
view(agt,hists(e))\,\cap\, view(agt,hists(e'))\,\neq\varnothing\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Then the 
\emph on
minimal overlapping set
\emph default
 for an outcome set 
\begin_inset Formula $e$
\end_inset

 and agent 
\begin_inset Formula $agt$
\end_inset

 is the set of all 
\begin_inset Formula $e'$
\end_inset

 satisfying:
\begin_inset Formula \[
overlaps(agt,e,e')\wedge\neg\exists e''\left[overlaps(agt,e,e'')\wedge e''\sqsubset e'\right]\]

\end_inset


\end_layout

\begin_layout Standard
This is the minimal set of outcome sets that the agent could potentially
 confuse for the set 
\begin_inset Formula $e$
\end_inset

.
 To ensure there is no confusion about whether an action is enabled, for
 each 
\begin_inset Formula $a\in A$
\end_inset

, every 
\begin_inset Formula $e$
\end_inset

 in the minimal overlapping set of 
\begin_inset Formula $ens(a)$
\end_inset

 for 
\begin_inset Formula $actor(a)$
\end_inset

 must enable an event 
\begin_inset Formula $a'$
\end_inset

 with identical action 
\begin_inset Formula $\gamma(a')=\gamma(a)$
\end_inset

.
 This ensures that the agent's local information is always enough to know
 when it should perform an action.
 While it may not know precisely which 
\emph on
event
\emph default
 is enabled, it will know enough to determine the action it must perform.
\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
In this section we have defined a 
\emph on
joint execution
\emph default
 as a prime event structure with some additional restrictions.
 It is our contention that such a structure is highly suitable for representing
 the actions to be performed by a team when executing a shared ConGolog
 program.
 
\end_layout

\begin_layout Standard
On one hand, joint executions are restricted enough to be practical for
 such use.
 Like the situation terms or conditional action trees used in previous ConGolog
 variants, prime event structures are purely reactive (equivalent to a kind
 of finite automaton 
\begin_inset LatexCommand cite
key "pratt91modeling_conc_with_geom"

\end_inset

) and can be executed without further deliberation.
 It is restricted to ensure that whenever an agent is required to perform
 an action, it is able to determine this using only its local information.
 Each branch of execution can be easily converted into a standard history
 or situation term for the purposes of reasoning.
\end_layout

\begin_layout Standard
On the other, joint executions are significantly more flexible than previous
 approaches.
 They allow independent actions to be performed without synchronisation,
 in any order.
 The agents need never know precisely what actions have been executed, only
 those that enable them to perform their next action.
 Where synchronisation is required between actions, it is achieved by explicitly
 reasoning about what actions each agent can observe, rather than requiring
 that all actions be public.
\end_layout

\begin_layout Standard
Of course, the ultimate demonstration of the utility of these structures
 is to implement a ConGolog variant using them.
 In the next section, we highlight the key aspects of our implementation
 and give a small example of its output.
\end_layout

\begin_layout Section
Implementation
\begin_inset LatexCommand label
name "sec:Implementation"

\end_inset


\end_layout

\begin_layout Standard
Our implementation
\begin_inset Foot
status collapsed

\begin_layout Standard
available at [identifying information omitted]
\end_layout

\end_inset

 utilises the Mozart programming system 
\begin_inset LatexCommand cite
key "vanroy03mozart_logic"

\end_inset

 rather than the traditional use of prolog.
 As we shall see, Mozart's strong support for distributed logic programming
 allows the team of agents to share the planning workload with almost no
 additional code.
 While the syntax is quite different from prolog, care has been taken to
 keep the code samples as clear and readable as possible.
 
\end_layout

\begin_layout Standard
To make things more concrete, figure 
\begin_inset LatexCommand ref
reference "fig:plan-output"

\end_inset

 shows the output of our system when run on the 
\begin_inset Formula $MakeSalad$
\end_inset

 example of figure 
\begin_inset LatexCommand ref
reference "fig:makesalad-program"

\end_inset

.
 Since all actions in this program have a single outcome, the outcome events
 have been suppressed for brevity.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\family sans
\series bold
\size tiny
\begin_inset Include \include{listings/plan.tex}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Resulting plan for 
\begin_inset Formula $MakeSalad(bowl(1))$
\end_inset


\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:plan-output"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this domain there are three agents, but only two knives are available.
 The agents must thus synchronise their use of these resources.
 Actions are taken to be independent if they deal with different objects.
 As seen in figure 
\begin_inset LatexCommand ref
reference "fig:plan-output"

\end_inset

, the use of a partial order structure facilitates parallelism between the
 agents, with each processing a different ingredient and only synchonrising
 on the availability of the required resources.
 There is no need for processing actions, such as 
\begin_inset Formula $mix$
\end_inset

 and 
\begin_inset Formula $chop$
\end_inset

, to be publicly observable.
 This output is clearly a significant improvement over a simple sequence
 of actions as produced by existing ConGolog systems.
\end_layout

\begin_layout Standard
In the following subsections, we briefly highlight some key aspects of our
 implementation.
\end_layout

\begin_layout Subsection
Program Steps
\end_layout

\begin_layout Standard
While the ability to determine whether actions are independent is necessary
 in constructing partially-ordered executions, it is not sufficient.
 Actions might have an order imposed on them directly by the program (for
 example by the sequence construct 
\begin_inset Formula $a_{1};a_{2}$
\end_inset

).
 The execution of the program may require that some additional conditions
 are true immediately prior to executing an action (for example to satisfy
 a test construct 
\begin_inset Formula $\phi?$
\end_inset

), which could be falsified by an otherwise independent action.
\end_layout

\begin_layout Standard
To ensure that the dependencies between actions reflect the needs of the
 program being executed, we augment the implementation of the 
\begin_inset Formula $Trans$
\end_inset

 predicate to keep additional information about what transitions were made.
 A 
\emph on
step 
\emph default
object has the following attributes:
\end_layout

\begin_layout Itemize
action: the action performed in that step, or 
\begin_inset Formula $nil$
\end_inset

 if it is an internal program transition
\end_layout

\begin_layout Itemize
test: an additional fluent formula that must hold immediately before performing
 the step
\end_layout

\begin_layout Itemize
thread: a sequence of '1' and '2' characters indicating the concurrent thread
 in which the step is performed
\end_layout

\begin_layout Itemize
outcome: the outcome of performing the action.
\end_layout

\begin_layout Standard
We call a sequence of such steps a 
\emph on
run
\emph default
, which can be converted to a history by taking just the action and outcome
 attributes.
 The procedure implementing 
\begin_inset Formula $Trans$
\end_inset

 takes a program and a run as input, and returns a new program and new step
 of execution.
 As an example consider the code in figure 
\begin_inset LatexCommand ref
reference "fig:trans-code"

\end_inset

, implementing the test operator and the concurrency operator from equation
 
\begin_inset LatexCommand ref
reference "eqn:trans_conc_orig"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size scriptsize
\begin_inset Include \verbatiminput{listings/ConGolog.oz}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Code for 
\begin_inset Formula $Trans$
\end_inset

 predicate
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:trans-code"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that whenever the procedure descends through the left side of a concurrency
 operator it pushes a '1' onto the step's 
\begin_inset Quotes eld
\end_inset

thread
\begin_inset Quotes erd
\end_inset

 attribute, and each descent through the right side pushes a '2'.
 Two steps can be said to come from different threads as long as neither
 
\begin_inset Quotes eld
\end_inset

thread
\begin_inset Quotes erd
\end_inset

 attribute is a prefix of the other.
 
\end_layout

\begin_layout Subsection
Joint Execution ADT
\end_layout

\begin_layout Standard
We implement a joint execution as an abstract data type.
 The primary operation is inserting a new action event.
 This requires the branch on which to insert it, and a list of previous
 events that the new action 
\emph on
may
\emph default
 be executed independently of.
 It returns a list of new branches, one for each outcome of the action.
 It also ensures that the restrictions listed in section 
\begin_inset LatexCommand ref
reference "sub:Restrictions"

\end_inset

 are maintained, possibly by inserting additional action events on other
 branches to satisfy the restriction on overlapping views.
\end_layout

\begin_layout Subsection
Planning Procedure
\end_layout

\begin_layout Standard
The code for planning a joint execution from a given ConGolog program is
 shown in figure 
\begin_inset LatexCommand ref
reference "fig:planning-code"

\end_inset

.
 The main procedure is 
\begin_inset Formula $MakePlan$
\end_inset

, a recursive procedure that operates on a list of branches-in-progress
 of the form 
\begin_inset Formula $(D,R,B)$
\end_inset

.
 Here 
\begin_inset Formula $B$
\end_inset

 is a branch in the joint execution under construction, 
\begin_inset Formula $D$
\end_inset

 is the program remaining to be executed on that branch, and 
\begin_inset Formula $R$
\end_inset

 is the run of program steps performed on that branch so far.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size scriptsize
\begin_inset Include \verbatiminput{listings/Planner.oz}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Code for main planning loop
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:planning-code"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each itertion of the planning loop proceeds as follows.
 The procedure 
\begin_inset Formula $FindOpenBranch$
\end_inset

 updates each branch to account for events that were added since it was
 last processed (some may have been added automatically in response to a
 new action on anther branch), then searches the list to find a branch for
 which 
\begin_inset Formula $Final(D,R)$
\end_inset

 does not hold.
 If all branches are final, planning can terminate.
 Otherwise, the procedure 
\begin_inset Formula $FindTrans1$
\end_inset

 is called to find a new step of execution for that branch.
 The action is inserted into the joint execution, which returns a list of
 new branches, one for each outcome of the action.
 Each of these outcomes is added to the list of branches, and the loop is
 started again.
\end_layout

\begin_layout Standard
Of particular interest is the procedure 
\begin_inset Formula $FindTrans1$
\end_inset

, which uses the encapsulated search functionality of Mozart to yield possible
 next steps according to an estimate of how good they are.
 The procedure 
\begin_inset Formula $LP.yieldOrdered$
\end_inset

 yields the solutions of the given search context, sorted using the procedure
 
\begin_inset Formula $CompareSteps$
\end_inset

.
 This procedure (not shown) gives preference to steps that can be performed
 concurrently with as many existing actions as possible.
\end_layout

\begin_layout Subsection
Disitributing the Planning Workload
\end_layout

\begin_layout Standard
A primary motivation in using Mozart for our implementation is its strong
 support for distributed logic programming.
 Utilising the parallel search feature 
\begin_inset LatexCommand cite
key "schulte00oz_parallel"

\end_inset

, the planning workload can be transparently distributed between the agents.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size scriptsize
\begin_inset Include \verbatiminput{listings/psearch.oz}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Code to run planning procedure in parallel
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:parallel-search"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset LatexCommand ref
reference "fig:parallel-search"

\end_inset

 shows the necessary code, which should be executed by one of the agents.
 The planning procedure is encapsulated in a 
\emph on
functor
\emph default
, a portable code object.
 A parallel search object is then created, that uses an ssh connection to
 spawn remote computations on each of the three agents (identified by their
 DNS names).
 The object is asked to provide a single solution, which is then written
 to a file in the graphviz 'dot' format for easy display.
\end_layout

\begin_layout Standard
For the simple example shown in this paper, parallel plan search does not
 demonstrate a significant time saving since almost no backtracking is required
 to reach a solution.
 For more difficult problems, significant gains can be expected.
\end_layout

\begin_layout Section
Related Work
\begin_inset LatexCommand label
name "sec:Related-Work"

\end_inset


\end_layout

\begin_layout Standard
The idea of having a shared ConGolog program that is executed by a team
 of agents is used with considerable success in 
\begin_inset LatexCommand cite
key "Ferrein2005readylog"

\end_inset

, where the variant Readylog is used to coordinate and control a RoboCup
 soccer team.
 Their domain satisfies the assumption that all actions are public, so they
 can afford to produce totally ordered plans.
 We consider this paper a generalisation of such an approach to a wider
 variety of domains.
 (although 
\begin_inset LatexCommand cite
key "Ferrein2005readylog"

\end_inset

 includes some decision theoretic aspects that are not present in our work).
\end_layout

\begin_layout Standard
There has also been significant work using ConGolog in settings where each
 agent has its own control program 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

.
 The behavior of the overall system is specified as the concurrent combination
 of each agent's program, 
\begin_inset Formula $\delta_{1}||\delta_{2}||\dots$
\end_inset

, and ConGolog is used to verify that the system satisfies certain constraints
 (e.g.
 safety or liveness properties).
 Again, this cannot handle partial observability of actions since all reasoning
 is based on a full situation term.
 We believe the joint execution formalism could be helpful in such settings,
 by permitting syncrhonisation only when actions are observable by the agents.
\end_layout

\begin_layout Standard
Several authors have introduced operators for expressing partial orderings
 between actions into the ConGolog language itself, for example 
\begin_inset LatexCommand cite
key "son00htn_golog"

\end_inset

.
 While this is unquestionably useful for specifying behavior, the 
\emph on
output
\emph default
 from such systems is still a totally ordered sequence of actions and thus
 maintains the limitations of existing systems in actually performing the
 execution.
\end_layout

\begin_layout Standard
There is, of course, an extensive body of work on partial-order planning
 in the context of goal-based planning.
 Unsurprisingly, the joint execution structure we develop here has deep
 similarities to the structures used in conditional partial-order planners
 such as 
\begin_inset LatexCommand cite
key "peot92conditional_nonlinear"

\end_inset

.
 It is, however, intentionally specific to the situation calculus.
 We make no use of many concepts common in partial-order goal-based planning
 (causal links, threats, conflicts, etc) because we do not deal explicitly
 with goals, but with steps generated by an underlying transition semantics.
 Indeed, our approach can be considered roughly equivalent to 
\emph on
deordering
\emph default
 of a totally-ordered plan as described in 
\begin_inset LatexCommand cite
key "backstrom99reordering"

\end_inset

, except performed during plan construction rather than as a post-processing
 step.
\end_layout

\begin_layout Section
Conclusions and Future Work
\begin_inset LatexCommand label
name "sec:Conclusion"

\end_inset


\end_layout

\begin_layout Standard
In this paper, we have shown how a team of agents can cooperate to plan
 and perform an execution of a shared ConGolog program.
 The output of the planning process is a special kind of prime event structure
 that we term a joint execution.
 Joint executions are restricted enough that they can be reasoned about
 directly using the underlying situation calculus theory, but are flexible
 enough to represent different branches of execution and partial ordering
 between actions.
 By imposing appropriate restrictions on these structures, we ensure that
 they can be executed in a reactive manner by the agents based only on their
 local information.
\end_layout

\begin_layout Standard
Our immediate plans for future work involve incorporating the idea of online
 execution from IndiGolog 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 to allow the interleaving of planning and execution.
 This is a non-trivial extension in the multi-agent case when the agents
 may have different knowledge about the world.
 We are presently developing an approach based on explicit notions of knowledge
 and common knowledge, leveraging the formlism developed by 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

.
\end_layout

\begin_layout Standard
In the single-agent case, a joint execution reduces to something similar
 to a conditional action tree as introduced by 
\begin_inset LatexCommand cite
key "lakemeyer99golog_cats"

\end_inset

.
 While these kinds of branching structures are powerful, they are not universal
 - specifically, they cannot handle programs requiring unbounded iteration.
 The 
\begin_inset Quotes eld
\end_inset

agent assembly language
\begin_inset Quotes erd
\end_inset

 introduced in 
\begin_inset LatexCommand cite
key "levesque96what_is_planning"

\end_inset

 includes a looping construct and is shown to capture all possible behaviors
 of an agent.
 We are currently investigating ways to lift such capabilities into a properly
 multi-agent setting such as the one detailed in this paper.
\end_layout

\begin_layout Standard
TODO: final summary.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "abbrv"
bibfiles "/storage/uni/pgrad/library/references"

\end_inset


\end_layout

\end_body
\end_document
