
\documentclass{llncs}
\usepackage{verbatim}
\usepackage{amsmath}

\begin{document}


\title{High-Level Program Execution for Multi-Agent Teams}

\author{Ryan Kelly \and Adrian Pearce}

\institute{The University of Melbourne\\
\email{\{rfk,adrian\}@csse.unimelb.edu.au}}

\maketitle

\begin{abstract}
In this paper we present a promising approach to programming multi-agent
teams based high-level program execution, and a concrete implementation
named MIndiGolog. While the concept of high-level program execution,
as embodied by the language Golog, has recently arisen as a practical
alternative to traditional planning for single-agent systems, several
challenges are encountered when moving to a multi-agent setting: concurrency
operators must be modified to accurately reflect the concurrency present
in multi-agent teams, predictable exogenous actions (often called
"natural actions") must be effectively modelled, and a representation
of time must be incorporated to assist agent coordination and to ensure
correctness with respect to natural actions. 

The contributions of this paper include the integration of true concurrency
with interleaved concurrency in Golog; the incorporation of an explicit
notion of time for coordination; and the tight integration of natural
actions into the semantics of the language. An implementation using
the programming language Mozart is presented, that demonstrates both
its effectiveness as a centralised multi-agent planner and how existing
techniques for distributed logic programming allow planning work to
be shared among agents.
\end{abstract}

\section{Introduction}

When a team of agents must cooperate closely in order to achieve some
shared goal, they can often be conceptualised as a single agent with
distributed sensing, reasoning and acting capabilities. Behaviours
and goals are naturally ascribed to the team rather than to individual
members. This suggests that \emph{high-level program execution}, an
alternate approach to single-agent planning, can also provide an attractive
alternative to team planning.

As described in \cite{giacomo99indigolog}, high-level program execution
is emerging as a practical alternative to traditional plan
synthesis. By "high-level program" is meant a program whose
primitive operations are domain-specific actions, and which may be
incompletely specified due to nondeterministic constructs. Rather
than a planner finding a sequence of actions leading from an initial
state to a state in which some goals are achieved, the task is to
find a sequence of actions which constitute an instance of this program.

This task can range from executing a fully-specified program to synthesising
an action sequence from a completely nondeterministic program, thus
subsuming both deterministic agent programming and traditional planning.
The primary advantage of this approach is \emph{controlled nondeterminism},
allowing some aspects of the program to remain unspecified while avoiding
an exponential increase in planning difficulty for large programs.
One very successful application of this technique is the Golog \cite{levesque97golog}
family of programming languages, which have provided clear benefits
for single-agent programming that include: the ability to control
the amount of nondeterminism; sophisticated symbolic reasoning about
the world; and formal verification of program properties, in some
cases using automated tools.

TODO: references for these opinions? Systems involving multiple autonomous
agents are often classified into two subtypes - "open multi-agent
systems" in which agent behaviors are loosely coupled, and "multi-agent
teams" in which agents depend intimately on one another to accomplish
a shared task. From a programming viewpoint, open multi-agent systems
are typically constructed by specifying the behavior and goals of
individual agents and using communication primitives to design interaction
between them.

For tightly-coupled teams it is frequently more convenient to conceptualise
the team as a single agent with distributed sensing, reasoning and
acting abilities, and ascribe behaviors and goals to the team as a
whole. This suggests high-level program execution as an attractive
approach, potentially providing the benefits described above for applications
involving multi-agent teams.

Pursuant to this goal, we combine several existing extensions to the
Golog language to make it suitable for representing multi-agent teams.
Key among these is the notion of true concurrency of actions, which
we combine with the interleaved concurrency found in the language
ConGolog \cite{giacomo00congolog} to give a flexible account of concurrent
execution. An explicit notion of time is incorporated, both to enrich
the world model and to assist in coordination between agents. The
concept of natural actions \cite{reiter96sc_nat_conc} is also tightly
integrated into the language, to allow agents to predict the behavior
of each other and their environment. We name the resulting language
"MIndiGolog" for "Multi-Agent IndiGolog".

Our new language has been implemented in both CIAO Prolog \cite{iclp99ciao}
and Mozart \cite{vanroy03mozart_logic} to facilitate research into
its semantics and operation. Using the distributed computing capabilities
of Mozart, we show how the combined resources of all agents in a team
may be effectively utilised when planning the execution of a program.

The contributions of this paper are thus: to motivate high-level program
execution as a problem-solving paradigm for multi-agent teams; to
robustly combine several existing extensions to the Golog language
into a semantics suitable for describing multi-agent teams; and to
describe a concrete implementation of this language and demonstrate
its effectiveness both as a centralised multi-agent planner and a
method for distributed execution.

The paper is structured as follows. Sections \ref{sec:Situation-Calculus}
and \ref{sec:Golog} briefly review the Golog family of languages
and their underlying formalism the situation calculus. In Section
\ref{sec:Language-Features} we present the extensions that allow
MIndiGolog to properly describe multi-agent teams, while Section \ref{sec:Langauge-Semantics}
details the properties of the formal semantics and Section \ref{sec:Language-Execution}
describes our implementation. Section \ref{sec:Other-Work} places
this work in the context of existing Golog implementations, and Section
\ref{sec:Conclusions-and-Future} presents our conclusions and future
research. 

TODO introduce the running example at an appropriate point


\section{The Situation Calculus}

\label{sec:Situation-Calculus}

The representation of a dynamic world in the situation calculus consists
of first-order logic statements capturing the following: actions that
can be performed in the world; fluents describing the state of the
world; precondition axioms describing when actions are possible; and
successor state axioms describing how fluents change across situations.
For space reasons only a brief overview is given here, with individual
ideas explained as required throughout the paper. A detailed treatment
is available in \cite{pirri99contributions_sitcalc}.

\emph{Actions} are functions terms in the logic denoting the ways
in which the world can be changed, and are taken to be instantaneous.
The evolution of the world is handled using \emph{situations}, which
are histories of actions that have been performed. The initial situation
represented by the term $S_{0}$, and terms representing other situations
are constructed using the function $do(a,s)$ which represents the
situation resulting from performing action $a$ in situation $s$.
Properties of the world are described by \emph{fluents}, which are
functions or predicates taking a situation as their final argument.
The conditions under which an action can be performed are given in
terms of the \emph{possibility fluent} $Poss(a,s)$. The truth values
of fluents are specified by defining what is true in the initial situation,
and collecting the effects of various actions into \emph{successor
state axioms} characterising how they change from one situation to
the next.

Formally, a dynamic world is defined using a \emph{theory of action}
$\mathcal{D}$, a collection of (mostly) first-order axioms describing
how the world behaves. It contains axioms describing: the foundational
axioms of the calculus; action precondition axioms; successor state
axioms; unique names axioms for actions; and axioms describing the
initial situation. The theory of action thus consists of several independent
sets of axioms:

\[
\mathcal{D}=\Sigma\cup\mathcal{D}_{ap}\cup\mathcal{D}_{ss}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}
\]


Statements about the world are then evaluated relative to this theory
of action.


\section{Golog}

\label{sec:Golog}

Golog is a declarative agent programming language based on the situation
calculus, developed by Levesque et. al \cite{levesque97golog}. Testimony
to its success are its wide range of applications (see, for example,
\cite{levesque97golog,Ferrein2005readylog} ) and many extensions
to provide additional functionality (such as ConGolog \cite{giacomo00congolog},
DTGolog \cite{boutilier00dtgolog}, and IndiGolog \cite{giacomo99indigolog}).
In this paper we use the term "Golog" to refer to the family
of languages based on this technique.

To program an agent using Golog one specifies a situation calculus
theory of action, and a program consisting of actions from the world
connected using programming constructs such as if-then-else, while
loops, and nondeterministic choice. Table \ref{tbl:Golog-Operators}
lists some of the operators available from various incarnations of
the language.

\begin{table}[hbt]
\begin{center}\begin{tabular}{|c|c|}
\hline 
Operator&
Meaning\tabularnewline
\hline
\hline 
$\phi?$&
Proceed only if condition $\phi$ is true\tabularnewline
\hline 
$\delta_{1};\delta_{2}$&
Execute program $\delta_{1}$followed by $\delta_{2}$\tabularnewline
\hline 
$\delta_{1}|\delta_{2}$&
Execute either $\delta_{1}$ or $\delta_{2}$\tabularnewline
\hline 
$\pi(x)\delta(x)$&
Nondet. select arguments for $\delta$\tabularnewline
\hline 
$\delta*$&
Execute $\delta$ zero or more times\tabularnewline
\hline 
$\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$&
Exec. $\delta_{1}$ if $\phi$ holds, $\delta_{2}$ otherwise\tabularnewline
\hline 
$\mathbf{while\,}\phi\mathbf{\, do}\,\delta$&
Execute $\delta$ while $\phi$ holds\tabularnewline
\hline 
$\delta_{1}||\delta_{2}$&
Concurrently execute $\delta_{1}$and $\delta_{2}$\tabularnewline
\hline 
$\Sigma\delta$&
Find and perform legal exec. of $\delta$\tabularnewline
\hline 
$\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$&
Procedure definition\tabularnewline
\hline
\end{tabular}\end{center}


\caption{Some Golog Operators\label{tbl:Golog-Operators}}
\end{table}


In line with the idea of high-level program execution, the agent's
control program is nondeterministic. It is the task of the agent to
find a deterministic instantiation of the program, a sequence of actions
that can be performed in the world. Such a sequence is called a "legal
execution" of the Golog program.

The original Golog was conceived as on offline planner - the agent
would determine a complete execution of the program before any actions
were performed in the world. While this guarantees that a legal execution
will be found if possible, it can be impractical for large programs
and cannot account for unexpected occurrences or information obtained
from run-time sensing. An alternative is online execution, where nondeterministic
choices become arbitrary choices and are committed to immediately.
This notion was formalised in the extension IndiGolog \cite{giacomo99indigolog},
which introduced a search operator to allow offline planning to be
conducted over specific parts of the program.

The semantics of the Golog operators are typically defined recursively
using logical formulae. The most flexible semantics have proven to
be the transition semantics introduced with the extension ConGolog
\cite{giacomo00congolog} to allow concurrent execution of several
programs. Two predicates $Trans$ and $Final$ are defined for each
operator. Intuitively, $Trans(\delta,s,\delta',s')$ is true precisely
when executing a single step of program $\delta$ can cause the world
to move from situation $s$ to situation $s'$, after which $\delta'$
remains to be executed. It thus specifies single steps of computation
of the program $\delta$. $Final(\delta,s)$ is true when program
$\delta$ may legally terminate its execution in situation $s$. Finding
a legal execution then consists of finding a situation $s$ such that:

\[
\mathcal{D}\models\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]
\]


Here $Trans*$ is the reflexive transitive closure of $Trans$.


\section{The New Language}

\label{sec:Language-Features}

Our new language overcomes several challenges encountered when moving
to a multi-agent setting. It allows the programmer to represent the
following aspects of the system, each of which are described using
examples from the Cooking Agents domain:

\begin{itemize}
\item \textbf{Time}: Some tasks in the cooking domain require an explicit
notion of time. For example, a cake must be baked for 30 minutes before
being removed from the oven. Explicit time also makes coordination
between agents easier, as they may arrange to perform joint actions
at a particular time.
\item \textbf{Concurrency}: Since agents are capable of acting at the same
time, several primitive actions can occur simultaneously. They must
also be able to perform high-level tasks concurrently, such as preparing
several parts of a meal at once.
\item \textbf{Natural Actions}: These are predictable actions which occur
outside of the agent's control. If an agent sets a timer then it will
ring at the appropriate time without intervention from any agent.
Natural actions should incorporate easily into the program.
\end{itemize}
While these concepts have been independently addressed in Golog and
the situation calculus, we systematically develop and integrate them
into the new language in the following subsections. Many other aspects
of multi-agent domains can already be captured in the situation calculus
- for example, contention over shared resources can be modelled using
action precondition axioms.


\subsection{Time}

There have been several efforts to incorporate a temporal component
into the situation calculus, beginning with Pinto \cite{pinto94temporal}.
Reiter \cite{reiter96sc_nat_conc} simplified this work by including
within each action an explicit argument indicating the time at which
it was performed. While this is useful when specifying precise times
for action occurrences, it adds complexity when actions are performed
concurrently as described in Section \ref{sub:Concurrency}.

This complexity can be avoided by attaching the occurrence time not
to actions but to situations. The successor situation function $do(a,s)$
becomes $do(a,t,s)$, to indicate "action $a$ was performed at
time $t$ in situation $s$". Likewise, the possibility predicate
$Poss(a,s)$ becomes $Poss(a,t,s)$, meaning "it is possible to
perform action $a$ at time $t$ in situation $s$". The function
$start(s)$ is added which gives the starting time of a situation:

\[
start(do(a,t,s))=t
\]


Note that the start time of the initial situation is arbitrary, and
may be defined as required for specific applications.


\subsection{Concurrency}

\label{sub:Concurrency}

For multi-agent teams, concurrency refers to two distinct ideas -
the possibility of performing several actions at the same instant,
and the possibility of interleaving the execution of several high-level
programs. These are referred to as \emph{true concurrency} and \emph{interleaved
concurrency} respectively.

The work of \cite{lin92sc_conc,reiter96sc_nat_conc} provides an extension
to the situation calculus that allows several primitive actions to
occur at the same time. Action terms are replaced with sets of actions
to be performed simultaneously. All functions and predicates that
take an action are modified to accept sets of actions instead. For
example, $do$ and $Poss$ become $do(\{ a_{1},a_{2},...\},t,s)$
and $Poss(\{ a_{1},a_{2},...\},t,s)$ respectively.

The approach to time used in \cite{reiter96sc_nat_conc} requires
a predicate $coherent(c)$ to be defined, which is true when the concurrent
action $c$ contains at least one action and all the actions occur
at the same time. By attaching time to situations instead of actions,
this property is automatically satisfied. To ensure that program executions
do not include empty sets of actions one need only ensure that it
is never possible to perform such an empty set:

\[
\forall s,t.\left[Poss(\{\},t,s)\equiv False\right]
\]


The notion of concurrently executing multiple high-level programs
is treated in \cite{giacomo00congolog} with the development of ConGolog.
The operator $\delta_{1}||\delta_{2}$ is introduced, meaning "execute
both $\delta_{1}$ and $\delta_{2}$ concurrently". This is achieved
by interleaving steps of execution from the two programs.

These two notions of concurrency were combined by Baier and Pinto
\cite{pinto99tcongolog} by modifying ConGolog to incorporate sets
of concurrent actions. We follow a similar approach below, but place
additional restrictions on the semantics to ensure that programs are
well-behaved. Their work also does not include an explicit account
of time.

Recall that the semantics of a ConGolog program is a transition system
based on the predicate $Trans$. It is straightforward to modify the
transition for primitive actions to handle sets of concurrent actions
instead. The fact that several actions can occur simultaneously has
deeper implications for the concurrency operator, which in ConGolog
is implemented by accepting a transition from either of the two programs
as a transition for the pair:

\begin{align*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s')\\
 & \vee\,\exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')
\end{align*}


In the presence of true concurrency, this is insufficient. It may
also be possible to simultaneously transition both $\delta_{1}$ and
$\delta_{2}$ by executing actions concurrently:%
\footnote{Here we use implication to indicate an additional sufficient, but
not necessary, condition for $Trans$ %
}

\begin{align*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow & \exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\,\wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\,\wedge\\
 & \delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)
\end{align*}


This approach introduces several complications. First, the combination
of actions $c_{1}\cup c_{2}$ is not guaranteed to be possible. While
the actions $acquire(Thomas,Bowl)$ and $acquire(Richard,Bowl)$ may
individually be possible, performing them concurrently clearly is
not. This is known as the precondition interaction problem \cite{pinto94temporal}
and is an area of ongoing research.

For our purposes this is addressed by introducing a predicate $Conflicts(c,t,s)$
which is true when the actions in $c$ are in conflict and cannot
be performed together. The possibility axiom for concurrent actions
is then:

\[
Poss(c,t,s)\leftrightarrow\forall a\left[a\in c\rightarrow Poss(a,t,s)\right]\wedge\neg Conflicts(c,t,s)
\]


A typical use of this approach is to prevent each agent from performing
more than one action at a time (here $actor(a)$ gives the agent performing
action $a$):

\[
\exists a_{1},a_{2}\left[a_{1}\in c\wedge a_{2}\in c\wedge actor(a_{1})=actor(a_{2})\right]\rightarrow Conflicts(c,t,s)
\]

Another issue arises when two programs can legitimately be transitioned
by executing the same action. Consider the following programs which
add ingredients to a bowl:

\begin{align*}
\delta_{1}=place\_ in(Thomas,Flour,Bowl)\,;\, place\_ in(Thomas,Sugar,Bowl)\\
\delta_{2}=place\_ in(Thomas,Flour,Bowl)\,;\, place\_ in(Thomas,Egg,Bowl)
\end{align*}


Executing $\delta_{1}||\delta_{2}$ should result in the bowl containing
two units of flour, one unit of sugar and an egg. However, the above
transition rule allows a transition with $c_{1}=c_{2}=place\_ in(Thomas,Flour,Bowl)$,
which adds only one unit of flour. Alternately, consider two programs
waiting for a timer to ring (a natural action, see Section \ref{sub:Natural-Actions}):

\begin{align*}
\delta_{1}=ring\_ timer(OvenTimer)\,;\, acquire(Thomas,Bowl)\\
\delta_{2}=ring\_ timer(OvenTimer)\,;\, acquire(Richard,Board)
\end{align*}


Both programs should be allowed to proceed with a single occurrence
of the $ring\_ timer$ action. To enforce this intuitive notion of
how programs should behave, concurrent execution must not be allowed
to transition both programs through the occurrence of the same agent-initiated
action.

Taking these factors into account, we derive an improved transition
rule are follows:

\begin{align*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow & \exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\,\wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge Poss(c_{1}\cup c_{2},t,s)\,\wedge\\
 & \forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow natural(a)\right]\,\wedge\\
 & \delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)
\end{align*}


This robust combination of true and interleaved concurrency allows
the language to more accurately reflect the concurrency present in
multi-agent teams.


\subsection{Natural Actions}

\label{sub:Natural-Actions}

Natural actions are a special class of exogenous actions, those actions
which occur outside of the agent's control. Introduced to the situation
calculus by Pinto \cite{pinto94temporal} and expanded by Reiter \cite{reiter96sc_nat_conc},
they are classified according to the following requirement: natural
actions must occur at their predicted times, provided no earlier actions
prevent them from occurring. For example, a timer will ring at the
time it was set for, unless it is switched off. In the context of
high-level programing, they are a tool for predicting the behavior
of the environment.

The methodology of \cite{reiter96sc_nat_conc} is adopted, suitably
modified for our handling of time. Natural actions are indicated by
truth of the predicate $natural(a)$. As usual, the times at which
natural actions may occur are specified by the $Poss$ predicate.
For example, suppose that the fluent $timer\_ set(ID,m,s)$ represents
the fact that a particular timer is set to ring in $m$ minutes in
situation $S$. The possibility predicate for the $ring\_ timer(ID)$
action would be:

\[
Poss(ring\_ timer(ID),t,s)\leftrightarrow\exists m.\left[timer\_ set(ID,m,s)\wedge t=start(s)+m\right]
\]


An important concept when dealing with natural actions it the least
natural time point (LNTP) of a situation. This is defined as the earliest
time at which a natural action may occur in a situation:

\begin{align*}
lntp(s,t)\leftrightarrow & \exists a\left[natural(a)\wedge Poss(a,t,s)\right]\wedge\\
 & \forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]
\end{align*}


Note that the LNTP need not exist for a given situation. This can
happen both when no natural actions are possible in a situation, or
when a natural action may occur at any time in a situation (and there
is thus no earliest time). We will assume that the domain axiomatisation
is designed to avoid such pathological cases, and the absence of an
LNTP implies that no natural actions are possible.

To enforce the requirement that natural actions must occur when possible,
a predicate $legal(s)$ is introduced which is true only for situations
which respect this requirement (assuming no precondition interaction
among natural actions):

\begin{align*}
legal(S_{0}) \leftrightarrow & True\\
legal(do(c,t,s)) \leftrightarrow & (\forall a,t_{a}).natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c\vee t<t_{a}\right]\\
 & \wedge\, legal(s)\wedge Poss(c,t,s)\wedge start(s)\leq t
\end{align*}


When utilising natural actions within a Golog program, all legal program
executions should result in situations for which the $legal$ predicate
is true. This can be enforced in the semantics of the language, avoiding
the need to check it explicitly.

The possible transitions for a program containing a single action
depend on whether the accompanying situation has a least natural time
point. If not, it is legal to perform the action at any time greater
than or equal to the start of the situation. If there is an LNTP,
a legal situation can be produced in one of three ways: perform the
action before the LNTP, perform it at the LNTP in conjunction with
the natural actions, or perform the natural actions first. This is
captured by the following transition rule:

\begin{align*}
Trans(c,s,\delta',s')\equiv & \exists t_{n}. lntp(s,t_{n}) \\
  & \wedge \left\{ \left[\exists t.t\geq start(s)\wedge t<t_{n}\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\right.\\
  &  \quad\vee\exists cn.\left(\forall a.natural(a)\wedge Poss(a,t_{n},s)\leftrightarrow a\in cn\right)\\
  & \quad\wedge\left[poss(c\cup cn,t_{n},s)\wedge s'=do(c\cup cn,t_{n},s)\wedge\delta'=nil\right.\\
  & \quad\vee\left.\left.s'=do(cn,t_{n},s)\wedge\delta'=c\right]\right\}\\
  & \vee\quad\neg\exists t_{n}.lntp(s,t_{n})\wedge\exists t.\left[Poss(c,t,s)\wedge\right.\\
  & \left.t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]
\end{align*}


Using this formulation, natural actions will occur at their predicted
times without the programmer needing to mention them explicitly. If
natural actions are included in the program, they will performed only
at their predicted time. A proof of this is offered in Section \ref{sub:Legality-of-the-semantics}.

TODO: use theorem and proof environment here

This section shows the modifications that have been made to the semantics
of IndiGolog to incorporate the extensions outlined above and produce
the language MIndiGolog. Many operators are defined recursively using
combinations of $Trans$ and $Final$ and thus do not need to be modified
- for semantics of the operators not presented here, refer to \cite{giacomo00congolog,giacomo99indigolog}.

All other operators from ConGolog and IndiGolog can be incorporated
into our new language without modification.

From the formal semantics presented above, it is possible to prove
that if a program starts in a legal situation, all legal executions
of the program will produce legal situations. That is:

\[
\forall\delta,\delta'.\, Trans(\delta,s,\delta',s')\wedge legal(s)\rightarrow legal(s')\]


First notice that only two transition rules directly modify the situation
term - execution of a primitive action, and concurrent execution.
All other rules modify the situation term by further use of the $Trans$
predicate. Thus, it suffices to show that these two rules will produce
only legal situations. Recall the definition of $legal(s)$:

\[
\begin{array}{c}
legal(do(c,t,s))\leftrightarrow\\
legal(s)\wedge Poss(c,t,s)\wedge start(s)\leq t\wedge\\
(\forall a,t_{a}).natural(a)\wedge Poss(a,t_{a},s)\rightarrow\\
\left[a\in c\vee t<t_{a}\right]\end{array}\]


Considering the $Trans$ rule for primitive actions, each of the four
disjuncts may produce a new situation term. Here we consider only
the case of performing the actions before the LNTP:

\[
\begin{array}{c}
\exists t_{n}.\left[lntp(s,t_{n})\wedge\exists t.\left[t\geq start(s)\wedge t<t_{n}\right.\right.\\
\left.\left.\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\right]\end{array}\]


From this it is immediately clear that:

\[
start(s)\leq t\,\,\,\,\, Poss(c,t,s)\]


Using the definition of $lntp(s,t_{n})$:

\[
\begin{array}{c}
\exists a\left[natural(a)\wedge Poss(a,t_{n},s)\right]\wedge\\
\forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t_{n}\leq t_{a}\right]\end{array}\]


Since $t<t_{n}$, this gives:

\[
\begin{array}{c}
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]\\
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow a\in c\vee t\leq t_{a}\right]\end{array}\]


Given $legal(s)$, these are sufficient to establish $legal(do(c,t,s))$
and so $legal(s')$ as required. Similar arguments can be made for
the remaining parts of this transition rule.

Consider then the case of $Trans(\delta_{1}||\delta_{2},s,\delta',s')$.
The only part of interest is the disjunct which directly produces
a modified situation $s'=do(c_{1}\cup c_{2},t,s)$. Assume that $s$
is a legal situation, that $\delta_{1}$ and $\delta_{2}$ contain
no further concurrency operators and that all other transition rules
produce legal situations. Then $Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))$
and $Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))$ will produce legal
situations $do(c_{1},t,s)$ and $do(c_{2},t,s)$.

From $legal(do(c_{1},t,s))$ it can be inferred that:

\[
\begin{array}{c}
legal(s)\,\,\,\,\,\,\,\,\,\, start(s)\leq t\\
(\forall a,t_{a}).\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c_{1}\vee t<t_{a}\right]\right]\end{array}\]


This implies that:

\[
(\forall a,t_{a}).\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c_{1}\cup c_{2}\vee t<t_{a}\right]\right]\]


The definition of $Trans$ further requires that:

\[
Poss(c_{1}\cup c_{2},t,s)\]


Thus all four conjuncts necessary to prove $legal(do(c_{1}\cup c_{2},t,s))$
are true, and this rule generates only legal situations. Since cases
where $\delta_{1}$ and $\delta_{2}$ contain further concurrency
operators must eventually decompose into cases where they do not,
it is a simple inductive argument to show that this transition rule
produces legal situations for all programs.

Natural actions are thus guaranteed to be inserted into program executions
at their appropriate times, without requiring explicit mention by
the programmer.

While time and natural actions in Golog have previously been utilised
as a planning tool \cite{pirri00planning_nat_acts}, the programmer
was required to explicitly check for the possible occurrence of natural
actions and ensure that executions of the program resulted in legal
situations. Our integration significantly lowers the burden on the
programmer by guaranteeing that all program executions produce legal
situations.


\subsection{Example Programs}

Having developed the necessary extensions, we now give some examples
of programs which could be used in the cooking agents domain. One
powerful feature of our language is the ability to nondeterministically
select an agent for a particular task. Consider the following procedure
for making a simple salad in a specified container:

\[
\begin{array}{c}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)(acquire(agt,dest)\,;\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, begin\_ task(agt,mix(dest,1))\,;\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, end\_ task(agt,mix(dest,1))\,;\\
\,\,\,\, release(agt,dest))\,\,\mathbf{end}\end{array}\]


The procedure $ChopTypeInto$ (not shown) picks an object of the given
type and an available chopping board, chops the object using the board,
then transfers it into the destination container. $MakeSalad$ asks
the agents to do this for a lettuce, a carrot and a tomato, then mix
the ingredients together. Crucially, the agent assigned to handling
each ingredient is not specified, nor is the order in which they should
be added. The agents are free to determine an appropriate strategy.

%
\begin{figure}[hbt]
\verbatiminput{listings/output_makeSalad.txt}

\verbatiminput{listings/constraints_makeSalad.txt}


\caption{\label{cap:example_trace}Trace of an execution of the $MakeSalad$
program with three agents (top). Variables $\_ U$, $\_ T$, etc give
the occurrence times of each action, constrained to ensure all situations
are legal (bottom).}
\end{figure}


A trace of a legal execution of the $MakeSalad$ program is shown
in Figure \ref{cap:example_trace}. Notice the occurrence of several
actions within each \textbf{do} statement, demonstrating the integration
of true concurrency into the language. By contrast, an implementation
in ConGolog would have only a single action at each step - assuming
each step represents a finite time interval, this would unnecessarily
leave some agents idle. Note also the explicit occurrence time for
each step, allowing the agents to properly synchronise their actions.
This time is not fixed but rather constrained based on the times at
which previous actions were performed. These constraints emerge from
the underlying situation calculus description of the world and are
maintained automatically by the language. For coordination purposes
the agents would agree, for example, to perform each action at the
earliest possible time.

In this example there are three agents but only two chopping boards,
meaning one agent has to remain idle while waiting for the necessary
resources. If other tasks were given concurrently with $MakeSalad$,
this agent could make progress on those while waiting. For example:

\[
MakeSalad()\,||\, MakeMainMeal()\,||\, MakeCake()\]





\section{Execution}

\label{sec:Language-Execution}

As the existing languages based on Golog have demonstrated, an interpreter
can be conveniently constructed using a logic programming language
such a Prolog. We have followed the style of \cite{giacomo00congolog,giacomo99indigolog},
to build interpreters for our language%
\footnote{Available from the author's website at http://www.cs.mu.oz.au/\textasciitilde{}rfk/golog/%
} in CIAO Prolog \cite{iclp99ciao} and Mozart \cite{vanroy03mozart_logic}.
The Mozart implementation is highlighted in this paper as it provides
strong support for distributed execution.

Programs are encoded in Mozart as record terms, with the name of the
record representing an operator and its features the arguments. Actions
are also encoded as records. In line with convention in both Prolog
and Mozart, uppercase terms now represent variables. For example,
the program:

\[
\pi(agt)\left[acquire(agt,Bowl);acquire(agt,Knife)\right]\]


Is represented as follows:

\verbatiminput{listings/goloz_ex_prog.oz}

The predicates $Trans$ and $Final$ have a straightforward encoding
as Mozart procedures:

\verbatiminput{listings/goloz_trans.oz}

\verbatiminput{listings/goloz_final.oz}

The block \textbf{proc...end} defines a new procedure, the \textbf{case}
statement performs pattern matching, and the \textbf{choice} statement
indicates that the procedure can choose one of several evaluation
paths.

By defining a procedure $Do(\delta,s,s')\leftrightarrow Trans*(\delta,s,\delta',s')\wedge Final(\delta',s')$
it is possible to use the inbuilt depth-first search procedure to
find a legal execution for a given program:

\verbatiminput{listings/goloz_do.oz}

The actions thus determined can then be communicated to the team members
for execution. This can be viewed as a centralised planner for the
multi-agent team.

Of course, a centralised planner fails to utilise all the resources
available to the team. While a legal execution is being found, other
agents are idle. An important aspect of the Mozart system is that
it provides a parallel search procedure that can take advantage of
networked machines to speed up the search. Utilising this, our implementation
can be used to form a distributed multi-agent planner. In the following,
"agent1" and "agent2" are names mapping to the IP-addresses
of agents in the team, and "Goloz" is a Mozart functor that
encapsulates the EvalOffline procedure defined above:

\verbatiminput{listings/goloz_do_parallel.oz}

The result is the same as the centralised case, a sequence of actions
that can be communicated to the team members for execution. Agents
can thus plan the execution of their shared program both individually
and collectively. 


\section{Related Work}

\label{sec:Other-Work}

The utility of the high-level program execution paradigm is highlighted
by the many extensions which have been developed for the base Golog
language. Prominent among these are the following: \emph{ConGolog}
\cite{giacomo00congolog} introduced the ability for an agent to interleave
the execution of multiple high-level programs, along with the notion
of an interrupt which gains control when certain conditions become
true. \emph{IndiGolog} \cite{giacomo99indigolog} formalised online
execution of Golog programs and introduced the search operator to
allow controlled offline planning. \emph{DTGolog} \cite{boutilier00dtgolog}
combined the situation calculus with Markov Decision Processes to
allow agents to determine the best execution of a program in the face
of probabilistic action outcomes.

There has also been work on extending the situation calculus to allow
richer world models, notably that of Pinto \cite{pinto94temporal}
and Reiter \cite{reiter96sc_nat_conc}. Work on concurrent execution
of primitive actions and explicit time in particular make the situation
calculus more suitable for representing worlds containing multiple
agents. However, there appears to be little work incorporating these
extensions with extensions to the Golog language.

While work with Golog has predominantly focused on single-agent systems,
there have been several notable applications of the technique to multi-agent
systems. The Cognitive Agent Specification Language \cite{shapiro02}
uses ConGolog to describe the behavior of agents in a multi-agent
setting, and an automated theorem prover is in development that can
verify properties of the programs. It differs from our work in that
it is designed for open multi-agent systems, with each agent having
its own Golog program defining its behavior. By contrast, we seek
to develop a single Golog program that is cooperatively executed by
all agents. Another difference is its focus on modelling and simulation
of agent systems, rather than producing executable programs.

Closer to the spirit of this paper is the work of Ferrein et. al.
\cite{Ferrein2005readylog} on ReadyLog, a Golog derivative designed
for highly dynamic domains. It has been successfully applied to control
multi-agent teams in the RoboCup soccer tournament. ReadyLog integrates
the facilities of concurrency, online execution and decision theory
and can be seen as a unification of ConGolog, IndiGolog and DTGolog.
The programs used to control the soccer team intersperse actions by
several agents and can thus be viewed as team programs. However, the
program is evaluated separately by each agent.

In summary, while there have been extensions to Golog that allow more
expressive programs to be written and extensions to the situation
calculus which provide richer models of the world, the integration
of these approaches is a topic of ongoing work. It is at this crossroads
that our new language, MIndiGolog, is positioned. It combines the
collective capabilities of these extensions to represent and program
the behavior of multi-agent teams.


\section{Conclusions}

\label{sec:Conclusions-and-Future}

In this paper, we have integrated a combination of several important
extensions to the situation calculus and Golog to provide a new language
suitable for expressing high-level programs for multi-agent teams.
The main contribution of this work is the effective integration of
elements important to multi-agent programs into the semantics: the
combination of true and interleaved concurrency; an explicit notion
of time for coordination; and the tight integration of natural actions.
An implementation of this language using Mozart has demonstrated its
effectiveness as a centralised multi-agent planner and a method for
distributed execution. 

We are presently exploring the potential of this approach for a range
of distributed programming applications, and the integration of additional
techniques from the field of high-level program execution. Key among
these is the significant work on representing knowledge and belief
in Golog. As many applications involve partially observable worlds,
different agents must be capable of having different beliefs about
the world. Additionally, while we have distributed the workload of
planning an execution, overall control is still centralised. We are
actively researching techniques to allow an execution to be found
in a decentralised manner.

As our implementations have demonstrated, the combination of state-of-the-art
techniques from Golog is highly capable of representing the behavior
of multi-agent teams. Combined with facilities for distributed logic
programming, MIndiGolog promises to provide the advantages of high-level
program execution for multi-agent teams.

\bibliographystyle{abbrv}
\bibliography{/storage/uni/pgrad/library/references}


\end{document}
