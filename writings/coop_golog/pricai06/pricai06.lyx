# The reLyX bundled with LyX 1.3 created this file.
# For more info see http://www.lyx.org/
\lyxformat 2.15
\textclass llncs
\use_natbib 0
\use_numerical_citations 0
\begin_preamble
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amssymb}

\end_preamble

\layout Standard


\latex latex 

\backslash vfill{}
\latex default 

\layout Title

High-Level Program Execution for Multi-Agent Teams
\layout Standard


\latex latex 

\backslash vfill{}
\latex default 

\layout Author

Ryan Kelly and Adrian Pearce
\layout Institute

The University of Melbourne
\layout Abstract

In this paper we present a promising approach to programming multi-agent
 teams based high-level program execution, and a concrete implementation
 named MIndiGolog.
 While the concept of high-level program execution, as embodied by the language
 Golog, has recently arisen as a practical alternative to traditional planning
 for single-agent systems, several challenges are encountered when moving
 to a multi-agent setting: concurrency operators must be modified to accurately
 reflect the concurrency present in multi-agent teams, predictable exogenous
 actions (often called 
\begin_inset Quotes eld
\end_inset 

natural actions
\begin_inset Quotes erd
\end_inset 

) must be effectively modelled, and a representation of time must be incorporate
d
 to assist agent coordination and to ensure correctness with respect to
 natural actions.
\layout Abstract

The contributions of this paper include the integration of true concurrency
 with interleaved concurrency in Golog; the incorporation of an explicit
 notion of time for coordination; and the tight integration of natural actions
 into the semantics of the language.
 An implementation using the programming language Mozart is presented, that
 demonstrates both its effectiveness as a centralised multi-agent planner
 and how existing techniques for distributed logic programming allow planning
 work to be shared among agents. 
\layout Standard


\latex latex 

\backslash newpage
\newline 

\latex default 

\layout Section

Introduction
\layout Standard

When a team of agents must cooperate closely in order to achieve some shared
 goal, they can often be conceptualised as a single agent with distributed
 sensing, reasoning and acting capabilities.
 Behaviours and goals are naturally ascribed to the team rather than to
 individual members.
 This suggests that 
\emph on 
high-level program execution
\emph default 
, 
\emph on 

\emph default 
an alternate approach to single-agent planning, can also provide an attractive
 alternative to team planning.
\layout Standard

As described in 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset 

, high-level program execution 
\emph on 

\emph default 
is emerging as a practical alternative to traditional plan synthesis.
 By 
\begin_inset Quotes eld
\end_inset 

high-level program
\begin_inset Quotes erd
\end_inset 

 is meant a program whose primitive operations are domain-specific actions,
 and which may be incompletely specified due to nondeterministic constructs.
 Rather than a planner finding a sequence of actions leading from an initial
 state to a state in which some goals are achieved, the task is to find
 a sequence of actions which constitute an instance of this program.
\layout Standard

This task can range from executing a fully-specified program to synthesising
 an action sequence from a completely nondeterministic program, thus subsuming
 both deterministic agent programming and traditional planning.
 The primary advantage of this approach is 
\emph on 
controlled nondeterminism
\emph default 
, allowing some aspects of the program to remain unspecified while avoiding
 an exponential increase in planning difficulty for large programs.
 One very successful application of this technique is the Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

 family of programming languages, which have provided clear benefits for
 single-agent programming that include: the ability to control the amount
 of nondeterminism; sophisticated symbolic reasoning about the world; and
 formal verification of program properties, in some cases using automated
 tools.
\layout Standard

TODO: references for these opinions? Systems involving multiple autonomous
 agents are often classified into two subtypes - 
\begin_inset Quotes eld
\end_inset 

open multi-agent systems
\begin_inset Quotes erd
\end_inset 

 in which agent behaviors are loosely coupled, and 
\begin_inset Quotes eld
\end_inset 

multi-agent teams
\begin_inset Quotes erd
\end_inset 

 in which agents depend intimately on one another to accomplish a shared
 task.
 From a programming viewpoint, open multi-agent systems are typically constructe
d
 by specifying the behavior and goals of individual agents and using communicati
on
 primitives to design interaction between them.
\layout Standard

For tightly-coupled teams it is frequently more convenient to conceptualise
 the team as a single agent with distributed sensing, reasoning and acting
 abilities, and ascribe behaviors and goals to the team as a whole.
 This suggests high-level program execution as an attractive approach, potential
ly
 providing the benefits described above for applications involving multi-agent
 teams.
\layout Standard

Pursuant to this goal, we combine several existing extensions to the Golog
 language to make it suitable for representing multi-agent teams.
 Key among these is the notion of true concurrency of actions, which we
 combine with the interleaved concurrency found in the language ConGolog
 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 to give a flexible account of concurrent execution.
 An explicit notion of time is incorporated, both to enrich the world model
 and to assist in coordination between agents.
 The concept of natural actions 
\begin_inset LatexCommand \cite{reiter96sc
\latex latex 
_
\latex default 
nat
\latex latex 
_
\latex default 
conc}

\end_inset 

 is also tightly integrated into the language, to allow agents to predict
 the behavior of each other and their environment.
 We name the resulting language 
\begin_inset Quotes eld
\end_inset 

MIndiGolog
\begin_inset Quotes erd
\end_inset 

 for 
\begin_inset Quotes eld
\end_inset 

Multi-Agent IndiGolog
\begin_inset Quotes erd
\end_inset 

.
\layout Standard

Our new language has been implemented in both CIAO Prolog 
\begin_inset LatexCommand \cite{iclp99ciao}

\end_inset 

 and Mozart 
\begin_inset LatexCommand \cite{vanroy03mozart
\latex latex 
_
\latex default 
logic}

\end_inset 

 to facilitate research into its semantics and operation.
 Using the distributed computing capabilities of Mozart, we show how the
 combined resources of all agents in a team may be effectively utilised
 when planning the execution of a program.
\layout Standard

The contributions of this paper are thus: to motivate high-level program
 execution as a problem-solving paradigm for multi-agent teams; to robustly
 combine several existing extensions to the Golog language into a semantics
 suitable for describing multi-agent teams; and to describe a concrete implement
ation
 of this language and demonstrate its effectiveness both as a centralised
 multi-agent planner and a method for distributed execution.
\layout Standard

The paper is structured as follows.
 Sections 
\begin_inset LatexCommand \ref{sec:Situation-Calculus}

\end_inset 

 and 
\begin_inset LatexCommand \ref{sec:Golog}

\end_inset 

 briefly review the Golog family of languages and their underlying formalism
 the situation calculus.
 In Section 
\begin_inset LatexCommand \ref{sec:Language-Features}

\end_inset 

 we present the extensions that allow MIndiGolog to properly describe multi-agen
t
 teams, while Section 
\begin_inset LatexCommand \ref{sec:Langauge-Semantics}

\end_inset 

 details the properties of the formal semantics and Section 
\begin_inset LatexCommand \ref{sec:Language-Execution}

\end_inset 

 describes our implementation.
 Section 
\begin_inset LatexCommand \ref{sec:Other-Work}

\end_inset 

 places this work in the context of existing Golog implementations, and
 Section 
\begin_inset LatexCommand \ref{sec:Conclusions-and-Future}

\end_inset 

 presents our conclusions and future research.
\layout Standard

TODO introduce the running example at an appropriate point
\layout Section

The Situation Calculus
\layout Standard


\begin_inset LatexCommand \label{sec:Situation-Calculus}

\end_inset 


\layout Standard

The representation of a dynamic world in the situation calculus consists
 of first-order logic statements capturing the following: actions that can
 be performed in the world; fluents describing the state of the world; precondit
ion
 axioms describing when actions are possible; and successor state axioms
 describing how fluents change across situations.
 For space reasons only a brief overview is given here, with individual
 ideas explained as required throughout the paper.
 A detailed treatment is available in 
\begin_inset LatexCommand \cite{pirri99contributions
\latex latex 
_
\latex default 
sitcalc}

\end_inset 

.
\layout Standard


\emph on 
Actions
\emph default 
 are functions terms in the logic denoting the ways in which the world can
 be changed, and are taken to be instantaneous.
 The evolution of the world is handled using 
\emph on 
situations
\emph default 
, which are histories of actions that have been performed.
 The initial situation represented by the term 
\begin_inset Formula \( S_{0}\)
\end_inset 

, and terms representing other situations are constructed using the function
 
\begin_inset Formula \( do(a,s)\)
\end_inset 

 which represents the situation resulting from performing action 
\begin_inset Formula \( a\)
\end_inset 

 in situation 
\begin_inset Formula \( s\)
\end_inset 

.
 Properties of the world are described by 
\emph on 
fluents
\emph default 
, which are functions or predicates taking a situation as their final argument.
 The conditions under which an action can be performed are given in terms
 of the 
\emph on 
possibility fluent
\emph default 
 
\begin_inset Formula \( Poss(a,s)\)
\end_inset 

.
 The truth values of fluents are specified by defining what is true in the
 initial situation, and collecting the effects of various actions into 
\emph on 
successor state axioms
\emph default 
 characterising how they change from one situation to the next.
\layout Standard

Formally, a dynamic world is defined using a 
\emph on 
theory of action
\emph default 
 
\begin_inset Formula \( \mathcal{D}\)
\end_inset 

, a collection of (mostly) first-order axioms describing how the world behaves.
 It contains axioms describing: the foundational axioms of the calculus;
 action precondition axioms; successor state axioms; unique names axioms
 for actions; and axioms describing the initial situation.
 The theory of action thus consists of several independent sets of axioms:
\layout Standard


\begin_inset Formula \[ 
\mathcal{D}=\Sigma\cup\mathcal{D}_{ap}\cup\mathcal{D}_{ss}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\]
\end_inset 


\layout Standard

Statements about the world are then evaluated relative to this theory of
 action.
\layout Section

Golog
\layout Standard


\begin_inset LatexCommand \label{sec:Golog}

\end_inset 


\layout Standard

Golog is a declarative agent programming language based on the situation
 calculus, developed by Levesque et.
 al 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

.
 Testimony to its success are its wide range of applications (see, for example,
 
\begin_inset LatexCommand \cite{levesque97golog,Ferrein2005readylog}

\end_inset 

 ) and many extensions to provide additional functionality (such as ConGolog
 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

, DTGolog 
\begin_inset LatexCommand \cite{boutilier00dtgolog}

\end_inset 

, and IndiGolog 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset 

).
 In this paper we use the term 
\begin_inset Quotes eld
\end_inset 

Golog
\begin_inset Quotes erd
\end_inset 

 to refer to the family of languages based on this technique.
\layout Standard

To program an agent using Golog one specifies a situation calculus theory
 of action, and a program consisting of actions from the world connected
 using programming constructs such as if-then-else, while loops, and nondetermin
istic
 choice.
 Table 
\begin_inset LatexCommand \ref{tbl:Golog-Operators}

\end_inset 

 lists some of the operators available from various incarnations of the
 language.
\layout Standard


\begin_float tab 

\layout Standard


\align center 


\LyXTable
multicol5
11 2 0 0 0 0 0 0
1 2 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
0 1 0 0
8 1 1 "" ""
8 0 1 "" ""
0 8 1 2 0 0 0 "" ""
0 8 1 2 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""
0 8 0 1 0 0 0 "" ""

Operator
\newline 
 Meaning
\newline 

\begin_inset Formula \( \phi?\)
\end_inset 


\newline 
 Proceed only if condition 
\begin_inset Formula \( \phi\)
\end_inset 

 is true
\newline 

\begin_inset Formula \( \delta_{1};\delta_{2}\)
\end_inset 


\newline 
 Execute program 
\begin_inset Formula \( \delta_{1}\)
\end_inset 

followed by 
\begin_inset Formula \( \delta_{2}\)
\end_inset 


\newline 

\begin_inset Formula \( \delta_{1}|\delta_{2}\)
\end_inset 


\newline 
 Execute either 
\begin_inset Formula \( \delta_{1}\)
\end_inset 

 or 
\begin_inset Formula \( \delta_{2}\)
\end_inset 


\newline 

\begin_inset Formula \( \pi(x)\delta(x)\)
\end_inset 


\newline 
 Nondet.
 select arguments for 
\begin_inset Formula \( \delta\)
\end_inset 


\newline 

\begin_inset Formula \( \delta*\)
\end_inset 


\newline 
 Execute 
\begin_inset Formula \( \delta\)
\end_inset 

 zero or more times
\newline 

\begin_inset Formula \( \mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}\)
\end_inset 


\newline 
 Exec. 
\begin_inset Formula \( \delta_{1}\)
\end_inset 

 if 
\begin_inset Formula \( \phi\)
\end_inset 

 holds, 
\begin_inset Formula \( \delta_{2}\)
\end_inset 

 otherwise
\newline 

\begin_inset Formula \( \mathbf{while\,}\phi\mathbf{\, do}\,\delta\)
\end_inset 


\newline 
 Execute 
\begin_inset Formula \( \delta\)
\end_inset 

 while 
\begin_inset Formula \( \phi\)
\end_inset 

 holds
\newline 

\begin_inset Formula \( \delta_{1}||\delta_{2}\)
\end_inset 


\newline 
 Concurrently execute 
\begin_inset Formula \( \delta_{1}\)
\end_inset 

and 
\begin_inset Formula \( \delta_{2}\)
\end_inset 


\newline 

\begin_inset Formula \( \Sigma\delta\)
\end_inset 


\newline 
 Find and perform legal exec.
 of 
\begin_inset Formula \( \delta\)
\end_inset 


\newline 

\begin_inset Formula \( \mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}\)
\end_inset 


\newline 
 Procedure definition
 


\layout Caption

Some Golog Operators
\begin_inset LatexCommand \label{tbl:Golog-Operators}

\end_inset 


\end_float 


\layout Standard

In line with the idea of high-level program execution, the agent's control
 program is nondeterministic.
 It is the task of the agent to find a deterministic instantiation of the
 program, a sequence of actions that can be performed in the world.
 Such a sequence is called a 
\begin_inset Quotes eld
\end_inset 

legal execution
\begin_inset Quotes erd
\end_inset 

 of the Golog program.
\layout Standard

The original Golog was conceived as on offline planner - the agent would
 determine a complete execution of the program before any actions were performed
 in the world.
 While this guarantees that a legal execution will be found if possible,
 it can be impractical for large programs and cannot account for unexpected
 occurrences or information obtained from run-time sensing.
 An alternative is online execution, where nondeterministic choices become
 arbitrary choices and are committed to immediately.
 This notion was formalised in the extension IndiGolog 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset 

, which introduced a search operator to allow offline planning to be conducted
 over specific parts of the program.
\layout Standard

The semantics of the Golog operators are typically defined recursively using
 logical formulae.
 The most flexible semantics have proven to be the transition semantics
 introduced with the extension ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 to allow concurrent execution of several programs.
 Two predicates 
\begin_inset Formula \( Trans\)
\end_inset 

 and 
\begin_inset Formula \( Final\)
\end_inset 

 are defined for each operator.
 Intuitively, 
\begin_inset Formula \( Trans(\delta,s,\delta',s')\)
\end_inset 

 is true precisely when executing a single step of program 
\begin_inset Formula \( \delta\)
\end_inset 

 can cause the world to move from situation 
\begin_inset Formula \( s\)
\end_inset 

 to situation 
\begin_inset Formula \( s'\)
\end_inset 

, after which 
\begin_inset Formula \( \delta'\)
\end_inset 

 remains to be executed.
 It thus specifies single steps of computation of the program 
\begin_inset Formula \( \delta\)
\end_inset 

. 
\begin_inset Formula \( Final(\delta,s)\)
\end_inset 

 is true when program 
\begin_inset Formula \( \delta\)
\end_inset 

 may legally terminate its execution in situation 
\begin_inset Formula \( s\)
\end_inset 

.
 Finding a legal execution then consists of finding a situation 
\begin_inset Formula \( s\)
\end_inset 

 such that:
\layout Standard


\begin_inset Formula \[ 
\mathcal{D}\models\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]\]
\end_inset 


\layout Standard

Here 
\begin_inset Formula \( Trans*\)
\end_inset 

 is the reflexive transitive closure of 
\begin_inset Formula \( Trans\)
\end_inset 

.
\layout Section

The New Language
\layout Standard


\begin_inset LatexCommand \label{sec:Language-Features}

\end_inset 


\layout Standard

Our new language overcomes several challenges encountered when moving to
 a multi-agent setting.
 It allows the programmer to represent the following aspects of the system,
 each of which are described using examples from the Cooking Agents domain:
\layout Itemize


\series bold 
Time
\series default 
: Some tasks in the cooking domain require an explicit notion of time.
 For example, a cake must be baked for 30 minutes before being removed from
 the oven.
 Explicit time also makes coordination between agents easier, as they may
 arrange to perform joint actions at a particular time. 
\layout Itemize


\series bold 
Concurrency
\series default 
: Since agents are capable of acting at the same time, several primitive
 actions can occur simultaneously.
 They must also be able to perform high-level tasks concurrently, such as
 preparing several parts of a meal at once. 
\layout Itemize


\series bold 
Natural Actions
\series default 
: These are predictable actions which occur outside of the agent's control.
 If an agent sets a timer then it will ring at the appropriate time without
 intervention from any agent.
 Natural actions should incorporate easily into the program. 
\layout Standard

While these concepts have been independently addressed in Golog and the
 situation calculus, we systematically develop and integrate them into the
 new language in the following subsections.
 Many other aspects of multi-agent domains can already be captured in the
 situation calculus - for example, contention over shared resources can
 be modelled using action precondition axioms.
\layout Subsection

Time
\layout Standard

There have been several efforts to incorporate a temporal component into
 the situation calculus, beginning with Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

.
 Reiter 
\begin_inset LatexCommand \cite{reiter96sc
\latex latex 
_
\latex default 
nat
\latex latex 
_
\latex default 
conc}

\end_inset 

 simplified this work by including within each action an explicit argument
 indicating the time at which it was performed.
 While this is useful when specifying precise times for action occurrences,
 it adds complexity when actions are performed concurrently as described
 in Section 
\begin_inset LatexCommand \ref{sub:Concurrency}

\end_inset 

.
\layout Standard

This complexity can be avoided by attaching the occurrence time not to actions
 but to situations.
 The successor situation function 
\begin_inset Formula \( do(a,s)\)
\end_inset 

 becomes 
\begin_inset Formula \( do(a,t,s)\)
\end_inset 

, to indicate 
\begin_inset Quotes eld
\end_inset 

action 
\begin_inset Formula \( a\)
\end_inset 

 was performed at time 
\begin_inset Formula \( t\)
\end_inset 

 in situation 
\begin_inset Formula \( s\)
\end_inset 


\begin_inset Quotes erd
\end_inset 

.
 Likewise, the possibility predicate 
\begin_inset Formula \( Poss(a,s)\)
\end_inset 

 becomes 
\begin_inset Formula \( Poss(a,t,s)\)
\end_inset 

, meaning 
\begin_inset Quotes eld
\end_inset 

it is possible to perform action 
\begin_inset Formula \( a\)
\end_inset 

 at time 
\begin_inset Formula \( t\)
\end_inset 

 in situation 
\begin_inset Formula \( s\)
\end_inset 


\begin_inset Quotes erd
\end_inset 

.
 The function 
\begin_inset Formula \( start(s)\)
\end_inset 

 is added which gives the starting time of a situation:
\layout Standard


\begin_inset Formula \[ 
start(do(a,t,s))=t\]
\end_inset 


\layout Standard

Note that the start time of the initial situation is arbitrary, and may
 be defined as required for specific applications.
\layout Subsection

Concurrency
\layout Standard


\begin_inset LatexCommand \label{sub:Concurrency}

\end_inset 


\layout Standard

For multi-agent teams, concurrency refers to two distinct ideas - the possibilit
y
 of performing several actions at the same instant, and the possibility
 of interleaving the execution of several high-level programs.
 These are referred to as 
\emph on 
true concurrency
\emph default 
 and 
\emph on 
interleaved concurrency
\emph default 
 respectively.
\layout Standard

The work of 
\begin_inset LatexCommand \cite{lin92sc
\latex latex 
_
\latex default 
conc,reiter96sc
\latex latex 
_
\latex default 
nat
\latex latex 
_
\latex default 
conc}

\end_inset 

 provides an extension to the situation calculus that allows several primitive
 actions to occur at the same time.
 Action terms are replaced with sets of actions to be performed simultaneously.
 All functions and predicates that take an action are modified to accept
 sets of actions instead.
 For example, 
\begin_inset Formula \( do\)
\end_inset 

 and 
\begin_inset Formula \( Poss\)
\end_inset 

 become 
\begin_inset Formula \( do(\{ a_{1},a_{2},...\},t,s)\)
\end_inset 

 and 
\begin_inset Formula \( Poss(\{ a_{1},a_{2},...\},t,s)\)
\end_inset 

 respectively.
\layout Standard

The approach to time used in 
\begin_inset LatexCommand \cite{reiter96sc
\latex latex 
_
\latex default 
nat
\latex latex 
_
\latex default 
conc}

\end_inset 

 requires a predicate 
\begin_inset Formula \( coherent(c)\)
\end_inset 

 to be defined, which is true when the concurrent action 
\begin_inset Formula \( c\)
\end_inset 

 contains at least one action and all the actions occur at the same time.
 By attaching time to situations instead of actions, this property is automatica
lly
 satisfied.
 To ensure that program executions do not include empty sets of actions
 one need only ensure that it is never possible to perform such an empty
 set:
\layout Standard


\begin_inset Formula \[ 
\forall s,t.\left[Poss(\{\},t,s)\equiv False\right]\]
\end_inset 


\layout Standard

The notion of concurrently executing multiple high-level programs is treated
 in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 with the development of ConGolog.
 The operator 
\begin_inset Formula \( \delta_{1}||\delta_{2}\)
\end_inset 

 is introduced, meaning 
\begin_inset Quotes eld
\end_inset 

execute both 
\begin_inset Formula \( \delta_{1}\)
\end_inset 

 and 
\begin_inset Formula \( \delta_{2}\)
\end_inset 

 concurrently
\begin_inset Quotes erd
\end_inset 

.
 This is achieved by interleaving steps of execution from the two programs.
\layout Standard

These two notions of concurrency were combined by Baier and Pinto 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset 

 by modifying ConGolog to incorporate sets of concurrent actions.
 We follow a similar approach below, but place additional restrictions on
 the semantics to ensure that programs are well-behaved.
 Their work also does not include an explicit account of time.
\layout Standard

Recall that the semantics of a ConGolog program is a transition system based
 on the predicate 
\begin_inset Formula \( Trans\)
\end_inset 

.
 It is straightforward to modify the transition for primitive actions to
 handle sets of concurrent actions instead.
 The fact that several actions can occur simultaneously has deeper implications
 for the concurrency operator, which in ConGolog is implemented by accepting
 a transition from either of the two programs as a transition for the pair:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{cc}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s')\\
 & \vee\,\exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\end{array}\]
\end_inset 


\layout Standard

In the presence of true concurrency, this is insufficient.
 It may also be possible to simultaneously transition both 
\begin_inset Formula \( \delta_{1}\)
\end_inset 

 and 
\begin_inset Formula \( \delta_{2}\)
\end_inset 

 by executing actions concurrently:
\begin_float footnote 

\layout Standard

Here we use implication to indicate an additional sufficient, but not necessary,
 condition for 
\begin_inset Formula \( Trans\)
\end_inset 

 
\end_float 


\layout Standard


\begin_inset Formula \[ 
\begin{array}{cc}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow & \exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\,\wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\,\wedge\\
 & \delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\end{array}\]
\end_inset 


\layout Standard

This approach introduces several complications.
 First, the combination of actions 
\begin_inset Formula \( c_{1}\cup c_{2}\)
\end_inset 

 is not guaranteed to be possible.
 While the actions 
\begin_inset Formula \( acquire(Thomas,Bowl)\)
\end_inset 

 and 
\begin_inset Formula \( acquire(Richard,Bowl)\)
\end_inset 

 may individually be possible, performing them concurrently clearly is not.
 This is known as the precondition interaction problem 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 and is an area of ongoing research.
\layout Standard

For our purposes this is addressed by introducing a predicate 
\begin_inset Formula \( Conflicts(c,t,s)\)
\end_inset 

 which is true when the actions in 
\begin_inset Formula \( c\)
\end_inset 

 are in conflict and cannot be performed together.
 The possibility axiom for concurrent actions is then:
\layout Standard


\begin_inset Formula \[ 
Poss(c,t,s)\leftrightarrow\forall a\left[a\in c\rightarrow Poss(a,t,s)\right]\wedge\neg Conflicts(c,t,s)\]
\end_inset 


\layout Standard

A typical use of this approach is to prevent each agent from performing
 more than one action at a time (here 
\begin_inset Formula \( actor(a)\)
\end_inset 

 gives the agent performing action 
\begin_inset Formula \( a\)
\end_inset 

):
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
\exists a_{1},a_{2}\left[a_{1}\in c\wedge a_{2}\in c\wedge actor(a_{1})=actor(a_{2})\right]\rightarrow Conflicts(c,t,s)\end{array}\]
\end_inset 

 Another issue arises when two programs can legitimately be transitioned
 by executing the same action.
 Consider the following programs which add ingredients to a bowl:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
\begin{array}{cc}
\delta_{1}=place\_ in(Thomas,Flour,Bowl)\,;\, place\_ in(Thomas,Sugar,Bowl)\\
\delta_{2}=place\_ in(Thomas,Flour,Bowl)\,;\, place\_ in(Thomas,Egg,Bowl)\end{array}\end{array}\]
\end_inset 


\layout Standard

Executing 
\begin_inset Formula \( \delta_{1}||\delta_{2}\)
\end_inset 

 should result in the bowl containing two units of flour, one unit of sugar
 and an egg.
 However, the above transition rule allows a transition with 
\begin_inset Formula \( c_{1}=c_{2}=place\_ in(Thomas,Flour,Bowl)\)
\end_inset 

, which adds only one unit of flour.
 Alternately, consider two programs waiting for a timer to ring (a natural
 action, see Section 
\begin_inset LatexCommand \ref{sub:Natural-Actions}

\end_inset 

):
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
\delta_{1}=ring\_ timer(OvenTimer)\,;\, acquire(Thomas,Bowl)\\
\delta_{2}=ring\_ timer(OvenTimer)\,;\, acquire(Richard,Board)\end{array}\]
\end_inset 


\layout Standard

Both programs should be allowed to proceed with a single occurrence of the
 
\begin_inset Formula \( ring\_ timer\)
\end_inset 

 action.
 To enforce this intuitive notion of how programs should behave, concurrent
 execution must not be allowed to transition both programs through the occurrenc
e
 of the same agent-initiated action.
\layout Standard

Taking these factors into account, we derive an improved transition rule
 are follows:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{cc}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow & \exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\,\wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge Poss(c_{1}\cup c_{2},t,s)\,\wedge\\
 & \forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow natural(a)\right]\,\wedge\\
 & \delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\end{array}\]
\end_inset 


\layout Standard

This robust combination of true and interleaved concurrency allows the language
 to more accurately reflect the concurrency present in multi-agent teams.
\layout Subsection

Natural Actions
\layout Standard


\begin_inset LatexCommand \label{sub:Natural-Actions}

\end_inset 


\layout Standard

Natural actions are a special class of exogenous actions, those actions
 which occur outside of the agent's control.
 Introduced to the situation calculus by Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 and expanded by Reiter 
\begin_inset LatexCommand \cite{reiter96sc
\latex latex 
_
\latex default 
nat
\latex latex 
_
\latex default 
conc}

\end_inset 

, they are classified according to the following requirement: natural actions
 must occur at their predicted times, provided no earlier actions prevent
 them from occurring.
 For example, a timer will ring at the time it was set for, unless it is
 switched off.
 In the context of high-level programing, they are a tool for predicting
 the behavior of the environment.
\layout Standard

The methodology of 
\begin_inset LatexCommand \cite{reiter96sc
\latex latex 
_
\latex default 
nat
\latex latex 
_
\latex default 
conc}

\end_inset 

 is adopted, suitably modified for our handling of time.
 Natural actions are indicated by truth of the predicate 
\begin_inset Formula \( natural(a)\)
\end_inset 

.
 As usual, the times at which natural actions may occur are specified by
 the 
\begin_inset Formula \( Poss\)
\end_inset 

 predicate.
 For example, suppose that the fluent 
\begin_inset Formula \( timer\_ set(ID,m,s)\)
\end_inset 

 represents the fact that a particular timer is set to ring in 
\begin_inset Formula \( m\)
\end_inset 

 minutes in situation 
\begin_inset Formula \( S\)
\end_inset 

.
 The possibility predicate for the 
\begin_inset Formula \( ring\_ timer(ID)\)
\end_inset 

 action would be:
\layout Standard


\begin_inset Formula \[ 
Poss(ring\_ timer(ID),t,s)\leftrightarrow\exists m.\left[timer\_ set(ID,m,s)\wedge t=start(s)+m\right]\]
\end_inset 


\layout Standard

An important concept when dealing with natural actions it the least natural
 time point (LNTP) of a situation.
 This is defined as the earliest time at which a natural action may occur
 in a situation:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{cc}
lntp(s,t)\leftrightarrow & \exists a\left[natural(a)\wedge Poss(a,t,s)\right]\wedge\\
 & \forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]\end{array}\]
\end_inset 


\layout Standard

Note that the LNTP need not exist for a given situation.
 This can happen both when no natural actions are possible in a situation,
 or when a natural action may occur at any time in a situation (and there
 is thus no earliest time).
 We will assume that the domain axiomatisation is designed to avoid such
 pathological cases, and the absence of an LNTP implies that no natural
 actions are possible.
\layout Standard

To enforce the requirement that natural actions must occur when possible,
 a predicate 
\begin_inset Formula \( legal(s)\)
\end_inset 

 is introduced which is true only for situations which respect this requirement
 (assuming no precondition interaction among natural actions):
\layout Standard


\latex latex 

\backslash begin{multiline}
\newline 
legal(S_{0}) 
\backslash leftrightarrow & True
\backslash 
\backslash 
\newline 
legal(do(c,t,s)) 
\backslash leftrightarrow & (
\backslash forall a,t_{a}).natural(a)
\backslash wedge Poss(a,t_{a},s)
\backslash rightarrow
\backslash left[a
\backslash in c
\backslash vee t<t_{a}
\backslash right]
\backslash 
\backslash 
\newline 
 & 
\backslash wedge
\backslash , legal(s)
\backslash wedge Poss(c,t,s)
\backslash wedge start(s)
\backslash leq t
\newline 

\backslash end{multiline}
\latex default 

\layout Standard

When utilising natural actions within a Golog program, all legal program
 executions should result in situations for which the 
\begin_inset Formula \( legal\)
\end_inset 

 predicate is true.
 This can be enforced in the semantics of the language, avoiding the need
 to check it explicitly.
\layout Standard

The possible transitions for a program containing a single action depend
 on whether the accompanying situation has a least natural time point.
 If not, it is legal to perform the action at any time greater than or equal
 to the start of the situation.
 If there is an LNTP, a legal situation can be produced in one of three
 ways: perform the action before the LNTP, perform it at the LNTP in conjunction
 with the natural actions, or perform the natural actions first.
 This is captured by the following transition rule:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
Trans(c,s,\delta',s')\leftarrow\\
\exists t_{n}.\left\{ lntp(s,t_{n})\wedge\right.\\
\left[\exists t.t\geq start(s)\wedge t<t_{n}\wedge Poss(c,t,s)\wedge\right.\\
\left.s'=do(c,t,s)\wedge\delta'=nil\right]\,\,\,\,\vee\\
\exists cn.\left(\forall a.natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in cn\right)\wedge\\
\left[poss(c\cup cn,t_{n},s)\wedge s'=do(c\cup cn,t_{n},s)\wedge\delta'=nil\right.\,\,\,\,\vee\\
\left.\left.s'=do(cn,t_{n},s)\wedge\delta'=c\right]\right\} \,\,\,\,\vee\\
\neg\exists t_{n}.lntp(s,t_{n})\wedge\exists t.\left[Poss(c,t,s)\wedge\right.\\
\left.t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\end{array}\]
\end_inset 


\layout Standard

Using this formulation, natural actions will occur at their predicted times
 without the programmer needing to mention them explicitly.
 If natural actions are included in the program, they will performed only
 at their predicted time.
 A proof of this is offered in Section 
\begin_inset LatexCommand \ref{sub:Legality-of-the-semantics}

\end_inset 

.
\layout Standard

While time and natural actions in Golog have previously been utilised as
 a planning tool 
\begin_inset LatexCommand \cite{pirri00planning
\latex latex 
_
\latex default 
nat
\latex latex 
_
\latex default 
acts}

\end_inset 

, the programmer was required to explicitly check for the possible occurrence
 of natural actions and ensure that executions of the program resulted in
 legal situations.
 Our integration significantly lowers the burden on the programmer by guaranteei
ng
 that all program executions produce legal situations.
\layout Subsection

Example Programs
\layout Standard

Having developed the necessary extensions, we now give some examples of
 programs which could be used in the cooking agents domain.
 One powerful feature of our language is the ability to nondeterministically
 select an agent for a particular task.
 Consider the following procedure for making a simple salad in a specified
 container:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)(acquire(agt,dest)\,;\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, begin\_ task(agt,mix(dest,1))\,;\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, end\_ task(agt,mix(dest,1))\,;\\
\,\,\,\, release(agt,dest))\,\,\mathbf{end}\end{array}\]
\end_inset 


\layout Standard

The procedure 
\begin_inset Formula \( ChopTypeInto\)
\end_inset 

 (not shown) picks an object of the given type and an available chopping
 board, chops the object using the board, then transfers it into the destination
 container. 
\begin_inset Formula \( MakeSalad\)
\end_inset 

 asks the agents to do this for a lettuce, a carrot and a tomato, then mix
 the ingredients together.
 Crucially, the agent assigned to handling each ingredient is not specified,
 nor is the order in which they should be added.
 The agents are free to determine an appropriate strategy.
\layout Standard


\begin_float fig 

\latex latex 
 
\backslash verbatiminput||
\latex default 
listings/output
\latex latex 
_
\latex default 
makeSalad.txt
\layout Standard


\latex latex 

\backslash verbatiminput||
\latex default 
listings/constraints
\latex latex 
_
\latex default 
makeSalad.txt
\layout Caption


\begin_inset LatexCommand \label{cap:example
\latex latex 
_
\latex default 
trace}

\end_inset 

Trace of an execution of the 
\begin_inset Formula \( MakeSalad\)
\end_inset 

 program with three agents (top).
 Variables 
\begin_inset Formula \( \_ U\)
\end_inset 

, 
\begin_inset Formula \( \_ T\)
\end_inset 

, etc give the occurrence times of each action, constrained to ensure all
 situations are legal (bottom).
\end_float 


\layout Standard

A trace of a legal execution of the 
\begin_inset Formula \( MakeSalad\)
\end_inset 

 program is shown in Figure 
\begin_inset LatexCommand \ref{cap:example
\latex latex 
_
\latex default 
trace}

\end_inset 

.
 Notice the occurrence of several actions within each 
\series bold 
do
\series default 
 statement, demonstrating the integration of true concurrency into the language.
 By contrast, an implementation in ConGolog would have only a single action
 at each step - assuming each step represents a finite time interval, this
 would unnecessarily leave some agents idle.
 Note also the explicit occurrence time for each step, allowing the agents
 to properly synchronise their actions.
 This time is not fixed but rather constrained based on the times at which
 previous actions were performed.
 These constraints emerge from the underlying situation calculus description
 of the world and are maintained automatically by the language.
 For coordination purposes the agents would agree, for example, to perform
 each action at the earliest possible time.
\layout Standard

In this example there are three agents but only two chopping boards, meaning
 one agent has to remain idle while waiting for the necessary resources.
 If other tasks were given concurrently with 
\begin_inset Formula \( MakeSalad\)
\end_inset 

, this agent could make progress on those while waiting.
 For example:
\layout Standard


\begin_inset Formula \[ 
MakeSalad()\,||\, MakeMainMeal()\,||\, MakeCake()\]
\end_inset 


\layout Section

MIndiGolog Semantics
\layout Standard


\begin_inset LatexCommand \label{sec:Langauge-Semantics}

\end_inset 


\layout Subsection

Transition Semantics
\layout Standard

This section shows the modifications that have been made to the semantics
 of IndiGolog to incorporate the extensions outlined above and produce the
 language MIndiGolog.
 Many operators are defined recursively using combinations of 
\begin_inset Formula \( Trans\)
\end_inset 

 and 
\begin_inset Formula \( Final\)
\end_inset 

 and thus do not need to be modified - for semantics of the operators not
 presented here, refer to 
\begin_inset LatexCommand \cite{giacomo00congolog,giacomo99indigolog}

\end_inset 

.
\layout Standard

The execution of primitive actions needs to be modified to account for sets
 of actions instead of single ones, and to incorporate the least natural
 time point considerations of Section 
\begin_inset LatexCommand \ref{sub:Natural-Actions}

\end_inset 

:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
Trans(c,s,\delta',s')\leftarrow\\
\exists t_{n}.\left\{ lntp(s,t_{n})\wedge\right.\\
\left[\exists t.t\geq start(s)\wedge t<t_{n}\wedge Poss(c,t,s)\wedge\right.\\
\left.s'=do(c,t,s)\wedge\delta'=nil\right]\,\,\,\,\vee\\
\exists cn.\left(\forall a.natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in cn\right)\wedge\\
\left[poss(c\cup cn,t_{n},s)\wedge s'=do(c\cup cn,t_{n},s)\wedge\delta'=nil\right.\,\,\,\,\vee\\
\left.\left.s'=do(cn,t_{n},s)\wedge\delta'=c\right]\right\} \,\,\,\,\vee\\
\neg\exists t_{n}.lntp(s,t_{n})\wedge\exists t.\left[Poss(c,t,s)\wedge\right.\\
\left.t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\end{array}\]
\end_inset 


\layout Standard

The transition relation for the concurrency operators must also be modified
 in accordance with the considerations of Section 
\begin_inset LatexCommand \ref{sub:Concurrency}

\end_inset 

:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\\
\exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s')\,\,\,\,\vee\\
\exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\,\,\,\,\vee\\
\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t.Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\,\wedge\\
Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\delta'=(\gamma_{1}||\gamma_{2})\,\wedge\\
\forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow natural(a)\right]\,\wedge\\
Poss(c_{1}\cup c_{2},t,s)\wedge s'=do(c_{1}\cup c_{2},t,s)\end{array}\]
\end_inset 


\layout Standard

All other operators from ConGolog and IndiGolog can be incorporated into
 our new language without modification.
\layout Subsection

Legality of the Semantics
\begin_inset LatexCommand \label{sub:Legality-of-the-semantics}

\end_inset 


\layout Standard

From the formal semantics presented above, it is possible to prove that
 if a program starts in a legal situation, all legal executions of the program
 will produce legal situations.
 That is:
\layout Standard


\begin_inset Formula \[ 
\forall\delta,\delta'.\, Trans(\delta,s,\delta',s')\wedge legal(s)\rightarrow legal(s')\]
\end_inset 


\layout Standard

First notice that only two transition rules directly modify the situation
 term - execution of a primitive action, and concurrent execution.
 All other rules modify the situation term by further use of the 
\begin_inset Formula \( Trans\)
\end_inset 

 predicate.
 Thus, it suffices to show that these two rules will produce only legal
 situations.
 Recall the definition of 
\begin_inset Formula \( legal(s)\)
\end_inset 

:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
legal(do(c,t,s))\leftrightarrow\\
legal(s)\wedge Poss(c,t,s)\wedge start(s)\leq t\wedge\\
(\forall a,t_{a}).natural(a)\wedge Poss(a,t_{a},s)\rightarrow\\
\left[a\in c\vee t<t_{a}\right]\end{array}\]
\end_inset 


\layout Standard

Considering the 
\begin_inset Formula \( Trans\)
\end_inset 

 rule for primitive actions, each of the four disjuncts may produce a new
 situation term.
 Here we consider only the case of performing the actions before the LNTP:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
\exists t_{n}.\left[lntp(s,t_{n})\wedge\exists t.\left[t\geq start(s)\wedge t<t_{n}\right.\right.\\
\left.\left.\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\right]\end{array}\]
\end_inset 


\layout Standard

From this it is immediately clear that:
\layout Standard


\begin_inset Formula \[ 
start(s)\leq t\,\,\,\,\, Poss(c,t,s)\]
\end_inset 


\layout Standard

Using the definition of 
\begin_inset Formula \( lntp(s,t_{n})\)
\end_inset 

:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
\exists a\left[natural(a)\wedge Poss(a,t_{n},s)\right]\wedge\\
\forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t_{n}\leq t_{a}\right]\end{array}\]
\end_inset 


\layout Standard

Since 
\begin_inset Formula \( t<t_{n}\)
\end_inset 

, this gives:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]\\
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow a\in c\vee t\leq t_{a}\right]\end{array}\]
\end_inset 


\layout Standard

Given 
\begin_inset Formula \( legal(s)\)
\end_inset 

, these are sufficient to establish 
\begin_inset Formula \( legal(do(c,t,s))\)
\end_inset 

 and so 
\begin_inset Formula \( legal(s')\)
\end_inset 

 as required.
 Similar arguments can be made for the remaining parts of this transition
 rule.
\layout Standard

Consider then the case of 
\begin_inset Formula \( Trans(\delta_{1}||\delta_{2},s,\delta',s')\)
\end_inset 

.
 The only part of interest is the disjunct which directly produces a modified
 situation 
\begin_inset Formula \( s'=do(c_{1}\cup c_{2},t,s)\)
\end_inset 

.
 Assume that 
\begin_inset Formula \( s\)
\end_inset 

 is a legal situation, that 
\begin_inset Formula \( \delta_{1}\)
\end_inset 

 and 
\begin_inset Formula \( \delta_{2}\)
\end_inset 

 contain no further concurrency operators and that all other transition
 rules produce legal situations.
 Then 
\begin_inset Formula \( Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\)
\end_inset 

 and 
\begin_inset Formula \( Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\)
\end_inset 

 will produce legal situations 
\begin_inset Formula \( do(c_{1},t,s)\)
\end_inset 

 and 
\begin_inset Formula \( do(c_{2},t,s)\)
\end_inset 

.
\layout Standard

From 
\begin_inset Formula \( legal(do(c_{1},t,s))\)
\end_inset 

 it can be inferred that:
\layout Standard


\begin_inset Formula \[ 
\begin{array}{c}
legal(s)\,\,\,\,\,\,\,\,\,\, start(s)\leq t\\
(\forall a,t_{a}).\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c_{1}\vee t<t_{a}\right]\right]\end{array}\]
\end_inset 


\layout Standard

This implies that:
\layout Standard


\begin_inset Formula \[ 
(\forall a,t_{a}).\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c_{1}\cup c_{2}\vee t<t_{a}\right]\right]\]
\end_inset 


\layout Standard

The definition of 
\begin_inset Formula \( Trans\)
\end_inset 

 further requires that:
\layout Standard


\begin_inset Formula \[ 
Poss(c_{1}\cup c_{2},t,s)\]
\end_inset 


\layout Standard

Thus all four conjuncts necessary to prove 
\begin_inset Formula \( legal(do(c_{1}\cup c_{2},t,s))\)
\end_inset 

 are true, and this rule generates only legal situations.
 Since cases where 
\begin_inset Formula \( \delta_{1}\)
\end_inset 

 and 
\begin_inset Formula \( \delta_{2}\)
\end_inset 

 contain further concurrency operators must eventually decompose into cases
 where they do not, it is a simple inductive argument to show that this
 transition rule produces legal situations for all programs.
\layout Standard

Natural actions are thus guaranteed to be inserted into program executions
 at their appropriate times, without requiring explicit mention by the programme
r.
\layout Section

Execution
\layout Standard


\begin_inset LatexCommand \label{sec:Language-Execution}

\end_inset 


\layout Standard

As the existing languages based on Golog have demonstrated, an interpreter
 can be conveniently constructed using a logic programming language such
 a Prolog.
 We have followed the style of 
\begin_inset LatexCommand \cite{giacomo00congolog,giacomo99indigolog}

\end_inset 

, to build interpreters for our language
\begin_float footnote 

\layout Standard

Available from the author's website at http://www.cs.mu.oz.au/~rfk/golog/
\end_float 

 in CIAO Prolog 
\begin_inset LatexCommand \cite{iclp99ciao}

\end_inset 

 and Mozart 
\begin_inset LatexCommand \cite{vanroy03mozart
\latex latex 
_
\latex default 
logic}

\end_inset 

.
 The Mozart implementation is highlighted in this paper as it provides strong
 support for distributed execution.
\layout Standard

Programs are encoded in Mozart as record terms, with the name of the record
 representing an operator and its features the arguments.
 Actions are also encoded as records.
 In line with convention in both Prolog and Mozart, uppercase terms now
 represent variables.
 For example, the program:
\layout Standard


\begin_inset Formula \[ 
\pi(agt)\left[acquire(agt,Bowl);acquire(agt,Knife)\right]\]
\end_inset 


\layout Standard

Is represented as follows:
\layout Standard


\latex latex 

\backslash verbatiminput||
\latex default 
listings/goloz
\latex latex 
_
\latex default 
ex
\latex latex 
_
\latex default 
prog.oz
\layout Standard

The predicates 
\begin_inset Formula \( Trans\)
\end_inset 

 and 
\begin_inset Formula \( Final\)
\end_inset 

 have a straightforward encoding as Mozart procedures:
\layout Standard


\latex latex 

\backslash verbatiminput||
\latex default 
listings/goloz
\latex latex 
_
\latex default 
trans.oz
\layout Standard


\latex latex 

\backslash verbatiminput||
\latex default 
listings/goloz
\latex latex 
_
\latex default 
final.oz
\layout Standard

The block 
\series bold 
proc...end
\series default 
 defines a new procedure, the 
\series bold 
case
\series default 
 statement performs pattern matching, and the 
\series bold 
choice
\series default 
 statement indicates that the procedure can choose one of several evaluation
 paths.
\layout Standard

By defining a procedure 
\begin_inset Formula \( Do(\delta,s,s')\leftrightarrow Trans*(\delta,s,\delta',s')\wedge Final(\delta',s')\)
\end_inset 

 it is possible to use the inbuilt depth-first search procedure to find
 a legal execution for a given program:
\layout Standard


\latex latex 

\backslash verbatiminput||
\latex default 
listings/goloz
\latex latex 
_
\latex default 
do.oz
\layout Standard

The actions thus determined can then be communicated to the team members
 for execution.
 This can be viewed as a centralised planner for the multi-agent team.
\layout Standard

Of course, a centralised planner fails to utilise all the resources available
 to the team.
 While a legal execution is being found, other agents are idle.
 An important aspect of the Mozart system is that it provides a parallel
 search procedure that can take advantage of networked machines to speed
 up the search.
 Utilising this, our implementation can be used to form a distributed multi-agen
t
 planner.
 In the following, 
\begin_inset Quotes eld
\end_inset 

agent1
\begin_inset Quotes erd
\end_inset 

 and 
\begin_inset Quotes eld
\end_inset 

agent2
\begin_inset Quotes erd
\end_inset 

 are names mapping to the IP-addresses of agents in the team, and 
\begin_inset Quotes eld
\end_inset 

Goloz
\begin_inset Quotes erd
\end_inset 

 is a Mozart functor that encapsulates the EvalOffline procedure defined
 above:
\layout Standard


\latex latex 

\backslash verbatiminput||
\latex default 
listings/goloz
\latex latex 
_
\latex default 
do
\latex latex 
_
\latex default 
parallel.oz
\layout Standard

The result is the same as the centralised case, a sequence of actions that
 can be communicated to the team members for execution.
 Agents can thus plan the execution of their shared program both individually
 and collectively.
\layout Section

Related Work
\layout Standard


\begin_inset LatexCommand \label{sec:Other-Work}

\end_inset 


\layout Standard

The utility of the high-level program execution paradigm is highlighted
 by the many extensions which have been developed for the base Golog language.
 Prominent among these are the following: 
\emph on 
ConGolog
\emph default 
 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 introduced the ability for an agent to interleave the execution of multiple
 high-level programs, along with the notion of an interrupt which gains
 control when certain conditions become true. 
\emph on 
IndiGolog
\emph default 
 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset 

 formalised online execution of Golog programs and introduced the search
 operator to allow controlled offline planning. 
\emph on 
DTGolog
\emph default 
 
\begin_inset LatexCommand \cite{boutilier00dtgolog}

\end_inset 

 combined the situation calculus with Markov Decision Processes to allow
 agents to determine the best execution of a program in the face of probabilisti
c
 action outcomes.
\layout Standard

There has also been work on extending the situation calculus to allow richer
 world models, notably that of Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 and Reiter 
\begin_inset LatexCommand \cite{reiter96sc
\latex latex 
_
\latex default 
nat
\latex latex 
_
\latex default 
conc}

\end_inset 

.
 Work on concurrent execution of primitive actions and explicit time in
 particular make the situation calculus more suitable for representing worlds
 containing multiple agents.
 However, there appears to be little work incorporating these extensions
 with extensions to the Golog language.
\layout Standard

While work with Golog has predominantly focused on single-agent systems,
 there have been several notable applications of the technique to multi-agent
 systems.
 The Cognitive Agent Specification Language 
\begin_inset LatexCommand \cite{shapiro02}

\end_inset 

 uses ConGolog to describe the behavior of agents in a multi-agent setting,
 and an automated theorem prover is in development that can verify properties
 of the programs.
 It differs from our work in that it is designed for open multi-agent systems,
 with each agent having its own Golog program defining its behavior.
 By contrast, we seek to develop a single Golog program that is cooperatively
 executed by all agents.
 Another difference is its focus on modelling and simulation of agent systems,
 rather than producing executable programs.
\layout Standard

Closer to the spirit of this paper is the work of Ferrein et.
 al. 
\begin_inset LatexCommand \cite{Ferrein2005readylog}

\end_inset 

 on ReadyLog, a Golog derivative designed for highly dynamic domains.
 It has been successfully applied to control multi-agent teams in the RoboCup
 soccer tournament.
 ReadyLog integrates the facilities of concurrency, online execution and
 decision theory and can be seen as a unification of ConGolog, IndiGolog
 and DTGolog.
 The programs used to control the soccer team intersperse actions by several
 agents and can thus be viewed as team programs.
 However, the program is evaluated separately by each agent.
\layout Standard

In summary, while there have been extensions to Golog that allow more expressive
 programs to be written and extensions to the situation calculus which provide
 richer models of the world, the integration of these approaches is a topic
 of ongoing work.
 It is at this crossroads that our new language, MIndiGolog, is positioned.
 It combines the collective capabilities of these extensions to represent
 and program the behavior of multi-agent teams.
\layout Section

Conclusions
\layout Standard


\begin_inset LatexCommand \label{sec:Conclusions-and-Future}

\end_inset 


\layout Standard

In this paper, we have integrated a combination of several important extensions
 to the situation calculus and Golog to provide a new language suitable
 for expressing high-level programs for multi-agent teams.
 The main contribution of this work is the effective integration of elements
 important to multi-agent programs into the semantics: the combination of
 true and interleaved concurrency; an explicit notion of time for coordination;
 and the tight integration of natural actions.
 An implementation of this language using Mozart has demonstrated its effectiven
ess
 as a centralised multi-agent planner and a method for distributed execution.
\layout Standard

We are presently exploring the potential of this approach for a range of
 distributed programming applications, and the integration of additional
 techniques from the field of high-level program execution.
 Key among these is the significant work on representing knowledge and belief
 in Golog.
 As many applications involve partially observable worlds, different agents
 must be capable of having different beliefs about the world.
 Additionally, while we have distributed the workload of planning an execution,
 overall control is still centralised.
 We are actively researching techniques to allow an execution to be found
 in a decentralised manner.
\layout Standard

As our implementations have demonstrated, the combination of state-of-the-art
 techniques from Golog is highly capable of representing the behavior of
 multi-agent teams.
 Combined with facilities for distributed logic programming, MIndiGolog
 promises to provide the advantages of high-level program execution for
 multi-agent teams. 
\latex latex 

\backslash newpage
\latex default 

\layout Standard


\begin_inset LatexCommand \BibTeX[abbrv]{/storage/uni/pgrad/library/references}

\end_inset 


\the_end
