#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

MIndiGolog: A Programming Language for Multi-Agent Teams
\layout Author

Ryan Kelly
\layout Abstract

Research into applications involving multiple autonomous agents may be divided
 two subfields - 
\begin_inset Quotes eld
\end_inset 

multi-agent systems
\begin_inset Quotes erd
\end_inset 

 in which agent behaviors are loosley coupled and agents may by-and-large
 act independently, and 
\begin_inset Quotes eld
\end_inset 

multi-agent teams
\begin_inset Quotes erd
\end_inset 

 in which the agents depend intimately on one another for the accomplishment
 of a shared goal.
 (TODO: find a reference for this taxonomy) From a programming viewpoint,
 multi-agent systems are typically constructed by specifying the behavior
 of individual agents and using communication primitives to design interaction
 and cooperation between agents.
 This may be considered a bottom-up approach.
 For tightly-coupled multi-agent teams, it may be more convenient to take
 a top-down approach: consider the team to be a single 
\begin_inset Quotes eld
\end_inset 

super-agent
\begin_inset Quotes erd
\end_inset 

 with distributed reasoning and acting abilities, and design a single multi-agen
t program to encode its behavior.
 This program would then be distributed to all members of the team, who
 must carry it out in a robust fashion.
 This paper takes the first steps towards creating such a language, based
 on the agent programming language Golog.
\layout Abstract

The major contributions of this paper are: to motivate high-level program
 execution as a problem-solving paradigm for multi-agent teams, to combine
 previous extensions to the Golog language into a semantics suitable for
 use in a multi-agent setting, and to make some preliminary suggestions
 as to how this may be used as a practical programming language for multi-agent
 teams..
 The result is MIndiGolog, a Golog dialect incorporating: TODO: limitations
 of current approaches?
\layout Itemize

Multiple agents
\layout Itemize

Concurrent execution of actions
\layout Itemize

An explicity representation of time
\layout Itemize

Natural actions
\layout Section

TASKS
\layout Itemize

Motivate the use of Golog in multiagent teams
\layout Itemize

Give semantics as combinations of previous work
\layout Itemize

Prove interesting things about semantics, e.g.
 only generates executable situations - step up from 
\begin_inset Quotes eld
\end_inset 

Planning with Natural Actions in the Situation Calculus
\begin_inset Quotes erd
\end_inset 


\layout Itemize

Make simple suggestions on how to execute using distrubted system
\layout Itemize

TODO: discuss LNTPC, needed for proof of generating legal situations
\layout Itemize

TODO: 
\begin_inset Formula $lntp(s,t)\rightarrow start(s)\leq t$
\end_inset 


\layout Itemize

TODO: Distinction between 
\begin_inset Quotes eld
\end_inset 

Multi-Agent Planning
\begin_inset Quotes erd
\end_inset 

 and 
\begin_inset Quotes eld
\end_inset 

Team Planning
\begin_inset Quotes erd
\end_inset 


\layout Itemize

TODO: better term than 
\begin_inset Quotes eld
\end_inset 

multi-agent systems
\begin_inset Quotes erd
\end_inset 

 for the loosley coupled case, perhaps 
\begin_inset Quotes eld
\end_inset 

open
\begin_inset Quotes erd
\end_inset 

 or something...find a good reference!
\layout Itemize

TODO: mention FLUX somewhere?
\layout Itemize

TODO: why is explicit temporal component so important?
\layout Itemize

TODO: dont reference KIA textbook, use journal papers instead
\layout Section

Introduction
\layout Subsection

Multi-Agent Teams
\layout Standard

TODO: need some references, other approaches, problems with them...
\layout Standard

SharedPlans? Joint Intentions? TEAMCORE? Heaps of others here...
\layout Standard

Idea of Roles - reduce communication? Make programming easier?
\layout Subsection

Golog
\layout Standard

The programming language Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

 and its derivatives have found a wide range of applications in agent-oriented
 systems, from museum tour-guide robots (TODO:ref) and mail delivery (TODO:ref)
 to the RoboCup robotic soccer competition.
 Testimony to its success are the many enhacements to the language such
 as ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 to provide concurrent execution of programs, DTGolog [TODO] to provide
 probability and decision-theory, and IndiGolog 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset 

 to provide online execution.
\layout Standard

At its most basic level, a Golog program consists two components:
\layout Itemize

an axiomatisation of a dynamic domain in the Situation Calculus, a first-order
 logic formalism for describing dynamic worlds 
\begin_inset LatexCommand \cite{McCHay69sitcalc}

\end_inset 


\layout Itemize

a program consisting of actions from the domain, connected using various
 programming constructs such as loops, if-then-else, and nondeterministic
 choice
\layout Standard

It is then the task of the agent to find a deterministic insantiation of
 the program which will produce a sequence of legal actions - that is, that
 can actually be carried out in the world.
 Such a sequence of actions is called a 
\begin_inset Quotes eld
\end_inset 

legal execution
\begin_inset Quotes erd
\end_inset 

 of the Golog program.
\layout Standard

The growing use of Golog shows that, as suggested in 
\begin_inset LatexCommand \cite{lesperance2000_igl_ext}

\end_inset 

, 
\emph on 
high-level program execution
\emph default 
 is emerging as a practical alternative to traditional plan synthesis.
 Rather than a planner finding a legal sequence of actions leading from
 an initial state to a state in which some goals are achieved, the task
 is instead to find a sequence of actions which constitute a legal execution
 of some high-level program.
 As the amount of non-determinism is controlled by the programmer, this
 task can range from simply executing a fully-deterministic program to synthesis
ing actions from a completely non-deterministic program, a task equivalent
 to traditional planning.
 Indeed, in 
\begin_inset LatexCommand \cite{Finzi00}

\end_inset 

 Finzi et.
 al.
 show that an effective planning system can be build using Golog.
\layout Standard

The expected benefits of this new approach include:
\layout Itemize

Explicit control over the amount of non-determinism, possibly avoiding exponenti
al growth in difficulty as problem size increases
\layout Itemize

Ability to encode specific procedural knowledge about the domain
\layout Itemize

Ability to formally prove properties of the legal executions of the program,
 such as safey and liveness conditions
\layout Standard

A potential drawback of this approach is that a complete legal execution
 must be determined before any actions are carried out - otherwise, actions
 committed to by the agent could lead to situations where no legal execution
 is possible.
 Programs are thus executed offline.
 This is addressed in the language IndiGolog where an explicit search operator
 is introduced - a legal execution is determined offline for programs inside
 a search operator, while outside a search operator the program is executed
 online, with nondeterministic choices being executed as random choices.
 
\layout Standard

TODO: benefits for sensing?
\layout Subsection

Golog and Multiple Agents
\layout Standard

Golog has often focused on the modelling/implementation of single agent
 systems where a Golog program is written to describe the desired behavior
 of the agent, which then determines an appropriate legal execution and
 performs it.
 This approach has been successfully extended to a multi-agent setting -
 each agent is given a Golog program defining its behaviour, and various
 communication actions allow the agents to interact.
 This is the bottom-up approach discussed above.
 TODO: find some basic examples.
\layout Standard

The utility of Golog for modelling multi-agent systems is shown by the Cognitive
 Agent Specification Language 
\begin_inset LatexCommand \cite{lesperance05ecasl}

\end_inset 

, which uses ConGolog to describe the behavior of agents and validation
 software to prove various properties about the behavior of the resulting
 multi-agent system.
 While primarily designed for modelling multi-agent systems, its authors
 propose that the animation of such models into real-world implementations
 would be advantageous, an idea similar in spirit to this paper.
 However, the use of standard ConGolog may limit the kinds of domains which
 can be modelled, as will be discussed in the following sections.
\layout Standard

Another recent approach is Readygolog [TODO], which has been used in the
 implementation of a RoboCup team.
 The Golog programs used in this case-study are fully multi-agent plans,
 with actions from different agents interleaved in a single program.
 They thus embody the top-down approach suggested in this paper.
 However, the planning and deliberation is still carried out by a single
 agent, who simply reasons about the actions of other agents and assumes
 that the actions they perform can be percived.
 In contrast, the aim of this paper is to produce a language which can be
 cooperatively executed by a team of agents.
 TODO: what do they add? What are the limitations.
\layout Subsection

Example: The Cooking Agents
\layout Standard

In order to explore multi-agent Golog programs in a concrete way, a running
 example is introduced and investigated throughout this paper: the 
\begin_inset Quotes eld
\end_inset 

Cooking Agents
\begin_inset Quotes erd
\end_inset 

 domain.
 In this domain, several robotic chefs inhabit a kitchen, which they share
 with inanimate objects such as various ingredients, appliances and utensils.
 The agents must cooperate to produce a meal consisting of several dishes.
\layout Standard

This example is particularly suitable because tightly-coupled cooperation
 will be of benefit, rather than assigning specific tasks to specific agents
 and potentially leaving some agents idle.
 It contains several challenges common to a wide variety of multi-agent
 settings:
\layout Itemize

Contention for shared resources, such as utensils and the oven
\layout Itemize

Explicit time and time constraints, such as a cake needing to be baked for
 an hour or the entree needing to be ready 15 minutes before the main course
\layout Itemize

Scheduling constraints and conflicts, such as a board using for chopping
 meat being unusable for chopping salad
\layout Itemize

Large amount of procedural knowledge in the form of recipies
\layout Standard

The example domain also embodies several simplifications which make things
 easier for this initial investigation.
 Without difficulty it may be idealised as being completely deterministic
 and fully observable.
 The agents are also in close proximity allowing complete and reliable communica
tion.
 The details of this example domain will be developed through the paper.
\layout Section

Background
\layout Subsection

The Situation Calculus
\layout Standard

The situation calculus is a first order logic formalism designed for representin
g and reasoning about dynamically changing worlds, introduced by McCarthy
 and Hayes 
\begin_inset LatexCommand \cite{McCHay69sitcalc}

\end_inset 

.
 While the concepts of the situation calculus remain largely unchanged,
 the accompanying notation has evolved somewhat since its inception.
 The notation presented here is that of Reiter 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

.
\layout Standard

A representation of a dynamic world in the situation calculus consists of
 first order logic statements capturing the following:
\layout Itemize

The actions that can be performed in the world
\layout Itemize

The fluents that describe the state of the world
\layout Itemize

Action precondition axioms, one for each action
\layout Itemize

Successor state axioms, one for each fluent
\layout Itemize

Axioms describing the initial world situation
\layout Itemize

The foundational axioms of the situation calculus
\layout Standard

Only an overview of these concepts is presented here.
 A detailed treatment may be found in 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

.
\layout Standard


\emph on 
Actions
\emph default 
 are literals in the logic representing the ways in which the world can
 be changed, are are taken to be instantaneous.
 If an action does not occur, the world does not change.
 The 
\begin_inset Quotes eld
\end_inset 

state of the world
\begin_inset Quotes erd
\end_inset 

 is represented as a 
\emph on 
situation
\emph default 
, which is the history of actions that have been performed so far, with
 the initial situation represented by the term 
\begin_inset Formula $S_{0}$
\end_inset 

.
 Terms representing other situations are constructed using the function
 
\begin_inset Formula $do(a,s)$
\end_inset 

 which gives the situation resulting from performing action 
\begin_inset Formula $a$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

.
\layout Standard

In this paper, all actions have as their first argument the name of the
 agent performing them.
 For example, the agent 
\begin_inset Formula $Thomas$
\end_inset 

 may perform the action of placing an egg in a bowl, represented as:
\layout Standard


\begin_inset Formula \[
place\_ in(Thomas,Egg,Bowl)\]

\end_inset 


\layout Standard

If this is the first action performed in the world, the new situation becomes:
\layout Standard


\begin_inset Formula \[
do(place\_ in(Thomas,Egg,Bowl),S_{0})\]

\end_inset 


\layout Standard

Properties of the world are described by 
\emph on 
fluents
\emph default 
, which are functions or predicates taking a situation as their final argument.
 For example, the fact that agent 
\begin_inset Formula $Richard$
\end_inset 

 has possession of a knife in some situation 
\begin_inset Formula $S$
\end_inset 

 might be represented as:
\layout Standard


\begin_inset Formula \[
has\_ object(Richard,Knife,S)\]

\end_inset 


\layout Standard

Action precondition axioms are given in terms of 
\emph on 
possibility predicates
\emph default 
, which specify when it is possible for a given action to be performed.
 For example, to state that an agent may only place an object in a bowl
 when they have possession of that bowl, the following possibility fluent
 could be used:
\layout Standard


\begin_inset Formula \[
\forall agt,obj,s.\left[Poss(place\_ in(agt,obj,Bowl),s)\leftrightarrow has\_ object(agt,Bowl,s)\right]\]

\end_inset 


\layout Standard

The truth values of fluents are specified in two parts.
 First, one must define what is true of the initial situation, such as the
 following statement that no agents possess any objects initially:
\layout Standard


\begin_inset Formula \[
\forall agt.\left[\neg\exists obj.\left(has\_ object(agt,obj,S_{0})\right)\right]\]

\end_inset 


\layout Standard

TODO: good demo of successor state axioms
\layout Standard

This basic form of the situation calculus has been extended to incorporate
 ideas such as an explicit representation of time, continuously running
 tasks, and natural actions.
 These extensions will be incorporated throughout the paper.
\layout Subsection

Golog
\layout Standard

Golog (short for alGOl in LOGic) is a declarative programming language based
 on the situation calculus, developed by Levesque et.
 al 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

.
 It combines the primitive actions from the situation calculus description
 of the world into high-level programming constructs such as while-loops,
 if-then-else clauses, and nondeterministic choice.
 There are two popular methods for defining its semantics.
 The first, due to 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

, is to define a macro 
\begin_inset Formula $Do(\delta,s,s')$
\end_inset 

 which states that the Golog program 
\begin_inset Formula $\delta$
\end_inset 

 has an execution that begins in situation 
\begin_inset Formula $s$
\end_inset 

 and ends in situation 
\begin_inset Formula $s'$
\end_inset 

.
 This macro is defined for each of the language constructs and expands into
 a formula in the situation calculus.
 Executing the program corresponds to proving that 
\begin_inset Formula $\exists s.\left[Do(\delta,S_{0},s')\right]$
\end_inset 

 and then executing the actions in 
\begin_inset Formula $s$
\end_inset 

.
\layout Standard

The second method was introduced with the language ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 and is designed to allow for non-terminatin programs and concurrency.
 Two predicates 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

 are defined for each program construct.
 Intuitively, is true only when program 
\begin_inset Formula $\delta$
\end_inset 

 can cause the world to move from situation 
\begin_inset Formula $s$
\end_inset 

 to situation 
\begin_inset Formula $s'$
\end_inset 

, after which 
\begin_inset Formula $\delta'$
\end_inset 

 remains to be executed.
 It thus specifies single-steps of computation of the program 
\begin_inset Formula $\delta$
\end_inset 

.
 
\begin_inset Formula $Final(\delta,s)$
\end_inset 

 is true when program 
\begin_inset Formula $\delta$
\end_inset 

 may legally terminate its execution in situation 
\begin_inset Formula $s$
\end_inset 

.
 Execution then consist of proving that 
\begin_inset Formula $\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]$
\end_inset 

, where 
\begin_inset Formula $Trans*$
\end_inset 

 is the transitive closure of 
\begin_inset Formula $Trans$
\end_inset 

.
\layout Standard

By its nature, the macro approach results in offline execution of the program
 - an entire legal execution is found before being passed of for execution
 in the world.
 Since the solution based on transition semantics supports both incremental
 execution and non-terminating processes, it is preferred for this application.
\layout Standard

TODO: Some basic examples
\layout Section

Domain Axiomatisation
\layout Standard

As described above, the first task in implementing a Golog-based system
 is to produce an appropriate axiomatisation of the domain in the Situation
 Calculus.
 For the cooking agents example, there are a number of factors which make
 the axiomatisation challenging: 
\layout Itemize

Resources: The agents will be required to utilise consumable resourses such
 as ingredients.
 They will also face conention for physical resources such as the oven,
 mixing bowls and chopping boards.
\layout Itemize

Continuous Processes: Agents are required to perform actions with some finite
 duration, but the ontology of the situation calculus allows only for instantane
ous actions.
 An appropriate representation must be given.
\layout Itemize

Natural Actions: These are predictable actions which occur outside of the
 agent's control, and which must occur as long as nothing happens to stop
 them from occuring.
 For example, if an agent sets a timer then it will ring at the appropriate
 time without intervention from any agent.
\layout Itemize

Concurrency: For a multi-agent system two notions of concurrency must be
 considered - the concurrent execution of several high-level programs, and
 the concurrent performance of several actions by independent agents.
\layout Itemize

Explicit Time: Some tasks in the cooking domain may require an explicit
 notion of time.
 For example, a cake must be baked for 30 minutes before being removed from
 the oven.
\layout Standard

Many of these notions have been independently addressed in Golog and the
 situation calculus.
 They will be systematically addressed and combined in the following sections.
\layout Subsection

Time
\layout Standard

There have been several efforts to incorporate a temporal component into
 the situation calculus.
 Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 introduced the functions 
\begin_inset Formula $start(s)$
\end_inset 

 and 
\begin_inset Formula $end(s,a)$
\end_inset 

 which range over the real numbers and give the starting and ending time
 of a situation respectively.
 This was primarily designed for reasoning within a sequence of 
\begin_inset Quotes eld
\end_inset 

actual situations
\begin_inset Quotes erd
\end_inset 

.
 Reiter 
\begin_inset LatexCommand \cite{reiter01kia,reiter96sc_nat_conc}

\end_inset 

 simplified this scheme by including within each action an explicit temporal
 argument indicating the time at which it was performed.
 While this is useful when specifying precise times for actions, it requires
 additional clauses to ensure that concurrently executed actions all occur
 at the same time.
\layout Standard

In work on the related Fluent Calculus, Martin 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset 

 attaches the explicit occurance time not to actions but to situations,
 an approach which was also adopted for this paper.
 The successor situation predicate 
\begin_inset Formula $do(a,s)$
\end_inset 

 becomes 
\begin_inset Formula $do(a,t,s)$
\end_inset 

, to indicate 
\begin_inset Quotes eld
\end_inset 

perform action 
\begin_inset Formula $a$
\end_inset 

 at time 
\begin_inset Formula $t$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

.
 Likewise, the possibility predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset 

 becomes 
\begin_inset Formula $Poss(a,t,s)$
\end_inset 

, meaning 
\begin_inset Quotes eld
\end_inset 

it is possible to perform action 
\begin_inset Formula $a$
\end_inset 

 at time 
\begin_inset Formula $t$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 


\begin_inset Quotes erd
\end_inset 

.
 The function 
\begin_inset Formula $start(s)$
\end_inset 

 is added which gives the starting time of a situation:
\layout Standard


\begin_inset Formula \[
start(do(a,t,s))=t\]

\end_inset 


\layout Standard

Note that the start time of the initial situation is arbitrary, and may
 be defined as required according to the specific application.
\layout Subsection

Concurrency
\layout Standard

The notion of concurrently executing multiple high-level programs is given
 an in-depth treatment in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 with the development of ConGolog.
 This work adds support for prioritized concurrency and interrupts to the
 standard Golog semantics by means of interleaving of primitive actions,
 an approach which will be used in this paper.
\layout Standard

The work of 
\begin_inset LatexCommand \cite{lin92sc_conc}

\end_inset 

 and 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 provides a suitable extension to the situation calculus in which many primitive
 actions may be performed at a single time.
 This is particularly important for a multi-agent system in order to exploit
 the potential for parallel execution provided by multiple agents.
 Here the basic action terms are replaced with sets of actions to be performed
 concurrently.
 All predicates that take an action are modified to accept sets of actions
 instead:
\layout Standard


\begin_inset Formula \[
do(\{ a_{1},a_{2}\},t,s)\]

\end_inset 


\layout Standard

TODO: define other predicates as well
\layout Standard

The approach to time used in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 requires a predicate 
\begin_inset Formula $coherent(c)$
\end_inset 

 to be defined, which is true when the concurrent action 
\begin_inset Formula $c$
\end_inset 

 contains at least one action and all actions occur at the same time.
 Since time in this paper is attached to situations rather than actions,
 this property is automatically satisfied.
 To ensure that program executions do not include empty sets of actions,
 one need only ensure that it is never possible to perform such an empty
 set:
\layout Standard


\begin_inset Formula \[
\forall s,t.\left[Poss(\{\},t,s)\equiv False\right]\]

\end_inset 


\layout Standard

These two concepts of concurrency were first combined by Baier and Pinto
 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset 

 to give the language TConGolog, by modifying the transition semantics for
 ConGolog given in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 to act on sets of concurrent action terms as axiomatised in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

.
 Theirs is equivalent to the approach taken below, without the additional
 temporal component.
\layout Standard

Recall that the semantics of a ConGolog program is given in terms of a transitio
n system based on predicates 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

.
 In the simplest implementation, those instances of the transition predicates
 which operate at the level of primitive actions could be modified to accept
 sets of concurrent actions, and they would operate appropriately over the
 domain axiomatisation of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

.
 However, the fact that several primitive actions can occur simultaneously
 means that the definition of 
\begin_inset Quotes eld
\end_inset 

concurrent processes
\begin_inset Quotes erd
\end_inset 

 found in ConGolog can be extended.
\layout Standard

The concurrency operator 
\begin_inset Formula $(\delta_{1}||\delta_{2})$
\end_inset 

 is intended to mean 
\begin_inset Quotes eld
\end_inset 

execute programs 
\begin_inset Formula $\delta_{1}$
\end_inset 

and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 concurrently
\begin_inset Quotes erd
\end_inset 

.
 In the original single-step transition semantics, this is operationalised
 as:
\layout Quotation


\begin_inset Quotes eld
\end_inset 

...you single step 
\begin_inset Formula $(\delta_{1}||\delta_{2})$
\end_inset 

 by single stepping either 
\begin_inset Formula $\delta_{1}$
\end_inset 

 or 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and leaving the other process unchanged.
\begin_inset Quotes erd
\end_inset 


\layout Standard

This is characterised by the predicate:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\end{eqnarray*}

\end_inset 


\layout Standard

When multiple actions can occur concurrently, this notion of interleaving
 is insufficient.
 It may be possible to simultaneously single step both 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 by executing actions concurrently.
 Thus, there are three options for single stepping the concurrency operator:
\layout Itemize

Single step 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and execute the remainder concurrently with 
\begin_inset Formula $\delta_{2}$
\end_inset 


\layout Itemize

Single step 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and execute the remainder concurrently with 
\begin_inset Formula $\delta_{1}$
\end_inset 


\layout Itemize

Single step both 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and execute the remainders of both concurrently
\layout Standard

The following modified 
\begin_inset Formula $Trans$
\end_inset 

 predicate captures this extended notion of concurrent execution:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s') & \vee\\
 & \exists c_{1},c_{2},\gamma_{1},\gamma_{2},t.Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s)) & \wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\delta'=(\gamma_{1}||\gamma_{2}) & \wedge\\
 & Poss(c_{1}\cup c_{2},t,s)\wedge s'=do(c_{1}\cup c_{2},t,s)\end{eqnarray*}

 

\end_inset 


\layout Standard

This is equivalent to the semantics given in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset 

.
\layout Standard

TODO: precondition interaction and the conflicts() predicate
\layout Subsection

Natural Actions
\layout Standard

Natural actions are a special class of exogenous actions, those actions
 which occur outsite of the agent's control.
 Introduced to the situation calculus by Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 and expanded by Reiter 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc,reiter01kia}

\end_inset 

, they are classified according to the following requirement: natural actions
 are exogenous actions which must occur that their predicted times, provided
 no earlier actions prevent them from occuring.
 For example, the action of a ball bouncing when it reaches the ground is
 a natural action, which may be prevented by catching the ball.
\layout Standard

We adopt the methodology of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

, suitably modified for our alternate alternate encoding of time (again,
 this is similar to the approach of 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset 

).
 Each natural action is indicated by the predicate 
\begin_inset Formula $natural(a)$
\end_inset 

, which is true precisely when 
\begin_inset Formula $a$
\end_inset 

 is a natural action.
 The times at which natural actions may occur are specified by the 
\begin_inset Formula $Poss$
\end_inset 

 predicate, as with agent-initiated actions.
 For example, suppose that the following fluent represents the fact that
 a timer identified by 
\begin_inset Formula $ID$
\end_inset 

 is set to ring in 10 minutes in the situation 
\begin_inset Formula $S$
\end_inset 

:
\layout Standard


\begin_inset Formula \[
timer\_ set(ID,10,S)\]

\end_inset 


\layout Standard

The possibility predicate for the 
\begin_inset Formula $ring\_ timer(ID)$
\end_inset 

 action could then be given as:
\layout Standard


\begin_inset Formula \[
Poss(ring\_ timer(ID),t,s)\equiv\exists m.\left[timer\_ set(ID,m,s)\wedge t=start(s)+m\right]\]

\end_inset 


\layout Standard

To enforce the requirement that natural actions must occur provided nothing
 prevents them, a predicate 
\begin_inset Formula $legal(s)$
\end_inset 

 is introduced which is true only for situations which respect this requirement:
\layout Standard


\begin_inset Formula \[
legal(S_{0})\equiv True\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\begin{array}{cc}
legal(do(c,t,s))\equiv & legal(s)\wedge Poss(c,t,s)\wedge\\
 & start(s)\leq t\wedge\\
 & (\forall a,t_{a}).natural(a)\wedge Poss(a,t_{a},s)\rightarrow\\
 & \left[a\in c\vee t<t_{a}\right]\end{array}\]

\end_inset 


\layout Standard

When utilising natural actions within a Golog program, all legal program
 executions should result in situations for which the 
\begin_inset Formula $legal$
\end_inset 

 predicate is true.
 It will be shown that this can be enforced in the semantics of the language,
 avoiding the need to check it explicitly.
\layout Standard

TODO: this implicitly assumes no interaction among natural actions.
\layout Standard

An important concept when dealing with natural actions it the least natural
 time point (LNTP) of a situation.
 This is defined as the earliest time at which a natural action may occur
 in a situation:
\layout Standard


\begin_inset Formula \[
\begin{array}{ccc}
lntp(s,t) & \equiv & \exists a\left[natural(a)\wedge Poss(a,t,s)\right]\wedge\\
 &  & \forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]\end{array}\]

\end_inset 


\layout Standard

Note that the LNTP need not exist for a given situation.
 It is straightforward to extend the proof of Lemma 3 in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 to this notation,giving the result that:
\layout Standard


\begin_inset Formula \[
natural(a)\wedge legal(do(c,t,s))\wedge a\in c\rightarrow lntp(s,t)\]

\end_inset 


\layout Subsection

Continuous Processes
\layout Standard

TODO find a ref for this
\layout Standard

The standard way to represent continuous processes in the Situation Calculus
 is by assocating them with a fluent, which is true precisely when the process
 is being performed.
 This is accompanied by two actions, one indicating the start of the process
 and one indicating when it stops.
 This can be encoded in a general way using the fluent 
\begin_inset Formula $doing\_ task(agt,tsk,s)$
\end_inset 

 to indicate that agent 
\begin_inset Formula $agt$
\end_inset 

 is in the process of doing task 
\begin_inset Formula $tsk$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

.
 It is accompanied by two actions 
\begin_inset Formula $begin\_ task(agt,tsk)$
\end_inset 

 and 
\begin_inset Formula $end\_ task(agt,tsk)$
\end_inset 

.
 The successor state axiom for this fluent must ensure that it becomes true
 when 
\begin_inset Formula $begin\_ task$
\end_inset 

 is performed, and ceases to be true when 
\begin_inset Formula $end\_ task$
\end_inset 

 is performed.
\layout Standard

TODO: show the full axiom and possibility predicates
\layout Subsection

The Domain
\layout Standard

TODO: explain how the example domain is encoded in the sitcalc
\layout Section

Transition Semantics
\layout Standard

In this section, the transition semantics for MIndiGolog are presented.
\layout Standard

TODO: highlight the bits that are new
\layout Subsection

MIndiGolog Transition Semantics
\layout Standard

The following gives a transition semantics for MConGolog by defining the
 operators 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

 for each of the basic program constructs.
\layout Subsubsection

Empty Proram:
\layout Standard

An empty program is represented by the literal 
\begin_inset Formula $nil$
\end_inset 

.
 There are no transitions from an empty program and such a program is always
 final.
\layout Standard


\begin_inset Formula \[
Trans(nil,s,\delta',s')\equiv False\]

\end_inset 

 
\begin_inset Formula \[
Final(nil,s)\equiv True\]

\end_inset 


\layout Subsubsection

(Concurrent) Primitive Actions 
\layout Standard

A single action term represents a valid program, which can never be a final
 configuration.
 The possible transitions for such a program depend on whether the accompanying
 situation has a least natural time point.
 If not, the only legal transition is to perform the action at some time
 
\begin_inset Formula $t$
\end_inset 

 greater than or equal to the start of the situation.
 If there is an LNTP, a legal transition can be produced in one of three
 ways:
\layout Enumerate

Perform the action at some time 
\begin_inset Formula $t$
\end_inset 

 before the LNTP, leaving an empty program and new situation
\layout Enumerate

Perform the action at the LNTP 
\begin_inset Formula $t_{n}$
\end_inset 

, concurrently with the natural actions which must occur at that time, leaving
 an empty program and new situation
\layout Enumerate

Allow the natural actions to occur at the LNTP, producing a new situation
 and leaving the program unchanged
\layout Standard


\begin_inset Formula \[
\begin{array}{ccc}
Trans(c,s,\delta',s')\equiv & \exists t_{n}.\left[lntp(s,t_{n})\wedge\right.\\
 & \exists t.t\geq start(s)\wedge t<t_{n}\wedge Poss(c,t,s)\wedge\\
 & s'=do(c,t,s)\wedge\delta'=nil\\
 &  & \vee\\
 & \exists cn.\left(\forall a.natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in cn\right)\wedge\\
 & \left[poss(c\cup cn,t_{n},s)\wedge s'=do(c\cup cn,t_{n},s)\wedge\delta'=nil\right. & \vee\\
 & \left.\left.s'=do(cn,t_{n},s)\wedge\delta'=c\right]\right]\\
 &  & \vee\\
 & \neg\exists t_{n}.lntp(s,t_{n})\wedge\exists t.\left[Poss(c,t,s)\wedge\right.\\
 & \left.t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\end{array}\]

\end_inset 

 
\newline 

\begin_inset Formula \[
Final(c,s)\equiv False\]

\end_inset 


\layout Subsubsection

Wait/test actions:
\layout Standard


\begin_inset Formula \[
Trans(\phi?,s,\delta',s')\equiv\phi[s]\wedge\delta'=nil\wedge s'=s\]

\end_inset 

 
\begin_inset Formula \[
Final(\phi?,s)\equiv False\]

\end_inset 


\layout Subsubsection

Sequence:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1};\delta_{2},s,\delta',s')\equiv & \exists\gamma\delta'=(\gamma;\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & Final(\delta_{1},s)\wedge Trans(\delta_{2},s,\delta',s')\end{eqnarray*}

\end_inset 

 
\begin_inset Formula \[
Final(\delta_{1};\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Subsubsection

Nondeterministic branch:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}|\delta_{2},s,\delta',s')\equiv & Trans(\delta_{1},s,\delta',s') & \vee\\
 & Trans(\delta_{2},s,\delta',s)\end{eqnarray*}

\end_inset 

 
\begin_inset Formula \[
Final(\delta_{1}|\delta_{2},s)\equiv Final(\delta_{1},s)\vee Final(\delta_{2},s)\]

\end_inset 


\layout Subsubsection

Nondeterministic choice of argument:
\layout Standard


\begin_inset Formula \[
Trans(\pi v.\delta,x,\delta',s)\equiv\exists x.Trans(\delta_{x}^{v},s,\delta',s')\]

\end_inset 


\begin_inset Formula \[
Final(\pi v.\delta,s)\equiv\exists x.Final(\delta_{x}^{v},s)\]

\end_inset 


\layout Subsubsection

Iteration:
\layout Standard


\begin_inset Formula \[
Trans(\delta^{*},s,\delta',s')\equiv\exists\gamma.(\delta'=\gamma;\delta^{*})\wedge Trans(\delta,s,\gamma,s')\]

\end_inset 

 
\begin_inset Formula \[
Final(\delta^{*},s)\equiv True\]

\end_inset 


\layout Subsubsection

Synchonised Conditional:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\mathbf{if}\phi\mathbf{then}\delta_{1}\mathbf{else}\delta_{2},s,\delta',s')\equiv & \phi[s]\wedge Trans(\delta_{1},s,\delta',s') & \vee\\
 & \neg\phi[s]\wedge Trans(\delta_{2},s,\delta',s')\end{eqnarray*}

\end_inset 

 
\begin_inset Formula \begin{eqnarray*}
Final(\mathbf{if}\phi\mathbf{then}\delta_{1}\mathbf{else}\delta_{2},s)\equiv & \phi[s]\wedge Final(\delta_{1},s) & \vee\\
 & \neg\phi[s]\wedge Final(\delta_{1},s)\end{eqnarray*}

\end_inset 


\layout Subsubsection

Synchronised While:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\mathbf{while}\phi\mathbf{do}\delta,s,\delta',s')\equiv & \exists\gamma.(\delta'=\gamma;\mathbf{while}\phi\mathbf{do}\delta) & \wedge\\
 & \phi[s]\wedge Trans(\delta,s,\gamma,s')\end{eqnarray*}

\end_inset 

 
\begin_inset Formula \[
Final(\mathbf{while}\phi\mathbf{do}\delta,s,\delta',s')\equiv\neg\phi[s]\wedge Final(\delta,s)\]

\end_inset 


\layout Subsubsection

Concurrent Execution:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s') & \vee\\
 & \exists c_{1},c_{2},\gamma_{1},\gamma_{2},t.Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s)) & \wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\delta'=(\gamma_{1}||\gamma_{2}) & \wedge\\
 & Poss(c_{1}\cup c_{2},t,s)\wedge s'=do(c_{1}\cup c_{2},t,s)\end{eqnarray*}

 

\end_inset 

 
\begin_inset Formula \[
Final(\delta_{1}||\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Subsubsection

Prioritised Concurrency:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}\gg\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma\gg\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}\gg\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\wedge\neg\exists\zeta,s''.Trans(\delta_{1},s,\zeta,s'')\end{eqnarray*}

\end_inset 

 
\begin_inset Formula \[
Final(\delta_{1}\gg\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Subsubsection

Concurrent Iteration:
\layout Standard


\begin_inset Formula \[
Trans(\delta^{||},s,\delta',s')\equiv\exists\gamma.\delta'=(\gamma||\delta^{||})\wedge Trans(\delta,s,\gamma,s')\]

\end_inset 

 
\begin_inset Formula \[
Final(\delta^{||},s)\equiv True\]

\end_inset 


\layout Subsection

Properties of the Semantics
\layout Standard

From the formal semantics presented above, it is possible to prove useful
 properties of the proposed language.
 In particular, we seek to prove that if a program starts in a legal situation,
 all executions of the program will produce legal situations.
\layout Standard

To show this, first notice that only two transition rules directly modify
 the situation term - execution of a primitive action, and concurrent execution.
 All other rules modify the situation term by further use of the 
\begin_inset Formula $Trans$
\end_inset 

 predicate.
 Thus, it suffices to show that these two rules will only produce legal
 situations.
 Recall the definition of 
\begin_inset Formula $legal(s)$
\end_inset 

:
\layout Standard


\begin_inset Formula \[
\begin{array}{cc}
legal(do(c,t,s))\equiv & legal(s)\wedge Poss(c,t,s)\wedge\\
 & start(s)\leq t\wedge\\
 & (\forall a,t_{a}).natural(a)\wedge Poss(a,t_{a},s)\rightarrow\\
 & \left[a\in c\vee t<t_{a}\right]\end{array}\]

\end_inset 


\layout Standard

Consider first the case of 
\begin_inset Formula $Trans(\delta_{1}||\delta_{2},s,\delta',s')$
\end_inset 

.
 The only part of interested is the conjunction which directly produces
 a modified situation 
\begin_inset Formula $s'=do(c_{1}\cup c_{2},t,s)$
\end_inset 

.
 Assuming that 
\begin_inset Formula $s$
\end_inset 

 is a legal situation, we seek to prove that 
\begin_inset Formula $s'$
\end_inset 

 must be legal.
 Assuming that all other instances of 
\begin_inset Formula $Trans$
\end_inset 

 produce legal situations, 
\begin_inset Formula $Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))$
\end_inset 

 and 
\begin_inset Formula $Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))$
\end_inset 

 will produce legal situations 
\begin_inset Formula $do(c_{1},t,s)$
\end_inset 

 and 
\begin_inset Formula $do(c_{2},t,s)$
\end_inset 

.
\layout Standard

From 
\begin_inset Formula $legal(do(c_{1},t,s))$
\end_inset 

 it can be inferred that:
\layout Standard


\begin_inset Formula \[
legal(s)\]

\end_inset 


\layout Standard


\begin_inset Formula \[
start(s)\leq t\]

\end_inset 


\layout Standard


\begin_inset Formula \[
(\forall a,t_{a}).\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c_{1}\vee t<t_{a}\right]\right]\]

\end_inset 


\layout Standard

This implies that:
\layout Standard


\begin_inset Formula \[
(\forall a,t_{a}).\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c_{1}\cup c_{2}\vee t<t_{a}\right]\right]\]

\end_inset 


\layout Standard

The definition of 
\begin_inset Formula $Trans$
\end_inset 

 further requires that:
\layout Standard


\begin_inset Formula \[
Poss(c_{1}\cup c_{2},t,s)\]

\end_inset 


\layout Standard

Thus all four conjuncts necessary prove 
\begin_inset Formula $legal(do(c_{1}\cup c_{2},t,s))$
\end_inset 

 are true, and this rule generates only legal situations.
\layout Standard

Turning attention to the 
\begin_inset Formula $Trans$
\end_inset 

 rule for primitive actions there are four disjuncts to consider, each of
 which may produce a new situation term.
 The first requires that:
\layout Standard


\begin_inset Formula \[
\exists t_{n}.\left[lntp(s,t_{n})\wedge\exists t.\left[t\geq start(s)\wedge t<t_{n}\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\right]\]

\end_inset 


\layout Standard

From this it is immediately clear that:
\layout Standard


\begin_inset Formula \[
start(s)\leq t\]

\end_inset 


\layout Standard


\begin_inset Formula \[
Poss(c,t,s)\]

\end_inset 


\layout Standard

Using the definition of 
\begin_inset Formula $lntp(s,t_{n})$
\end_inset 

:
\layout Standard


\begin_inset Formula \[
\exists a\left[natural(a)\wedge Poss(a,t_{n},s)\right]\wedge\forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t_{n}\leq t_{a}\right]\]

\end_inset 


\layout Standard

Since 
\begin_inset Formula $t<t_{n}$
\end_inset 

, this gives:
\layout Standard


\begin_inset Formula \[
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow a\in c\vee t\leq t_{a}\right]\]

\end_inset 


\layout Standard

Assuming 
\begin_inset Formula $legal(s)$
\end_inset 

, these conjuncts are sufficient to establish 
\begin_inset Formula $legal(do(c,t,s))$
\end_inset 

.
 The next disjunct requires that:
\layout Standard


\begin_inset Formula \[
\exists t_{n}.\left[lntp(s,t_{n})\wedge\exists cn.\left(\forall a.natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in cn\right)\wedge Poss(c\cup cn,t_{n},s)\wedge s'=do(c\cup cn,t_{n},s)\wedge\delta'=nil\right]\]

\end_inset 


\layout Standard

Using this along with the definition of LNTP, it is clear that:
\layout Standard


\begin_inset Formula \[
Poss(c\cup cn,t_{n},s)\]

\end_inset 


\layout Standard


\begin_inset Formula \[
start(s)\leq t_{n}\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in cn\,\,\wedge\,\, natural(a)\wedge Poss(a,t_{a},s)\rightarrow t_{n}\leq t_{a}\right]\]

\end_inset 


\layout Standard

The last of which yields:
\layout Standard


\begin_inset Formula \[
\forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow c\in c\cup cn\vee t_{n}\leq t_{a}\right]\]

\end_inset 


\layout Standard

Again, all conjuncts necessary to prove 
\begin_inset Formula $legal(do(c\cup cn,t_{n},s))$
\end_inset 

 are true.
\layout Standard

TODO: finish this proof and clean it up *a lot*
\layout Section

Execution Model
\layout Standard

TODO: make some suggestions!
\layout Standard

TODO: Independent Execution? DCOP+ADOPT? Distributed CIAO?
\layout Section

Discussion
\layout Section

Conclusion
\layout Section

References
\layout Standard


\begin_inset LatexCommand \BibTeX[plain]{/storage/uni/pgrad/library/references}

\end_inset 


\the_end
