#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass IEEEtran
\options letterpaper
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
High-Level Program Execution for Multi-Agent Teams
\end_layout

\begin_layout Author
Ryan Kelly and Adrian Pearces
\end_layout

\begin_layout Abstract
We present MIndiGolog, a promising approach to programming multi-agent teams
 based on high-level program execution.
 While the concept of high-level program execution, as embodied by the programmi
ng language Golog, has recently arisen as a practical alternative to traditional
 planning for single-agent systems, several challenges are encountered when
 moving to a multi-agent setting.
 We introduce the following enhancements to make Golog more suitable for
 multi-agent teams: integration of true concurrency of actions with the
 interleaved concurrency of ConGolog; incorporation of an explicit notion
 of time to enrich the world model and assist coordination; and tight integratio
n of predictable exogenous actions (often called 
\begin_inset Quotes eld
\end_inset

natural actions
\begin_inset Quotes erd
\end_inset

) into the semantics of the language.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
As described in 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

, 
\emph on
high-level program execution
\emph default
 is emerging as a practical alternative to traditional plan synthesis.
 By 
\begin_inset Quotes eld
\end_inset

high-level program
\begin_inset Quotes erd
\end_inset

 is meant a program whose primitive operations are domain-specific actions,
 and which may be incompletely specified due to nondeterministic constructs.
 Rather than a planner finding a sequence of actions leading from an initial
 state to some goal state, the task is to find a sequence of actions which
 constitute an execution of this program.
\end_layout

\begin_layout Standard
This task can range from executing a fully-specified program to synthesizing
 an action sequence from a completely nondeterministic program, thus subsuming
 both deterministic agent programming and traditional planning.
 The primary advantage of this approach is 
\emph on
controlled nondeterminism
\emph default
, allowing some aspects of the program to remain unspecified while avoiding
 an exponential increase in planning difficulty for large programs.
 One very successful application of this technique is the Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

 family of programming languages, which have provided clear benefits for
 single-agent programming that include: the ability to control the amount
 of nondeterminism; sophisticated symbolic reasoning about the world; and
 formal verification of program properties, in some cases using automated
 tools.
\end_layout

\begin_layout Standard
When a team of agents must cooperate closely in order to achieve some shared
 goal, they can often be conceptualized as a single agent with distributed
 sensing, reasoning and acting capabilities.
 Behaviors and goals are naturally ascribed to the team rather than to individua
l members.
 This suggests high-level program execution as an attractive approach, potential
ly providing the benefits described above for applications involving multi-agent
 teams.
\end_layout

\begin_layout Standard
Pursuant to this goal, we combine several existing extensions to the Golog
 language to make it suitable for representing multi-agent teams.
 Key among these is the notion of true concurrency of actions, which we
 combine with the interleaved concurrency found in the language ConGolog
 to give a flexible account of concurrent execution.
 An explicit notion of time is incorporated, both to enrich the world model
 and to assist in coordination between agents.
 The concept of natural actions is also tightly integrated into the language,
 to allow agents to predict the behavior of each other and their environment.
 We name the resulting language 
\begin_inset Quotes eld
\end_inset

MIndiGolog
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Quotes eld
\end_inset

Multi-Agent IndiGolog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
The Situation Calculus and Golog
\end_layout

\begin_layout Standard
The representation of a dynamic world in the situation calculus consists
 of first-order logic statements modeling the world in terms of actions,
 situations, and fluents.
 For space reasons only a brief overview is given here.
 A detailed treatment is available in 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
\end_layout

\begin_layout Standard

\emph on
Actions
\emph default
 are function terms in the logic denoting the ways in which the state of
 the world can be changed.
 The evolution of the world is handled using 
\emph on
situations
\emph default
, which are histories of actions that have been performed.
 The initial situation is represented by the term 
\begin_inset Formula $S_{0}$
\end_inset

, and terms representing other situations are constructed using the function
 
\begin_inset Formula $do(a,s)$
\end_inset

 which represents the situation resulting from performing action 
\begin_inset Formula $a$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset

.
 Properties of the world are described by 
\emph on
fluents
\emph default
, which are functions or predicates taking a situation as their final argument.
 The conditions under which an action can be performed are given in terms
 of the 
\emph on
possibility fluent
\emph default
 
\begin_inset Formula $Poss(a,s)$
\end_inset

.
 The truth values of fluents are specified by defining what is true in the
 initial situation, and collecting the effects of various actions into 
\emph on
successor state axioms
\emph default
 characterizing how they change from one situation to the next.
\end_layout

\begin_layout Standard
Formally, a dynamic world is described using a 
\emph on
theory of action
\emph default
 
\begin_inset Formula $\mathcal{D}$
\end_inset

, a collection of (mostly) first-order axioms describing how the world behaves.
 It contains axioms describing: the foundational axioms of the calculus;
 action precondition axioms; successor state axioms; unique names axioms
 for actions; and a description of the initial situation: 
\begin_inset Formula \begin{equation}
\mathcal{D}=\Sigma\cup\mathcal{D}_{ap}\cup\mathcal{D}_{ss}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}\label{eqn:sc_action_theory}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Statements about the world are then evaluated relative to this theory of
 action.
\end_layout

\begin_layout Standard
Golog is a declarative agent programming language based on the situation
 calculus, developed by 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

.
 Testimony to its success are its wide range of applications and many extensions
 to provide additional functionality, some of which will be discussed below.
 In this paper we use the term 
\begin_inset Quotes eld
\end_inset

Golog
\begin_inset Quotes erd
\end_inset

 to refer to the family of languages based on this technique.
\end_layout

\begin_layout Standard
To program an agent using Golog one specifies a situation calculus theory
 of action, and a program consisting of actions from the world connected
 using programming constructs such as if-then-else, while loops, and nondetermin
istic choice.
 Table 
\begin_inset LatexCommand \ref{tbl:Golog-Operators}

\end_inset

 lists some of the operators available in various incarnations of the language.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement t
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Operator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Meaning
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\phi?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Proceed only if condition 
\begin_inset Formula $\phi$
\end_inset

 is true
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1};\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute program 
\begin_inset Formula $\delta_{1}$
\end_inset

followed by 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}|\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute either 
\begin_inset Formula $\delta_{1}$
\end_inset

 or 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\pi(x)\delta(x)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nondet.
 select arguments for 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 zero or more times
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Exec.
 
\begin_inset Formula $\delta_{1}$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 holds, 
\begin_inset Formula $\delta_{2}$
\end_inset

 otherwise
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{while\,}\phi\mathbf{\, do}\,\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 while 
\begin_inset Formula $\phi$
\end_inset

 holds
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Concurrently execute 
\begin_inset Formula $\delta_{1}$
\end_inset

and 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\Sigma\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Find and perform legal exec.
 of 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Procedure definition
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
Some Golog Operators
\begin_inset LatexCommand \label{tbl:Golog-Operators}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In line with the idea of high-level program execution, the agent's control
 program may be nondeterministic.
 It is the task of the agent to find a deterministic instantiation of the
 program, a sequence of actions that can legally be performed in the world.
 Such a sequence is called a 
\begin_inset Quotes eld
\end_inset

legal execution
\begin_inset Quotes erd
\end_inset

 of the Golog program.
\end_layout

\begin_layout Standard
The semantics of the Golog operators are typically defined recursively using
 logical formulae.
 The most flexible semantics have proven to be the transition semantics
 introduced with the extension ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset

 to allow concurrent execution of several programs.
 Two predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 are defined for each operator.
 Intuitively, 
\begin_inset Formula $Trans(\delta,s,\delta',s')$
\end_inset

 is true precisely when executing a single step of program 
\begin_inset Formula $\delta$
\end_inset

 can cause the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to situation 
\begin_inset Formula $s'$
\end_inset

, after which 
\begin_inset Formula $\delta'$
\end_inset

 remains to be executed.
 It thus characterizes single steps of computation.
 
\begin_inset Formula $Final(\delta,s)$
\end_inset

 is true when program 
\begin_inset Formula $\delta$
\end_inset

 may legally terminate its execution in situation 
\begin_inset Formula $s$
\end_inset

.
 For example, equation (
\begin_inset LatexCommand \ref{eqn:trans_conc_orig}

\end_inset

) characterizes transition for the concurrent execution construct of ConGolog:
 
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow the convention that lower-case free variables are implicitly universal
ly quantified
\end_layout

\end_inset

 
\begin_inset Formula \begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\label{eqn:trans_conc_orig}\\
\shoveright{\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\vee\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\end{multline}

\end_inset


\end_layout

\begin_layout Standard
In words, this states that it is possible to single-step the concurrent
 execution of 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

 by performing either a step from 
\begin_inset Formula $\delta_{1}$
\end_inset

 or a step from 
\begin_inset Formula $\delta_{2}$
\end_inset

, with the remainder 
\begin_inset Formula $\gamma$
\end_inset

 left to execute concurrently with the other program.
 It thus specifies concurrent execution as the interleaving of steps from
 the two programs.
\end_layout

\begin_layout Standard
The original Golog was conceived as on offline planner - the agent determines
 a complete legal execution of the program before any actions are performed
 in the world.
 If the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

 is enriched with 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

, this is a theorem proving task to find a suitable situation 
\begin_inset Formula $s$
\end_inset

: 
\begin_inset Formula \begin{equation}
\mathcal{D}\models\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]\label{eqn:golog_execution}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Here 
\begin_inset Formula $Trans*$
\end_inset

 is the reflexive transitive closure of 
\begin_inset Formula $Trans$
\end_inset

, or at least a first-order approximation thereof.
 While this guarantees that a legal execution will be found if possible,
 it can be impractical for large programs and cannot account for unexpected
 occurrences or information obtained from run-time sensing.
 IndiGolog 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

 is an extension that allows planning to be interleaved with performing
 the actions in the world.
\end_layout

\begin_layout Standard
As an example, consider a program 
\begin_inset Formula $MakeSalad$
\end_inset

 that instructs a team of agents to prepare a simple salad.
 
\begin_inset Formula \begin{multline}
\mathbf{proc}\, MakeSalad(dest)\label{eqn:MakeSalad}\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)\left[acquire(agt,dest)\,;\right.\\
\shoveright{begin\_task(agt,mix(dest,1))\,;\quad}\\
\shoveright{end\_task(agt,mix(dest,1))\,;\quad}\\
\left.release(agt,dest)\right]\,\,\mathbf{end}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
The procedure 
\begin_inset Formula $ChopTypeInto$
\end_inset

 (not shown) picks an object of the given type and an available chopping
 board, chops the object using the board, then transfers it into the destination
 container.
 
\begin_inset Formula $MakeSalad$
\end_inset

 tells the agents to do this for a lettuce, a carrot and a tomato, then
 mix the ingredients together for 1 minute.
 The agent assigned to handling each ingredient is not specified (
\begin_inset Formula $\pi$
\end_inset

 construct), nor is the order in which they should be added (
\begin_inset Formula $||$
\end_inset

 construct).
\end_layout

\begin_layout Standard
While this program could be executed using the existing semantics of ConGolog
 or IndiGolog, the result would be suboptimal.
 As these languages lack true concurrency, only a single agent could act
 at each step.
 Predictable exogenous actions such as 
\begin_inset Formula $end\_task$
\end_inset

 also require special handling in these languages.
 MIndiGolog is designed to produce executions of such programs that are
 more suitable for multi-agent teams.
\end_layout

\begin_layout Section
MIndiGolog Semantics
\end_layout

\begin_layout Standard
We have integrated three extensions to the situation calculus with the semantics
 of ConGolog and IndiGolog to overcome challenges encountered when moving
 to a multi-agent setting.
 These extensions allow the agents to represent time, concurrently-occurring
 actions, and natural actions.
\end_layout

\begin_layout Subsubsection
Time:
\end_layout

\begin_layout Standard
An explicit notion of time can make coordination between agents easier,
 as joint actions may be performed at a particular time.
 It also allows a richer description of the world - for example, it becomes
 possible to specify that cake must be baked for 30 minutes.
\end_layout

\begin_layout Standard
Several authors have successfully incorporated a temporal component into
 the situation calculus, notably 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

.
 We follow the ideas of Reiter but, to avoid complications with concurrent
 actions, we attach an explicit occurrence time to each situation rather
 than each action.
\end_layout

\begin_layout Standard
The successor situation function 
\begin_inset Formula $do(a,s)$
\end_inset

 becomes 
\begin_inset Formula $do(a,t,s)$
\end_inset

, to indicate 
\begin_inset Quotes eld
\end_inset

action 
\begin_inset Formula $a$
\end_inset

 was performed at time 
\begin_inset Formula $t$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Likewise, the possibility predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 becomes 
\begin_inset Formula $Poss(a,t,s)$
\end_inset

, meaning 
\begin_inset Quotes eld
\end_inset

it is possible to perform action 
\begin_inset Formula $a$
\end_inset

 at time 
\begin_inset Formula $t$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The existing semantics of IndiGolog are trivially modified to accommodate
 this.
 Time may be represented by any appropriately-behaved sequence (e.g.
 reals, integers), and no commitment is made about the starting time of
 
\begin_inset Formula $S_{0}$
\end_inset

.
 The function 
\begin_inset Formula $start(s)$
\end_inset

 is added to give the starting time of other situations: 
\begin_inset Formula \begin{equation}
start(do(a,t,s))=t\label{eqn:sit_start}\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
Concurrency:
\end_layout

\begin_layout Standard
For multi-agent teams, concurrency refers to two distinct ideas - the possibilit
y of performing several actions at the same instant, and the possibility
 of interleaving the execution of several high-level programs.
 These are referred to as 
\emph on
true concurrency
\emph default
 and 
\emph on
interleaved concurrency
\emph default
 respectively.
\end_layout

\begin_layout Standard
The work of 
\begin_inset LatexCommand \cite{lin92sc_conc,reiter96sc_nat_conc}

\end_inset

 provides an extension to the situation calculus that allows several primitive
 actions to occur at the same time.
 Action terms are replaced with sets of actions to be performed simultaneously.
 All functions and predicates that take an action are modified to accept
 sets of actions instead.
 For example, 
\begin_inset Formula $do$
\end_inset

 and 
\begin_inset Formula $Poss$
\end_inset

 become 
\begin_inset Formula $do(\{ a_{1},a_{2},...\},t,s)$
\end_inset

 and 
\begin_inset Formula $Poss(\{ a_{1},a_{2},...\},t,s)$
\end_inset

.
\end_layout

\begin_layout Standard
As mentioned earlier, concurrent execution of multiple programs was developed
 in the language ConGolog with the concurrency operator 
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset

.
 These two notions of concurrency were combined by 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

, who modified ConGolog to incorporate sets of concurrent actions.
 We follow a similar approach, but place additional restrictions on the
 semantics to ensure that programs are well-behaved and to incorporate an
 account of time.
\end_layout

\begin_layout Standard
While it is straightforward to modify the clause of 
\begin_inset Formula $Trans$
\end_inset

 for primitive actions to accept sets of concurrent actions, there are deeper
 implications for the concurrency operator.
 In ConGolog/IndiGolog it is implemented by accepting a transition from
 either of the two programs as a transition for the pair (equation 
\begin_inset LatexCommand \ref{eqn:trans_conc_orig}

\end_inset

).
 In the presence of true concurrency, this is insufficient.
 Suppose program 
\begin_inset Formula $\delta_{1}$
\end_inset

 may be transitioned by performing actions 
\begin_inset Formula $c_{1}$
\end_inset

, and 
\begin_inset Formula $\delta_{2}$
\end_inset

 may be transitioned by performing actions 
\begin_inset Formula $c_{2}$
\end_inset

.
 The potential for true concurrency should be exploited by performing both
 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $c_{2}$
\end_inset

 simultaneously, i.e.
 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
This approach introduces several complications.
 First, the combination of actions 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 is not guaranteed to be possible even if the individual actions are.
 For example, an agent may not perform two actions at once, or two agents
 may not be able to acquire the same resource at the same time.
 This is known as the precondition interaction problem 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and is an area of ongoing research.
\end_layout

\begin_layout Standard
For our purposes this is addressed by introducing a predicate 
\begin_inset Formula $Conflicts(c,t,s)$
\end_inset

 which is true when the actions in 
\begin_inset Formula $c$
\end_inset

 are in conflict and cannot be performed together.
 The possibility axiom for concurrent actions is then: 
\begin_inset Formula \begin{multline}
Poss(c,t,s)\equiv\label{eqn:poss_conc_acts}\\
\forall a\left[a\in c\rightarrow Poss(a,t,s)\right]\wedge\neg Conflicts(c,t,s)\end{multline}

\end_inset


\end_layout

\begin_layout Standard
Another issue arises when two programs can legitimately be transitioned
 by executing the same action.
 Consider the following programs which add ingredients to a bowl: 
\begin_inset Formula \begin{multline}
\delta_{1}=place\_in(Thomas,Flour,Bowl)\,;\\
\shoveright{place\_in(Thomas,Sugar,Bowl)}\\
\shoveleft{\delta_{2}=place\_in(Thomas,Flour,Bowl)\,;}\\
place\_in(Thomas,Egg,Bowl)\end{multline}

\end_inset


\end_layout

\begin_layout Standard
Executing 
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset

 should result in the bowl containing two units of flour, one unit of sugar
 and an egg.
 However, individual transitions for both programs are 
\begin_inset Formula $c_{1}=c_{2}=place\_in(Thomas,Flour,Bowl)$
\end_inset

.
 Naively executing 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 for the combination would add only one unit of flour.
 Alternately, consider two programs waiting for a timer to ring (a natural
 action, not initiated by any agent): 
\begin_inset Formula \begin{multline}
\delta_{1}=ring\_timer(OvenTimer)\,;\\
\shoveright{acquire(Thomas,Bowl)}\\
\shoveleft{\delta_{2}=ring\_timer(OvenTimer)\,;}\\
acquire(Richard,Board)\end{multline}

\end_inset


\end_layout

\begin_layout Standard
Both programs should be allowed to proceed with a single occurrence of the
 
\begin_inset Formula $ring\_timer$
\end_inset

 action.
 Thus to ensure consistency, concurrent execution must not be allowed to
 transition both programs through the occurrence of the same 
\emph on
agent-initiated
\emph default
 action.
 If-then-else or choice operators should be used to allow agent-initiated
 actions to be skipped if they are not necessary.
\end_layout

\begin_layout Standard
Taking these factors into account, we derive an improved transition rule
 for concurrency are follows: 
\begin_inset Formula \begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\label{eqn:trans_conc_new}\\
\shoveright{\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))}\\
\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\\
\wedge Poss(c_{1}\cup c_{2},t,s)\\
\wedge\forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Natural(a)\right]\\
\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\end{multline}

\end_inset


\end_layout

\begin_layout Standard
The first two lines are the original interleaved concurrency clause from
 ConGolog, while the remainder characterizes the above considerations for
 true concurrency.
 This robust combination allows the language to more accurately reflect
 the concurrency present in multi-agent teams.
\end_layout

\begin_layout Subsubsection
Natural Actions:
\end_layout

\begin_layout Standard
These are a special class of exogenous actions, those actions which occur
 outside of an agent's control.
 Introduced to the situation calculus by 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and expanded by 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

, they are classified according to the following requirement: natural actions
 must occur at their predicted times, provided no earlier actions prevent
 them from occurring.
 For example, a timer will ring at the time it was set for, unless it is
 switched off.
 They are especially important in a multi-agent context for predicting the
 behavior of other agents, such as when they will finish a particular long-runni
ng task.
\end_layout

\begin_layout Standard
The methodology of Reiter is adopted, suitably modified for our handling
 of time.
 Natural actions are indicated by the truth of the predicate 
\begin_inset Formula $Natural(a)$
\end_inset

.
 As usual, the times at which natural actions may occur are specified by
 the 
\begin_inset Formula $Poss$
\end_inset

 predicate.
 For example, suppose that the fluent 
\begin_inset Formula $Timer\_Set(ID,m,s)$
\end_inset

 represents the fact that a particular timer is set to ring in 
\begin_inset Formula $m$
\end_inset

 minutes in situation 
\begin_inset Formula $s$
\end_inset

.
 The possibility predicate for the 
\begin_inset Formula $ring\_timer(ID)$
\end_inset

 action would be: 
\begin_inset Formula \begin{multline}
Poss(ring\_timer(ID),t,s)\equiv\\
\exists m.\left[Timer\_Set(ID,m,s)\wedge t=start(s)+m\right]\end{multline}

\end_inset


\end_layout

\begin_layout Standard
An important concept when dealing with natural actions it the least natural
 time point (LNTP) of a situation.
 This is defined as the earliest time at which a natural action may occur:
 
\begin_inset Formula \begin{multline}
Lntp(s,t)\equiv\exists a\left[Natural(a)\wedge Poss(a,t,s)\right]\wedge\label{eqn:lntp_def}\\
\forall a,t_{a}\left[Natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]\end{multline}

\end_inset


\end_layout

\begin_layout Standard
Note that the LNTP need not exist for a given situation.
 We will assume that the domain axiomatisation is designed to avoid certain
 pathological cases, so that absence of an LNTP implies that no natural
 actions are possible.
\end_layout

\begin_layout Standard
To enforce the requirement that natural actions must occur when possible,
 a predicate 
\begin_inset Formula $Legal(s)$
\end_inset

 is introduced which is true only for situations which respect this requirement
 (assuming no precondition interaction among natural actions).
 Legal situations are the only situations that could actually be brought
 about in the real world: 
\begin_inset Formula \begin{multline}
Legal(S_{0})\equiv True\label{eqn:legal_def}\\
\shoveleft{Legal(do(c,t,s))\equiv}\\
Legal(s)\wedge Poss(c,t,s)\wedge start(s)\leq t\,\wedge\\
\forall a,t_{a}.\, Natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c\vee t<t_{a}\right]\end{multline}

\end_inset


\end_layout

\begin_layout Standard
While planning with natural actions has previously been done in Golog 
\begin_inset LatexCommand \cite{pirri00planning_nat_acts}

\end_inset

, the programmer was required to explicitly check for the possible occurrence
 of natural actions and ensure that executions of the program resulted in
 legal situations.
 Our integration significantly lowers the burden on the programmer by guaranteei
ng that all program executions produce legal situations.
 MIndiGolog agents will plan for the occurrence of natural actions without
 having them explicitly mentioned in the program.
 They may optionally be included in the program, instructing the agents
 to wait for the action to occur before proceeding.
\end_layout

\begin_layout Standard
This is achieved using a new 
\begin_inset Formula $Trans$
\end_inset

 clause for programs consisting of a single action 
\begin_inset Formula $c$
\end_inset

, shown in equation (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

).
 If 
\begin_inset Formula $s$
\end_inset

 has an LNTP 
\begin_inset Formula $t_{n}$
\end_inset

 and corresponding set of natural actions 
\begin_inset Formula $c_{n}$
\end_inset

, a transition can be made in three ways: perform 
\begin_inset Formula $c$
\end_inset

 at a time before 
\begin_inset Formula $t_{n}$
\end_inset

 (third line), perform it along with the natural actions at 
\begin_inset Formula $t_{n}$
\end_inset

 (fourth line), or wait for the natural actions to occur (fifth line).
 If there is no LNTP, then 
\begin_inset Formula $c$
\end_inset

 may be performed at any time greater than 
\begin_inset Formula $start(s)$
\end_inset

.
 
\begin_inset Formula \begin{multline}
Trans(c,s,\delta',s')\equiv\label{eqn:trans_prim_new}\\
\exists t,t_{n},c_{n}.\, Lntp(s,t_{n})\wedge t\geq start(s)\wedge\\
\forall a.\left[\, Natural(a)\wedge Poss(a,t_{n},s)\equiv c\in c_{n}\right]\wedge\\
\left[t<t_{n}\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=Nil\right.\\
\vee Poss(c\cup c_{n},t_{n},s)\wedge s'=do(c\cup c_{n},t,s)\wedge\delta'=Nil\\
\vee\left.s'=do(c_{n},t_{n},s)\wedge\delta'=c\right]\\
\vee\,\neg\exists t_{n}.\, Lntp(s,t_{n})\wedge\exists t.\, Poss(c,t,s)\wedge\\
t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=Nil\end{multline}

\end_inset


\end_layout

\begin_layout Subsubsection
MIndiGolog:
\end_layout

\begin_layout Standard
Let a 
\emph on
MIndiGolog Theory of Action
\emph default
 be a theory of action in the situation calculus enhanced with time, true
 concurrency and natural actions, augmented with the predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 from IndiGolog, modified according to equations (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

).
 IndiGolog programs can be executed relative to this theory of action as
 in equation (
\begin_inset LatexCommand \ref{eqn:golog_execution}

\end_inset

), and the resulting legal executions will be suitable for execution by
 multi-agent teams.
 In particular, all legal executions of a MIndiGolog program produce legal
 situations:
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $\mathcal{D}$
\end_inset

 be a MIndiGolog theory of action.
 Then: 
\begin_inset Formula \begin{multline*}
\mathcal{D}\models\forall s,s',\delta,\delta'.Legal(s)\wedge Trans(\delta,s,\delta',s')\\
\rightarrow Legal(s')\end{multline*}

\end_inset


\end_layout

\begin_layout Proof
By induction on the structure of 
\begin_inset Formula $\delta$
\end_inset

.
 Consider first the base case of a single concurrent action 
\begin_inset Formula $\delta=c$
\end_inset

.
 This 
\begin_inset Formula $Trans$
\end_inset

 clause (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

) has four disjuncts.
 We treat here only the case where actions are performed before the LNTP,
 other cases employ similar reasoning.
 Assuming this case, (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

) reduces to: 
\begin_inset Formula \begin{multline*}
Trans(c,s,Nil,do(c,t,s))\equiv\exists t_{n}.Lntp(s,t_{n})\wedge\\
t<t_{n}\wedge ti\geq start(s)\wedge Poss(c,t,s)\end{multline*}

\end_inset

 By the definition of 
\begin_inset Formula $Lntp$
\end_inset

 (
\begin_inset LatexCommand \ref{eqn:lntp_def}

\end_inset

) and given 
\begin_inset Formula $t<t_{n}$
\end_inset

, no natural actions can be possible before or at time 
\begin_inset Formula $t$
\end_inset

, allowing us to add: 
\begin_inset Formula \begin{multline*}
Trans(c,s,Nil,do(c,t,s))\equiv\exists t_{n}.Lntp(s,t_{n})\wedge\\
t<t_{n}\wedge t\geq start(s)\wedge Poss(c,t,s)\wedge\\
\forall a,t_{a}\left[Natural(a)\wedge Poss(a,t_{a},s)\rightarrow t<t_{a}\right]\end{multline*}

\end_inset

 Given 
\begin_inset Formula $Legal(s)$
\end_inset

 and equation (
\begin_inset LatexCommand \ref{eqn:legal_def}

\end_inset

), it is then clear that for this case: 
\begin_inset Formula \begin{multline*}
\mathcal{D}\models Legal(s)\wedge Trans(c,s,Nil,do(c,t,s))\\
\rightarrow Legal(do(c,t,s))\end{multline*}

\end_inset

 Next consider the case of concurrent execution of two programs.
 The 
\begin_inset Formula $Trans$
\end_inset

 clause for concurrency (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

) only introduces a new situation term when both sub-programs transition
 simultaneously, with other cases trivially handled by the inductive hypothesis.
 Assuming this case, (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

) reduces to: 
\begin_inset Formula \begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\\
Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\,\wedge\\
Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\\
Poss(c_{1}\cup c_{2},t,s)\,\wedge\\
\forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Natural(a)\right]\,\wedge\\
\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\end{multline*}

\end_inset

 Both 
\begin_inset Formula $do(c_{1},t,s)$
\end_inset

 and 
\begin_inset Formula $do(c_{2},t,s)$
\end_inset

 will be legal by the inductive hypothesis, hence 
\begin_inset Formula $start(s)\leq t$
\end_inset

 and both 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $c_{2}$
\end_inset

 contain any required natural actions.
 Since 
\begin_inset Formula $Trans$
\end_inset

 requires that 
\begin_inset Formula $Poss(c_{1}\cup c_{2},t,s)$
\end_inset

 all conjuncts in equation (
\begin_inset LatexCommand \ref{eqn:legal_def}

\end_inset

) are satisfied, and: 
\begin_inset Formula \[
\mathcal{D}\models Legal(s)\wedge Trans(\delta_{1}||\delta_{2},s,\delta,s'))\rightarrow Legal(s')\]

\end_inset

 No other 
\begin_inset Formula $Trans$
\end_inset

 clauses introduce new situation terms, making the remaining induction trivial.
 
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $\mathcal{D}$
\end_inset

 be a MIndiGolog theory of action.
 Then: 
\begin_inset Formula \[
\mathcal{D}\models\forall s',\delta,\delta'.\, Trans*(\delta,S_{0},\delta',s')\rightarrow Legal(s')\]

\end_inset

 Consequently, all legal executions of a MIndiGolog program respect the
 occurrence of natural actions.
 
\end_layout

\begin_layout Proof
Immediate from Theorem 
\begin_inset LatexCommand \ref{thm:trans_legal}

\end_inset

, the legality of 
\begin_inset Formula $S_{0}$
\end_inset

, and the properties of transitive closure.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide true
sideways false
status open

\begin_layout Standard
 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
centering
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset

 
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "50line%"
special "none"
height "0pt"
height_special "none"
status open

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/output_makeSalad_1.txt}
preview false

\end_inset

 
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "45line%"
special "none"
height "0pt"
height_special "none"
status open

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/output_makeSalad_2.txt}
preview false

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\end_layout

\begin_layout Caption
One possible execution of the 
\begin_inset Formula $MakeSalad$
\end_inset

 program with three agents.
 Variables 
\begin_inset Formula $\_U$
\end_inset

, 
\begin_inset Formula $\_T$
\end_inset

, etc give the occurrence times of each action, constrained to ensure all
 situations are legal.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{cap:example_trace}

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The effect of our enhancements can be seen in Figure 
\begin_inset LatexCommand \ref{cap:example_trace}

\end_inset

, which shows one possible legal execution of the 
\begin_inset Formula $MakeSalad$
\end_inset

 program (
\begin_inset LatexCommand \ref{eqn:MakeSalad}

\end_inset

).
 Notice the occurrence of several actions within each 
\series bold
do
\series default
 statement, demonstrating the integration of true concurrency into the language.
 Note also the explicit occurrence time for each step, allowing the agents
 to properly synchronize their actions.
 This time is not fixed, but constrained to synchronize with the natural
 actions included in the program.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Standard
The utility of the high-level program execution paradigm is highlighted
 by the many extensions which have been developed for the base Golog language.
 Prominent among these are the already mentioned 
\emph on
ConGolog
\emph default
 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset

 and 
\emph on
IndiGolog
\emph default
 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

 Another useful extension is 
\emph on
DTGolog
\emph default
 
\begin_inset LatexCommand \cite{boutilier00dtgolog}

\end_inset

, which combines the situation calculus with Markov Decision Processes to
 allow agents to determine the optimal execution of a program in the face
 of probabilistic action outcomes.
\end_layout

\begin_layout Standard
There has also been work on extending the situation calculus to allow richer
 world models, notably that of Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and Reiter 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

.
 However, the incorporation of such enrichments with extensions to Golog
 remains a topic of ongoing work.
 It is at this crossroads that MIndiGolog is positioned.
 It combines the collective capabilities of several of these extensions
 to represent and program the behavior of multi-agent teams.
\end_layout

\begin_layout Standard
While work with Golog has predominantly focused on single-agent systems,
 there have been several notable applications of the technique to multi-agent
 systems.
 The Cognitive Agent Specification Language 
\begin_inset LatexCommand \cite{shapiro02casl}

\end_inset

 uses ConGolog to describe the behavior of agents in a multi-agent setting,
 and an automated theorem prover is in development that can verify properties
 of the programs.
 It differs from our work in that it is designed for open multi-agent systems,
 with each agent having its own Golog program defining its individual behavior.
 By contrast, we seek to develop a single Golog program that is cooperatively
 executed by all agents.
 It also appears to focus on modeling and simulation of agent systems more
 than actually executing the programs.
\end_layout

\begin_layout Standard
Closer to the spirit of this paper is the work of 
\begin_inset LatexCommand \cite{Ferrein2005readylog}

\end_inset

 on ReadyLog, a Golog derivative designed for highly dynamic domains.
 It has been successfully used to control multi-agent teams in the RoboCup
 soccer tournament by having the agents execute a shared Golog program.
 ReadyLog agents each individually determine a legal execution of the program,
 allowing them to coordinate without communication.
 We aim to allow the agents to communicate and pool their computational
 resources in planning an execution.
 ReadyLog integrates the facilities of concurrency, online execution and
 decision theory and can be seen as a unification of ConGolog, IndiGolog
 and DTGolog.
 We believe our enhancements to be compatible with and complimentary to
 this work.
\end_layout

\begin_layout Standard
It should be noted that our work does not treat many higher-level concepts
 relevant to teamwork, such as team formation and the development of joint
 goals and intentions.
 MIndiGolog programs allow a given team of agents to plan the performance
 of a specific task.
 We believe the approach to be complimentary to the wide variety of formalisms
 for modeling and programming higher-level aspects of teamwork.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
In this paper, we have integrated of several important extensions to the
 situation calculus and Golog to provide a new language suitable for expressing
 high-level programs for multi-agent teams.
 Specifically, MIndiGolog combines both true and interleaved concurrency,
 an explicit account of time, and seamless integration of natural actions.
\end_layout

\begin_layout Standard
Since planning a legal execution in MIndiGolog is a theorem-proving task,
 existing tools for distributed logic programming can be used to allow a
 team of agents to share the planning workload.
 Preliminary tests using the distributed programming capabilities of the
 Oz language 
\begin_inset LatexCommand \cite{schulte00oz_parallel}

\end_inset

 have yielded promising results.
 We are presently exploring the potential of this approach for a range of
 distributed programming applications, and the integration of additional
 techniques from the Golog community.
 Key among these is the significant work on representing knowledge and belief
 in Golog.
 As many applications involve partially observable worlds, different agents
 must be capable of having different beliefs about the world.
 This will in turn require more complex strategies for sharing the planning
 workload.
\end_layout

\begin_layout Standard
As we have shown, the combination of state-of-the-art techniques from Golog
 is highly capable of representing tasks and behavior for multi-agent teams.
 Combined with facilities for distributed logic programming, MIndiGolog
 promises to provide the advantages of the high-level program execution
 paradigm for multi-agent teams.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex{/storage/uni/pgrad/library/references}

\end_inset

 
\end_layout

\end_body
\end_document
