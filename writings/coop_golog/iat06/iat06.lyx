#LyX 1.4.2 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass latex8
\begin_preamble
\usepackage{calc}
\usepackage{subfigure}
\usepackage{latex8}
\usepackage{times}
\usepackage{amsthm}
\newtheorem{lemma}{Lemma}
\newtheorem{thm}{Theorem}
\end_preamble
\options times, 10pt, twocolumn
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\paperwidth 0cm
\paperheight 0cm
\leftmargin 0cm
\topmargin 0cm
\rightmargin 0cm
\bottommargin 0cm
\headheight 0cm
\headsep 0cm
\footskip 0cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
Towards High-Level Programming for Distributed Problem Solving
\end_layout

\begin_layout Author
Ryan F.
 Kelly and Adrian R.
 Pearce
\newline
 NICTA Victoria Laboratory
\newline
 Department of Computer Science and Software
 Engineering
\newline
 The University of Melbourne
\newline
 Victoria, 3010, Australia
\newline
 {rfk,adrian}@
csse.unimelb.edu.au
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a new approach to distributed problem solving based on high-level
 program execution.
 While this technique has proven itself for single-agent systems based on
 the Golog language, several challenges are encountered when moving to a
 multi-agent setting.
 Key to our approach is a better representation of the dynamics of multi-agent
 teams by means of the following features: a robust combination of true
 concurrency of actions with the interleaved concurrency of ConGolog; an
 explicit notion of time to assist coordination; and semantic support for
 predictable exogenous actions (also called 
\begin_inset Quotes eld
\end_inset

natural actions
\begin_inset Quotes erd
\end_inset

).
 The result is MIndiGolog, a new Golog variant suitable for distributed,
 cooperative execution by a multi-agent team.
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In distributed problem solving applications, a team of agents must cooperate
 closely to achieve a shared goal.
 Such teams can often be conceptualized as a single agent with distributed
 sensing, reasoning and acting capabilities, which leads to a two-stage
 technique for programming such teams: adapt a formalism from single-agent
 programming to specify the tasks to be performed, then provide a coordination
 strategy allowing the team to execute the specification cooperatively.
 This approach has been successfully employed by platforms such as STEAM
 
\begin_inset LatexCommand \cite{tambe97flexible_teamwork}

\end_inset

, SharedPlans 
\begin_inset LatexCommand \cite{grosz99planning_together}

\end_inset

, and TAEMS 
\begin_inset LatexCommand \cite{decker95designing_coordination}

\end_inset

, which specify tasks with variants of the Hierarchical Task Networks (HTN)
 formalism.
\end_layout

\begin_layout Standard
While HTN is a popular and powerful approach to task specification, an increasin
gly popular alternative is 
\emph on
high-level program execution
\emph default
 as embodied by the Golog programming language 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

.
 By 
\begin_inset Quotes eld
\end_inset

high-level program
\begin_inset Quotes erd
\end_inset

 is meant a program whose primitive components are domain-specific actions,
 connected by standard programming constructs, and that may contain nondetermini
stic operators.
 The primary advantage of this approach is 
\emph on
controlled nondeterminism
\emph default
, allowing some parts of the task to be fully specified while others may
 involve arbitrary amounts of nondeterminism, or even goal-based planning.
 Golog has the following additional advantages over HTN: it provides a more
 natural representation of many tasks thanks to common programming constructs;
 and it is based on a more sophisticated logic of action 
\begin_inset LatexCommand \cite{son00htn_golog}

\end_inset

.
\end_layout

\begin_layout Standard
Extensions to the original Golog have introduced further advantageous features,
 including concurrent program execution by interleaving of actions (ConGolog
 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset

) and the ability to combine online execution with offline planning (IndiGolog
 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

).
 We refer to these extensions collectively as the 
\begin_inset Quotes eld
\end_inset

Golog family
\begin_inset Quotes erd
\end_inset

 of programming languages.
\end_layout

\begin_layout Standard
Motivated by these advantages, our research program aims to build a distributed
 problem solving system based on cooperative execution of shared high-level
 programs.
 This paper represents a first step towards that goal.
 We integrate several existing extensions to the situation calculus into
 the Golog language to better represent the dynamics of a multi-agent team.
 Key among these is true concurrency of actions, which we combine with the
 interleaved concurrency of ConGolog to give a flexible account of concurrent
 execution.
 An explicit notion of time is incorporated to enrich the world model and
 to assist in coordination between agents.
 The concept of natural actions is also tightly integrated into the language,
 to allow agents to predict the behavior of their teammates and environment.
 We name the resulting language 
\begin_inset Quotes eld
\end_inset

MIndiGolog
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Quotes eld
\end_inset

Multi-Agent IndiGolog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The paper proceeds as follows: section 
\begin_inset LatexCommand \ref{sec:Background}

\end_inset

 gives some background on the situation calculus and Golog, and describes
 extensions to these formalisms that we will integrate in our work; section
 
\begin_inset LatexCommand \ref{sec:MIndiGolog}

\end_inset

 gives the semantics of MIndiGolog, demonstrates their utility, and shows
 how techniques for distributed logic programming can facilitate the shared
 execution of MIndiGolog programs; section 
\begin_inset LatexCommand \ref{sec:Related-Work}

\end_inset

 discusses related work and section 
\begin_inset LatexCommand \ref{sec:Conclusions}

\end_inset

 concludes with a summary of our results and ongoing research.
 The work is motivated and illustrated throughout by examples from a simple
 multi-agent domain, in which a team of robotic chefs must be programmed
 to cooperatively prepare a meal.
\end_layout

\begin_layout Section
Background
\begin_inset LatexCommand \label{sec:Background}

\end_inset


\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Standard
The situation calculus is a first-order logic formalism for modeling dynamic
 worlds, with the following key features: 
\emph on
Actions
\emph default
 are functions denoting individual instantaneous events that can cause the
 state of the world to change; 
\emph on
Situations
\emph default
 are histories of the actions that have occurred, with 
\begin_inset Formula $S_{0}$
\end_inset

 being the initial situation and successive situations built up using the
 function 
\begin_inset Formula $do(a,s)$
\end_inset

; 
\emph on
Fluents
\emph default
 are predicates or functions representing properties of the world that may
 change from one situation to another.
 The special fluent 
\begin_inset Formula $Poss(a,s)$
\end_inset

 indicates when it is possible to perform an action in a situation.
 For a detailed description consult 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
\end_layout

\begin_layout Standard
A collection of situation calculus statements 
\begin_inset Formula $\mathcal{D}$
\end_inset

 describing a dynamic world is referred to as a 
\emph on
theory of action
\emph default
, and queries about the behavior or evolution of the world are posed as
 logical entailment queries relative to this theory.
\end_layout

\begin_layout Standard

\series bold
\emph on
Concurrency:
\series default
\emph default
 In the basic situation calculus only a single action can occur at any instant.
 While suitable for most single-agent domains, this limitation is emphatically
 not suitable for multi-agent systems - several actions can easily occur
 simultaneously if performed by different agents.
 Modeling this 
\emph on
true concurrency
\emph default
 is necessary to avoid problems with conflicting or incompatible actions.
 There is also the potential to utilize concurrency to execute tasks more
 efficiently.
 Clearly a solid account of concurrency is required for programming multi-agent
 teams.
\end_layout

\begin_layout Standard
The work of 
\begin_inset LatexCommand \cite{lin92sc_conc,reiter96sc_nat_conc}

\end_inset

 adds true concurrency to the situation calculus by replacing action terms
 with sets of actions that are performed simultaneously.
 All functions and predicates that take an action are modified to take sets
 of actions instead.
 For example, 
\begin_inset Formula $do(a,s)$
\end_inset

 becomes 
\begin_inset Formula $do(\{ a_{1},a_{2},...\},s)$
\end_inset

.
\end_layout

\begin_layout Standard
This seemingly simple modification introduces a complication - a combination
 of actions is not guaranteed to be possible even if each of the individual
 actions are.
 For example, two agents may not be able to acquire the same resource at
 the same time.
 This is known as the precondition interaction problem 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and is an area of ongoing research.
 For our purposes it is addressed by introducing a predicate 
\begin_inset Formula $Conflicts(c,s)$
\end_inset

 which is true when the actions in 
\begin_inset Formula $c$
\end_inset

 are in conflict and cannot be performed together.
\end_layout

\begin_layout Standard

\series bold
\emph on
Time:
\series default
\emph default
 An explicit notion of time can make coordination between agents easier,
 as joint actions may be performed at a particular time.
 It also allows a richer description of the world, for example when stating
 the baking time of a cake.
\end_layout

\begin_layout Standard
The standard approach to time in the situation calculus is that of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc,pinto94temporal}

\end_inset

.
 Each action gains an extra argument indicating the time at which is was
 performed.
 Time itself can be represented by any appropriately-behaved sequence, such
 as integers or reals, whose axiomatisation must be included in the theory
 of action.
 The functions 
\begin_inset Formula $time$
\end_inset

 and 
\begin_inset Formula $start$
\end_inset

 are introduced to give the performance time of an action and the start
 time of a situation respectively.
 The start time of the initial situation may be defined arbitrarily.
\end_layout

\begin_layout Standard
An additional predicate 
\begin_inset Formula $Coherent$
\end_inset

 is defined to ensure that the performance time is the same for all members
 in a set of concurrent actions.
 The 
\begin_inset Formula $Poss$
\end_inset

 fluent for concurrent actions can then be defined to ensure that the temporal
 relation between past and future situations is respected, as well as accounting
 for conflicting actions
\begin_inset Foot
status collapsed

\begin_layout Standard
As usual, lower-case terms are variables and free variables are implicitly
 universally quantified
\end_layout

\end_inset

:
\begin_inset Formula \begin{multline*}
Poss(c,s)\equiv\forall a.\left[a\in c\rightarrow Poss(a,s)\right]\\
\wedge\,\neg Conflicts(c,s)\,\wedge\, time(c)>start(s)\,\wedge\, Coherent(c)\end{multline*}

\end_inset

 This representation is accompanied by a standard approach to actions with
 a finite duration: they are decomposed into instantaneous 
\begin_inset Formula $start$
\end_inset

 and 
\begin_inset Formula $end$
\end_inset

 actions and a fluent indicating that the action is in progress.
 For example, a long-running task may be represented by the actions 
\begin_inset Formula $beginTask$
\end_inset

 and 
\begin_inset Formula $endTask$
\end_inset

 along with a fluent 
\begin_inset Formula $doingTask$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\emph on
Natural Actions:
\series default
\emph default
 These are a special class of exogenous actions, those actions which occur
 outside of an agent's control 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

.
 They are classified according to the following requirement: natural actions
 must occur at their predicted times, provided no earlier actions prevent
 them from occurring.
 For example, a timer will ring at the time it was set for, unless it is
 switched off.
 The action 
\begin_inset Formula $endTask$
\end_inset

 from above is another example - it must occur whenever it is possible,
 which is at the time when the agent finishes the task.
 In domains where many agents may be simultaneously engaged in many long-running
 tasks, strong semantic support for natural actions will therefore be of
 significant benefit.
\end_layout

\begin_layout Standard
Natural actions are indicated by the truth of the predicate 
\begin_inset Formula $Natural(a)$
\end_inset

.
 The times at which natural actions may occur are specified by the 
\begin_inset Formula $Poss$
\end_inset

 predicate as usual.
 For example, suppose that the fluent 
\begin_inset Formula $TimerSet(m,s)$
\end_inset

 represents the fact that a timer is set to ring in 
\begin_inset Formula $m$
\end_inset

 minutes in situation 
\begin_inset Formula $s$
\end_inset

.
 The possibility predicate for the 
\begin_inset Formula $ringTimer(t)$
\end_inset

 action would be:
\begin_inset Formula \begin{multline*}
Poss(ringTimer(t),s)\equiv\\
\exists m.\left[TimerSet(m,s)\wedge t=start(s)+m\right]\end{multline*}

\end_inset

 The timer may thus ring only at its predicted time.
 To enforce the requirement that natural actions 
\emph on
must
\emph default
 occur whenever possible, a predicate 
\begin_inset Formula $Legal(s)$
\end_inset

 is introduced which is true only for situations that respect this requirement.
 Legal situations are the only situations that could be brought about in
 the real world:
\begin_inset Formula \begin{multline*}
Legal(S_{0})\equiv True\\
\shoveleft{Legal(do(c,s))\equiv Legal(s)\wedge Poss(c,s)}\\
\wedge\,\forall a.\left[Natural(a)\wedge Poss(a,s)\rightarrow\left[a\in c\vee t<time(a)\right]\right]\end{multline*}

\end_inset

 An important concept when dealing with natural actions is the least natural
 time point (LNTP) of a situation, defined as the earliest time at which
 a natural action may occur.
 We assume that the theory of action avoids certain pathological cases,
 so that absence of an LNTP implies that no natural actions are possible.
\begin_inset Formula \begin{multline*}
Lntp(s,t)\equiv\\
\exists a.\left[Natural(a)\wedge Poss(a,s)\wedge time(a)=t\right]\wedge\\
\forall a.\left[Natural(a)\wedge Poss(a,s)\rightarrow t\leq time(a)\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Subsection
Golog
\end_layout

\begin_layout Standard
Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

 is a declarative agent programming language based on the situation calculus.
 Testimony to its success are its wide range of applications and many extensions
 to provide additional functionality (
\begin_inset LatexCommand \cite{giacomo00congolog,giacomo99indigolog,Ferrein2005readylog}

\end_inset

).
 We use 
\begin_inset Quotes eld
\end_inset

Golog
\begin_inset Quotes erd
\end_inset

 to refer to the family of languages based on this technique, including
 ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset

 and IndiGolog 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

.
\end_layout

\begin_layout Standard
To program an agent using Golog one specifies a situation calculus theory
 of action, and a program consisting of actions from the theory connected
 by programming constructs such as if-then-else, while loops, and nondeterminist
ic choice.
 Table 
\begin_inset LatexCommand \ref{tbl:Golog-Operators}

\end_inset

 lists some of the operators available in various incarnations of the language.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Operator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Meaning
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute action 
\begin_inset Formula $a$
\end_inset

 in the world
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\phi?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Proceed if condition 
\begin_inset Formula $\phi$
\end_inset

 is true
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1};\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta_{1}$
\end_inset

followed by 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}|\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute either 
\begin_inset Formula $\delta_{1}$
\end_inset

 or 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\pi(x)\delta(x)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nondet.
 select arguments for 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 zero or more times
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Exec.
 
\begin_inset Formula $\delta_{1}$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 holds, 
\begin_inset Formula $\delta_{2}$
\end_inset

 otherwise
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{while\,}\phi\mathbf{\, do}\,\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 while 
\begin_inset Formula $\phi$
\end_inset

 holds
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Procedure definition
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Concurrent execution (ConGolog)
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\Sigma\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Plan execution offline (IndiGolog)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
Some Golog Operators
\begin_inset LatexCommand \label{tbl:Golog-Operators}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In line with the idea of high-level program execution, the agent's control
 program may be nondeterministic.
 It is the task of the agent to plan a deterministic instantiation of the
 program, a sequence of actions that can legally be performed in the world.
 Such a sequence is called a 
\emph on
legal execution
\emph default
 of the Golog program.
\end_layout

\begin_layout Standard
Two predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 define the semantics for each operator.
 
\begin_inset Formula $Trans(\delta,s,\delta',s')$
\end_inset

 holds when executing a step of program 
\begin_inset Formula $\delta$
\end_inset

 can cause the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to situation 
\begin_inset Formula $s'$
\end_inset

, after which 
\begin_inset Formula $\delta'$
\end_inset

 remains to be executed.
 It thus characterizes single steps of computation.
 
\begin_inset Formula $Final(\delta,s)$
\end_inset

 holds when program 
\begin_inset Formula $\delta$
\end_inset

 may legally terminate its execution in situation 
\begin_inset Formula $s$
\end_inset

.
 We base our work on the semantics of IndiGolog, which builds on ConGolog
 and is the most feature-full of the standard Golog variants.
 The full semantics are available in the references, but as an example consider
 equation (
\begin_inset LatexCommand \ref{eqn:trans_conc_orig}

\end_inset

), which specifies the concurrent-execution operator as an 
\emph on
interleaving
\emph default
 of computation steps.
 It states that it is possible to single-step the concurrent execution of
 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

 by performing either a step from 
\begin_inset Formula $\delta_{1}$
\end_inset

 or a step from 
\begin_inset Formula $\delta_{2}$
\end_inset

, with the remainder 
\begin_inset Formula $\gamma$
\end_inset

 left to execute concurrently with the other program:
\begin_inset Formula \begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\\
\shoveright{\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\vee\,\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\label{eqn:trans_conc_orig}\end{multline}

\end_inset

 Clearly there are two notions of concurrency to be considered: the possibility
 of performing several actions at the same instant (
\emph on
true concurrency
\emph default
), and the possibility of interleaving the execution of several programs
 (
\emph on
interleaved concurrency
\emph default
).
 These were combined in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

 by modifying Golog to incorporate sets of concurrent actions.
 However, they give a semantics which may call for actions to be performed
 that are not possible and which can result in unintuitive program behavior.
 A key aspect of our work is a more robust integration of these two notions
 of concurrency.
\end_layout

\begin_layout Standard
If the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

 is enriched with 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

, planning an execution of a Golog program 
\begin_inset Formula $\delta$
\end_inset

 is basically a theorem proving task as shown in equation (
\begin_inset LatexCommand \ref{eqn:golog_execution}

\end_inset

).
 Here 
\begin_inset Formula $Trans*$
\end_inset

 indicates reflexive transitive closure.
 The situation 
\begin_inset Formula $s$
\end_inset

 gives a sequence of actions forming a legal execution of the program.
\begin_inset Formula \begin{equation}
\mathcal{D}\models\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]\label{eqn:golog_execution}\end{equation}

\end_inset

 In IndiGolog agents can also proceed without planning a full terminating
 execution of their program, by searching for a legal 
\begin_inset Quotes eld
\end_inset

next step
\begin_inset Quotes erd
\end_inset

 action 
\begin_inset Formula $a$
\end_inset

 such that 
\begin_inset Formula $\mathcal{D}\models\exists a\,.\, Trans*(\delta,s,\delta',do(a,s))$
\end_inset

.
 The search operator (
\begin_inset Formula $\Sigma$
\end_inset

) controls which parts of the program are subject to full execution planning,
 providing fine-grained control over nondeterminism and the amount of planning
 work required.
\end_layout

\begin_layout Standard
As an example of a multi-agent task specification in Golog, consider a program
 
\begin_inset Formula $MakeSalad$
\end_inset

 that instructs a team of agents to prepare a simple salad:
\begin_inset Formula \begin{multline}
\mathbf{proc}\, MakeSalad(dest)\label{eqn:MakeSalad}\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)\left[acquire(agt,dest)\,;\,\right.\\
beginTask(agt,mix(dest,1))\,;\\
\left.\, release(agt,dest)\right]\,\,\mathbf{end}\end{multline}

\end_inset

 The sub-procedure 
\begin_inset Formula $ChopTypeInto$
\end_inset

 (not shown) picks an object of the given type and an available chopping
 board, chops the object using the board, then transfers it into the destination
 container.
 
\begin_inset Formula $MakeSalad$
\end_inset

 tells the agents to do this for a lettuce, a carrot and a tomato, then
 mix the ingredients together for 1 minute.
 Note the nondeterminism in this program - the agent assigned to handling
 each ingredient is not specified (
\begin_inset Formula $\pi$
\end_inset

 construct), nor is the order in which they should be added (
\begin_inset Formula $||$
\end_inset

 construct).
 There is thus considerable scope for cooperation between agents to effectively
 carry out this task.
\end_layout

\begin_layout Standard
While this is a valid program in standard IndiGolog, executing it using
 the existing semantics would be far from ideal.
 The explicit temporal component described above must to added to IndiGolog
 to accommodate the 
\begin_inset Formula $mix(dest,1)$
\end_inset

 task.
 The lack of true concurrency would mean only one agent could act at a time,
 while others would remain idle.
 And since there is no support for natural actions, IndiGolog would fail
 to find a legal execution of this program: it would find that the final
 action 
\begin_inset Formula $release$
\end_inset

 cannot be performed after doing 
\begin_inset Formula $beginTask$
\end_inset

, as our theory of action ensures agents can only be doing one thing at
 a time.
 But it would not determine that the natural action 
\begin_inset Formula $endTask$
\end_inset

 will occur after one minute and enable to program to finish.
\end_layout

\begin_layout Standard
Our new Golog variant, MIndiGolog, is designed to produce executions of
 such programs in a manner that overcome these limitations, and is thus
 suitable for specifying tasks to be performed by multi-agent teams in distribut
ed problem solving applications.
\end_layout

\begin_layout Section
MIndiGolog
\begin_inset LatexCommand \label{sec:MIndiGolog}

\end_inset


\end_layout

\begin_layout Standard
We have integrated three extensions to the situation calculus with the semantics
 of IndiGolog to better model the dynamics of a multi-agent setting.
 These extensions allow agents to represent time, concurrently-occurring
 actions, and natural actions in a robust way.
\end_layout

\begin_layout Subsection
Time
\end_layout

\begin_layout Standard
It is clear from the background section that the approach of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 to modeling time is complicated by the presence of concurrent actions.
 To avoid the need for the 
\begin_inset Formula $Coherent$
\end_inset

 predicate, we attach the temporal argument to each situation rather than
 to each action.
 The successor situation function 
\begin_inset Formula $do(a,s)$
\end_inset

 becomes 
\begin_inset Formula $do(a,t,s)$
\end_inset

, to indicate 
\begin_inset Quotes eld
\end_inset

action 
\begin_inset Formula $a$
\end_inset

 was performed at time 
\begin_inset Formula $t$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The possibility predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 likewise becomes 
\begin_inset Formula $Poss(a,t,s)$
\end_inset

.
 The semantics of IndiGolog trivially accommodate this change, and the predicate
 
\begin_inset Formula $Coherent$
\end_inset

 and function 
\begin_inset Formula $time$
\end_inset

 are no longer needed.
\end_layout

\begin_layout Subsection
Concurrency
\end_layout

\begin_layout Standard
While it is straightforward to modify the IndiGolog 
\begin_inset Formula $Trans$
\end_inset

 rule for primitive actions to accept sets of concurrent actions, there
 are deeper implications for the concurrency operator.
 This is implemented by accepting a transition from either of the two programs
 as a transition for the pair 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset

.
 In the presence of true concurrency, this is insufficient.
 Suppose program 
\begin_inset Formula $\delta_{1}$
\end_inset

 may be transitioned by performing actions 
\begin_inset Formula $c_{1}$
\end_inset

, and 
\begin_inset Formula $\delta_{2}$
\end_inset

 may be transitioned by performing actions 
\begin_inset Formula $c_{2}$
\end_inset

.
 As noted in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

, it should be possible to exploit true concurrency by performing both simultane
ously, i.e.
 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

.
 However, this introduces several complications that 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

 does not address.
\end_layout

\begin_layout Standard
First, precondition interaction means that 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 may not be possible even if the individual actions are.
 The transition clause must ensure that the combination of the two sets
 of actions is possible.
 Another issue arises when two programs can legitimately be transitioned
 by executing the same action.
 Consider the following programs which add ingredients to a bowl:
\begin_inset Formula \begin{multline*}
\delta_{1}=placeIn(Thomas,Flour,Bowl)\,;\\
\shoveright{placeIn(Thomas,Sugar,Bowl)}\\
\shoveleft{\delta_{2}=placeIn(Thomas,Flour,Bowl)\,;}\\
placeIn(Thomas,Egg,Bowl)\end{multline*}

\end_inset

 Executing 
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset

 should result in the bowl containing two units of flour, one unit of sugar
 and an egg.
 However, an individual transition for both programs is 
\begin_inset Formula $c_{1}=c_{2}=placeIn(Thomas,Flour,Bowl)$
\end_inset

.
 Naively executing 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 to transition both programs would add only one unit of flour.
 Alternately, consider two programs waiting for a timer to ring:
\begin_inset Formula \begin{gather*}
\delta_{1}=ringTimer\,;\, acquire(Thomas,Bowl)\\
\delta_{2}=ringTimer\,;\, acquire(Richard,Board)\end{gather*}

\end_inset

 Both programs should be allowed to proceed with a single occurrence of
 the 
\begin_inset Formula $ringTimer$
\end_inset

 action, because it is an aspect of the environment.
 To avoid unintuitive (and potentially dangerous) behavior, concurrent execution
 must not be allowed to transition both programs using the same 
\emph on
agent-initiated
\emph default
 action.
 If an agent-initiated action may be safely skipped, it can be enclosed
 in an appropriate if-then-else or choice construct.
\end_layout

\begin_layout Standard
Taking these factors into account, we develop the improved transition rule
 for concurrency in equation (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

).
 The first two lines are the original interleaved concurrency clause from
 ConGolog, while the remainder characterizes the above considerations for
 true concurrency.
 This robust combination allows the language to more accurately reflect
 the concurrency present in multi-agent teams.
 As with ConGolog and IndiGolog, our semantics make no attempt to maximize
 concurrency or otherwise differentiate between potential executions, they
 only state which transitions can be legally performed.
\begin_inset Formula \begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\\
\shoveright{\exists\gamma\,.\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})}\\
\shoveright{\vee\exists\gamma\,.\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))}\\
\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge Poss(c_{1}\cup c_{2},t,s)\\
\shoveright{\wedge\forall a.\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Natural(a)\right]}\\
\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\label{eqn:trans_conc_new}\end{multline}

\end_inset


\end_layout

\begin_layout Subsection
Natural Actions
\end_layout

\begin_layout Standard
The formalism of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 is adopted, with simple modifications for our handling of time.
 While planning with natural actions has previously been done in Golog 
\begin_inset LatexCommand \cite{pirri00planning_nat_acts}

\end_inset

, the programmer was required to explicitly check for any possible natural
 actions and ensure that they appear in the execution.
 We significantly lower the burden on the programmer by guaranteeing that
 all legal program executions result in legal situations.
 MIndiGolog agents will plan for the occurrence of natural actions without
 having them explicitly mentioned in the program.
 They may optionally be included in the program, instructing the agents
 to wait for the action to occur before proceeding.
\end_layout

\begin_layout Standard
This is achieved using a new 
\begin_inset Formula $Trans$
\end_inset

 clause for the case of a single action 
\begin_inset Formula $c$
\end_inset

, as shown in equation (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

).
 If 
\begin_inset Formula $s$
\end_inset

 has an LNTP 
\begin_inset Formula $t_{n}$
\end_inset

 and corresponding set of natural actions 
\begin_inset Formula $c_{n}$
\end_inset

, a transition can be made in three ways: perform 
\begin_inset Formula $c$
\end_inset

 at a time before 
\begin_inset Formula $t_{n}$
\end_inset

 (fourth line), perform it along with the natural actions at 
\begin_inset Formula $t_{n}$
\end_inset

 (fifth line), or wait for the natural actions to occur (sixth line).
 If there is no LNTP, then 
\begin_inset Formula $c$
\end_inset

 may be performed at any time greater than 
\begin_inset Formula $start(s)$
\end_inset

.
\begin_inset Formula \begin{multline}
Trans(c,s,\delta',s')\equiv\\
\exists t,t_{n},c_{n}\,.\, Lntp(s,t_{n})\wedge t\geq start(s)\wedge\\
\forall a.\left[Natural(a)\wedge Poss(a,t_{n},s)\equiv a\in c_{n}\right]\wedge\\
\left[t<t_{n}\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=Nil\right.\\
\vee Poss(c\cup c_{n},t_{n},s)\wedge s'=do(c\cup c_{n},t,s)\wedge\delta'=Nil\\
\vee\left.s'=do(c_{n},t_{n},s)\wedge\delta'=c\right]\\
\vee\,\neg\exists t_{n}\,.\, Lntp(s,t_{n})\wedge\exists t\,.\, Poss(c,t,s)\wedge\\
t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=Nil\label{eqn:trans_prim_new}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
The occurrence of natural actions may also cause test conditions within
 the program to become satisfied, so a new 
\begin_inset Formula $Trans$
\end_inset

 clause for 
\begin_inset Formula $\phi?$
\end_inset

 is also required as shown in equation (
\begin_inset LatexCommand \ref{eqn:trans_cond_new}

\end_inset

).
 This permits a program consisting of a single test condition to make a
 transition if the condition is satisfied, or if a natural action occurs:
\begin_inset Foot
status collapsed

\begin_layout Standard
\begin_inset Formula $\phi[s]$
\end_inset

 should be read as 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\phi$
\end_inset

 holds in situation 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 
\begin_inset Formula \begin{multline}
Trans(\phi?,s,\delta',s')\,\,\equiv\,\,\phi[s]\wedge\delta'=Nil\wedge s'=s\\
\shoveright{\vee\,\exists t_{n},c_{n}\,.\, Lntp(s,t_{n})\wedge\delta'=\phi?\wedge s'=do(c_{n},t_{n}s)}\\
\wedge\,\forall a.\left[Natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in c_{n}\right]\label{eqn:trans_cond_new}\end{multline}

\end_inset


\end_layout

\begin_layout Standard
A MIndiGolog execution will thus contain all natural actions that will occur,
 regardless of whether they were considered explicitly by the programmer.
\end_layout

\begin_layout Standard
Contrast this with the standard handling of exogenous events in IndiGolog,
 which is achieved by executing the main program concurrently with a program
 that generates exogenous actions:
\begin_inset Formula \[
\delta_{main}\,||\,\left(\pi(a)(Exog(a)?\,;\, a)\right)^{*}\]

\end_inset

 This allows the program to make a legal transition regardless of what exogenous
 actions occur - an approach suitable for dealing with arbitrary exogenous
 actions which may occur at any time, but suboptimal for handling 
\emph on
predictable
\emph default
 exogenous actions.
 Our approach allows the agents to directly predict the natural actions
 that will occur and automatically include them in a planned execution.
\end_layout

\begin_layout Subsection
Legality of the Semantics
\end_layout

\begin_layout Standard
Let a 
\emph on
MIndiGolog Theory of Action
\emph default
 be a theory of action in the situation calculus enhanced with time, true
 concurrency and natural actions, augmented with the predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 from IndiGolog, modified according to equations (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

), (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:trans_cond_new}

\end_inset

).
 All legal executions of a MIndiGolog program derived from such a theory
 of action produce legal situations.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{lemma}
\end_layout

\end_inset

 Let 
\begin_inset Formula $\mathcal{D}$
\end_inset

 be a MIndiGolog theory of action.
 Then:
\begin_inset LatexCommand \label{thm:trans_legal}

\end_inset


\begin_inset Formula \[
\mathcal{D}\models\forall s,s',\delta,\delta'.Legal(s)\wedge Trans(\delta,s,\delta',s')\rightarrow Legal(s')\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{lemma}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{proof}
\end_layout

\end_inset

 By induction on the structure of 
\begin_inset Formula $\delta$
\end_inset

.
 That the theorem holds for the modified 
\begin_inset Formula $Trans$
\end_inset

 clauses of equations (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

), (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:trans_cond_new}

\end_inset

) is straightforward, and no other clause constructs new situation terms.
 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{thm}
\end_layout

\end_inset

 Let 
\begin_inset Formula $\mathcal{D}$
\end_inset

 be a MIndiGolog theory of action.
 Then: 
\begin_inset Formula \[
\mathcal{D}\models\forall s',\delta,\delta'\,.\, Trans*(\delta,S_{0},\delta',s')\rightarrow Legal(s')\]

\end_inset

 
\newpage
Thus, all legal executions of a MIndiGolog program produce legal situations.
 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{thm}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{proof}
\end_layout

\end_inset

 From lemma 
\begin_inset LatexCommand \ref{thm:trans_legal}

\end_inset

, the legality of 
\begin_inset Formula $S_{0}$
\end_inset

, and the properties of transitive closure.
 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Like standard IndiGolog, MIndiGolog will only call for actions to be performed
 if it is actually possible to perform them.
 MIndiGolog has the added advantage of effortlessly incorporating any natural
 actions that may occur.
\end_layout

\begin_layout Subsection
Example Execution
\end_layout

\begin_layout Standard
The effect of our new semantics can be seen in figure 
\begin_inset LatexCommand \ref{cap:example_trace}

\end_inset

, which shows one possible legal execution of the 
\begin_inset Formula $MakeSalad$
\end_inset

 program using the new semantics of MIndiGolog
\begin_inset Foot
status collapsed

\begin_layout Standard
A Prolog implementation of the MIndiGolog semantics, from which this trace
 was obtained, is available at http://www.csse.unimelb.edu.au/~rfk/golog/
\end_layout

\end_inset

 in a domain with thee agents.
 Note the occurrence of several actions within each 
\series bold
do
\series default
 statement, demonstrating the integration of true concurrency into the language.
 Note also the incorporation of natural 
\begin_inset Formula $endTask$
\end_inset

 actions into the program, and the explicit occurrence time for each action.
 (in this trace the occurrence times have been instantiated to their earliest
 possible value).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide true
sideways false
status open

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
centering
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
subfigure[One possible execution of the $MakeSalad$ program with three agents,
\end_layout

\begin_layout Standard

using MIndiGolog.
 Note the occurrence of multiple
\end_layout

\begin_layout Standard

actions within each do statement.]{
\end_layout

\end_inset

 
\begin_inset LatexCommand \label{cap:example_trace}

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
makebox[1
\backslash
textwidth]{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/output_makeSalad_1.txt}
preview false

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/output_makeSalad_2.txt}
preview false

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
subfigure[One possible execution of the $MakeSalad$ program with three
\end_layout

\begin_layout Standard

agents, using IndiGolog.
 Note that only one agent acts at
\end_layout

\begin_layout Standard

each step.]{
\end_layout

\end_inset

 
\begin_inset LatexCommand \label{cap:indigolog_trace}

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
framebox{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
makebox[1
\backslash
textwidth]{
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "50text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/output_makeSalad_ig_1.txt}
preview false

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "45text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/output_makeSalad_ig_2.txt}
preview false

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Standard

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Caption
Example executions of the 
\begin_inset Formula $MakeSalad$
\end_inset

 program
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For comparison purposes, we added a temporal element and inserted explicit
 
\begin_inset Formula $endTask$
\end_inset

 actions into 
\begin_inset Formula $MakeSalad$
\end_inset

 to allow a legal execution to be found using the standard IndiGolog semantics.
 Such an execution is shown in figure 
\begin_inset LatexCommand \ref{cap:indigolog_trace}

\end_inset

.
 Note that the lack of true concurrency means only a single agent can act
 at each step, leaving the other two agents completely idle.
 The ability to reduce idle time by performing actions concurrency is clearly
 an advantage for distributed problem solving applications.
\end_layout

\begin_layout Subsection
Distributed Execution Planning
\end_layout

\begin_layout Standard
As the existing languages based on Golog have demonstrated, an interpreter
 can be conveniently constructed using a logic programming language such
 a Prolog.
 We have followed the style of 
\begin_inset LatexCommand \cite{giacomo00congolog,giacomo99indigolog}

\end_inset

 to build interpreters for our language in both Prolog and Oz 
\begin_inset LatexCommand \cite{vanroy03mozart_logic}

\end_inset

, a multi-paradigm programming language with strong support for distributed
 computing.
\end_layout

\begin_layout Standard
One powerful feature of Oz is the ability to use several networked computers
 to search for solutions to a logic program in parallel.
 Since the task of planning a MIndiGolog execution is encoded as a logic
 program, this immediately allows a team of agents to distribute the execution
 planning workload.
 Below we briefly summarize our implementation; the full version is available
 from the author's website
\begin_inset Foot
status collapsed

\begin_layout Standard
http://www.csse.unimelb.edu.au/~rfk/golog/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
MIndiGolog programs are represented in Oz as record terms (which are similar
 to Prolog data terms) with the name of the record representing an operator
 and its features the arguments.
 Actions are also encoded as records.
 As in Prolog, uppercase terms in Oz represent variables.
 For example, the program:
\begin_inset Formula \[
\pi(agt)\left[acquire(agt,Bowl);acquire(agt,Knife)\right]\]

\end_inset


\end_layout

\begin_layout Standard
is represented as follows:
\end_layout

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/goloz_ex_prog.oz}
preview false

\end_inset

 
\end_layout

\begin_layout Standard
The predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 have a straightforward encoding as Oz procedures, using the 
\series bold
case
\series default
 statement to encode each individual clause using pattern matching, and
 the 
\series bold
choice
\series default
 statement to explicitly introduce choice points:
\end_layout

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/goloz_trans.oz}
preview false

\end_inset

 
\end_layout

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/goloz_final.oz}
preview false

\end_inset

 
\end_layout

\begin_layout Standard
A procedure 
\begin_inset Formula $Do(\delta,s,s')\equiv Trans*(\delta,s,\delta',s')\wedge Final(\delta',s')$
\end_inset

 is defined that determines a legal execution 
\series bold
\emph on
Sp
\series default
\emph default
 for a given program 
\series bold
\emph on
D
\series default
\emph default
:
\end_layout

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/goloz_do.oz}
preview false

\end_inset

 
\end_layout

\begin_layout Standard
This 
\series bold
\emph on
Do
\series default
\emph default
 procedure can then be passed to the parallel search functionality to plan
 a program execution.
 Here 
\begin_inset Quotes eld
\end_inset

agent1
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

agent2
\begin_inset Quotes erd
\end_inset

 are the DNS names of agents in the team, and 
\begin_inset Quotes eld
\end_inset

Goloz
\begin_inset Quotes erd
\end_inset

 is an Oz functor (basically, a portable piece of code) that exports the
 
\series bold
\emph on
Do
\series default
\emph default
 procedure defined above:
\end_layout

\begin_layout Standard

\size small
\begin_inset Include \verbatiminput{listings/goloz_do_parallel.oz}
preview false

\end_inset

 
\end_layout

\begin_layout Standard
When this code is run, it will utilize the computational resources of both
 agents to plan a legal execution of a given MIndiGolog program.
 This requires that the same information is available to each agent, which
 restricts the technique to fully-observable domains.
 We are currently developing an algorithm for cooperative execution of MIndiGolo
g programs that utilizes such distribution of the planning workload.
\end_layout

\begin_layout Section
Related Work
\begin_inset LatexCommand \label{sec:Related-Work}

\end_inset


\end_layout

\begin_layout Standard
That Golog shows promise for multi-agent teams is evidenced by the success
 of 
\begin_inset LatexCommand \cite{Ferrein2005readylog}

\end_inset

 with a RoboCup soccer team executing a shared Golog program.
 However, the semantics of their Golog variant 
\begin_inset Quotes eld
\end_inset

ReadyLog
\begin_inset Quotes erd
\end_inset

 remain largely single-agent and do not address concerns such as: the possibilit
y of performing actions concurrently and the coordination of concurrent
 actions; differing knowledge or beliefs between team members; sharing the
 computational workload of planning; and predicting the behavior of teams
 members and the environment in the face of many concurrently-executing
 tasks.
 MIndiGolog overcomes some of these limitations, while our ongoing work
 on cooperative execution will address the others.
\end_layout

\begin_layout Standard
As stated earlier, there has been much promising work on distributed problem
 solving systems using the Hierarchical Task Networks formalism (
\begin_inset LatexCommand \cite{tambe97flexible_teamwork,decker95designing_coordination,grosz99planning_together}

\end_inset

, among others).
 We believe high-level program execution to have several clear advantages
 over HTN, in particular the ready availability of controlled nondeterminism.
 Combined with familiar programming constructs such as loops and if-then-else,
 it provides a very powerful formalism for expressing complex behaviors
 and tasks 
\begin_inset LatexCommand \cite{Gabaldon02htn_in_golog,son00htn_golog}

\end_inset

.
 Golog also benefits from a logic of action rich enough to capture many
 challenging aspects of multi-agent domains (such as time and concurrency)
 while remaining computationally feasible.
\end_layout

\begin_layout Standard
Note that this paper focuses on task specification using Golog and does
 not deal with coordination between team members.
 We are currently developing techniques for cooperative execution of MIndiGolog
 programs based on these successful approaches to executing HTN specifications.
\end_layout

\begin_layout Section
Conclusions and Future Work
\begin_inset LatexCommand \label{sec:Conclusions}

\end_inset


\end_layout

\begin_layout Standard
Our work integrates several important extensions to the situation calculus
 and Golog to better model the dynamics of multi-agent teams.
 Specifically, MIndiGolog combines true and interleaved concurrency, an
 explicit account of time, and seamless integration of natural actions.
 It defines legal executions of high-level programs that are suitable for
 cooperative execution by a multi-agent team.
\end_layout

\begin_layout Standard
Since the semantics of MIndiGolog are based on first-order logic, existing
 techniques for distributed logic programming can be used to share the execution
-planning workload between agents.
 In fully-observable domains, the parallel search capabilities of Oz can
 be used directly.
 We are currently developing a more sophisticated coordination strategy
 to augment these techniques and allow cooperative execution of MIndiGolog
 programs by a team of autonomous agents in partially observable domains.
\end_layout

\begin_layout Standard
Such coordination strategies are typically based on explicit mental attitudes
 such as knowledge and intention.
 A key aspect of our recent work has been the development of a computationally-f
easible account of knowledge in partially observable domains 
\begin_inset LatexCommand \cite{kelly07sc_know_obs}

\end_inset

.
 This requires efficient reasoning about what cannot be changed by certain
 types of action, and we have developed a technique for answering such 
\begin_inset Quotes eld
\end_inset

persistence queries
\begin_inset Quotes erd
\end_inset

 under some simple assumptions 
\begin_inset LatexCommand \cite{kelly07sc_persistence}

\end_inset

.
 An implementation of these techniques will form the base of our distributed
 problem solving system.
\end_layout

\begin_layout Standard
This paper thus represents a first step towards providing the advantages
 of Golog (such as controlled nondeterminism, powerful programming constructs,
 and a rich logic of action) for task specification for multi-agent teams.
 While significant work remains to be done to produce a full distributed
 problem solving system, our current implementations of MIndiGolog in Prolog
 and Oz, particularly combined with distributed logic programming techniques,
 have already proven useful for programming the behavior of multi-agent
 teams in fully observable domains.
\begin_inset LatexCommand \bibtex[latex8]{../../../library/references}

\end_inset


\end_layout

\end_body
\end_document
