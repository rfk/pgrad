#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass IEEEtran
\options letterpaper
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
High-Level Program Execution for Multi-Agent Teams
\end_layout

\begin_layout Author
Ryan F.
 Kelly and Adrian R.
 Pearce
\end_layout

\begin_layout Abstract
We present MIndiGolog, a new variant of the Golog programming language specifica
lly designed for multi-agent teams.
 While the concept of high-level program execution, as embodied by Golog,
 has proven a practical approach for single-agent systems, several challenges
 are encountered when moving to a multi-agent setting.
 We develop a robust integration of the following enhancements to Golog
 that make it more suitable for multi-agent teams: a combination of true
 concurrency of actions with the interleaved concurrency of ConGolog; an
 explicit notion of time to enrich the world model and assist coordination;
 and semantic support for predictable exogenous actions (often called 
\begin_inset Quotes eld
\end_inset

natural actions
\begin_inset Quotes erd
\end_inset

).
 The result is a language with much richer support for expressing and planning
 the behavior of multi-agent teams.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
When a team of agents must cooperate closely in order to achieve some shared
 goal, they can often be conceptualized as a single agent with distributed
 sensing, reasoning and acting capabilities.
 Behaviors and goals are naturally ascribed to the team rather than to individua
l members.
 This insight leads naturally to a two-stage technique for programming the
 behavior of such teams: adapt a formalism from single-agent programming
 to specify the tasks to be performed, then provide the team with a coordination
 strategy to allow them to execute it cooperatively.
\end_layout

\begin_layout Standard
This approach has been successfully employed by team programming environments
 such as STEAM 
\begin_inset LatexCommand \cite{tambe97flexible_teamwork}

\end_inset

, SharedPlans 
\begin_inset LatexCommand \cite{grosz99planning_together}

\end_inset

, and TAEMS 
\begin_inset LatexCommand \cite{decker95designing_coordination}

\end_inset

.
 These approaches specify the tasks to be performed using adaptations of
 the Heirachcial Task Networks (HTN) formalism, in which tasks are specified
 by repeatedly decomposing them into simpler sub-tasks until only primitive
 actions remain.
 While this is a powerful approach, there are alternative task-representation
 formalisms popular in single-agent programming that are also worthy of
 consideration.
 In this paper we adapt the 
\emph on
high-level program execution
\emph default
 approach for specifying the behavior of multi-agent teams.
\end_layout

\begin_layout Standard
As described in 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

, high-level program execution has recently emerged as a practical alternative
 to traditional plan synthesis for single-agent systems.
 By 
\begin_inset Quotes eld
\end_inset

high-level program
\begin_inset Quotes erd
\end_inset

 is meant a program whose primitive operations are domain-specific actions,
 composed using familiar programming operators such as 
\begin_inset Formula $\mathbf{if}$
\end_inset

 and 
\begin_inset Formula $\mathbf{while}$
\end_inset

, and which may be incompletely specified due to nondeterministic constructs.
 Rather than a planner finding a sequence of actions leading from an initial
 state to some goal state, the task is to find a sequence of actions which
 constitute an execution of this program.
 Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

 is a programming language built on the situation calculus that implements
 the high-level program execution idea.
\end_layout

\begin_layout Standard
The primary advantage of this approach is 
\emph on
controlled nondeterminism
\emph default
, allowing some aspects of the program to be fully specified while others
 may involve arbitrary amounts of nondeterminism, or even open-ended planning.
 A discussion of the relative merits of HTN and Golog can be found in 
\begin_inset LatexCommand \cite{son00htn_golog}

\end_inset

, where the following additional advantages are highlighted: Golog provides
 a more natural representation of many tasks by means of common programming
 constructs; and it is based on a more sophisticated logic of action than
 the propositional domains considered by most HTN systems.
\end_layout

\begin_layout Standard
That the Golog approach shows promise for multi-agent teams is evidenced
 by the success of 
\begin_inset LatexCommand \cite{Ferrein2005readylog}

\end_inset

 with a RoboCup soccer team programmed in the Golog variant ReadyLog.
 However, ReadyLog itself remains largely single-agent and does not address
 concerns such as: the possibility of performing actions concurrently and
 the coordination of concurrent actions; differing knowledge or beliefs
 between team members; sharing the computational workload of planning between
 agents; and predicting the behavior of teams members and the environment
 in the face of many concurrently-executing tasks.
 Our research program aims to address these concerns and build a Golog system
 suitable for specifying the behavior of a wide range of multi-agent teams.
\end_layout

\begin_layout Standard
This paper represents a first step towards this goal.
 We combine several existing extensions to the Golog language to make it
 more suitable for representing the dynamics of a multi-agent team.
 Key among these is the notion of true concurrency of actions, which we
 combine with the interleaved concurrency found in the language ConGolog
 to give a flexible account of concurrent execution.
 An explicit notion of time is incorporated, both to enrich the world model
 and to assist in coordination between agents.
 The concept of natural actions is also tightly integrated into the language,
 to allow agents to predict the behavior of each other and their environment.
 We name the resulting language 
\begin_inset Quotes eld
\end_inset

MIndiGolog
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Quotes eld
\end_inset

Multi-Agent IndiGolog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The paper is laid out as follows: section 
\begin_inset LatexCommand \ref{sec:Background}

\end_inset

 gives the necessary background on the situation calculus and Golog, and
 describes some extensions to these formalisms that we will integrate in
 our work; section 
\begin_inset LatexCommand \ref{sec:MIndiGolog}

\end_inset

 gives our new Golog semantics and shows that it has several (TODO: several?)
 desirable qualities; and section 
\begin_inset LatexCommand \ref{sec:Conclusions}

\end_inset

 concludes with a summary of our results and ongoing research.
 TODO: discuss example domain
\end_layout

\begin_layout Section
Background
\begin_inset LatexCommand \label{sec:Background}

\end_inset


\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 It has the following sorts: 
\emph on
Action
\emph default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change; 
\emph on
Situation
\emph default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built up using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\emph on
Object
\emph default
 terms represent any other object in the domain.
 It further distinguishes 
\emph on
Fluents
\emph default
 as predicates or functions representing properties of the world that may
 change from one situation to another, and so take a situation term as their
 final argument.
 The special fluent 
\begin_inset Formula $Poss(a,s)$
\end_inset

 indicates when it is possible to perform an action in a situation.
 For a detailed description consult 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 
\end_layout

\begin_layout Standard
A collection of situation calculus statements 
\begin_inset Formula $\mathcal{D}$
\end_inset

 describing a dynamic world is referred to as a 
\emph on
theory of action
\emph default
, and queries about the behavior or evolution of the world are posed as
 logical entailment queries relative to this theory.
\end_layout

\begin_layout Subsubsection
Concurrency
\end_layout

\begin_layout Standard
In the basic situation calculus only a single action can occur at any instant.
 While suitable for most single-agent domains, this limitation is emphatically
 not suitable for multi-agent systems - several actions can easily occur
 simultenously if performed by different agents.
 Such domains are said to exhibit 
\emph on
true concurrency 
\emph default
of actions.
 Modelling this concurrency is necessary to avoid problems with conflicting
 or incompatible actions.
 There is also the potential to utilize concurrency to execute tasks more
 efficiently.
 Clearly a solid account of concurrency is required for programming multi-agent
 systems.
\end_layout

\begin_layout Standard
The work of 
\begin_inset LatexCommand \cite{lin92sc_conc,reiter96sc_nat_conc}

\end_inset

 adds true concurrency to the situation calculus by replacing action terms
 with sets of actions that are performed simultaneously.
 All functions and predicates that take an action are modified to take sets
 of actions instead.
 For example, 
\begin_inset Formula $do$
\end_inset

 and 
\begin_inset Formula $Poss$
\end_inset

 become 
\begin_inset Formula $do(\{ a_{1},a_{2},...\},s)$
\end_inset

 and 
\begin_inset Formula $Poss(\{ a_{1},a_{2},...\},s)$
\end_inset

.
\end_layout

\begin_layout Standard
This seemingly simple modification introduces a complication - the combination
 of actions 
\begin_inset Formula $\{ a_{1},a_{2}\}$
\end_inset

 is not guaranteed to be possible even if the individual actions are.
 For example, an agent may not perform two actions at once, or two agents
 may not be able to acquire the same resource at the same time.
 This is known as the precondition interaction problem 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and is an area of ongoing research.
 For our purposes it is addressed by introducing a predicate 
\begin_inset Formula $Conflicts(c,t,s)$
\end_inset

 which is true when the actions in 
\begin_inset Formula $c$
\end_inset

 are in conflict and cannot be performed together.
 The possibility axiom for concurrent actions is then
\begin_inset Foot
status collapsed

\begin_layout Standard
We follow the convention that lower-case free variables are implicitly universal
ly quantified
\end_layout

\end_inset

:
\begin_inset Formula \begin{equation}
Poss(c,s)\equiv\forall a\,\left[a\in c\rightarrow Poss(a,s)\right]\wedge\neg Conflicts(c,s)\label{eqn:poss_conc_acts}\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
Time
\end_layout

\begin_layout Standard
An explicit notion of time can make coordination between agents easier,
 as joint actions may be performed at a particular time.
 It also allows a richer description of the world - for example, it becomes
 possible to specify that a cake must be baked for 30 minutes.
 
\end_layout

\begin_layout Standard
A temporal component was incorporated into the situation calculus by 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and simplified by 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

.
 Each action gains an extra argument indicating the time at which is was
 performed.
 Time itself can be represented by any appropriately-behaved sequence, such
 as integers or reals, whose axiomatisation must be included in the theory
 of action.
 The functions 
\begin_inset Formula $time$
\end_inset

 and 
\begin_inset Formula $start$
\end_inset

 are introduced to give the performance time of an action and the starting
 time of a situation respectively, and are defined using an axiom like the
 following for each type of action 
\begin_inset Formula $A$
\end_inset

:
\begin_inset Formula \begin{equation}
time(A(\overrightarrow{x},t))=t\label{eqn:act_time}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
start(do(a,s))=time(a)\label{eqn:sit_start}\end{equation}

\end_inset

The start time of the initial situation may be defined as appropriate for
 the application.
 All members in a set of concurrent actions are required to be performed
 at the same time.
 An additional predicate 
\begin_inset Formula $Coherent$
\end_inset

 is defined to ensure this, allowing 
\begin_inset Formula $time$
\end_inset

 and 
\begin_inset Formula $start$
\end_inset

 to be easily defined in the presence of concurrency:
\begin_inset Formula \[
Coherent(c)\equiv\exists t\,\forall a\left[a\in c\rightarrow time(a)=t\right]\]

\end_inset


\end_layout

\begin_layout Standard
These authors also introduce a standard approach to actions with a finite
 duraction - they are decomposed into instantaneous 
\begin_inset Formula $start$
\end_inset

 and 
\begin_inset Formula $end$
\end_inset

 actions and a fluent indicating that the action is in progress.
 For example, a generic task may be formalised as the actions 
\begin_inset Formula $begin\_task$
\end_inset

 and 
\begin_inset Formula $end\_task$
\end_inset

, along with a fluent 
\begin_inset Formula $doing\_task$
\end_inset

.
 We adopt this approach in our work.
\end_layout

\begin_layout Subsubsection
Natural Actions
\end_layout

\begin_layout Standard
These are a special class of exogenous actions, those actions which occur
 outside of an agent's control.
 Introduced to the situation calculus by 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and expanded by 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

, they are classified according to the following requirement: natural actions
 must occur at their predicted times, provided no earlier actions prevent
 them from occurring.
 For example, a timer will ring at the time it was set for, unless it is
 switched off.
 
\end_layout

\begin_layout Standard
End-of-task actions such as 
\begin_inset Formula $end\_task$
\end_inset

 from above are another example of natural actions - an agents are not free
 to perform these at any time, rather they must occur whenever possible.
 In domains where many agents may be simultaneously engaged in many long-running
 tasks, strong semantic support for such natural actions will be of significant
 benefit to the programmer.
\end_layout

\begin_layout Standard
Natural actions are indicated by the truth of the predicate 
\begin_inset Formula $Natural(a)$
\end_inset

.
 As usual, the times at which natural actions may occur are specified by
 the 
\begin_inset Formula $Poss$
\end_inset

 predicate.
 For example, suppose that the fluent 
\begin_inset Formula $Timer\_Set(ID,m,s)$
\end_inset

 represents the fact that a particular timer is set to ring in 
\begin_inset Formula $m$
\end_inset

 minutes in situation 
\begin_inset Formula $s$
\end_inset

.
 The possibility predicate for the 
\begin_inset Formula $ring\_timer(ID,t)$
\end_inset

 action would be: 
\begin_inset Formula \begin{multline}
Poss(ring\_timer(ID,t),s)\equiv\\
\exists m.\left[Timer\_Set(ID,m,s)\wedge t=start(s)+m\right]\end{multline}

\end_inset


\end_layout

\begin_layout Standard
The timer may thus ring only at its predicted time.
 To enforce the requirement that natural actions 
\emph on
must
\emph default
 occur whenever possible, a predicate 
\begin_inset Formula $Legal(s)$
\end_inset

 is introduced which is true only for situations which respect this requirement
 (assuming no precondition interaction among natural actions).
 Legal situations are the only situations that could be brought about in
 the real world:
\begin_inset Formula \begin{multline}
Legal(S_{0})\equiv True\label{eqn:legal_def}\\
\shoveleft{Legal(do(c,s))\equiv}\\
\shoveright{Legal(s)\wedge Poss(c,s)\wedge Coherent(c)\wedge start(s)\leq time(c)\,\wedge}\\
\forall a\,\, Natural(a)\wedge Poss(a,s)\rightarrow\left[a\in c\vee t<time(a)\right]\end{multline}

\end_inset

An important concept when dealing with natural actions it the least natural
 time point (LNTP) of a situation.
 This is defined as the earliest time at which a natural action may occur:
\begin_inset Formula \begin{align}
Lntp(s,t)\equiv & \exists a\,\left[Natural(a)\wedge Poss(a,s)\wedge time(a)=t\right]\wedge\nonumber \\
 & \forall a\,\left[Natural(a)\wedge Poss(a,s)\rightarrow t\leq time(a)\right]\label{eqn:lntp_def}\end{align}

\end_inset

 Note that the LNTP need not exist for a given situation.
 We will assume that the domain axiomatisation is designed to avoid certain
 pathological cases, so that absence of an LNTP implies that no natural
 actions are possible.
\end_layout

\begin_layout Subsection
Golog
\end_layout

\begin_layout Standard
Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

 is a declarative agent programming language based on the situation calculus.
 Testimony to its success are its wide range of applications and many extensions
 to provide additional functionality (
\begin_inset LatexCommand \cite{giacomo00congolog,giacomo99indigolog,boutilier00dtgolog,Ferrein2005readylog}

\end_inset

).
 We use the term 
\begin_inset Quotes eld
\end_inset

Golog
\begin_inset Quotes erd
\end_inset

 to refer to the family of languages based on this technique.
\end_layout

\begin_layout Standard
To program an agent using Golog one specifies a situation calculus theory
 of action, and a program consisting of actions connected by programming
 constructs such as if-then-else, while loops, and nondeterministic choice.
 Table 
\begin_inset LatexCommand \ref{tbl:Golog-Operators}

\end_inset

 lists some of the operators available in various incarnations of the language.
\begin_inset Float table
placement t
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Operator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Meaning
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\phi?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Proceed only if condition 
\begin_inset Formula $\phi$
\end_inset

 is true
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1};\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute program 
\begin_inset Formula $\delta_{1}$
\end_inset

followed by 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}|\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute either 
\begin_inset Formula $\delta_{1}$
\end_inset

 or 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\pi(x)\delta(x)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nondet.
 select arguments for 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 zero or more times
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Exec.
 
\begin_inset Formula $\delta_{1}$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 holds, 
\begin_inset Formula $\delta_{2}$
\end_inset

 otherwise
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{while\,}\phi\mathbf{\, do}\,\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 while 
\begin_inset Formula $\phi$
\end_inset

 holds
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Concurrently execute 
\begin_inset Formula $\delta_{1}$
\end_inset

and 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\Sigma\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Find and perform legal exec.
 of 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Procedure definition
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
Some Golog Operators
\begin_inset LatexCommand \label{tbl:Golog-Operators}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In line with the idea of high-level program execution, the agent's control
 program may be nondeterministic.
 It is the task of the agent to find a deterministic instantiation of the
 program, a sequence of actions that can legally be performed in the world.
 Such a sequence is called a 
\begin_inset Quotes eld
\end_inset

legal execution
\begin_inset Quotes erd
\end_inset

 of the Golog program.
\end_layout

\begin_layout Standard
The semantics of the Golog operators are defined recursively using situation
 calculus sentences.
 The most flexible semantics have proven to be the transition semantics
 of ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset

 and IndiGolog 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

.
 Two predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 are defined for each operator.
 
\begin_inset Formula $Trans(\delta,s,\delta',s')$
\end_inset

 holds when executing a single step of program 
\begin_inset Formula $\delta$
\end_inset

 can cause the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to situation 
\begin_inset Formula $s'$
\end_inset

, after which 
\begin_inset Formula $\delta'$
\end_inset

 remains to be executed.
 It thus characterizes single steps of computation.
 
\begin_inset Formula $Final(\delta,s)$
\end_inset

 holds when program 
\begin_inset Formula $\delta$
\end_inset

 may legally terminate its execution in situation 
\begin_inset Formula $s$
\end_inset

.
 The full semantics on which we base our work can be found in 
\begin_inset LatexCommand \cite{giacomo00congolog,giacomo99indigolog}

\end_inset

, but as an example consider the clause for the concurrency operator in
 equation (
\begin_inset LatexCommand \ref{eqn:trans_conc_orig}

\end_inset

) which specifies concurrency via interleaving.
 It states that that it is possible to single-step the concurrent execution
 of 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

 by performing either a step from 
\begin_inset Formula $\delta_{1}$
\end_inset

 or a step from 
\begin_inset Formula $\delta_{2}$
\end_inset

, with the remainder 
\begin_inset Formula $\gamma$
\end_inset

 left to execute concurrently with the other program: 
\begin_inset Formula \begin{align}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \,\,\,\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})\nonumber \\
 & \vee\,\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\label{eqn:trans_conc_orig}\end{align}

\end_inset

 If the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

 is enriched with 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

, executing a golog program 
\begin_inset Formula $\delta$
\end_inset

 is basically a theorem proving task to find a suitable situation 
\begin_inset Formula $s$
\end_inset

, which gives the actions that must be performed.
\begin_inset Formula \begin{equation}
\mathcal{D}\models\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]\label{eqn:golog_execution}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
As seen above, the term 
\begin_inset Quotes eld
\end_inset

concurrency
\begin_inset Quotes erd
\end_inset

 can refer to two distinct ideas: the possibility of performing several
 actions at the same instant, and the possibility of interleaving the execution
 of several programs.
 These are referred to as 
\emph on
true concurrency
\emph default
 and 
\emph on
interleaved concurrency
\emph default
 respectively.
 These two notions of concurrency were combined by 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

, who modified ConGolog to incorporate sets of concurrent actions.
 However, their semantics do not guarantee legality of situations and (as
 we shall see below) may result in unexpected program behavior.
 We develop a more robust integration of these notions of concurrency.
\end_layout

\begin_layout Standard
As an example of a multi-agent task specification in Golog, consider a program
 
\begin_inset Formula $MakeSalad$
\end_inset

 that instructs a team of agents to prepare a simple salad:
\begin_inset Formula \begin{multline}
\mathbf{proc}\, MakeSalad(dest)\label{eqn:MakeSalad}\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)\left[acquire(agt,dest)\,;\, begin\_task(agt,mix(dest,1))\,;\right.\\
\left.end\_task(agt,mix(dest,1))\,;\, release(agt,dest)\right]\,\,\mathbf{end}\end{multline}

\end_inset

The procedure 
\begin_inset Formula $ChopTypeInto$
\end_inset

 (not shown) picks an object of the given type and an available chopping
 board, chops the object using the board, then transfers it into the destination
 container.
 
\begin_inset Formula $MakeSalad$
\end_inset

 tells the agents to do this for a lettuce, a carrot and a tomato, then
 mix the ingredients together for 1 minute.
 The agent assigned to handling each ingredient is not specified (
\begin_inset Formula $\pi$
\end_inset

 construct), nor is the order in which they should be added (
\begin_inset Formula $||$
\end_inset

 construct).
\end_layout

\begin_layout Standard
While this program could be executed using the existing semantics of ConGolog
 or IndiGolog, the result would be suboptimal.
 As these languages lack true concurrency, only a single agent could act
 at each step.
 Predictable exogenous actions such as 
\begin_inset Formula $end\_task$
\end_inset

 also require special handling in these languages.
 Our new variant MIndiGolog is designed to produce executions of such programs
 that are more suitable for multi-agent teams.
\end_layout

\begin_layout Subsection
Related Work
\end_layout

\begin_layout Standard
While work with Golog has predominantly focused on single-agent systems,
 there have been several notable applications of the technique to multi-agent
 systems.
 The Cognitive Agent Specification Language 
\begin_inset LatexCommand \cite{shapiro02casl}

\end_inset

 uses ConGolog to describe the behavior of agents in a multi-agent setting,
 and an automated theorem prover is in development that can verify properties
 of the programs.
 It differs from our work in that it is designed for open multi-agent systems,
 with each agent having its own Golog program defining its individual behavior.
 By contrast, we seek to develop a single Golog program that is cooperatively
 executed by all agents.
 It also appears to focus on modeling and simulation of agent systems more
 than actually executing the programs.
\end_layout

\begin_layout Standard
Closer to the spirit of this paper is the work of 
\begin_inset LatexCommand \cite{Ferrein2005readylog}

\end_inset

 on ReadyLog, a Golog derivative designed for highly dynamic domains.
 It has been successfully used to control multi-agent teams in the RoboCup
 soccer tournament by having the agents execute a shared Golog program.
 ReadyLog agents each individually determine a legal execution of the program,
 allowing them to coordinate without communication.
 We aim to allow the agents to communicate and pool their computational
 resources in planning an execution.
 ReadyLog integrates the facilities of concurrency, online execution and
 decision theory and can be seen as a unification of ConGolog, IndiGolog
 and DTGolog.
 We believe our enhancements to be compatible with and complimentary to
 this work.
\end_layout

\begin_layout Standard
Note that this paper focusses on task specification using Golog and does
 not deal with coordination between team members.
 Our ongoing research program is developing techniques for cooperative execution
 of such Golog programs, based on successful approaches to executing HTN
 task specifications such as 
\begin_inset LatexCommand \cite{tambe97flexible_teamwork,grosz99planning_together,decker95designing_coordination}

\end_inset

.
\end_layout

\begin_layout Section
MIndiGolog
\begin_inset LatexCommand \label{sec:MIndiGolog}

\end_inset


\end_layout

\begin_layout Standard
We have integrated three extensions to the situation calculus with the semantics
 of ConGolog and IndiGolog to overcome challenges encountered when moving
 to a multi-agent setting.
 These extensions allow the agents to represent time, concurrently-occurring
 actions, and natural actions.
\end_layout

\begin_layout Subsection
Time:
\end_layout

\begin_layout Standard
As should be clear from the background section, the approach of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 to modelling time is complicated by the presence of concurrent actions.
 To avoid the need for the 
\begin_inset Formula $Coherent$
\end_inset

 predicate, we attach the temporal argument to each situation rather than
 to each action.
 The successor situation function 
\begin_inset Formula $do(a,s)$
\end_inset

 becomes 
\begin_inset Formula $do(a,t,s)$
\end_inset

, to indicate 
\begin_inset Quotes eld
\end_inset

action 
\begin_inset Formula $a$
\end_inset

 was performed at time 
\begin_inset Formula $t$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 Likewise, the possibility predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 becomes 
\begin_inset Formula $Poss(a,t,s)$
\end_inset

.
 
\begin_inset Formula $Coherent$
\end_inset

 and 
\begin_inset Formula $time$
\end_inset

 are no longer needed, and the definition of 
\begin_inset Formula $start$
\end_inset

 becomes simply:
\begin_inset Formula \[
start(do(a,t,s))=t\]

\end_inset


\end_layout

\begin_layout Standard
The existing semantics of IndiGolog are trivially modified to accommodate
 this change.
\end_layout

\begin_layout Subsection
Concurrency:
\end_layout

\begin_layout Standard
While it is straightforward to modify the clause of 
\begin_inset Formula $Trans$
\end_inset

 for primitive actions to accept sets of concurrent actions, there are deeper
 implications for the concurrency operator.
 In ConGolog/IndiGolog this is implemented by accepting a transition from
 either of the two programs as a transition for the pair (equation 
\begin_inset LatexCommand \ref{eqn:trans_conc_orig}

\end_inset

).
 In the presence of true concurrency, this is insufficient.
 Suppose program 
\begin_inset Formula $\delta_{1}$
\end_inset

 may be transitioned by performing actions 
\begin_inset Formula $c_{1}$
\end_inset

, and 
\begin_inset Formula $\delta_{2}$
\end_inset

 may be transitioned by performing actions 
\begin_inset Formula $c_{2}$
\end_inset

.
 As noted in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

, the potential for true concurrency should be exploited by performing both
 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $c_{2}$
\end_inset

 simultaneously, i.e.
 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
However, this introduces several complications not addressed by 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

.
 First, the precondition interaction problem means that 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 is not guaranteed to be possible even if the individual actions are.
 The transition clause must ensure that the combination of the two sets
 of actions is possible.
\end_layout

\begin_layout Standard
Another issue arises when two programs can legitimately be transitioned
 by executing the same action.
 Consider the following programs which add ingredients to a bowl:
\begin_inset Formula \begin{gather*}
\delta_{1}=place\_in(Thomas,Flour,Bowl)\,;\, place\_in(Thomas,Sugar,Bowl)\\
\delta_{2}=place\_in(Thomas,Flour,Bowl)\,;\, place\_in(Thomas,Egg,Bowl)\end{gather*}

\end_inset

Executing 
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset

 should result in the bowl containing two units of flour, one unit of sugar
 and an egg.
 However, an individual transition for both programs is 
\begin_inset Formula $c_{1}=c_{2}=place\_in(Thomas,Flour,Bowl)$
\end_inset

.
 Naively executing 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 to transition both programs would add only one unit of flour.
 Alternately, consider two programs waiting for a timer to ring (a natural
 action, not initiated by any agent):
\begin_inset Formula \begin{gather*}
\delta_{1}=ring\_timer(OvenTimer)\,;\, acquire(Thomas,Bowl)\\
\delta_{2}=ring\_timer(OvenTimer)\,;\, acquire(Richard,Board)\end{gather*}

\end_inset

Both programs should be allowed to proceed with a single occurrence of the
 
\begin_inset Formula $ring\_timer$
\end_inset

 action, because it is an aspect of the environment.
 To avoid such untuitive (and potentially dangerous) behavior, concurrent
 execution must not be allowed to transition both programs using the same
 agent-initiated action.
 If an action may be safely skipped, it should be enclosed in an appropriate
 if-then-else or choice construct.
\end_layout

\begin_layout Standard
Taking these factors into account, we develop an improved transition rule
 for concurrency as shown in equation (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

).
 The first two lines are the original interleaved concurrency clause from
 ConGolog, while the remainder characterizes the above considerations for
 true concurrency.
 This robust combination allows the language to more accurately reflect
 the concurrency present in multi-agent teams.
\begin_inset Formula \begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\label{eqn:trans_conc_new}\\
\exists\gamma\,\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})\\
\vee\exists\gamma\,\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\\
\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,\,\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\\
\shoveright{\wedge Poss(c_{1}\cup c_{2},t,s)\wedge\forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Natural(a)\right]}\\
\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\end{multline}

\end_inset


\end_layout

\begin_layout Subsection
Natural Actions:
\end_layout

\begin_layout Standard
The methodology of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 is adopted, suitably modified for our handling of time.
 To see how this works, consider stating the axiom for 
\begin_inset Formula $ring\_timer$
\end_inset

 (equation TODO) using our notation:
\begin_inset Formula \begin{multline}
Poss(ring\_timer(ID),t,s)\equiv\\
\exists m.\left[Timer\_Set(ID,m,s)\wedge t=start(s)+m\right]\end{multline}

\end_inset

While planning with natural actions has previously been done in Golog 
\begin_inset LatexCommand \cite{pirri00planning_nat_acts}

\end_inset

, the programmer was required to explicitly check for the possible occurrence
 of natural actions and ensure that they appear in the execution.
 We significantly lower the burden on the programmer by guaranteeing that
 all program executions produce legal situations.
 MIndiGolog agents will plan for the occurrence of natural actions without
 having them explicitly mentioned in the program.
 They may optionally be included in the program, instructing the agents
 to wait for the action to occur before proceeding.
\end_layout

\begin_layout Standard
This is achieved using a new 
\begin_inset Formula $Trans$
\end_inset

 clause for programs consisting of a single action 
\begin_inset Formula $c$
\end_inset

, shown in equation (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

).
 If 
\begin_inset Formula $s$
\end_inset

 has an LNTP 
\begin_inset Formula $t_{n}$
\end_inset

 and corresponding set of natural actions 
\begin_inset Formula $c_{n}$
\end_inset

, a transition can be made in three ways: perform 
\begin_inset Formula $c$
\end_inset

 at a time before 
\begin_inset Formula $t_{n}$
\end_inset

 (third line), perform it along with the natural actions at 
\begin_inset Formula $t_{n}$
\end_inset

 (fourth line), or wait for the natural actions to occur (fifth line).
 If there is no LNTP, then 
\begin_inset Formula $c$
\end_inset

 may be performed at any time greater than 
\begin_inset Formula $start(s)$
\end_inset

.
\begin_inset Formula \begin{multline}
Trans(c,s,\delta',s')\equiv\label{eqn:trans_prim_new}\\
\exists t,t_{n},c_{n}\,\, Lntp(s,t_{n})\wedge t\geq start(s)\wedge\\
\forall a\,\,\left[Natural(a)\wedge Poss(a,t_{n},s)\equiv c\in c_{n}\right]\wedge\\
\left[t<t_{n}\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=Nil\right.\\
\vee Poss(c\cup c_{n},t_{n},s)\wedge s'=do(c\cup c_{n},t,s)\wedge\delta'=Nil\\
\vee\left.s'=do(c_{n},t_{n},s)\wedge\delta'=c\right]\\
\vee\,\neg\exists t_{n}.\, Lntp(s,t_{n})\wedge\exists t.\, Poss(c,t,s)\wedge\\
t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=Nil\end{multline}

\end_inset


\end_layout

\begin_layout Subsubsection
Legality of our Semantics
\end_layout

\begin_layout Standard
Let a 
\emph on
MIndiGolog Theory of Action
\emph default
 be a theory of action in the situation calculus enhanced with time, true
 concurrency and natural actions, augmented with the predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 from IndiGolog, modified according to equations (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

).
 IndiGolog programs can be executed relative to this theory of action as
 in equation (
\begin_inset LatexCommand \ref{eqn:golog_execution}

\end_inset

), and the resulting legal executions will be suitable for execution by
 multi-agent teams.
 In particular, all legal executions of a MIndiGolog program produce legal
 situations:
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $\mathcal{D}$
\end_inset

 be a MIndiGolog theory of action.
 Then:
\begin_inset LatexCommand \label{thm:trans_legal}

\end_inset


\begin_inset Formula \[
\mathcal{D}\models\forall s,s',\delta,\delta'\,\, Legal(s)\wedge Trans(\delta,s,\delta',s')\rightarrow Legal(s')\]

\end_inset


\end_layout

\begin_layout Proof
By induction on the structure of 
\begin_inset Formula $\delta$
\end_inset

.
 Consider first the base case of a single concurrent action 
\begin_inset Formula $\delta=c$
\end_inset

.
 This 
\begin_inset Formula $Trans$
\end_inset

 clause (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

) has four disjuncts.
 We treat here only the case where actions are performed before the LNTP,
 other cases employ similar reasoning.
 Assuming this case, (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

) reduces to:
\begin_inset Formula \begin{multline*}
Trans(c,s,Nil,do(c,t,s))\equiv\\
\exists t_{n}.Lntp(s,t_{n})\wedge t<t_{n}\wedge ti\geq start(s)\wedge Poss(c,t,s)\end{multline*}

\end_inset

By the definition of 
\begin_inset Formula $Lntp$
\end_inset

 (
\begin_inset LatexCommand \ref{eqn:lntp_def}

\end_inset

) and given 
\begin_inset Formula $t<t_{n}$
\end_inset

, no natural actions can be possible before or at time 
\begin_inset Formula $t$
\end_inset

, allowing us to add:
\begin_inset Formula \begin{multline*}
Trans(c,s,Nil,do(c,t,s))\equiv\\
\exists t_{n}.Lntp(s,t_{n})\wedge t<t_{n}\wedge t\geq start(s)\wedge Poss(c,t,s)\wedge\\
\forall a,t_{a}\left[Natural(a)\wedge Poss(a,t_{a},s)\rightarrow t<t_{a}\right]\end{multline*}

\end_inset

 Given 
\begin_inset Formula $Legal(s)$
\end_inset

 and equation (
\begin_inset LatexCommand \ref{eqn:legal_def}

\end_inset

), it is then clear that for this case:
\begin_inset Formula \[
\mathcal{D}\models Legal(s)\wedge Trans(c,s,Nil,do(c,t,s))\rightarrow Legal(do(c,t,s))\]

\end_inset

Of the remaining clauses for 
\begin_inset Formula $Trans$
\end_inset

, only that for the concurrency operator explicitly builds a new situation
 term.
 Establishing the theorem for this construction is straightforward and is
 not detailed here.
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $\mathcal{D}$
\end_inset

 be a MIndiGolog theory of action.
 Then: 
\begin_inset Formula \[
\mathcal{D}\models\forall s',\delta,\delta'.\, Trans*(\delta,S_{0},\delta',s')\rightarrow Legal(s')\]

\end_inset

 Consequently, all legal executions of a MIndiGolog program respect the
 occurrence of natural actions.
 
\end_layout

\begin_layout Proof
Immediate from Theorem 
\begin_inset LatexCommand \ref{thm:trans_legal}

\end_inset

, the legality of 
\begin_inset Formula $S_{0}$
\end_inset

, and the properties of transitive closure.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide true
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "100in"
height_special "depth"
status open

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
scriptsize 
\backslash
verbatiminput{listings/output_makeSalad_1.txt}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
scriptsize 
\backslash
verbatiminput{listings/output_makeSalad_2.txt}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Caption
One possible execution of the 
\begin_inset Formula $MakeSalad$
\end_inset

 program with three agents.
 Variables 
\begin_inset Formula $\_U$
\end_inset

, 
\begin_inset Formula $\_T$
\end_inset

, etc give the occurrence times of each action, constrained to ensure all
 situations are legal.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{cap:example_trace}

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The effect of our enhancements can be seen in Figure 
\begin_inset LatexCommand \ref{cap:example_trace}

\end_inset

, which shows one possible legal execution of the 
\begin_inset Formula $MakeSalad$
\end_inset

 program (
\begin_inset LatexCommand \ref{eqn:MakeSalad}

\end_inset

).
 Notice the occurrence of several actions within each 
\series bold
do
\series default
 statement, demonstrating the integration of true concurrency into the language.
 Note also the explicit occurrence time for each step, allowing the agents
 to properly synchronize their actions.
 This time is not fixed, but constrained to synchronize with the natural
 actions included in the program.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Conclusions and Future Work
\begin_inset LatexCommand \label{sec:Conclusions}

\end_inset


\end_layout

\begin_layout Standard
In this paper, we have integrated of several important extensions to the
 situation calculus and Golog to provide a new language suitable for expressing
 high-level programs for multi-agent teams.
 Specifically, MIndiGolog combines both true and interleaved concurrency,
 an explicit account of time, and seamless integration of natural actions.
\end_layout

\begin_layout Standard
Since planning a legal execution in MIndiGolog is a theorem-proving task,
 existing tools for distributed logic programming can be used to allow a
 team of agents to share the planning workload.
 We are presently exploring the potential of this approach for a range of
 distributed programming applications, and the integration of additional
 techniques from the Golog community.
 Key among these is the significant work on representing knowledge and belief
 in Golog.
 As many applications involve partially observable worlds, different agents
 must be capable of having different beliefs about the world.
 This will in turn require more complex strategies for sharing the planning
 workload.
\end_layout

\begin_layout Standard
As we have shown, the combination of state-of-the-art techniques from Golog
 is highly capable of representing tasks and behavior for multi-agent teams.
 Combined with facilities for distributed logic programming, MIndiGolog
 promises to provide the advantages of the high-level program execution
 paradigm for multi-agent teams.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex{/storage/uni/pgrad/library/references}

\end_inset

 
\end_layout

\end_body
\end_document
