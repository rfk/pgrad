#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Cooperative Execution of Golog Programs
\layout Abstract

The Golog family of programming languages are designed for high-level control
 of autonomous agents such as mobile robots.
 Based on the logical formalism of the situation calculus, these languages
 allow the programmer to define a (potentially non-deterministic) program
 or plan, from which the agent will determine an appropriate execution strategy.
 This paper seeks to extend the Golog system by allowing multiple autonomous
 agents to cooperate in executing a Golog plan.
\layout Section

Introduction
\layout Standard

The programming language Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

 and its derivatives have found a wide range of applications in agent-oriented
 systems, from museum tour-guide robots (TODO:ref), mail delivery, TODO:more
 here to the RoboCup robotic soccer competition.
 It has proven to be a flexible programming language with the right mix
 of high-level programming constructs and domain abstraction...TODO:talk it
 up some more.
\layout Standard

In all of these situations, Golog is used as a programming language to define
 the behavior of a single agent.
 Viewed in a slightly different way, however, a Golog procedure can be viewed
 not as a program but as a plan - a specification of tasks to be performed
 and the constaints between them.
 TODO:hmm...more here.
\layout Standard

While Golog has been utilised in multi-agent settings, the Golog programs
 themselves are typically designed to be executed by a single agent.
 For example, in the ECASL system of TODO:ref, the behavior of multiple
 interacting agents may be specified, but each agent's behavior is given
 by an individual Golog program.
\layout Standard

In all these cases, Golog programs are written to specify a 
\emph on 
solution
\emph default 
, to set out what the agent is to achieve.
 But a Golog program may also be viewed as a specification of a task, what
 the programmer wants achieved.
 In this view, the Golog program specifies a 
\emph on 
problem
\emph default 
 which the agent(s) are to solve.
 Viewed in this way, it is not difficult to imagine that several independent
 agents may cooperate in order to execute a single Golog program that specified
 what is to be achieved.
 Exploring this idea is the purpose of this paper.
\layout Subsection

Running Example: The Cooking Agents
\layout Standard

In order to explore the cooperative execution of Golog programs in a concrete
 way, a running example is introduced and expounded throughout this paper.
 It consists of a number of agents cooperating to cook dinner.
 
\layout Standard

The task will be as follows: have the agents cooperate to produce a salad,
 steak, roast potatoes and a cake by executing Golog programs representing
 the recipies for each component of the meal.
 They should make good use of the fact that there are multiple agents available
 to reduce the overall preparation time through multitasking.
\layout Standard

This example is particularly suitable because the domain has explicit need
 for task specification in the form of recipies.
 For example, there may be Golog procedure describing how to prepare a salad
 and another describing how to bake a cake.
 These are obviously task descriptions seperate from the behavioral control
 of any individual agent, and therefore amenable to cooperative execution.
\layout Standard

The example domain also embodies several simplifications which should make
 things easier for this initial investigation.
 Without difficulty it may be idealised as being completely deterministic
 and fully observable.
 The agents are also in close proximity allowing full and reliable communication.
\layout Section

Background
\layout Subsection

The Situation Calculus
\layout Standard

The situation calculus is a first order logic formalism designed for representin
g and reasoning about dynamically changing worlds, introduced by McCarthy
 and Hayes 
\begin_inset LatexCommand \cite{McCHay69sitcalc}

\end_inset 

.
 While the concepts of the situation calculus remain largely unchanged,
 the accompanying notation has evolved somewhat since its inception.
 The notation presented here is that of Reiter 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

.
\layout Standard

A representation of a dynamic world in the situation calculus consists of
 first order logic statements capturing the following, which will be explained
 further in later sections:
\layout Itemize

The actions that can be performed in the world
\layout Itemize

The fluents that describe the state of the world
\layout Itemize

Action precondition axioms, one for each action
\layout Itemize

Successor state axioms, one for each fluent
\layout Itemize

Axioms describing the initial world situation
\layout Itemize

The foundational axioms of the situation calculus
\layout Standard

The foundational axioms support reasoning and induction over situation calculus
 models.
 Since they will not be referenced in this paper, they are not repeated
 here.
 A detailed treatment may be found in 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

.
\layout Standard

To assist in the presentation of this material, a simple robot world will
 be modelled as a running example.
 In this world there is a single robot and several inanimate objects.
 The world is laid out according to a grid so that locations can be specified
 in terms of 
\begin_inset Formula $(x,y)$
\end_inset 

 coordinate points.
 It is possible for the robot to move around the world, and to pick up and
 drop items.
 Some items may be too heavy for the robot to pick up, or fragile so that
 they break when they are dropped.
 The robot also has the ability to repair any broken items that it is holding.
\layout Subsubsection

Situations and Actions
\layout Standard

A dynamic world in the situation calculus is modelled as progressing through
 a series of 
\emph on 
situations 
\emph default 
as a result of various 
\emph on 
actions
\emph default 
 being performed within the world.
 A situation corresponds to a particular history of action occurrences.
 The situation before any actions have been performed is typically denoted
 
\begin_inset Formula $S_{0}$
\end_inset 

 and referred to as the initial situation.
 The new situation resulting from the performance of an action is obtained
 using the function 
\begin_inset Formula $do$
\end_inset 

.
 This function takes a situation and an action as arguments, and returns
 the situation that results from performing the given action in the given
 situation.
 Actions may be parameterised and both actions and situations are first
 order terms within the language.
\layout Standard

In the example world, possible action terms would be 
\begin_inset Formula $move(x,y)$
\end_inset 

 to model the robot moving to a new location 
\begin_inset Formula $(x,y)$
\end_inset 

, and 
\begin_inset Formula $pickup(o)$
\end_inset 

 to model the robot picking up an object 
\begin_inset Formula $o$
\end_inset 

.
 The world is initially in situation 
\begin_inset Formula $S_{0}$
\end_inset 

.
 If the robot's first action is to move to location 
\begin_inset Formula $(2,3)$
\end_inset 

, the new situation would be 
\begin_inset Formula $do(move(2,3),S_{0})$
\end_inset 

.
 If its next action is the pick up the ball, the new situation would be
 
\begin_inset Formula $do(pickup(Ball),do(move(2,3),S_{0}))$
\end_inset 

.
\layout Subsubsection

Fluents
\layout Standard

Statements whose truth value may change as the result of actions being performed
 are modelled by 
\emph on 
relational fluents
\emph default 
, predicates which take a situation as their final argument.
 It is also possible to define 
\emph on 
functional fluents
\emph default 
, functions which take a situation as their final argument and return a
 situation-dependent value.
 Fluents may be through of as 
\begin_inset Quotes eld
\end_inset 

properties of the world
\begin_inset Quotes erd
\end_inset 

.
\layout Standard

In the example world, the fluent 
\begin_inset Formula $is\_ carrying(o,s)$
\end_inset 

 could be used to indicate that the robot is carrying a particular object
 in a particular situation.
 Assuming the robot initially carries nothing, 
\begin_inset Formula $is\_ carrying(Ball,S_{0})$
\end_inset 

 would be false while 
\begin_inset Formula $is\_ carrying(Ball,do(pickup(Ball),S_{0}))$
\end_inset 

 would be true.
 The location of the robot could be modelled using a functional fluent 
\begin_inset Formula $(x,y)=location(s)$
\end_inset 

 which returns the location of the robot in a particular situation.
\layout Subsubsection

Action Preconditions and Effects
\layout Standard

It may not be possible to perform a given action in a give situation - for
 example, it is impossible to put down an object unless one is in fact carrying
 it.
 These restrictions on the performance of actions are modelled by action
 precondition axioms of the form 
\begin_inset Formula $Poss(a,s)$
\end_inset 

, where 
\begin_inset Formula $a$
\end_inset 

 is an action and 
\begin_inset Formula $s$
\end_inset 

 a situation.
 The condition that dropping an object is only possible when one is carrying
 it would be modelled in the example world by:
\layout Standard


\begin_inset Formula \[
Poss(drop(o),s)\leftrightarrow is\_ carrying(o,s)\]

\end_inset 


\layout Standard

As a more complex example, the following models that the robot can carry
 only one object at a time, and that some objects are too heavy for the
 robot to lift (indicated by the predicate 
\begin_inset Formula $heavy$
\end_inset 

):
\layout Standard


\begin_inset Formula \[
Poss(pickup(o),s)\leftrightarrow(\forall z\neg is\_ carrying(z,s))\wedge\neg heavy(o)\]

\end_inset 


\layout Standard

Given that an action is possible in a situation, one must specify the effects
 that performing that action would have on the world's fluents.
 This is done by specifying effect axioms.
 For example, the fact that picking up an object causes the robot to be
 carrying it can be modelled as:
\layout Standard


\begin_inset Formula \[
Poss(pickup(o),s)\rightarrow is\_ carrying(o,do(pickup(o),s))\]

\end_inset 


\layout Standard

It is also possible to specify conditional effects, based on other properties
 of the objects under consideration.
 The following models that some objects are fragile (indicated by the predicate
 
\begin_inset Formula $fragile$
\end_inset 

) and dropping them cases them to be broken (indicated by the fluent 
\begin_inset Formula $broken$
\end_inset 

):
\layout Standard


\begin_inset Formula \[
Poss(drop(o),s)\wedge fragile(o)\rightarrow broken(o,do(drop(o),s))\]

\end_inset 


\layout Subsubsection

The Frame Problem
\layout Standard

While the model at this stage is suitable for reasoning about the effects
 of actions, is has a critical weakness - it cannot be used to reason about
 the 
\emph on 
non-effects
\emph default 
 of actions.
 For example, it is not possible to deduce that after picking up an object,
 the robot's location remains unchanged.
 This requires a so-called frame axiom of the form:
\layout Standard


\begin_inset Formula \[
Poss(pickup(o),s)\wedge location(s)=(x,y)\rightarrow location(do(pickup(o),s))=(x,y)\]

\end_inset 


\layout Standard

The need to specify frame axioms has long been recognised as a problem in
 axiomatizing dynamic worlds (TODO:ref), as there are generally a very large
 number of such axioms.
 It is very easy for the designer to leave out a necessary frame axiom,
 or to forget to modify all appropriate axioms when a change to the world
 model is made.
\layout Subsubsection

Successor State Axioms
\layout Standard

A simple solution to the frame problem (TODO:under what circumstances?)
 was proposed by Reiter 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset 

 in the form of successor state axioms.
 It requires that the designer has enumerated as effect axioms all the ways
 in which the value of a particular fluent can be changed.
 The effect axioms affecting the value of fluent 
\begin_inset Formula $F(\overrightarrow{x},s)$
\end_inset 

 can be written in generalised form as a positive and a negative effect
 axiom:
\layout Standard


\begin_inset Formula \[
Poss(a,s)\wedge\gamma_{F}^{+}(\overrightarrow{x},a,s)\rightarrow F(\overrightarrow{x},do(a,s))\]

\end_inset 


\layout Standard


\begin_inset Formula \[
Poss(a,s)\wedge\gamma_{F}^{-}(\overrightarrow{x},a,s)\rightarrow\neg F(\overrightarrow{x},do(a,s))\]

\end_inset 


\layout Standard

Here the formula 
\begin_inset Formula $\gamma_{F}^{+}$
\end_inset 

describes the conditions under which action 
\begin_inset Formula $a$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

 can make the fluent 
\begin_inset Formula $F$
\end_inset 

 become true in the successor situation 
\begin_inset Formula $do(a,s)$
\end_inset 

.
 Likewise, 
\begin_inset Formula $\gamma_{F}^{-}$
\end_inset 

 describes the conditions under which performing action 
\begin_inset Formula $a$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

 will make fluent 
\begin_inset Formula $F$
\end_inset 

 false in the successor situation.
\layout Standard

Assuming that this pair of axioms describe all the ways in which fluent
 
\begin_inset Formula $F$
\end_inset 

 can change value, they can be re-written as a single axiom:
\layout Standard


\begin_inset Formula \[
Poss(a,s)\rightarrow\left[F(\overrightarrow{x},do(a,s))\leftrightarrow\gamma_{F}^{+}(\overrightarrow{x},a,s)\vee\left(F(\overrightarrow{x},s)\wedge\neg\gamma_{F}^{-}(\overrightarrow{x},a,s)\right)\right]\]

\end_inset 


\layout Standard

In words this states: 
\begin_inset Quotes eld
\end_inset 

given that is is possible to perform action 
\begin_inset Formula $a$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

, the fluent 
\begin_inset Formula $F$
\end_inset 

 would be true in the resulting situation 
\begin_inset Formula $do(a,s)$
\end_inset 

 if and only if performing 
\begin_inset Formula $a$
\end_inset 

 in 
\begin_inset Formula $s$
\end_inset 

 would make it true, or it is true in situation 
\begin_inset Formula $s$
\end_inset 

 and performing 
\begin_inset Formula $a$
\end_inset 

 in 
\begin_inset Formula $s$
\end_inset 

 would not make it false.
\begin_inset Quotes erd
\end_inset 


\layout Standard

By way of example, the fluent 
\begin_inset Formula $broken$
\end_inset 

 introduced above can be given the following successor state axiom:
\layout Standard


\begin_inset Formula \[
Poss(a,s)\rightarrow\left[broken(o,do(a,s)\leftrightarrow\right.\]

\end_inset 


\layout Standard


\begin_inset Formula \[
a=drop(o)\wedge fragile(o)\,\,\vee\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\left.broken(o,s)\wedge a\neq repair(o)\right]\]

\end_inset 


\layout Subsubsection

The Initial Situation
\layout Standard

Finally, the designer must specify the properties of the initial situation.
 This is done simply by making assertions about 
\begin_inset Formula $S_{0}$
\end_inset 

.
 The following statements model that initially, the robot carries nothing,
 is at location 
\begin_inset Formula $(0,0)$
\end_inset 

, and there are no broken objects:
\layout Standard


\begin_inset Formula \[
\forall z\,\neg is\_ carrying(z,S_{0})\]

\end_inset 


\layout Standard


\begin_inset Formula \[
location(S_{0})=(0,0)\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\forall o\,\neg broken(o,S_{0})\]

\end_inset 


\layout Standard

Continuing as shown in these examples, it is possible to obtain a full axiomatis
ation of a dynamic world in first order logic.
 This can then be used to reason about how sequences of actions affect propertie
s of the world.
\layout Subsection

Golog
\layout Standard

Golog (short for alGOl in LOGic) is a declarative programming language based
 on the situation calculus, developed by Levesque et.
 al 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

.
 It combines the primitive actions frm the situation calculus description
 of the world into high-level programming constructs such as while-loops,
 if-then-else clauses, and nondeterministic choice.
\layout Standard

TODO:oh so much more here!
\layout Section

Domain Axiomatisation
\layout Standard

As described above, the first task in implementing a Golog-based system
 is to produce an appropriate axiomatisation of the domain in the Situation
 Calculus.
 Ideally this will be done in a principled way which can be easily applied
 to other domains.
 For the cooking agents example, there are a number of factors which make
 the axiomatisation challenging: 
\layout Itemize

Consumables: The agents should have access to a limitless supply of consumables
 such as lettuce, flour and eggs.
 However, each individual instance of a consumable needs to be a first-order
 object and thus have a unique name.
\layout Itemize

Resources: The agents will face conention for resources such as the oven,
 mixing bowls and chopping boards.
 There should be a principled way to represent these limited resources and
 the acquisition/relase of them within the Situation Calculus.
\layout Itemize

Continuous Processes: The domain requires continuous processes such as the
 setting of a timer to control the baking time of a cake.
 These processes will not necessarily end under the control of the agent.
\layout Itemize

Natural Actions: These are predictable actions which occur outside of the
 agent's control, and which must occur as long as nothing happens to stop
 them from occuring.
\layout Itemize

Concurrency: For a multi-agent system two notions of concurrency must be
 considered - the concurrent execution of several high-level programs, and
 the concurrent performance of several actions by independent agents.
\layout Itemize

Time: Some tasks in the cooking domain may require an explicit notion of
 time.
 For example, a cake must be baked for 30 minutes before being removed from
 the oven.
\layout Itemize

Abilities: Different agents may have different skills and abilities.
 For example, one of the agents may be hyper-sensitive to onion and therefore
 cannot be expected to handle it.
\layout Standard

These will be systematically addressed in the following sections.
\layout Subsection

Abilities
\layout Standard

The work of Cholvy et al 
\begin_inset LatexCommand \cite{cholvy04sitcalc_ability}

\end_inset 

 provides a suitable formalism for representing ability in the situation
 calculus.
 TODO:expand, find proper ref.
\layout Subsection

Concurrency
\layout Standard

The notion of concurrently executing multiple high-level programs is given
 an in-depth treatment in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 with the development of ConGolog.
 As discussed above, this adds support for prioritized concurrency and interrupt
s to the standard Golog semantics by means of interleaving of primitive
 actions.
\layout Standard

The work of 
\begin_inset LatexCommand \cite{lin92sc_conc}

\end_inset 

 and 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 provides a suitable extension to the situation calculus in which many actions
 may be performed at a single time.
 This is particularly important the a multi-agent system in order to expoit
 the potential for parallel execution provided by multiple agents.
\layout Standard

In 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

, Reiter provides a simple Golog planner for an eight-armed agent a blocks
 world (the OCTOPUS example).
 This could equivalently have been viewed as a system of eight independent
 agents and a centralised planner.
 
\layout Standard

However, there appears to be no account of a combination of these two models
 of concurrency.
 We provide a simple combination here, by modifying the transition semantics
 for ConGolog given in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 to act on concurrent action terms as axiomatised in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

.
\layout Standard

Recall that the semantics of a ConGolog program s given in terms of a transition
 system based on predicates 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

.
 In the simplest implementation, those instances of the transition predicates
 which operate at the level of primitive actions could be modified to accept
 sets of concurrent actions, and they would operate appropriately over the
 domain axiomatisation of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

.
 However, the fact that several primitive actions can occur simultaneously
 means that the definition of 
\begin_inset Quotes eld
\end_inset 

concurrent processes
\begin_inset Quotes erd
\end_inset 

 found in ConGolog can be extended.
\layout Standard

The concurrency operator 
\begin_inset Formula $(\delta_{1}||\delta_{2})$
\end_inset 

 is intended to mean 
\begin_inset Quotes eld
\end_inset 

execute programs 
\begin_inset Formula $\delta_{1}$
\end_inset 

and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 concurrently
\begin_inset Quotes erd
\end_inset 

.
 In the original single-step transition semantics, this is operationalised
 as:
\layout Quotation


\begin_inset Quotes eld
\end_inset 

...you single step 
\begin_inset Formula $(\delta_{1}||\delta_{2})$
\end_inset 

 by single stepping either 
\begin_inset Formula $\delta_{1}$
\end_inset 

 or 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and leaving the other process unchanged.
\begin_inset Quotes erd
\end_inset 


\layout Standard

This is characterised by the predicate:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\end{eqnarray*}

\end_inset 


\layout Standard

When multiple actions can occur concurrently, this notion of interleaving
 is insufficient.
 It may be possible to simultaneously single step both 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 by executing actions concurrently.
 Thus, there are three options for single stepping the concurrency operator:
\layout Itemize

Single step 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and execute the remainder concurrently with 
\begin_inset Formula $\delta_{2}$
\end_inset 


\layout Itemize

Single step 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and execute the remainder concurrently with 
\begin_inset Formula $\delta_{1}$
\end_inset 


\layout Itemize

Single step both 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and execute the remainders of both concurrently
\layout Standard

The following modified 
\begin_inset Formula $Trans$
\end_inset 

 predicate captures this extended notion of concurrent execution:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s') & \vee\\
 & \exists c_{1},c_{2},\gamma_{1},\gamma_{2}.Trans(\delta_{1},s,\gamma_{1},do(c_{1},s)) & \wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2}) & \wedge\\
 & Poss((c_{1}\cup c_{2})[s],s)\wedge s'=do((c_{1}\cup c_{2})[s],s)\end{eqnarray*}
 

\end_inset 


\layout Section

References
\layout Standard


\begin_inset LatexCommand \BibTeX[plain]{/storage/uni/pgrad/library/references}

\end_inset 


\layout Section
\start_of_appendix 
MConGolog Transition Semantics
\layout Standard

The following gives a transition semantics for MConGolog by defining the
 operators 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

 for each of the basic program constructs.
\layout Enumerate

Empty Proram:
\newline 

\begin_inset Formula \[
Trans(nil,s,\delta',s')\equiv False\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(nil,s)\equiv True\]

\end_inset 


\layout Enumerate

(Concurrent) Primitive Actions
\newline 

\begin_inset Formula \[
Trans(c,s,\delta',s')\equiv Poss(c[s],s)\wedge\delta'=nil\wedge s'=do(c[s],s)\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(c,s)\equiv False\]

\end_inset 


\layout Enumerate

Wait/test actions:
\newline 

\begin_inset Formula \[
Trans(\phi?,s,\delta',s')\equiv\phi[s]\wedge\delta'=nil\wedge s'=s\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(\phi?,s)\equiv False\]

\end_inset 


\layout Enumerate

Sequence:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1};\delta_{2},s,\delta',s')\equiv & \exists\gamma\delta'=(\gamma;\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & Final(\delta_{1},s)\wedge Trans(\delta_{2},s,\delta',s')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1};\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Nondeterministic brank:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}|\delta_{2},s,\delta',s')\equiv & Trans(\delta_{1},s,\delta',s') & \vee\\
 & Trans(\delta_{2},s,\delta',s)\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1}|\delta_{2},s)\equiv Final(\delta_{1},s)\vee Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Nondeterministic choice of argument:
\newline 

\begin_inset Formula \[
Trans(\pi v.\delta,x,\delta',s)\equiv\exists x.Trans(\delta_{x}^{v},s,\delta',s')\]

\end_inset 


\begin_inset Formula \[
Final(\pi v.\delta,s)\equiv\exists x.Final(\delta_{x}^{v},s)\]

\end_inset 


\newline 

\layout Enumerate

Iteration:
\newline 

\begin_inset Formula \[
Trans(\delta^{*},s,\delta',s')\equiv\exists\gamma.(\delta'=\gamma;\delta^{*})\wedge Trans(\delta,s,\gamma,s')\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta^{*},s)\equiv True\]

\end_inset 


\layout Enumerate

Synchonised Conditional:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\mathbf{if}\phi\mathbf{then}\delta_{1}\mathbf{else}\delta_{2},s,\delta',s')\equiv & \phi[s]\wedge Trans(\delta_{1},s,\delta',s') & \vee\\
 & \neg\phi[s]\wedge Trans(\delta_{2},s,\delta',s')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \begin{eqnarray*}
Final(\mathbf{if}\phi\mathbf{then}\delta_{1}\mathbf{else}\delta_{2},s)\equiv & \phi[s]\wedge Final(\delta_{1},s) & \vee\\
 & \neg\phi[s]\wedge Final(\delta_{1},s)\end{eqnarray*}

\end_inset 


\layout Enumerate

Synchronised While:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\mathbf{while}\phi\mathbf{do}\delta,s,\delta',s')\equiv & \exists\gamma.(\delta'=\gamma;\mathbf{while}\phi\mathbf{do}\delta) & \wedge\\
 & \phi[s]\wedge Trans(\delta,s,\gamma,s')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\mathbf{while}\phi\mathbf{do}\delta,s,\delta',s')\equiv\neg\phi[s]\wedge Final(\delta,s)\]

\end_inset 


\layout Enumerate

Concurrent Execution:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s') & \vee\\
 & \exists c_{1},c_{2},\gamma_{1},\gamma_{2}.Trans(\delta_{1},s,\gamma_{1},do(c_{1},s)) & \wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2}) & \wedge\\
 & Poss((c_{1}\cup c_{2})[s],s)\wedge s'=do((c_{1}\cup c_{2})[s],s)\end{eqnarray*}
 

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1}||\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Prioritised Concurrency:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}\gg\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma\gg\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}\gg\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\wedge\neg\exists\zeta,s''.Trans(\delta_{1},s,\zeta,s'')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1}\gg\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Concurrent Iteration:
\newline 

\begin_inset Formula \[
Trans(\delta^{||},s,\delta',s')\equiv\exists\gamma.\delta'=(\gamma||\delta^{||})\wedge Trans(\delta,s,\gamma,s')\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta^{||},s)\equiv True\]

\end_inset 


\the_end
