#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Cooperative Execution of Golog Programs
\layout Abstract

The Golog family of programming languages are designed for high-level control
 of autonomous agents such as mobile robots.
 Based on the logical formalism of the situation calculus, these languages
 allow the programmer to define a (potentially non-deterministic) program
 or plan, from which the agent will determine an appropriate execution strategy.
 This paper seeks to extend the Golog system by allowing multiple autonomous
 agents to cooperate in executing a Golog plan.
\layout Section

Introduction
\layout Standard

The programming language Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

 and its derivatives have found a wide range of applications in agent-oriented
 systems, from museum tour-guide robots (TODO:ref), mail delivery, TODO:more
 here to the RoboCup robotic soccer competition.
 It has proven to be a flexible programming language with the right mix
 of high-level programming constructs and domain abstraction...TODO:talk it
 up some more.
\layout Standard

In all of these situations, Golog is used as a programming language to define
 the behavior of a single agent.
 Viewed in a slightly different way, however, a Golog procedure can be viewed
 not as a program but as a plan - a specification of tasks to be performed
 and the constaints between them.
 TODO:hmm...more here.
\layout Standard

While Golog has been utilised in multi-agent settings, the Golog programs
 themselves are typically designed to be executed by a single agent.
 For example, in the ECASL system of TODO:ref, the behavior of multiple
 interacting agents may be specified, but each agent's behavior is given
 by an individual Golog program.
\layout Standard

In all these cases, Golog programs are written to specify a 
\emph on 
solution
\emph default 
, to set out what the agent is to achieve.
 But a Golog program may also be viewed as a specification of a task, what
 the programmer wants achieved.
 In this view, the Golog program specifies a 
\emph on 
problem
\emph default 
 which the agent(s) are to solve.
 Viewed in this way, it is not difficult to imagine that several independent
 agents may cooperate in order to execute a single Golog program that specified
 what is to be achieved.
 Exploring this idea is the purpose of this paper.
\layout Subsection

Running Example: The Cooking Agents
\layout Standard

In order to explore the cooperative execution of Golog programs in a concrete
 way, a running example is introduced and investigated throughout this paper:
 the 
\begin_inset Quotes eld
\end_inset 

Cooking Agents
\begin_inset Quotes erd
\end_inset 

 domain.
 In this domain, several robotic chefs inhabit a kitchen, which they share
 with ananimate objects such as various ingredients and utensils.
 The agents must cooperate to produce a meal consisting of several dishes.
\layout Standard

This example is particularly suitable because the domain has explicit need
 for task specification in the form of recipies.
 For example, there may be a Golog procedure describing how to prepare a
 salad and another describing how to bake a cake.
 These are obviously task descriptions seperate from the behavioral control
 of any individual agent, and therefore amenable to cooperative execution.
\layout Standard

The example domain also embodies several simplifications which make things
 easier for this initial investigation.
 Without difficulty it may be idealised as being completely deterministic
 and fully observable.
 The agents are also in close proximity allowing complete and reliable communica
tion.
\layout Section

Background
\layout Subsection

The Situation Calculus
\layout Standard

The situation calculus is a first order logic formalism designed for representin
g and reasoning about dynamically changing worlds, introduced by McCarthy
 and Hayes 
\begin_inset LatexCommand \cite{McCHay69sitcalc}

\end_inset 

.
 While the concepts of the situation calculus remain largely unchanged,
 the accompanying notation has evolved somewhat since its inception.
 The notation presented here is that of Reiter 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

.
\layout Standard

A representation of a dynamic world in the situation calculus consists of
 first order logic statements capturing the following, which will be explained
 further in later sections:
\layout Itemize

The actions that can be performed in the world
\layout Itemize

The fluents that describe the state of the world
\layout Itemize

Action precondition axioms, one for each action
\layout Itemize

Successor state axioms, one for each fluent
\layout Itemize

Axioms describing the initial world situation
\layout Itemize

The foundational axioms of the situation calculus
\layout Standard

The foundational axioms support reasoning and induction over situation calculus
 models.
 Since they will not be referenced in this paper, they are not repeated
 here.
 A detailed treatment may be found in 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

.
\layout Subsection

Golog
\layout Standard

Golog (short for alGOl in LOGic) is a declarative programming language based
 on the situation calculus, developed by Levesque et.
 al 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

.
 It combines the primitive actions frm the situation calculus description
 of the world into high-level programming constructs such as while-loops,
 if-then-else clauses, and nondeterministic choice.
\layout Standard

TODO:oh so much more here!
\layout Section

Domain Axiomatisation
\layout Standard

As described above, the first task in implementing a Golog-based system
 is to produce an appropriate axiomatisation of the domain in the Situation
 Calculus.
 For the cooking agents example, there are a number of factors which make
 the axiomatisation challenging: 
\layout Itemize

Resources: The agents will be required to utilise consumable resourses such
 as ingredients.
 They will also face conention for physical resources such as the oven,
 mixing bowls and chopping boards.
\layout Itemize

Continuous Processes: The domain requires continuous processes such as the
 progress of a timer which is set to time the baking of a cake.
 These processes will not necessarily end under the control of an agent.
\layout Itemize

Natural Actions: These are predictable actions which occur outside of the
 agent's control, and which must occur as long as nothing happens to stop
 them from occuring.
\layout Itemize

Concurrency: For a multi-agent system two notions of concurrency must be
 considered - the concurrent execution of several high-level programs, and
 the concurrent performance of several actions by independent agents.
\layout Itemize

Time: Some tasks in the cooking domain may require an explicit notion of
 time.
 For example, a cake must be baked for 30 minutes before being removed from
 the oven.
\layout Itemize

Abilities: Different agents may have different skills and abilities.
 For example, one of the agents may be hyper-sensitive to onion and therefore
 cannot be expected to handle it.
\layout Standard

These will be systematically addressed in the following sections.
\layout Subsection

Abilities
\layout Standard

The work of Cholvy et al 
\begin_inset LatexCommand \cite{cholvy04sitcalc_ability}

\end_inset 

 provides a suitable formalism for representing ability in the situation
 calculus.
 TODO:expand, find proper ref.
\layout Subsection

Concurrency
\layout Standard

The notion of concurrently executing multiple high-level programs is given
 an in-depth treatment in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 with the development of ConGolog.
 As discussed above, this adds support for prioritized concurrency and interrupt
s to the standard Golog semantics by means of interleaving of primitive
 actions.
\layout Standard

The work of 
\begin_inset LatexCommand \cite{lin92sc_conc}

\end_inset 

 and 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 provides a suitable extension to the situation calculus in which many actions
 may be performed at a single time.
 This is particularly important the a multi-agent system in order to expoit
 the potential for parallel execution provided by multiple agents.
\layout Standard

In 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

, Reiter provides a simple Golog planner for an eight-armed agent a blocks
 world (the OCTOPUS example).
 This could equivalently have been viewed as a system of eight independent
 agents and a centralised planner.
 
\layout Standard

However, there appears to be no account of a combination of these two models
 of concurrency.
 We provide a simple combination here, by modifying the transition semantics
 for ConGolog given in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 to act on concurrent action terms as axiomatised in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

.
\layout Standard

Recall that the semantics of a ConGolog program is given in terms of a transitio
n system based on predicates 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

.
 In the simplest implementation, those instances of the transition predicates
 which operate at the level of primitive actions could be modified to accept
 sets of concurrent actions, and they would operate appropriately over the
 domain axiomatisation of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

.
 However, the fact that several primitive actions can occur simultaneously
 means that the definition of 
\begin_inset Quotes eld
\end_inset 

concurrent processes
\begin_inset Quotes erd
\end_inset 

 found in ConGolog can be extended.
\layout Standard

The concurrency operator 
\begin_inset Formula $(\delta_{1}||\delta_{2})$
\end_inset 

 is intended to mean 
\begin_inset Quotes eld
\end_inset 

execute programs 
\begin_inset Formula $\delta_{1}$
\end_inset 

and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 concurrently
\begin_inset Quotes erd
\end_inset 

.
 In the original single-step transition semantics, this is operationalised
 as:
\layout Quotation


\begin_inset Quotes eld
\end_inset 

...you single step 
\begin_inset Formula $(\delta_{1}||\delta_{2})$
\end_inset 

 by single stepping either 
\begin_inset Formula $\delta_{1}$
\end_inset 

 or 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and leaving the other process unchanged.
\begin_inset Quotes erd
\end_inset 


\layout Standard

This is characterised by the predicate:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\end{eqnarray*}

\end_inset 


\layout Standard

When multiple actions can occur concurrently, this notion of interleaving
 is insufficient.
 It may be possible to simultaneously single step both 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 by executing actions concurrently.
 Thus, there are three options for single stepping the concurrency operator:
\layout Itemize

Single step 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and execute the remainder concurrently with 
\begin_inset Formula $\delta_{2}$
\end_inset 


\layout Itemize

Single step 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and execute the remainder concurrently with 
\begin_inset Formula $\delta_{1}$
\end_inset 


\layout Itemize

Single step both 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and execute the remainders of both concurrently
\layout Standard

The following modified 
\begin_inset Formula $Trans$
\end_inset 

 predicate captures this extended notion of concurrent execution:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s') & \vee\\
 & \exists c_{1},c_{2},\gamma_{1},\gamma_{2}.Trans(\delta_{1},s,\gamma_{1},do(c_{1},s)) & \wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2}) & \wedge\\
 & Poss((c_{1}\cup c_{2})[s],s)\wedge s'=do((c_{1}\cup c_{2})[s],s)\end{eqnarray*}
 

\end_inset 


\layout Standard

(TODO: also reference 
\begin_inset Quotes eld
\end_inset 

planning_concurrent_golog
\begin_inset Quotes erd
\end_inset 

 which does a similar thing using the Do() macro semantics).
\layout Subsection

Time
\layout Standard

There have been several efforts to incorporate a temporal component into
 the situation calculus.
 Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 introduced the functions 
\begin_inset Formula $start(s)$
\end_inset 

 and 
\begin_inset Formula $end(s,a)$
\end_inset 

 which range over the real numbers and give the starting and ending time
 of a situation respectively.
 This was primarily designed for reasoning about the within a sequence of
 
\begin_inset Quotes eld
\end_inset 

actual situations
\begin_inset Quotes erd
\end_inset 

.
 Reiter 
\begin_inset LatexCommand \cite{reiter01kia,reiter96sc_nat_conc}

\end_inset 

 simplified this scheme by including within each action an explicit temporal
 argument indicating the time at which it was performed.
 While this is useful when specifying precise times for actions, it requires
 additional clauses to ensure that concurrently executed actions all occur
 at the same time.
\layout Standard

In work on the related Fluent Calculus, Martin 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset 

 attaches the explicit occurance time not to actions but to situations,
 an approach which was also adopted for this paper.
 The successor situation predicate 
\begin_inset Formula $do(a,s)$
\end_inset 

 becomes 
\begin_inset Formula $do(a,t,s)$
\end_inset 

, to indicate 
\begin_inset Quotes eld
\end_inset 

perform action 
\begin_inset Formula $a$
\end_inset 

 at time 
\begin_inset Formula $t$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

.
 Likewise, the possibility predicate 
\begin_inset Formula $poss(a,s)$
\end_inset 

 becomes 
\begin_inset Formula $poss(a,t,s)$
\end_inset 

, meaning 
\begin_inset Quotes eld
\end_inset 

it is possible to perform action 
\begin_inset Formula $a$
\end_inset 

 at time 
\begin_inset Formula $t$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 


\begin_inset Quotes erd
\end_inset 

.
\layout Subsection

The Domain
\layout Section

References
\layout Standard


\begin_inset LatexCommand \BibTeX[plain]{/storage/uni/pgrad/library/references}

\end_inset 


\layout Section
\start_of_appendix 
MConGolog Transition Semantics
\layout Standard

The following gives a transition semantics for MConGolog by defining the
 operators 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

 for each of the basic program constructs.
\layout Enumerate

Empty Proram:
\newline 

\begin_inset Formula \[
Trans(nil,s,\delta',s')\equiv False\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(nil,s)\equiv True\]

\end_inset 


\layout Enumerate

(Concurrent) Primitive Actions
\newline 

\begin_inset Formula \[
Trans(c,s,\delta',s')\equiv Poss(c[s],s)\wedge\delta'=nil\wedge s'=do(c[s],s)\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(c,s)\equiv False\]

\end_inset 


\layout Enumerate

Wait/test actions:
\newline 

\begin_inset Formula \[
Trans(\phi?,s,\delta',s')\equiv\phi[s]\wedge\delta'=nil\wedge s'=s\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(\phi?,s)\equiv False\]

\end_inset 


\layout Enumerate

Sequence:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1};\delta_{2},s,\delta',s')\equiv & \exists\gamma\delta'=(\gamma;\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & Final(\delta_{1},s)\wedge Trans(\delta_{2},s,\delta',s')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1};\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Nondeterministic brank:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}|\delta_{2},s,\delta',s')\equiv & Trans(\delta_{1},s,\delta',s') & \vee\\
 & Trans(\delta_{2},s,\delta',s)\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1}|\delta_{2},s)\equiv Final(\delta_{1},s)\vee Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Nondeterministic choice of argument:
\newline 

\begin_inset Formula \[
Trans(\pi v.\delta,x,\delta',s)\equiv\exists x.Trans(\delta_{x}^{v},s,\delta',s')\]

\end_inset 


\begin_inset Formula \[
Final(\pi v.\delta,s)\equiv\exists x.Final(\delta_{x}^{v},s)\]

\end_inset 


\newline 

\layout Enumerate

Iteration:
\newline 

\begin_inset Formula \[
Trans(\delta^{*},s,\delta',s')\equiv\exists\gamma.(\delta'=\gamma;\delta^{*})\wedge Trans(\delta,s,\gamma,s')\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta^{*},s)\equiv True\]

\end_inset 


\layout Enumerate

Synchonised Conditional:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\mathbf{if}\phi\mathbf{then}\delta_{1}\mathbf{else}\delta_{2},s,\delta',s')\equiv & \phi[s]\wedge Trans(\delta_{1},s,\delta',s') & \vee\\
 & \neg\phi[s]\wedge Trans(\delta_{2},s,\delta',s')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \begin{eqnarray*}
Final(\mathbf{if}\phi\mathbf{then}\delta_{1}\mathbf{else}\delta_{2},s)\equiv & \phi[s]\wedge Final(\delta_{1},s) & \vee\\
 & \neg\phi[s]\wedge Final(\delta_{1},s)\end{eqnarray*}

\end_inset 


\layout Enumerate

Synchronised While:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\mathbf{while}\phi\mathbf{do}\delta,s,\delta',s')\equiv & \exists\gamma.(\delta'=\gamma;\mathbf{while}\phi\mathbf{do}\delta) & \wedge\\
 & \phi[s]\wedge Trans(\delta,s,\gamma,s')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\mathbf{while}\phi\mathbf{do}\delta,s,\delta',s')\equiv\neg\phi[s]\wedge Final(\delta,s)\]

\end_inset 


\layout Enumerate

Concurrent Execution:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s') & \vee\\
 & \exists c_{1},c_{2},\gamma_{1},\gamma_{2}.Trans(\delta_{1},s,\gamma_{1},do(c_{1},s)) & \wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2}) & \wedge\\
 & Poss((c_{1}\cup c_{2})[s],s)\wedge s'=do((c_{1}\cup c_{2})[s],s)\end{eqnarray*}
 

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1}||\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Prioritised Concurrency:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}\gg\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma\gg\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}\gg\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\wedge\neg\exists\zeta,s''.Trans(\delta_{1},s,\zeta,s'')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1}\gg\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Concurrent Iteration:
\newline 

\begin_inset Formula \[
Trans(\delta^{||},s,\delta',s')\equiv\exists\gamma.\delta'=(\gamma||\delta^{||})\wedge Trans(\delta,s,\gamma,s')\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta^{||},s)\equiv True\]

\end_inset 


\the_end
