#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Cooperative Execution of Golog Programs
\layout Abstract

The Golog family of programming languages are designed for high-level control
 of autonomous agents such as mobile robots.
 Based on the logical formalism of the situation calculus, these languages
 allow the programmer to define a (potentially non-deterministic) program
 or plan, from which the agent will determine an appropriate execution strategy.
 This paper seeks to extend the Golog system by allowing multiple autonomous
 agents to cooperate in executing a Golog plan.
\layout Section

TASKS
\layout Itemize

Motivate the use of Golog in multiagent teams
\layout Itemize

Give semantics as combinations of previous work
\layout Itemize

Prove interesting things about semantics, e.g.
 only generates executable situations
\layout Itemize

Make simple suggestions on how to execute using distrubted system
\layout Section

Introduction
\layout Standard

The programming language Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

 and its derivatives have found a wide range of applications in agent-oriented
 systems, from museum tour-guide robots (TODO:ref), mail delivery, TODO:more
 here to the RoboCup robotic soccer competition.
 It has proven to be a flexible programming language with the right mix
 of high-level programming constructs and domain abstraction...TODO:talk it
 up some more.
\layout Standard

In all of these situations, Golog is used as a programming language to define
 the behavior of a single agent.
 Viewed in a slightly different way, however, a Golog procedure can be viewed
 not as a program but as a plan - a specification of tasks to be performed
 and the constaints between them.
 TODO:hmm...more here.
\layout Standard

While Golog has been utilised in multi-agent settings, the Golog programs
 themselves are typically designed to be executed by a single agent.
 For example, in the ECASL system of TODO:ref, the behavior of multiple
 interacting agents may be specified, but each agent's behavior is given
 by an individual Golog program.
\layout Standard

In all these cases, Golog programs are written to specify a 
\emph on 
solution
\emph default 
, to set out what the agent is to achieve.
 But a Golog program may also be viewed as a specification of a task, what
 the programmer wants achieved.
 In this view, the Golog program specifies a 
\emph on 
problem
\emph default 
 which the agent(s) are to solve.
 Viewed in this way, it is not difficult to imagine that several independent
 agents may cooperate in order to execute a single Golog program that specified
 what is to be achieved.
 Exploring this idea is the purpose of this paper.
\layout Standard

The growing use of Golog shows that, as suggested in 
\begin_inset LatexCommand \cite{lesperance2000_igl_ext}

\end_inset 

, 
\emph on 
high-level program execution
\emph default 
 is emerging as a practical alternative to traditional plan synthesis.
 Rather than a planner finding a legal sequence of actions leading from
 an initial state to a state in which some goals are achieved, the task
 is instead to find a sequence of actions which constitute a legal execution
 of some high-level program.
 As the amount of non-determinism is controlled by the programmer, this
 task can range from simply executing a fully-deterministic program to synthesis
ing actions from a completely non-deterministic program, a task equivalent
 to traditional planning.
 Indeed, in 
\begin_inset LatexCommand \cite{Finzi00}

\end_inset 

 Finzi et.
 al.
 show that an effective planning system can be build using Golog.
\layout Subsection

Running Example: The Cooking Agents
\layout Standard

In order to explore the cooperative execution of Golog programs in a concrete
 way, a running example is introduced and investigated throughout this paper:
 the 
\begin_inset Quotes eld
\end_inset 

Cooking Agents
\begin_inset Quotes erd
\end_inset 

 domain.
 In this domain, several robotic chefs inhabit a kitchen, which they share
 with inanimate objects such as various ingredients, appliances and utensils.
 The agents must cooperate to produce a meal consisting of several dishes.
\layout Standard

This example is particularly suitable because the domain has explicit need
 for task specification in the form of recipies.
 For example, there may be a Golog procedure describing how to prepare a
 salad and another describing how to bake a cake.
 These are obviously task descriptions seperate from the behavioral control
 of any individual agent, and therefore amenable to cooperative execution.
\layout Standard

The example domain also embodies several simplifications which make things
 easier for this initial investigation.
 Without difficulty it may be idealised as being completely deterministic
 and fully observable.
 The agents are also in close proximity allowing complete and reliable communica
tion.
 The details of this example domain will be developed through the paper.
\layout Section

Background
\layout Subsection

The Situation Calculus
\layout Standard

The situation calculus is a first order logic formalism designed for representin
g and reasoning about dynamically changing worlds, introduced by McCarthy
 and Hayes 
\begin_inset LatexCommand \cite{McCHay69sitcalc}

\end_inset 

.
 While the concepts of the situation calculus remain largely unchanged,
 the accompanying notation has evolved somewhat since its inception.
 The notation presented here is that of Reiter 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

.
\layout Standard

A representation of a dynamic world in the situation calculus consists of
 first order logic statements capturing the following:
\layout Itemize

The actions that can be performed in the world
\layout Itemize

The fluents that describe the state of the world
\layout Itemize

Action precondition axioms, one for each action
\layout Itemize

Successor state axioms, one for each fluent
\layout Itemize

Axioms describing the initial world situation
\layout Itemize

The foundational axioms of the situation calculus
\layout Standard

Only an overview of these concepts is presented here.
 A detailed treatment may be found in 
\begin_inset LatexCommand \cite{reiter01kia}

\end_inset 

.
\layout Standard

Actions are literals in the logic representing the ways in which the world
 can be changed.
 If an action does not occur, the world does not change.
 The 
\begin_inset Quotes eld
\end_inset 

state of the world
\begin_inset Quotes erd
\end_inset 

 is represented as a situation, which is the history of actions that have
 been performed so far, with the initial situation represented by the term
 
\begin_inset Formula $S_{0}$
\end_inset 

.
 Terms representing other situations are constructed using the function
 
\begin_inset Formula $do(a,s)$
\end_inset 

 which gives the situation resulting from performing action 
\begin_inset Formula $a$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

.
\layout Standard

TODO: finish this
\layout Subsection

Golog
\layout Standard

Golog (short for alGOl in LOGic) is a declarative programming language based
 on the situation calculus, developed by Levesque et.
 al 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

.
 It combines the primitive actions from the situation calculus description
 of the world into high-level programming constructs such as while-loops,
 if-then-else clauses, and nondeterministic choice.
\layout Standard

TODO:oh so much more here!
\layout Section

Domain Axiomatisation
\layout Standard

As described above, the first task in implementing a Golog-based system
 is to produce an appropriate axiomatisation of the domain in the Situation
 Calculus.
 For the cooking agents example, there are a number of factors which make
 the axiomatisation challenging: 
\layout Itemize

Resources: The agents will be required to utilise consumable resourses such
 as ingredients.
 They will also face conention for physical resources such as the oven,
 mixing bowls and chopping boards.
\layout Itemize

Continuous Processes: The domain requires continuous processes such as the
 progress of a timer which is set to time the baking of a cake.
 These processes will not necessarily end under the control of an agent.
\layout Itemize

Natural Actions: These are predictable actions which occur outside of the
 agent's control, and which must occur as long as nothing happens to stop
 them from occuring.
\layout Itemize

Concurrency: For a multi-agent system two notions of concurrency must be
 considered - the concurrent execution of several high-level programs, and
 the concurrent performance of several actions by independent agents.
\layout Itemize

Time: Some tasks in the cooking domain may require an explicit notion of
 time.
 For example, a cake must be baked for 30 minutes before being removed from
 the oven.
\layout Itemize

Abilities: Different agents may have different skills and abilities.
 For example, one of the agents may be hyper-sensitive to onion and therefore
 cannot be expected to handle it.
\layout Standard

These will be systematically addressed in the following sections.
\layout Subsection

Abilities
\layout Standard

The work of Cholvy et al 
\begin_inset LatexCommand \cite{cholvy04sitcalc_ability}

\end_inset 

 provides a suitable formalism for representing ability in the situation
 calculus.
 TODO:expand, find proper ref.
\layout Subsection

Time
\layout Standard

There have been several efforts to incorporate a temporal component into
 the situation calculus.
 Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 introduced the functions 
\begin_inset Formula $start(s)$
\end_inset 

 and 
\begin_inset Formula $end(s,a)$
\end_inset 

 which range over the real numbers and give the starting and ending time
 of a situation respectively.
 This was primarily designed for reasoning about the within a sequence of
 
\begin_inset Quotes eld
\end_inset 

actual situations
\begin_inset Quotes erd
\end_inset 

.
 Reiter 
\begin_inset LatexCommand \cite{reiter01kia,reiter96sc_nat_conc}

\end_inset 

 simplified this scheme by including within each action an explicit temporal
 argument indicating the time at which it was performed.
 While this is useful when specifying precise times for actions, it requires
 additional clauses to ensure that concurrently executed actions all occur
 at the same time.
\layout Standard

In work on the related Fluent Calculus, Martin 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset 

 attaches the explicit occurance time not to actions but to situations,
 an approach which was also adopted for this paper.
 The successor situation predicate 
\begin_inset Formula $do(a,s)$
\end_inset 

 becomes 
\begin_inset Formula $do(a,t,s)$
\end_inset 

, to indicate 
\begin_inset Quotes eld
\end_inset 

perform action 
\begin_inset Formula $a$
\end_inset 

 at time 
\begin_inset Formula $t$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

.
 Likewise, the possibility predicate 
\begin_inset Formula $poss(a,s)$
\end_inset 

 becomes 
\begin_inset Formula $poss(a,t,s)$
\end_inset 

, meaning 
\begin_inset Quotes eld
\end_inset 

it is possible to perform action 
\begin_inset Formula $a$
\end_inset 

 at time 
\begin_inset Formula $t$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 


\begin_inset Quotes erd
\end_inset 

.
 The function 
\begin_inset Formula $start(s)$
\end_inset 

 is added which gives the start time of a situation:
\layout Standard


\begin_inset Formula \[
start(do(a,t,s))=t\]

\end_inset 


\layout Standard

Note that the start time of the initial situation need not be defined.
\layout Subsection

Concurrency
\layout Standard

The notion of concurrently executing multiple high-level programs is given
 an in-depth treatment in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 with the development of ConGolog.
 This work adds support for prioritized concurrency and interrupts to the
 standard Golog semantics by means of interleaving of primitive actions,
 an approach which will be used in this paper.
\layout Standard

The work of 
\begin_inset LatexCommand \cite{lin92sc_conc}

\end_inset 

 and 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 provides a suitable extension to the situation calculus in which many primitive
 actions may be performed at a single time.
 This is particularly important for a multi-agent system in order to expoit
 the potential for parallel execution provided by multiple agents.
 Here the basic action terms are replaced with sets of actions, TODO explain
 how it affects the predicates.
\layout Standard

These two approaches were first combined by Baier and Pinto 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset 

 to give the language TConGolog, by modifying the transition semantics for
 ConGolog given in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 to act on sets of concurrent action terms as axiomatised in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

.
 Theirs is equivalent to the approach taken below.
\layout Standard

Recall that the semantics of a ConGolog program is given in terms of a transitio
n system based on predicates 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

.
 In the simplest implementation, those instances of the transition predicates
 which operate at the level of primitive actions could be modified to accept
 sets of concurrent actions, and they would operate appropriately over the
 domain axiomatisation of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

.
 However, the fact that several primitive actions can occur simultaneously
 means that the definition of 
\begin_inset Quotes eld
\end_inset 

concurrent processes
\begin_inset Quotes erd
\end_inset 

 found in ConGolog can be extended.
\layout Standard

The concurrency operator 
\begin_inset Formula $(\delta_{1}||\delta_{2})$
\end_inset 

 is intended to mean 
\begin_inset Quotes eld
\end_inset 

execute programs 
\begin_inset Formula $\delta_{1}$
\end_inset 

and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 concurrently
\begin_inset Quotes erd
\end_inset 

.
 In the original single-step transition semantics, this is operationalised
 as:
\layout Quotation


\begin_inset Quotes eld
\end_inset 

...you single step 
\begin_inset Formula $(\delta_{1}||\delta_{2})$
\end_inset 

 by single stepping either 
\begin_inset Formula $\delta_{1}$
\end_inset 

 or 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and leaving the other process unchanged.
\begin_inset Quotes erd
\end_inset 


\layout Standard

This is characterised by the predicate:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\end{eqnarray*}

\end_inset 


\layout Standard

When multiple actions can occur concurrently, this notion of interleaving
 is insufficient.
 It may be possible to simultaneously single step both 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 by executing actions concurrently.
 Thus, there are three options for single stepping the concurrency operator:
\layout Itemize

Single step 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and execute the remainder concurrently with 
\begin_inset Formula $\delta_{2}$
\end_inset 


\layout Itemize

Single step 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and execute the remainder concurrently with 
\begin_inset Formula $\delta_{1}$
\end_inset 


\layout Itemize

Single step both 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 and execute the remainders of both concurrently
\layout Standard

The following modified 
\begin_inset Formula $Trans$
\end_inset 

 predicate captures this extended notion of concurrent execution:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s') & \vee\\
 & \exists c_{1},c_{2},\gamma_{1},\gamma_{2}.Trans(\delta_{1},s,\gamma_{1},do(c_{1},s)) & \wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2}) & \wedge\\
 & Poss((c_{1}\cup c_{2})[s],s)\wedge s'=do((c_{1}\cup c_{2})[s],s)\end{eqnarray*}

 

\end_inset 


\layout Standard

This is equivalent to the semantics given in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset 

.
\layout Standard

TODO: precondition interaction and the conflicts() predicate
\layout Subsection

Natural Actions
\layout Standard

Natural actions are a special class of exogenous actions, those actions
 which occur outsite of the agent's control.
 Introduced to the situation calculus by Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 and expanded by Reiter 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc,reiter01kia}

\end_inset 

, they are classified according to the following requirement: natural actions
 are exogenous actions which must occur that their predicted times, provided
 no earlier actions prevent them from occuring.
 For example, the action of a ball bouncing when it reaches the ground is
 a natural action, which may be prevented by catching the ball.
\layout Standard

We adopt the methodology of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

, suitably modified for our alternate alternate encoding of time (again,
 this is similar to the approach of 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset 

).
 Each natural action is indicated by the predicate 
\begin_inset Formula $natural(a)$
\end_inset 

, which is true precisely when 
\begin_inset Formula $a$
\end_inset 

 is a natural action.
 The times at which natural actions may occur are specified by the 
\begin_inset Formula $Poss$
\end_inset 

 predicate, as with agent-initiated actions:
\layout Standard

TODO: example here
\layout Standard

To enforce the requirement that natural actions must occur provided nothing
 prevents them, a predicate 
\begin_inset Formula $legal(s)$
\end_inset 

 is introduced which is true only for situations which respect this requirement:
\layout Standard


\begin_inset Formula \[
legal(S_{0})\equiv True\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\begin{array}{cc}
legal(do(c,t,s))\equiv & legal(s)\wedge Poss(c,t,s)\wedge\\
 & start(s)\leq t\wedge\\
 & (\forall a,t_{a}).natural(a)\wedge Poss(a,t_{a},s)\rightarrow\\
 & \left[a\in c\vee t<t_{a}\right]\end{array}\]

\end_inset 


\layout Standard

When utilising natural actions within a Golog program, all legal program
 executions must result in situations for which the 
\begin_inset Formula $legal$
\end_inset 

 predicate is true.
 It will be shown that this can be enforced in the semantics of the language,
 avoiding the need to check it explicitly.
 TODO: this implicitly assumes no interaction among natural actions.
\layout Standard

An important concept when dealing with natural actions it the least natural
 time point (LNTP) of a situation.
 This is defined as the earliest time at which a natural action may occur
 in a situation:
\layout Standard


\begin_inset Formula \begin{eqnarray*}
lntp(s,t) & \equiv & \exists a[\end{eqnarray*}

natural(a)\wedge Poss(a,t,s)]\wedge

\end_inset 


\layout Standard

Note that the LNTP need not exist for a given situation.
 It is straightforward to extend the proof of Lemma 3 in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 to this notation,giving the result that:
\layout Standard


\begin_inset Formula \[
natural(a)\wedge legal(do(c,t,s))\wedge a\in c\rightarrow lntp(s,t)\]

\end_inset 


\layout Subsection

Continuous Processes
\layout Subsection

The Domain
\layout Section

Transition Semantics
\layout Standard

In this section, the transition semantics for MIndiGolog are presented.
\layout Subsection

MIndiGolog Transition Semantics
\layout Standard

The following gives a transition semantics for MConGolog by defining the
 operators 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

 for each of the basic program constructs.
\layout Enumerate

Empty Proram:
\newline 

\begin_inset Formula \[
Trans(nil,s,\delta',s')\equiv False\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(nil,s)\equiv True\]

\end_inset 


\layout Enumerate

(Concurrent) Primitive Actions
\newline 

\begin_inset Formula \[
Trans(c,s,\delta',s')\equiv Poss(c[s],s)\wedge\delta'=nil\wedge s'=do(c[s],s)\]

\end_inset 


\begin_inset Formula \begin{eqnarray*}
Trans(c,s,\delta',s') & \equiv & (\exists t_{n}).\left[lntp(s,t_{n})\wedge\right\\\
 &  & some\end{eqnarray*}

\end_inset 


\newline 
 
\newline 

\begin_inset Formula \[
Final(c,s)\equiv False\]

\end_inset 


\layout Enumerate

Wait/test actions:
\newline 

\begin_inset Formula \[
Trans(\phi?,s,\delta',s')\equiv\phi[s]\wedge\delta'=nil\wedge s'=s\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(\phi?,s)\equiv False\]

\end_inset 


\layout Enumerate

Sequence:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1};\delta_{2},s,\delta',s')\equiv & \exists\gamma\delta'=(\gamma;\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & Final(\delta_{1},s)\wedge Trans(\delta_{2},s,\delta',s')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1};\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Nondeterministic brank:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}|\delta_{2},s,\delta',s')\equiv & Trans(\delta_{1},s,\delta',s') & \vee\\
 & Trans(\delta_{2},s,\delta',s)\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1}|\delta_{2},s)\equiv Final(\delta_{1},s)\vee Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Nondeterministic choice of argument:
\newline 

\begin_inset Formula \[
Trans(\pi v.\delta,x,\delta',s)\equiv\exists x.Trans(\delta_{x}^{v},s,\delta',s')\]

\end_inset 


\begin_inset Formula \[
Final(\pi v.\delta,s)\equiv\exists x.Final(\delta_{x}^{v},s)\]

\end_inset 


\newline 

\layout Enumerate

Iteration:
\newline 

\begin_inset Formula \[
Trans(\delta^{*},s,\delta',s')\equiv\exists\gamma.(\delta'=\gamma;\delta^{*})\wedge Trans(\delta,s,\gamma,s')\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta^{*},s)\equiv True\]

\end_inset 


\layout Enumerate

Synchonised Conditional:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\mathbf{if}\phi\mathbf{then}\delta_{1}\mathbf{else}\delta_{2},s,\delta',s')\equiv & \phi[s]\wedge Trans(\delta_{1},s,\delta',s') & \vee\\
 & \neg\phi[s]\wedge Trans(\delta_{2},s,\delta',s')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \begin{eqnarray*}
Final(\mathbf{if}\phi\mathbf{then}\delta_{1}\mathbf{else}\delta_{2},s)\equiv & \phi[s]\wedge Final(\delta_{1},s) & \vee\\
 & \neg\phi[s]\wedge Final(\delta_{1},s)\end{eqnarray*}

\end_inset 


\layout Enumerate

Synchronised While:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\mathbf{while}\phi\mathbf{do}\delta,s,\delta',s')\equiv & \exists\gamma.(\delta'=\gamma;\mathbf{while}\phi\mathbf{do}\delta) & \wedge\\
 & \phi[s]\wedge Trans(\delta,s,\gamma,s')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\mathbf{while}\phi\mathbf{do}\delta,s,\delta',s')\equiv\neg\phi[s]\wedge Final(\delta,s)\]

\end_inset 


\layout Enumerate

Concurrent Execution:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s') & \vee\\
 & \exists c_{1},c_{2},\gamma_{1},\gamma_{2}.Trans(\delta_{1},s,\gamma_{1},do(c_{1},s)) & \wedge\\
 & Trans(\delta_{2},s,\gamma_{2},do(c_{2},s))\wedge\delta'=(\gamma_{1}||\gamma_{2}) & \wedge\\
 & Poss((c_{1}\cup c_{2})[s],s)\wedge s'=do((c_{1}\cup c_{2})[s],s)\end{eqnarray*}

 

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1}||\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Prioritised Concurrency:
\newline 

\begin_inset Formula \begin{eqnarray*}
Trans(\delta_{1}\gg\delta_{2},s,\delta',s')\equiv & \exists\gamma.\delta'=(\gamma\gg\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s') & \vee\\
 & \exists\gamma.\delta'=(\delta_{1}\gg\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\wedge\neg\exists\zeta,s''.Trans(\delta_{1},s,\zeta,s'')\end{eqnarray*}

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta_{1}\gg\delta_{2},s)\equiv Final(\delta_{1},s)\wedge Final(\delta_{2},s)\]

\end_inset 


\layout Enumerate

Concurrent Iteration:
\newline 

\begin_inset Formula \[
Trans(\delta^{||},s,\delta',s')\equiv\exists\gamma.\delta'=(\gamma||\delta^{||})\wedge Trans(\delta,s,\gamma,s')\]

\end_inset 


\newline 

\begin_inset Formula \[
Final(\delta^{||},s)\equiv True\]

\end_inset 


\layout Section

References
\layout Standard


\begin_inset LatexCommand \BibTeX[plain]{/storage/uni/pgrad/library/references}

\end_inset 


\the_end
