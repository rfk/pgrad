
\documentclass[letterpaper]{article}

\usepackage{aaai}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}

\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{subfigure}

\title{High-Level Program Execution for Multi-Agent Teams}

\author{Ryan Kelly \and Adrian Pearce \\
Department of Commputer Science and Software Engineering \\
NICTA Victoria Laboratory \\
The University of Melbourne \\
Victoria, 3010, Australia \\
\{rfk,adrian\}@csse.unimelb.edu.au}

%\nocopyright

\newtheorem{theorem}{Theorem}

\begin{document}

\maketitle

\begin{abstract}
In this paper we present a promising approach to programming multi-agent
teams based high-level program execution, and a concrete implementation
named MIndiGolog. While the concept of high-level program execution,
as embodied by the language Golog, has recently arisen as a practical
alternative to traditional planning for single-agent systems, several
challenges are encountered when moving to a multi-agent setting: concurrency
operators must be modified to accurately reflect the concurrency present
in multi-agent teams, predictable exogenous actions (often called
``natural actions'') must be effectively modelled, and a representation
of time must be incorporated to assist agent coordination and to ensure
correctness with respect to natural actions. 

The contributions of this paper include the integration of true concurrency
with interleaved concurrency in Golog; the incorporation of an explicit
notion of time for coordination; and the tight integration of natural
actions into the semantics of the language.
\end{abstract}

\section{Introduction}

When a team of agents must cooperate closely in order to achieve some
shared goal, they can often be conceptualised as a single agent with
distributed sensing, reasoning and acting capabilities. Behaviours
and goals are naturally ascribed to the team rather than to individual
members. This suggests that \emph{high-level program execution}, an
alternate approach to single-agent planning, can also provide an attractive
alternative to team planning.

As described in \cite{giacomo99indigolog}, high-level program execution
is emerging as a practical alternative to traditional plan
synthesis. By ``high-level program'' is meant a program whose
primitive operations are domain-specific actions, and which may be
incompletely specified due to nondeterministic constructs. Rather
than a planner finding a sequence of actions leading from an initial
state to a state in which some goals are achieved, the task is to
find a sequence of actions which constitute an instance of this program.

This task can range from executing a fully-specified program to synthesising
an action sequence from a completely nondeterministic program, thus
subsuming both deterministic agent programming and traditional planning.
The primary advantage of this approach is \emph{controlled nondeterminism},
allowing some aspects of the program to remain unspecified while avoiding
an exponential increase in planning difficulty for large programs.
One very successful application of this technique is the Golog \cite{levesque97golog}
family of programming languages, which have provided clear benefits
for single-agent programming that include: the ability to control
the amount of nondeterminism; sophisticated symbolic reasoning about
the world; and formal verification of program properties, in some
cases using automated tools.

TODO: references for these opinions? Systems involving multiple autonomous
agents are often classified into two subtypes - ``open multi-agent
systems'' in which agent behaviors are loosely coupled, and ``multi-agent
teams'' in which agents depend intimately on one another to accomplish
a shared task. From a programming viewpoint, open multi-agent systems
are typically constructed by specifying the behavior and goals of
individual agents and using communication primitives to design interaction
between them.

For tightly-coupled teams it is frequently more convenient to conceptualise
the team as a single agent with distributed sensing, reasoning and
acting abilities, and ascribe behaviors and goals to the team as a
whole. This suggests high-level program execution as an attractive
approach, potentially providing the benefits described above for applications
involving multi-agent teams.

Pursuant to this goal, we combine several existing extensions to the
Golog language to make it suitable for representing multi-agent teams.
Key among these is the notion of true concurrency of actions, which
we combine with the interleaved concurrency found in the language
ConGolog \cite{giacomo00congolog} to give a flexible account of concurrent
execution. An explicit notion of time is incorporated, both to enrich
the world model and to assist in coordination between agents. The
concept of natural actions \cite{reiter96sc_nat_conc} is also tightly
integrated into the language, to allow agents to predict the behavior
of each other and their environment. We name the resulting language
``MIndiGolog'' for ``Multi-Agent IndiGolog''.

The contributions of this paper are thus: to motivate high-level program
execution as a problem-solving paradigm for multi-agent teams; to
robustly combine several existing extensions to the Golog language
into a semantics suitable for describing multi-agent teams; and to
describe a concrete implementation of this language.

The paper is structured as follows. Section \ref{sec:SC-Golog}
briefly reviews the Golog family of languages
and their underlying formalism the situation calculus. In Section
\ref{sec:Language-Features} we present the extensions that allow
MIndiGolog to properly describe multi-agent teams, while Section \ref{sec:Langauge-Semantics}
details the properties of the formal semantics.
Section \ref{sec:Other-Work} places
this work in the context of existing Golog implementations, and Section
\ref{sec:Conclusions-and-Future} presents our conclusions and future
research. 

TODO introduce the running example at an appropriate point


\section{The Situation Calculus and Golog}

\label{sec:SC-Golog}

The representation of a dynamic world in the situation calculus consists
of first-order logic statements capturing the following: actions that
can be performed in the world; fluents describing the state of the
world; precondition axioms describing when actions are possible; and
successor state axioms describing how fluents change across situations.
For space reasons only a brief overview is given here, with individual
ideas explained as required throughout the paper. A detailed treatment
is available in \cite{pirri99contributions_sitcalc}.

\emph{Actions} are functions terms in the logic denoting the ways
in which the world can be changed, and are taken to be instantaneous.
The evolution of the world is handled using \emph{situations}, which
are histories of actions that have been performed. The initial situation
represented by the term $S_{0}$, and terms representing other situations
are constructed using the function $do(a,s)$ which represents the
situation resulting from performing action $a$ in situation $s$.
Properties of the world are described by \emph{fluents}, which are
functions or predicates taking a situation as their final argument.
The conditions under which an action can be performed are given in
terms of the \emph{possibility fluent} $Poss(a,s)$. The truth values
of fluents are specified by defining what is true in the initial situation,
and collecting the effects of various actions into \emph{successor
state axioms} characterising how they change from one situation to
the next.

Formally, a dynamic world is defined using a \emph{theory of action}
$\mathcal{D}$, a collection of (mostly) first-order axioms describing
how the world behaves. It contains axioms describing: the foundational
axioms of the calculus; action precondition axioms; successor state
axioms; unique names axioms for actions; and axioms describing the
initial situation. The theory of action thus consists of several independent
sets of axioms:
\begin{equation}
\mathcal{D}=\Sigma\cup\mathcal{D}_{ap}\cup\mathcal{D}_{ss}\cup\mathcal{D}_{una}\cup\mathcal{D}_{S_{0}}
\end{equation}


Statements about the world are then evaluated relative to this theory
of action.

Golog is a declarative agent programming language based on the situation
calculus, developed by Levesque et. al \cite{levesque97golog}. Testimony
to its success are its wide range of applications (see, for example,
\cite{levesque97golog,Ferrein2005readylog} ) and many extensions
to provide additional functionality (such as ConGolog \cite{giacomo00congolog},
DTGolog \cite{boutilier00dtgolog}, and IndiGolog \cite{giacomo99indigolog}).
In this paper we use the term ``Golog'' to refer to the family
of languages based on this technique.

To program an agent using Golog one specifies a situation calculus
theory of action, and a program consisting of actions from the world
connected using programming constructs such as if-then-else, while
loops, and nondeterministic choice. Table \ref{tbl:Golog-Operators}
lists some of the operators available from various incarnations of
the language.

\begin{table}[t]
\begin{center}\begin{tabular}{|c|c|}
\hline 
Operator&
Meaning\tabularnewline
\hline
\hline 
$\phi?$&
Proceed only if condition $\phi$ is true\tabularnewline
\hline 
$\delta_{1};\delta_{2}$&
Execute program $\delta_{1}$followed by $\delta_{2}$\tabularnewline
\hline 
$\delta_{1}|\delta_{2}$&
Execute either $\delta_{1}$ or $\delta_{2}$\tabularnewline
\hline 
$\pi(x)\delta(x)$&
Nondet. select arguments for $\delta$\tabularnewline
\hline 
$\delta*$&
Execute $\delta$ zero or more times\tabularnewline
\hline 
$\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$&
Exec. $\delta_{1}$ if $\phi$ holds, $\delta_{2}$ otherwise\tabularnewline
\hline 
$\mathbf{while\,}\phi\mathbf{\, do}\,\delta$&
Execute $\delta$ while $\phi$ holds\tabularnewline
\hline 
$\delta_{1}||\delta_{2}$&
Concurrently execute $\delta_{1}$and $\delta_{2}$\tabularnewline
\hline 
$\Sigma\delta$&
Find and perform legal exec. of $\delta$\tabularnewline
\hline 
$\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$&
Procedure definition\tabularnewline
\hline
\end{tabular}\end{center}


\caption{Some Golog Operators\label{tbl:Golog-Operators}}
\end{table}


In line with the idea of high-level program execution, the agent's
control program is nondeterministic. It is the task of the agent to
find a deterministic instantiation of the program, a sequence of actions
that can be performed in the world. Such a sequence is called a ``legal
execution'' of the Golog program.

The original Golog was conceived as on offline planner - the agent
would determine a complete execution of the program before any actions
were performed in the world. While this guarantees that a legal execution
will be found if possible, it can be impractical for large programs
and cannot account for unexpected occurrences or information obtained
from run-time sensing. An alternative is online execution, where nondeterministic
choices become arbitrary choices and are committed to immediately.
This notion was formalised in the extension IndiGolog \cite{giacomo99indigolog},
which introduced a search operator to allow offline planning to be
conducted over specific parts of the program.

The semantics of the Golog operators are typically defined recursively
using logical formulae. The most flexible semantics have proven to
be the transition semantics introduced with the extension ConGolog
\cite{giacomo00congolog} to allow concurrent execution of several
programs. Two predicates $Trans$ and $Final$ are defined for each
operator. Intuitively, $Trans(\delta,s,\delta',s')$ is true precisely
when executing a single step of program $\delta$ can cause the world
to move from situation $s$ to situation $s'$, after which $\delta'$
remains to be executed. It thus specifies single steps of computation
of the program $\delta$. $Final(\delta,s)$ is true when program
$\delta$ may legally terminate its execution in situation $s$. Finding
a legal execution then consists of finding a situation $s$ such that:
\begin{equation}
\mathcal{D}\models\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]
\end{equation}

Here $Trans*$ is the reflexive transitive closure of $Trans$, or at least a
first-order appropximation thereof.

\section{Improved Semantics}

\label{sec:MIndiGolog}

We have integrated three extensions to the situation calculus with the
existing semanitcs of ConGolog and IndiGolog to overcome several
challenges encountered when moving to a multi-agent setting.  These
extensions allow the agents to represent time, concurrently-occuring actions,
and natural actions.
\\

\textbf{Time}: An explicit notion of time can make coordination between agents
easier, as they may arrange to perform joint actions at a particular time.  It
also alows a richer description of the world - for example, it becomes possible
to specify that cake must be baked for 30 minutes.

There have been several efforts to incorporate a temporal component
into the situation calculus, beginning with Pinto \cite{pinto94temporal}.
Reiter \cite{reiter96sc_nat_conc} simplified this work by including
within each action an explicit argument indicating the time at which
it was performed. While this is useful when specifying precise times
for action occurrences, it adds complexity when actions are performed
concurrently.

This complexity can be avoided by attaching the occurrence time not
to actions but to situations. The successor situation function $do(a,s)$
becomes $do(a,t,s)$, to indicate ``action $a$ was performed at
time $t$ in situation $s$''. Likewise, the possibility predicate
$Poss(a,s)$ becomes $Poss(a,t,s)$, meaning ``it is possible to
perform action $a$ at time $t$ in situation $s$''.  The existing semantics
of IndiGolog are trivially modified to accomodate this.

Time may be represented by any appropriately-behaved sequence (e.g. reals,
integers), and no commitment is made about the starting time of $S_0$.
The function $start(s)$ is added to give the starting time of other situations:
\begin{equation}
start(do(a,t,s))=t
\end{equation}

\textbf{Concurrency}: 
For multi-agent teams, concurrency refers to two distinct ideas -
the possibility of performing several actions at the same instant,
and the possibility of interleaving the execution of several high-level
programs. These are referred to as \emph{true concurrency} and \emph{interleaved
concurrency} respectively.

The work of \cite{lin92sc_conc,reiter96sc_nat_conc} provides an extension
to the situation calculus that allows several primitive actions to
occur at the same time. Action terms are replaced with sets of actions
to be performed simultaneously. All functions and predicates that
take an action are modified to accept sets of actions instead. For
example, $do$ and $Poss$ become $do(\{ a_{1},a_{2},...\},t,s)$
and $Poss(\{ a_{1},a_{2},...\},t,s)$.

The notion of concurrently executing multiple high-level programs
is treated in \cite{giacomo00congolog} with the development of ConGolog.
The operator $\delta_{1}||\delta_{2}$ is introduced, meaning ``execute
both $\delta_{1}$ and $\delta_{2}$ concurrently''. This is achieved
by interleaving steps of execution from the two programs.

These two notions of concurrency were combined by Baier and Pinto
\cite{pinto99tcongolog} by modifying ConGolog to incorporate sets
of concurrent actions. We follow a similar approach, but place
additional restrictions on the semantics to ensure that programs are
well-behaved. Their work also does not include an explicit account
of time.

It is straightforward to modify the clause of $Trans$
for primitive actions to instead accept sets of concurrent actions.
The fact that several actions can occur simultaneously has
deeper implications for the concurrency operator, which in ConGolog
is implemented by accepting a transition from either of the two programs
as a transition for the pair:
\begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\\
\shoveright{\exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s')}\\
\vee\exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')
\end{multline}

In the presence of true concurrency, this is insufficient. It may
also be possible to simultaneously transition both $\delta_{1}$ and
$\delta_{2}$ by executing actions concurrently:%
\footnote{Here we use implication to indicate an additional sufficient, but
not necessary, condition for $Trans$ %
}
\begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow \exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\,\\
 Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\\
 \wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\\
 \wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)
\end{multline}


This approach introduces several complications. First, the combination
of actions $c_{1}\cup c_{2}$ is not guaranteed to be possible. While
the actions $acquire(Thomas,Bowl)$ and $acquire(Richard,Bowl)$ may
individually be possible, performing them concurrently clearly is
not. This is known as the precondition interaction problem \cite{pinto94temporal}
and is an area of ongoing research.

For our purposes this is addressed by introducing a predicate $Conflicts(c,t,s)$
which is true when the actions in $c$ are in conflict and cannot
be performed together. The possibility axiom for concurrent actions
is then:
\begin{multline}
Poss(c,t,s)\leftrightarrow\\
\forall a\left[a\in c\rightarrow Poss(a,t,s)\right]\wedge\neg Conflicts(c,t,s)
\end{multline}

This can be used, for example, to prevent each agent from performing
more than one action at a time.

Another issue arises when two programs can legitimately be transitioned
by executing the same action. Consider the following programs which
add ingredients to a bowl:
\begin{multline}
\delta_{1}=place\_ in(Thomas,Flour,Bowl)\,;\\
   \shoveright{place\_ in(Thomas,Sugar,Bowl)}\\
\shoveleft{\delta_{2}=place\_ in(Thomas,Flour,Bowl)\,;}\\
   place\_ in(Thomas,Egg,Bowl)
\end{multline}

Executing $\delta_{1}||\delta_{2}$ should result in the bowl containing
two units of flour, one unit of sugar and an egg. However, the above
transition rule allows a transition with $c_{1}=c_{2}=place\_ in(Thomas,Flour,Bowl)$,
which adds only one unit of flour. Alternately, consider two programs
waiting for a timer to ring (a natural action, see Section \ref{sub:Natural-Actions}):
\begin{multline}
\delta_{1}=ring\_ timer(OvenTimer)\,;\\
   \shoveright{acquire(Thomas,Bowl)}\\
\shoveleft{\delta_{2}=ring\_ timer(OvenTimer)\,;}\\
    acquire(Richard,Board)
\end{multline}


Both programs should be allowed to proceed with a single occurrence
of the $ring\_ timer$ action. To enforce this intuitive notion of
how programs should behave, concurrent execution must not be allowed
to transition both programs through the occurrence of the same agent-initiated
action.

Taking these factors into account, we derive an improved transition
rule are follows:
\begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow \exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\\
Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\,\wedge\\
Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\\
Poss(c_{1}\cup c_{2},t,s)\,\wedge\\
\forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow natural(a)\right]\,\wedge\\
\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)
\end{multline}

This robust combination of true and interleaved concurrency allows
the language to more accurately reflect the concurrency present in
multi-agent teams.
\\

\textbf{Natural Actions}: These are a special class of exogenous actions, those
actions which occur
outside of the agent's control.
If an agent sets a timer then it will
ring at the appropriate time without further intervention from any agent.  They
are especially important in a multi-agent context for predicting the
behavior of other agents, such as when they will finish a particular
long-running task.

Introduced to the situation
calculus by Pinto \cite{pinto94temporal} and expanded by Reiter \cite{reiter96sc_nat_conc},
they are classified according to the following requirement: natural
actions must occur at their predicted times, provided no earlier actions
prevent them from occurring. For example, a timer will ring at the
time it was set for, unless it is switched off.

The methodology of \cite{reiter96sc_nat_conc} is adopted, suitably
modified for our handling of time. Natural actions are indicated by
truth of the predicate $natural(a)$. As usual, the times at which
natural actions may occur are specified by the $Poss$ predicate.
For example, suppose that the fluent $timer\_set(ID,m,s)$ represents
the fact that a particular timer is set to ring in $m$ minutes in
situation $S$. The possibility predicate for the $ring\_timer(ID)$
action would be:
\begin{multline}
Poss(ring\_timer(ID),t,s)\leftrightarrow\\
\exists m.\left[timer\_set(ID,m,s)\wedge t=start(s)+m\right]
\end{multline}

An important concept when dealing with natural actions it the least
natural time point (LNTP) of a situation. This is defined as the earliest
time at which a natural action may occur in a situation:
\begin{multline}
lntp(s,t)\leftrightarrow \exists a\left[natural(a)\wedge Poss(a,t,s)\right]\wedge\\
\forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]
\end{multline}

Note that the LNTP need not exist for a given situation. This can
happen both when no natural actions are possible in a situation, or
when a natural action may occur at any time in a situation (and there
is thus no earliest time). We will assume that the domain axiomatisation
is designed to avoid such pathological cases, and the absence of an
LNTP implies that no natural actions are possible.

To enforce the requirement that natural actions must occur when possible,
a predicate $legal(s)$ is introduced which is true only for situations
which respect this requirement (assuming no precondition interaction
among natural actions):
\begin{equation}
legal(S_{0}) \leftrightarrow True
\end{equation}
\begin{multline}
legal(do(c,t,s)) \leftrightarrow legal(s)\wedge Poss(c,t,s)\wedge start(s)\leq t\\
\wedge (\forall a,t_{a}).natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c\vee t<t_{a}\right]
\end{multline}

While time and natural actions in Golog have previously been utilised
for planning \cite{pirri00planning_nat_acts}, the programmer
was required to explicitly check for the possible occurrence of natural
actions and ensure that executions of the program resulted in legal
situations. Our integration significantly lowers the burden on the
programmer by guaranteeing that all program executions produce legal
situations.
MIndiGolog agents will plan for the occurance of natural actions
without having them explicitly mentioned in the program.  They may
optionally be included in the program, instructing the agents to wait for
the action to occur before proceeding.

The possible transitions for a program containing a single action
depend on whether the accompanying situation has a least natural time
point. If not, it is legal to perform the action at any time greater
than or equal to the start of the situation. If there is a LNTP,
a legal situation can be produced in one of three ways: perform the
action before the LNTP, perform it at the LNTP in conjunction with
the natural actions, or perform the natural actions first.  We modify
the $Trans$ clause for primitive actions to account for these four options:
\begin{multline}
Trans(c,s,\delta',s')\equiv \exists t_{n}. lntp(s,t_{n}) \\
  \wedge \left\{ \left[\exists t.t\geq start(s)\wedge t<t_{n}\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\right.\\
   \quad\vee\exists cn.\left(\forall a.natural(a)\wedge Poss(a,t_{n},s)\leftrightarrow a\in cn\right)\\
  \quad\wedge\left[poss(c\cup cn,t_{n},s)\wedge s'=do(c\cup cn,t_{n},s)\wedge\delta'=nil\right.\\
  \quad\vee\left.\left.s'=do(cn,t_{n},s)\wedge\delta'=c\right]\right\}\\
  \vee\quad\neg\exists t_{n}.lntp(s,t_{n})\wedge\exists t.\left[Poss(c,t,s)\wedge\right.\\
  \left.t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]
\end{multline}

\textbf{MIndiGolog}:   

\begin{theorem}
Let $\mathcal{D}$ be a MIndiGolog theory of action. Then:
\begin{multline*}
\mathcal{D} \models \forall s,s',\delta,\delta'.legal(s)\wedge Trans(\delta,s,\delta',s')\\
\rightarrow legal(s')
\end{multline*}
\end{theorem}

\begin{proof}
By induction on the structure of $\delta$.
Consider first the case of a single concurrent action, $\delta=c$.  This
$Trans$ clause (TODO) has four disjuncts. We treat here only the
case where actions are performed before the LNTP, other
cases employ similar reasoning.
Assuming this case, (TODO) reduces to:
\begin{multline*}
Trans(c,s,nil,do(c,t,s)) \equiv \exists t_n . lntp(s,t_n) \wedge \\
  t < t_n \wedge ti \geq start(s) \wedge Poss(c,t,s)
\end{multline*}
By the definition of $lntp$ (TODO) and given $t < t_n$, no natural actions
can be possible before or at time $t$, allowing us to add:
\begin{multline*}
Trans(c,s,nil,do(c,t,s)) \equiv \exists t_n . lntp(s,t_n) \wedge \\
  t < t_n \wedge t \geq start(s) \wedge Poss(c,t,s) \wedge\\
  \forall a,t_a \left[ natural(a) \wedge Poss(a,t_a,s) \rightarrow t < t_a \right]
\end{multline*}
Given $legal(s)$ and equation TODO, it is then clear that:
\begin{multline*}
\mathcal{D} \models legal(s) \wedge Trans(c,s,nil,do(c,t,s))\\
\rightarrow legal(do(c,t,s))
\end{multline*}
Next consider the case of concurrent execution of two programs.  The $Trans$
clause (TODO)for concurrency will only introduce a new situation term when both
sub-programs transition simulaneously, with other cases trivially legal by
the inductive hypothesis.  Limiting to this case, (TODO) reduces to:
\begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow \exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\\
Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\,\wedge\\
Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\\
Poss(c_{1}\cup c_{2},t,s)\,\wedge\\
\forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow natural(a)\right]\,\wedge\\
\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)
\end{multline*}
Both $do(c_1,t,s)$ and $(do,c_2,t,s)$ will be legal by the inductive hypothesis,
hence $start(s) \leq t$ and $c_1$ contains any required natural actions.
Since $Trans$ requires that $Poss(c_1 \cup c_2,t,s)$ all conjuncts in
equation (TODO) are satisfied, and:
\begin{equation*}
\mathcal{D} \models legal(s) \wedge Trans(\delta_1 || \delta_2,s,\delta,s'))
\rightarrow legal(s')
\end{equation*}
No other $Trans$ clauses introduce new situation terms, making
the remaining induction trivial.
\end{proof}


\begin{theorem}
Let $\mathcal{D}$ be a MIndiGolog theory of action. Then:
\begin{equation*}
\mathcal{D} \models \forall s',\delta,\delta'. Trans*(\delta,S_0,\delta',s')
\rightarrow legal(s')
\end{equation*}
Consequently, all legal executions of a MIndiGolog program respect
the occurance of natural actions.
\end{theorem}

\begin{proof}
Immediate from Theorem TODO, the legality of $S_0$, and the properties
of transitive closure.
\end{proof}


\subsection{Example Programs}

Having developed the necessary extensions, we now give some examples
of programs which could be used in the cooking agents domain. One
powerful feature of our language is the ability to nondeterministically
select an agent for a particular task. Consider the following procedure
for making a simple salad in a specified container:

\[
\begin{array}{c}
\mathbf{proc}\, MakeSalad(dest)\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)(acquire(agt,dest)\,;\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, begin\_ task(agt,mix(dest,1))\,;\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, end\_ task(agt,mix(dest,1))\,;\\
\,\,\,\, release(agt,dest))\,\,\mathbf{end}\end{array}\]


The procedure $ChopTypeInto$ (not shown) picks an object of the given
type and an available chopping board, chops the object using the board,
then transfers it into the destination container. $MakeSalad$ asks
the agents to do this for a lettuce, a carrot and a tomato, then mix
the ingredients together. Crucially, the agent assigned to handling
each ingredient is not specified, nor is the order in which they should
be added. The agents are free to determine an appropriate strategy.

%
\begin{figure*}[t]
\centering
\framebox{
\begin{minipage}[t]{0.5\linewidth}
\small
\verbatiminput{listings/output_makeSalad_1.txt}
\end{minipage}
\begin{minipage}[t]{0.45\linewidth}
\small
\verbatiminput{listings/output_makeSalad_2.txt}
\end{minipage}
}
\caption{One possible execution of the $MakeSalad$
program with three agents. Variables $\_ U$, $\_ T$, etc give
the occurrence times of each action, constrained to ensure all situations
are legal.}\label{cap:example_trace}
\end{figure*}


A trace of a legal execution of the $MakeSalad$ program is shown
in Figure \ref{cap:example_trace}. Notice the occurrence of several
actions within each \textbf{do} statement, demonstrating the integration
of true concurrency into the language. By contrast, an implementation
in ConGolog would have only a single action at each step - assuming
each step represents a finite time interval, this would unnecessarily
leave some agents idle. Note also the explicit occurrence time for
each step, allowing the agents to properly synchronise their actions.
This time is not fixed but rather constrained based on the times at
which previous actions were performed. These constraints emerge from
the underlying situation calculus description of the world and are
maintained automatically by the language. For coordination purposes
the agents would agree, for example, to perform each action at the
earliest possible time.

In this example there are three agents but only two chopping boards,
meaning one agent has to remain idle while waiting for the necessary
resources. If other tasks were given concurrently with $MakeSalad$,
this agent could make progress on those while waiting. For example:

\[
MakeSalad()\,||\, MakeMainMeal()\,||\, MakeCake()\]


\section{Related Work}

\label{sec:Other-Work}

The utility of the high-level program execution paradigm is highlighted
by the many extensions which have been developed for the base Golog
language. Prominent among these are the following: \emph{ConGolog}
\cite{giacomo00congolog} introduced the ability for an agent to interleave
the execution of multiple high-level programs, along with the notion
of an interrupt which gains control when certain conditions become
true. \emph{IndiGolog} \cite{giacomo99indigolog} formalised online
execution of Golog programs and introduced the search operator to
allow controlled offline planning. \emph{DTGolog} \cite{boutilier00dtgolog}
combined the situation calculus with Markov Decision Processes to
allow agents to determine the best execution of a program in the face
of probabilistic action outcomes.

There has also been work on extending the situation calculus to allow
richer world models, notably that of Pinto \cite{pinto94temporal}
and Reiter \cite{reiter96sc_nat_conc}. Work on concurrent execution
of primitive actions and explicit time in particular make the situation
calculus more suitable for representing worlds containing multiple
agents. However, there appears to be little work incorporating these
extensions with extensions to the Golog language.

While work with Golog has predominantly focused on single-agent systems,
there have been several notable applications of the technique to multi-agent
systems. The Cognitive Agent Specification Language \cite{shapiro02}
uses ConGolog to describe the behavior of agents in a multi-agent
setting, and an automated theorem prover is in development that can
verify properties of the programs. It differs from our work in that
it is designed for open multi-agent systems, with each agent having
its own Golog program defining its behavior. By contrast, we seek
to develop a single Golog program that is cooperatively executed by
all agents. Another difference is its focus on modelling and simulation
of agent systems, rather than producing executable programs.

Closer to the spirit of this paper is the work of Ferrein et. al.
\cite{Ferrein2005readylog} on ReadyLog, a Golog derivative designed
for highly dynamic domains. It has been successfully applied to control
multi-agent teams in the RoboCup soccer tournament. ReadyLog integrates
the facilities of concurrency, online execution and decision theory
and can be seen as a unification of ConGolog, IndiGolog and DTGolog.
The programs used to control the soccer team intersperse actions by
several agents and can thus be viewed as team programs. However, the
program is evaluated separately by each agent.

TODO: another paragraph on the wider MA contex,
Closer to the spirit of this paper is the work of Ferrein et. al.
\cite{Ferrein2005readylog} on ReadyLog, a Golog derivative designed
for highly dynamic domains. It has been successfully applied to control
multi-agent teams in the RoboCup soccer tournament. ReadyLog integrates
the facilities of concurrency, online execution and decision theory
and can be seen as a unification of ConGolog, IndiGolog and DTGolog.
The programs used to control the soccer team intersperse actions by
several agents and can thus be viewed as team programs. However, the
program is evaluated separately by each agent.

In summary, while there have been extensions to Golog that allow more
expressive programs to be written and extensions to the situation
calculus which provide richer models of the world, the integration
of these approaches is a topic of ongoing work. It is at this crossroads
that our new language, MIndiGolog, is positioned. It combines the
collective capabilities of these extensions to represent and program
the behavior of multi-agent teams.


\section{Conclusions}

\label{sec:Conclusions-and-Future}

In this paper, we have integrated a combination of several important
extensions to the situation calculus and Golog to provide a new language
suitable for expressing high-level programs for multi-agent teams.
The main contribution of this work is the effective integration of
elements important to multi-agent programs into the semantics: the
combination of true and interleaved concurrency; an explicit notion
of time for coordination; and the tight integration of natural actions.
An implementation of this language using Mozart has demonstrated its
effectiveness as a centralised multi-agent planner and a method for
distributed execution. 

We are presently exploring the potential of this approach for a range
of distributed programming applications, and the integration of additional
techniques from the field of high-level program execution. Key among
these is the significant work on representing knowledge and belief
in Golog. As many applications involve partially observable worlds,
different agents must be capable of having different beliefs about
the world. Additionally, while we have distributed the workload of
planning an execution, overall control is still centralised. We are
actively researching techniques to allow an execution to be found
in a decentralised manner.

As our implementations have demonstrated, the combination of state-of-the-art
techniques from Golog is highly capable of representing the behavior
of multi-agent teams. Combined with facilities for distributed logic
programming, MIndiGolog promises to provide the advantages of high-level
program execution for multi-agent teams.

\bibliography{/storage/uni/pgrad/library/references}
\bibliographystyle{aaai}

\end{document}
