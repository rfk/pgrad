#LyX 1.5.1 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{aaai}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage{tikz}
\usepackage{amsthm}
\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}
\nocopyright

\newtheorem{theorem}{Theorem}
\end_preamble
\options letterpaper
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Cooperative Execution in the Situation Calculus
\newline
using Prime Event Structures
\end_layout

\begin_layout Author
Tracking Number: 9
\end_layout

\begin_layout Abstract
We develop a powerful extension to the situation calculus for representing
 and reasoning about the cooperative execution of tasks by a team of agents
 in asynchronous, partially observable domains.
 Existing applications of the situation calculus utilize totally ordered
 sequences of actions, requiring constant synchronization between agents
 that is undesirable or even impossible in some settings.
 Our new approach utilizes 
\emph on
joint executions
\emph default
, partially ordered branching action sequences based on a prime event structure.
 We show how a team of agents can use these structures to cooperatively
 plan and perform an execution of a shared ConGolog program.
 The use of prime event structures has the capacity to guarantee legal execution
s in spite of asynchronicity and partial observability, facilitating the
 use of powerful non-deterministic programming techniques for multi-agent
 problem solving tasks.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

, and programming languages such as ConGolog that are built upon it 
\begin_inset LatexCommand cite
key "giacomo00congolog"

\end_inset

, has proven an effective formalism for specifying and reasoning about the
 behavior of agents in a dynamic world.
 While mostly used for single-agent domains, it has also found application
 in a variety of multi-agent settings 
\begin_inset LatexCommand cite
key "shapiro02casl,Ferrein2005readylog,kelly06hlp_dps_anon"

\end_inset

.
 Among its advantages are an effective reasoning procedure based on regression,
 a straightforward encoding as a logic program, and a wide range of extensions
 such as concurrent actions, time, and natural actions.
\end_layout

\begin_layout Standard
However, some representational limits of the situation calculus make it
 unsatisfactory for rich multi-agent domains.
 The fundamental unit of reasoning, and the output of the ConGolog execution
 planning process, is the 
\emph on
situation
\emph default
: a complete, ordered history of all actions that have occurred in the world.
 Executing such a total ordering in a multi-agent setting requires constant
 synchronization between the agents, severely limiting the potential for
 concurrency in the system.
 Such synchronization may not even be possible if agents are unaware of
 the actions performed by others.
 Multi-agent applications of the situation calculus thus invariably assume
 that all actions performed are public, available to all agents for the
 purposes of reasoning and synchronization.
 This is clearly unrealistic in many domains.
\end_layout

\begin_layout Standard
To overcome these limitations, we leverage a model of concurrent computation
 known as 
\emph on
prime event
\emph default
 
\emph on
structures
\emph default
, which are partially-ordered branching sequences of events 
\begin_inset LatexCommand cite
key "npw79event_structures"

\end_inset

.
 Rather than building ordinary situation terms during the planning process,
 we build a restricted prime event structure which we call a 
\emph on
joint execution.

\emph default
 These structures are rich enough to capture the concurrent execution of
 independent actions, including actions with sensing results, but restricted
 enough to be unambiguously reduced to situation terms for the purposes
 of reasoning.
 They are further restricted such that for every action, the agent required
 to perform it can determine when to do so based only on its local history
 of observations, allowing synchronization in the face of partial observability.
 To demonstrate the utility of our approach, we show how a team of agents
 can cooperate to plan and perform an execution of a shared ConGolog program.
\end_layout

\begin_layout Standard
Joint executions allow us to capture the actions that a team of agents are
 to perform in service of some shared task, without requiring constant synchroni
zation between the agents, and without assuming that agents know all the
 actions that have been performed, while utilizing existing reasoning methods
 based on full situation terms.
 This is a significant increase in expressiveness over existing approaches
 to modeling multi-agent teams in the situation calculus.
 
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Standard
The situation calculus 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

 is a formalism for representing and reasoning about dynamic worlds.
 We use a variant with multiple agents 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

, sensing actions and partial observability of actions 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

.
 Below is a brief review.
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom, with the following sorts: 
\noun on
Agent
\noun default
 terms represent the agents operating in the world; 
\emph on
\noun on
Action
\emph default
\noun default
 terms are functions denoting instantaneous events that can cause the state
 of the world to change, with the initiating agent indicated by their first
 argument; 
\noun on
Situation
\noun default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built using the function 
\begin_inset Formula $do(a,s)$
\end_inset

; 
\noun on
Result
\noun default
 terms represent the sensing results of actions; 
\noun on
Observation 
\noun default
terms represent what an agent may perceive when an action takes place; 
\noun on
Object
\noun default
 terms are other objects in the domain.
 
\emph on
Fluents
\emph default
 are predicates or functions representing properties of the world that change
 between situations, and so take a situation as their final argument.
\end_layout

\begin_layout Standard
A 
\emph on
basic action theory
\emph default
 is a set 
\begin_inset Formula $\mathcal{D}$
\end_inset

 of situation calculus sentences (with a specific syntactic form as specified
 in 
\begin_inset LatexCommand cite
key "pirri99contributions_sitcalc"

\end_inset

) that describes a particular dynamic world.
 Queries about the behavior of the world are posed as logical entailment
 queries relative to this theory.
 There is a distinguished fluent 
\begin_inset Formula $Poss(a,s)$
\end_inset

 that indicates when it is possible to perform an action in a given situation.
 The function 
\begin_inset Formula $SR(a,s)=r$
\end_inset

 gives the sensing result of an action, and we assume there is a finite
 set of possible results for each action.
\end_layout

\begin_layout Standard
Rather than assuming all actions are public, the function 
\begin_inset Formula $Obs(agt,a,s)=o$
\end_inset

 gives the set of 
\emph on
observations
\emph default
 perceived by an agent when an action occurs.
 For simple domains it suffices to have it yield: the empty set 
\begin_inset Formula $\{\}$
\end_inset

 if the agent is unaware of the occurrence of the action; 
\begin_inset Formula $\{a\}$
\end_inset

 if the agent perceives the action but not its result; and 
\begin_inset Formula $\{(a,SR(a,s)\}$
\end_inset

 if the agent is also aware of the result.
 See 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

 for full details.
 We define the 
\emph on
outcome
\emph default
 of an action to be the full set of 
\begin_inset Formula $(agt,Obs(agt,a,s))$
\end_inset

 pairs for every agent in the domain, and denote this 
\begin_inset Formula $Out(a,s)$
\end_inset

.
 The suggestive notation 
\begin_inset Formula $Out(a,s)[agt]$
\end_inset

 accesses a specific 
\begin_inset Formula $Obs(agt,a,s)$
\end_inset

 term.
\end_layout

\begin_layout Standard
The regression meta-operator 
\begin_inset Formula $\mathcal{R}$
\end_inset

 is used to handle reasoning effectively.
 Queries must be posed in the form 
\begin_inset Formula $\mathcal{D}\,\models\,\phi(s)$
\end_inset

.
 This reads 
\begin_inset Quotes eld
\end_inset

formula 
\begin_inset Formula $\phi$
\end_inset

 holds in situation 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

, where 
\begin_inset Formula $\phi$
\end_inset

 is some logical combination of fluents and 
\begin_inset Formula $s$
\end_inset

 is a situation term rooted at 
\begin_inset Formula $S_{0}$
\end_inset

.
 This restriction means that a full situation term is required in order
 to perform reasoning.
 Regression can be effectively implemented as a logic program.
\end_layout

\begin_layout Standard
For reasoning with sensing results that are only available at run-time,
 we follow the approach of 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 and introduce the concept of a 
\emph on
history
\emph default
, denoted 
\begin_inset Formula $\sigma$
\end_inset

.
 This is a sequence of pairs 
\begin_inset Formula $(a,Out(a,s))$
\end_inset

 giving the outcome produced by each action.
 Histories are strictly a meta-level construct and do not exist in the language
 of the situation calculus.
 Rather, the macro 
\begin_inset Formula $\mathbf{end}[\sigma]$
\end_inset

 gives the situation term corresponding to the history, and 
\begin_inset Formula $\mathbf{res}[\sigma]$
\end_inset

 gives a formula capturing the information given by the sensing results.
 To determine whether 
\begin_inset Formula $\phi$
\end_inset

 holds after history 
\begin_inset Formula $\sigma$
\end_inset

 the query 
\begin_inset Formula $\mathcal{D}\models\mathbf{res}[\sigma]\rightarrow\phi(\mathbf{end}[\sigma])$
\end_inset

 is used, which we abbreviate to 
\begin_inset Formula $\mathcal{D}\models\mathbf{holds}[\phi,\sigma]$
\end_inset

; see 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 for details.
 A history is 
\emph on
legal
\emph default
 if each action is possible at the time it is performed, and its outcome
 is consistent with previous outcomes; the macro 
\begin_inset Formula $\mathbf{legal}[\sigma]$
\end_inset

 asserts this.
 
\end_layout

\begin_layout Standard
We must also consider the local view of a history that is available to each
 agent, as agents can only act based on their local history of observations.
 Given a history 
\begin_inset Formula $\sigma$
\end_inset

, it is straightforward to produce the 
\emph on
view 
\emph default
of that history that is available to a given agent: it is the corresponding
 sequence of 
\begin_inset Formula $(a,Obs(agt,a,s))$
\end_inset

 pairs where 
\begin_inset Formula $Obs(agt,a,s)$
\end_inset

 is non-empty.
 We will denote this by 
\begin_inset Formula $view(agt,\sigma)$
\end_inset

.
\end_layout

\begin_layout Subsection
ConGolog
\end_layout

\begin_layout Standard
ConGolog is a declarative agent programming language based on the situation
 calculus 
\begin_inset LatexCommand cite
key "giacomo00congolog"

\end_inset

.
 Testimony to its success are its wide range of applications and many extensions
 to provide additional functionality 
\begin_inset LatexCommand cite
key "kelly06hlp_dps_anon,giacomo99indigolog,farinelli07team_golog,Ferrein2005readylog,shapiro02casl"

\end_inset

.
 To program an agent using ConGolog one specifies a situation calculus action
 theory, and a program consisting of actions from the theory connected by
 programming constructs such as the following:
\newline

\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="right" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $nil$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
- the empty program
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
- perform action 
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\phi?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
- proceed if condition 
\begin_inset Formula $\phi$
\end_inset

 is true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1};\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
- execute program 
\begin_inset Formula $\delta_{1}$
\end_inset

, followed by 
\begin_inset Formula $\delta_{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}|\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
- execute either 
\begin_inset Formula $\delta_{1}$
\end_inset

 or 
\begin_inset Formula $\delta_{2}$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\pi(\overrightarrow{x})\delta(\overrightarrow{x})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
- nondeterministic choice of arguments
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
- execute 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

 concurrently
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\newline

\end_layout

\begin_layout Standard
Since the control program may be nondeterministic, it is the task of the
 agent to plan a deterministic instantiation of the program, a sequence
 of actions that can legally be performed in the world.
 We call this the 
\emph on
execution planning process 
\emph default
and the result is a 
\emph on
legal execution
\emph default
 of the program.
 ConGolog programs are executed in an offline manner: a complete situation
 term constituting a legal execution is constructed, then executed by the
 agent in a reactive manner.
 When actions can have multiple results, the output must be a branching
 structure rather than a straight situation term, and planning deals with
 each branch in turn 
\begin_inset LatexCommand cite
key "lakemeyer99golog_cats"

\end_inset

.
\end_layout

\begin_layout Standard
The idea of having a team of agents execute a shared ConGolog program has
 been utilized in 
\begin_inset LatexCommand cite
key "Ferrein2005readylog"

\end_inset

 as well as our own previous work 
\begin_inset LatexCommand cite
key "kelly06hlp_dps_anon"

\end_inset

.
 The advantages of this approach include the use of nondeterministic operators
 to provide 'dont-care' nondeterminism regarding which team-member carries
 out which task, the use of the concurrency operator to easily compose sub-tasks
, and the ability to plan for and resolve conflicts between agents.
 To demonstrate our approach, we adopt the example from 
\begin_inset LatexCommand cite
key "kelly06hlp_dps_anon"

\end_inset

 of a team of robotic chefs cooperating to prepare a simple salad.
 Their control program is shown in Figure 
\begin_inset LatexCommand ref
reference "fig:makesalad-program"

\end_inset

.
 It says, in essence: somebody chop a lettuce, somebody chop a tomato, and
 somebody
\emph on
 
\emph default
chop a carrot into the bowl, then mix.
 Later we show a joint execution found by our system for this program.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "97col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Standard
\begin_inset Formula \begin{multline*}
\mathbf{proc}\,\, MakeSalad(bowl):\\
\left[ChopTypeInto(Lettuce,bowl)\,||\right.\\
ChopTypeInto(Tomato,bowl)\,||\\
\left.ChopTypeInto(Carrot,bowl)\right];\\
\pi(agt,acquire(agt,bowl)\,;\, mix(agt,bowl)\,;\\
\shoveright{\, release(agt,bowl))\,\mathbf{end}}\\
\\\shoveleft{\mathbf{proc}\,\, ChopTypeInto(type,bowl):}\\
\pi((obj,agt,k),\, ObjIsType(obj,type)?\,;\\
ObjIsType(k,knife)?\,;acquire(agt,obj)\,;\\
acquire(agt,k)\,;\, chop(agt,obj)\,\\
acquire(agt,bowl)\,;\, placeIn(agt,bowl)\,;\\
release(agt,k)\,;\,\left[nil\,|\, release(agt,bowl)\right])\,\mathbf{end}\end{multline*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Example of a shared ConGolog program
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:makesalad-program"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Prime Event Structures
\end_layout

\begin_layout Standard
To tackle cooperative execution in a multi-agent setting, we have adopted
 a model of concurrent computation known as 
\emph on
event structures, 
\emph default
introduced in 
\begin_inset LatexCommand cite
key "npw79event_structures"

\end_inset

.
 The particular variant we use are 
\emph on
prime event structures
\emph default
, canonically defined as a four-tuple 
\begin_inset Formula $(\mathcal{V},\prec,\#,\gamma)$
\end_inset

 where: 
\begin_inset Formula $\mathcal{V}$
\end_inset

 is a set of events; 
\begin_inset Formula $\gamma$
\end_inset

 is a function assigning a label to each event; 
\begin_inset Formula $\prec$
\end_inset

 is the 
\emph on
enabling
\emph default
 relation, a strict partial order on events; and 
\begin_inset Formula $\#$
\end_inset

 is the 
\emph on
conflict
\emph default
 relation, a binary symmetric relation indicating event that are mutually
 exclusive.
 A 
\emph on
configuration
\emph default
 is a sequence of events consistent with 
\begin_inset Formula $\prec$
\end_inset

 in which no pair of events conflict.
 Each configuration thus represents a potential partial run of execution
 of the system.
\end_layout

\begin_layout Standard
In this paper we will specify our structures using the more convenient form
 
\begin_inset Formula $(\mathcal{V},ens,alts,\gamma)$
\end_inset

.
 Here 
\begin_inset Formula $ens(i)$
\end_inset

 assigns to each event 
\begin_inset Formula $i\in\mathcal{V}$
\end_inset

 a finite set of other events that are its direct 
\emph on
enablers
\emph default
, meaning that event 
\begin_inset Formula $i$
\end_inset

 can only occur after all the events in 
\begin_inset Formula $ens(i)$
\end_inset

.
 Similarly 
\begin_inset Formula $alts(i)$
\end_inset

 assigns to each event a set of direct 
\emph on
alternatives
\emph default
, meaning that only one event in 
\begin_inset Formula $\{i\}\cup alts(i)$
\end_inset

 can occur during execution of the system.
 Defining 
\begin_inset Formula $\prec$
\end_inset

 and 
\begin_inset Formula $\#$
\end_inset

 in terms of 
\begin_inset Formula $ens$
\end_inset

 and 
\begin_inset Formula $alts$
\end_inset

 is straightforward.
\end_layout

\begin_layout Standard
Event structures thus form a directed acyclic graph of the events that could
 occur during execution of the system.
 As shown in 
\begin_inset LatexCommand cite
key "pratt91modeling_conc_with_geom"

\end_inset

 they are a very general model of concurrent execution, and can be straightforwa
rdly converted to a kind of finite automaton for efficient execution.
\end_layout

\begin_layout Section
Independent Actions
\end_layout

\begin_layout Standard
In order to provide only a partial order on the actions to be performed,
 while maintaining the use of existing reasoning techniques based on full
 situation terms, we must capture the conditions under which actions can
 be performed out of order without invalidating the results of the reasoning
 process.
 Define 
\emph on
independent
\emph default
 actions, identified by 
\begin_inset Formula $indep(a_{1},a_{2})$
\end_inset

, as those that do not interfere with each others preconditions, outcome
 or effects.
 Formally, they must satisfy the following restrictions (where 
\begin_inset Formula $\mathcal{P}$
\end_inset

 and 
\begin_inset Formula $\mathcal{F}$
\end_inset

 are meta-variables ranging over predicate and functional fluents respectively):
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{D}\,\models\, Poss(a_{1},s)\equiv Poss(a_{1},do(a_{2},s))$
\end_inset

 and vice-versa 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{D}\,\models\, Out(a_{1},s)=Out(a_{1},do(a_{2},s))$
\end_inset

 and vice-versa
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{D}\,\models\,\mathcal{P}(do(a_{1},do(a_{2},s)))\equiv\mathcal{P}(do(a_{2},do(a_{1},s)))$
\end_inset


\newline
 for all predicate fluents 
\begin_inset Formula $\mathcal{P}(s)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{D}\,\models\,\mathcal{F}(do(a_{1},do(a_{2},s)))=\mathcal{F}(do(a_{2},do(a_{1},s)))$
\end_inset


\newline
 for all functional fluents 
\begin_inset Formula $\mathcal{F}(s)$
\end_inset


\end_layout

\begin_layout Standard
We assume that the planning system has some way of identifying independent
 actions.
 Two histories 
\begin_inset Formula $\sigma_{1}$
\end_inset

 and 
\begin_inset Formula $\sigma_{2}$
\end_inset

 are called 
\emph on
equivalent
\emph default
 if they are identical up to the ordering of independent actions: they contain
 the same set of 
\begin_inset Formula $(a,Out(a,s))$
\end_inset

 pairs, and whenever two such pairs occur in a different order in 
\begin_inset Formula $\sigma_{1}$
\end_inset

 than in 
\begin_inset Formula $\sigma_{2}$
\end_inset

 the actions are independent.
 Two histories 
\begin_inset Formula $\sigma_{1}$
\end_inset

 and 
\begin_inset Formula $\sigma_{2}$
\end_inset

 are 
\emph on
compatible for 
\begin_inset Formula $a$
\end_inset

 
\emph default
if they are equivalent after removing all actions that are independent of
 
\begin_inset Formula $a$
\end_inset

.
 We then have the following properties of histories:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset


\begin_inset LatexCommand label
name "thm:equiv-holds"

\end_inset

For equivalent histories 
\begin_inset Formula $\sigma_{1}$
\end_inset

 and 
\begin_inset Formula $\sigma_{2}$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\,\models\,\mathbf{holds}[\phi,\sigma_{1}]\,\,\equiv\,\,\mathbf{holds}[\phi,\sigma_{2}]\]

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{theorem}
\backslash
begin{proof}
\end_layout

\end_inset

A straightforward case analysis on the definition of the regression operator.
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset


\begin_inset LatexCommand label
name "thm:equiv-legal"

\end_inset

For equivalent histories 
\begin_inset Formula $\sigma_{1}$
\end_inset

 and 
\begin_inset Formula $\sigma_{2}$
\end_inset

:
\begin_inset Formula \[
\mathcal{D}\,\models\,\mathbf{legal}[\sigma_{1}]\,\,\equiv\,\,\mathbf{legal}[\sigma_{2}]\]

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{theorem}
\backslash
begin{proof}
\end_layout

\end_inset

Using theorem 
\begin_inset LatexCommand ref
reference "thm:equiv-holds"

\end_inset

, and invariance of 
\begin_inset Formula $Poss$
\end_inset

 and 
\begin_inset Formula $Out$
\end_inset

 when transposing independent actions.
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
begin{theorem}
\end_layout

\end_inset


\begin_inset LatexCommand label
name "thm:equiv-compat"

\end_inset

For histories 
\begin_inset Formula $\sigma_{1}$
\end_inset

 and 
\begin_inset Formula $\sigma_{2}$
\end_inset

 compatible for 
\begin_inset Formula $a$
\end_inset

:
\begin_inset Formula \begin{gather*}
\mathcal{D}\,\models\,\mathbf{holds}[Poss(a),\sigma_{1}]\,\,\equiv\,\,\mathbf{holds}[Poss(a),\sigma_{2}]\\
\mathcal{D}\,\models\,\mathbf{holds}[Out(a)=r,\sigma_{1}]\,\,\equiv\,\,\mathbf{holds}[Out(a)=r,\sigma_{2}]\end{gather*}

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{theorem}
\backslash
begin{proof}
\end_layout

\end_inset

Using theorem 
\begin_inset LatexCommand ref
reference "thm:equiv-holds"

\end_inset

, and the fact that the removed actions do not affect the preconditions
 or outcome of 
\begin_inset Formula $a$
\end_inset

.
\begin_inset ERT
status collapsed

\begin_layout Standard


\backslash
end{proof}
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Joint Executions
\end_layout

\begin_layout Standard
We now define 
\emph on
joint executions
\emph default
 to represent the actions that a team of agents are to perform.
 They are restricted prime event structures coupled with a total ordering
 relation:
\begin_inset Formula \[
(\mathcal{A}\cup\mathcal{O},ens,alts,\gamma,<)\]

\end_inset

A joint execution contains two disjoint sets of events: 
\emph on
action
\emph default
 events 
\begin_inset Formula $\mathcal{A}$
\end_inset

 represent the actions to be performed, and 
\emph on
outcome
\emph default
 events 
\begin_inset Formula $\mathcal{O}$
\end_inset

 represent the possible outcomes of the actions.
 For each action event 
\begin_inset Formula $i\in\mathcal{A}$
\end_inset

, its enablers 
\begin_inset Formula $ens(i)$
\end_inset

 is a set of outcome events, its alternatives 
\begin_inset Formula $alts(i)$
\end_inset

 is empty, and its label 
\begin_inset Formula $\gamma(i)$
\end_inset

 is the action to be performed.
 For each outcome event 
\begin_inset Formula $j\in\mathcal{O}$
\end_inset

, 
\begin_inset Formula $ens(j)$
\end_inset

 is a single action event for which it is a possible outcome, 
\begin_inset Formula $alts(j)$
\end_inset

 is the set of all other outcome events 
\begin_inset Formula $j'$
\end_inset

 such that 
\begin_inset Formula $ens(j')=ens(j)$
\end_inset

, and 
\begin_inset Formula $\gamma(j)$
\end_inset

 is an outcome of the action 
\begin_inset Formula $\gamma(ens(j))$
\end_inset

.
 A simple example of a joint execution is shown in Figure 
\begin_inset LatexCommand ref
reference "fig:example-je"

\end_inset

.
 Here 
\begin_inset Formula $act_{1}$
\end_inset

 has two possible outcomes, while 
\begin_inset Formula $act_{3}$
\end_inset

 must occur after both 
\begin_inset Formula $act_{1}$
\end_inset

 and 
\begin_inset Formula $act_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "97col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\align center

\family sans
\series bold
\size tiny
\begin_inset Include \include{listings/je_example.tex}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
The prime event structure representing a simple joint execution.
 Ellipses are action events, boxes are outcome events.
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:example-je"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The total
\emph on
 
\emph default
order 
\begin_inset Formula $<$
\end_inset

 on events is arbitrary, but must be consistent with the partial order 
\begin_inset Formula $\prec$
\end_inset

 induced by 
\begin_inset Formula $ens$
\end_inset

.
 We use it to perform reasoning by assuming that events occur in the fixed
 order given by 
\begin_inset Formula $<$
\end_inset

, allowing us to produce a proper situation or history term.
 Joint executions are restricted to ensure this assumption is acceptable
 (see R1 below).
\end_layout

\begin_layout Standard
Following some definitions, we describe and justify five restrictions that
 joint executions must satisfy.
 Since we will use joint executions as a replacement for situation terms
 in the planning process, they will be built up one action at a time.
 The restrictions should be considered invariants that must be preserved
 when each new action is added.
\end_layout

\begin_layout Subsection
Definitions
\end_layout

\begin_layout Standard
An 
\emph on
outcome set
\emph default
 is a minimal set of non-conflicting outcome events; that is, a set of events
 
\begin_inset Formula $e\subseteq\mathcal{O}$
\end_inset

 satisfying:
\begin_inset Formula \begin{gather*}
\forall j_{1},j_{2}\in e\,:\, j_{1}\not\prec j_{2}\,\wedge\, j_{2}\not\prec j_{1}\,\wedge\,\neg(j_{1}\#j_{2})\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
Recall that a 
\emph on
configuration
\emph default
 is a partial run of execution of the prime event structure.
 Any configuration ending in an outcome event corresponds to a unique history,
 as it is a sequence of alternating actions and their outcomes.
 The 
\emph on
histories
\emph default
 of an outcome set, 
\begin_inset Formula $hists(e)$
\end_inset

, is the set of all configurations that contain all elements of 
\begin_inset Formula $e$
\end_inset

, and end in an event from 
\begin_inset Formula $e$
\end_inset

.
 The unique history that is consistent with 
\begin_inset Formula $<$
\end_inset

 is called the 
\emph on
canonical history
\emph default
 and denoted 
\begin_inset Formula $hist(e)$
\end_inset

.
\end_layout

\begin_layout Standard
We say that a set 
\begin_inset Formula $e_{1}$
\end_inset

 
\emph on
covers
\emph default
 
\emph on

\begin_inset Formula $e_{2}$
\end_inset

, 
\emph default
denoted by 
\begin_inset Formula $e_{1}\sqsubseteq e_{2}$
\end_inset

, if every event in 
\begin_inset Formula $e_{1}$
\end_inset

 is either in 
\begin_inset Formula $e_{2}$
\end_inset

 or precedes something in 
\begin_inset Formula $e_{2}$
\end_inset

: 
\begin_inset Formula \[
e_{1}\sqsubseteq e_{2}\,\equiv\,\forall j_{1}\in e_{1}:\,\,\exists j_{2}\in e_{2}:\,\, j_{1}\preceq j_{2}\]

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
branch
\emph default
 is a special case of an outcome set that meets the following additional
 requirement:
\begin_inset Formula \[
\forall j_{1}\in\mathcal{O}:\,\, j_{1}\in b\,\oplus\,(\exists j_{2}\in b:\,\, j_{1}\#j_{2}\,\vee\, j_{1}\prec j_{2})\]

\end_inset


\end_layout

\begin_layout Standard
That is, every event is either in the branch, conflicts with something in
 the branch, or precedes something in the branch.
 The union of 
\begin_inset Formula $hists(b)$
\end_inset

 for every branch 
\begin_inset Formula $b$
\end_inset

 thus gives the complete set possible runs of execution.
\end_layout

\begin_layout Subsection
Restrictions
\end_layout

\begin_layout Standard
We now impose several restrictions on the structure of a joint execution,
 to ensure they are suitable for representing the actions to be performed
 by a team of agents.
\end_layout

\begin_layout Standard

\series bold
(R1) Independent events have independent actions
\newline

\series default
If the execution allows two action events to occur in either order, then
 the corresponding actions must be independent.
 Formally, for each 
\begin_inset Formula $i_{1},i_{2}\in\mathcal{A}$
\end_inset

:
\begin_inset Formula \[
i_{1}\prec i_{2}\,\vee\, i_{2}\prec i_{1}\,\vee\, i_{1}\#i_{2}\,\vee\, indep(\gamma(i_{1}),\gamma(i_{2}))\]

\end_inset


\end_layout

\begin_layout Standard
This restriction is key to the power of joint executions.
 It implies that for every branch 
\begin_inset Formula $b$
\end_inset

, all histories in 
\begin_inset Formula $hists(b)$
\end_inset

 are equivalent.
 By theorem 
\begin_inset LatexCommand ref
reference "thm:equiv-holds"

\end_inset

 we can use the canonical history 
\begin_inset Formula $hist(b)$
\end_inset

 for planning purposes, and be assured that the same fluents will hold regardles
s of the specific order in which actions are executed.
 More generally, it ensures that all histories in 
\begin_inset Formula $hists(ens(a))$
\end_inset

 are compatible for 
\begin_inset Formula $\gamma(a)$
\end_inset

.
 By theorem 
\begin_inset LatexCommand ref
reference "thm:equiv-compat"

\end_inset

 we can safely use 
\begin_inset Formula $hist(ens(a))$
\end_inset

 to reason about the preconditions and outcomes of 
\begin_inset Formula $\gamma(a)$
\end_inset

 using standard techniques.
\end_layout

\begin_layout Standard

\series bold
(R2) Every canonical branch history is legal
\newline

\series default
For every branch 
\begin_inset Formula $b$
\end_inset

: 
\begin_inset Formula \[
\mathcal{D}\,\models\,\mathbf{legal}[hist(b)]\]

\end_inset


\end_layout

\begin_layout Standard
By theorem 
\begin_inset LatexCommand ref
reference "thm:equiv-legal"

\end_inset

 this ensures that every possible run of execution of the system will produce
 a legal history.
\end_layout

\begin_layout Standard

\series bold
(R3) All possible outcomes are considered
\newline

\series default
Planning clearly requires that all possible outcomes of an action be considered.
 For each action event 
\begin_inset Formula $a\in\mathcal{A}$
\end_inset

, and each possible outcome 
\begin_inset Formula $r$
\end_inset

 of that action, if:
\begin_inset Formula \[
\mathcal{D}\,\not\models\,\mathbf{holds}[Out(\gamma(a))\neq r,hist(ens(a))]\]

\end_inset


\end_layout

\begin_layout Standard
then there must be a corresponding outcome event:
\begin_inset Formula \[
\exists o\in E:\,\, ens(o)=\{a\}\,\wedge\,\gamma(o)=r\]

\end_inset


\end_layout

\begin_layout Standard
We can safely use the canonical history 
\begin_inset Formula $hist(ens(a))$
\end_inset

 to perform this reasoning, thanks to R1.
\end_layout

\begin_layout Standard

\series bold
(R4) Actions are enabled by observable events:
\newline

\series default
If an action event 
\begin_inset Formula $i$
\end_inset

 is enabled by an outcome event 
\begin_inset Formula $j$
\end_inset

 produced by another agent, the agent performing 
\begin_inset Formula $i$
\end_inset

 must be able to observe the occurrence of 
\begin_inset Formula $j$
\end_inset

.
 Otherwise, it has no way of synchronizing its actions with those of its
 teammate.
 Let 
\begin_inset Formula $actor(i)$
\end_inset

 be the agent responsible for performing an action event 
\begin_inset Formula $i$
\end_inset

, then we require that:
\begin_inset Formula \[
\forall j\in ens(i):\,\,\gamma(j)[actor(i)]\neq\{\}\]

\end_inset


\end_layout

\begin_layout Standard
If this restriction cannot be met, then the agents have no way of synchronizing
 their actions.
 Construction of the joint execution must therefore fail.
\end_layout

\begin_layout Standard

\series bold
(R5) Overlapping views enable identical actions:
\newline

\series default
There must be no confusion about whether a particular action is enabled
 at any point during execution.
 Lifting the function 
\begin_inset Formula $view$
\end_inset

 to operate on sets of histories, then:
\begin_inset Formula \[
view(actor(i),\, hists(ens(i)))\]

\end_inset

 gives the set of all local histories after which 
\begin_inset Formula $actor(i)$
\end_inset

 is required to perform the action 
\begin_inset Formula $\gamma(i)$
\end_inset

.
 Since the agent has only a local viewpoint, it is possible that some other
 outcome set can produce an identical view.
 Say that two outcome sets overlap, denoted 
\begin_inset Formula $ovlaps(agt,e_{1},e_{2})$
\end_inset

, if they could produce an identical local history for a given agent:
\begin_inset Formula \[
view(agt,hists(e_{1}))\,\cap\, view(agt,hists(e_{2}))\,\neq\varnothing\]

\end_inset


\end_layout

\begin_layout Standard
Then the 
\emph on
minimal overlapping set
\emph default
 for 
\begin_inset Formula $e_{1}$
\end_inset

, from the perspective of 
\begin_inset Formula $agt$
\end_inset

, is the set of all 
\begin_inset Formula $e_{2}$
\end_inset

 satisfying:
\begin_inset Formula \begin{multline*}
e_{2}\in minovlp(agt,e_{1})\,\equiv\\
ovlaps(agt,e_{1},e_{2})\wedge\neg\exists e_{3}\left[ovlaps(agt,e_{1},e_{3})\wedge e_{3}\sqsubset e_{2}\right]\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
This captures all outcome sets that the agent could potentially confuse
 for 
\begin_inset Formula $e_{1}$
\end_inset

.
 To ensure there is no confusion about whether an action is enabled, for
 each 
\begin_inset Formula $i\in\mathcal{A}$
\end_inset

, every 
\begin_inset Formula $e$
\end_inset

 in the minimal overlapping set of 
\begin_inset Formula $ens(i)$
\end_inset

 for 
\begin_inset Formula $actor(i)$
\end_inset

 must enable an event 
\begin_inset Formula $i'$
\end_inset

 with identical action 
\begin_inset Formula $\gamma(i')=\gamma(a)$
\end_inset

.
 Formally:
\begin_inset Formula \begin{multline*}
\forall e\in minovlp(actor(i),ens(i)):\,\\
\exists i':\,\gamma(i')=\gamma(i)\,\wedge\, ens(i')=e\end{multline*}

\end_inset

 This ensures that the agent's local information is enough to know when
 it should perform an action.
 While it may not know precisely which 
\emph on
event
\emph default
 is enabled, it will know enough to determine the specific 
\emph on
action
\emph default
 that it must perform.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "97col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard

\family sans
\series bold
\size tiny
\begin_inset Include \include{listings/plan.tex}
preview false

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Joint execution for 
\begin_inset Formula $MakeSalad(bowl(1))$
\end_inset

, showing significant concurrency between agents
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:plan-output"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Planning with Joint Executions
\end_layout

\begin_layout Standard
Our ConGolog execution planner
\begin_inset Foot
status collapsed

\begin_layout Standard
available at [identifying information omitted]
\end_layout

\end_inset

 is implemented using the Mozart/Oz programming system rather than the tradition
al use of Prolog 
\begin_inset LatexCommand cite
key "vanroy99mozart"

\end_inset

.
 Figure 
\begin_inset LatexCommand ref
reference "fig:plan-output"

\end_inset

 shows the output our system produces for the 
\begin_inset Formula $MakeSalad$
\end_inset

 example of figure 
\begin_inset LatexCommand ref
reference "fig:makesalad-program"

\end_inset

.
 Since all actions in this program have a single outcome, the outcome events
 have been suppressed.
\end_layout

\begin_layout Standard
In this domain there are three agents but only two knives, so the agents
 must synchronize their use of these resources.
 Actions are independent if they deal with different objects.
 As seen in figure 
\begin_inset LatexCommand ref
reference "fig:plan-output"

\end_inset

, the use of a partial order structure facilitates concurrency between the
 agents, with each processing a different ingredient and only synchronizing
 on the availability of resources.
 There is no need for actions such as 
\begin_inset Formula $mix$
\end_inset

 and 
\begin_inset Formula $chop$
\end_inset

 to be public.
 This execution is maximally concurrent given the constraints of the domain,
 and is clearly a significant improvement over totally ordered sequences
 of actions as produced by existing systems.
\end_layout

\begin_layout Standard
Our main planning loop is very similar to the planning loop for existing
 ConGolog systems.
 It searches for a legal execution one program step at a time, but builds
 up a joint execution instead of situation terms.
 A significant advantage of remaining close to existing situation calculus
 techniques is that our planner remains a straightforward logic program.
 As demonstrated in 
\begin_inset LatexCommand cite
key "kelly06hlp_dps_anon"

\end_inset

, the parallel search capabilities of Mozart/Oz allow the team of agents
 to transparently share the workload of solving this logic program, allowing
 them to cooperate in both planning and performing the execution of their
 shared control program.
 See the source download for full details.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Related and Future Work
\end_layout

\begin_layout Standard
A shared ConGolog program is used with considerable success in 
\begin_inset LatexCommand cite
key "Ferrein2005readylog"

\end_inset

 to coordinate and control a RoboCup soccer team.
 In their target domain all actions are public, so totally ordered plans
 can be used.
 The techniques developed in this paper would generalize such an approach
 to a wider variety of domains (although their work includes decision theoretic
 aspects not considered here).
\end_layout

\begin_layout Standard
There is also significant work using the situation calculus for agents with
 individual control programs 
\begin_inset LatexCommand cite
key "shapiro02casl"

\end_inset

.
 The behavior of the whole system is specified as the concurrent combination
 of individual programs, and ConGolog is used to verify aspects of the behavior.
 This cannot handle partial observability of actions since all reasoning
 is based on a full situation term.
 Joint executions could be used to overcome this limitation.
\end_layout

\begin_layout Standard
An alternate approach to handling partial observability is the language
 TeamGolog developed in 
\begin_inset LatexCommand cite
key "farinelli07team_golog"

\end_inset

, where agents explicitly synchronize through communication and a shared
 state.
 By contrast, our approach constructs synchronization implicitly using the
 actions observed by each agent.
 This has the advantage of requiring no changes to the form or semantics
 of the agents' control program, but the disadvantage that joint execution
 construction may fail if too few actions are observable.
 It would be interesting to combine the approaches, using communication
 when implicit synchronization is impossible.
\end_layout

\begin_layout Standard
Several authors have introduced explicit partial-order operators into the
 ConGolog language itself, for example 
\begin_inset LatexCommand cite
key "son00htn_golog"

\end_inset

.
 While this is useful for specifying behavior, the 
\emph on
output
\emph default
 from such systems is still a totally ordered sequence of actions.
 They thus maintain the limitations of existing systems when executing in
 a multi-agent setting.
\end_layout

\begin_layout Standard
There is, of course, an extensive body of work using partial orders for
 goal-based planning.
 Our joint executions have deep similarities to the structures used in condition
al partial-order planners, but are intentionally specific to the situation
 calculus.
 We neglect common concepts from this field (e.g.
 threats, conflicts) because we do not deal explicitly with goals, but with
 single steps of execution.
 Our approach is roughly equivalent to 
\emph on
deordering
\emph default
 a totally-ordered plan 
\begin_inset LatexCommand cite
key "backstrom99reordering"

\end_inset

, but performed during plan construction rather than as a post-processing
 step.
\end_layout

\begin_layout Standard
While this paper considers only offline construction of a joint execution,
 IndiGolog 
\begin_inset LatexCommand cite
key "giacomo99indigolog"

\end_inset

 allows interleaving planning with steps of execution.
 Extending this technique a team of agents is difficult, as each may have
 different knowledge about the state of execution.
 We are developing an approach based on the epistemic reasoning techniques
 of 
\begin_inset LatexCommand cite
key "kelly07sc_know_obs"

\end_inset

.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
In this paper, we have demonstrated that an apparently fundamental limitation
 of the situation calculus - the need for a totally-ordered history of actions
 - can be overcome using a restricted prime event structure which we call
 a 
\emph on
joint execution
\emph default
.
 We contend that such structures are highly suitable for planning the actions
 to be performed by a team in service of some shared task, such as executing
 a shared ConGolog program.
 
\end_layout

\begin_layout Standard
On one hand, joint executions are restricted enough to be practical for
 such use.
 Like the totally-ordered structures used in previous approaches, prime
 event structures can be executed without further deliberation.
 They are restricted to ensure that whenever an agent is required to perform
 an action, it is able to determine this using only its local information.
 Each branch of execution can be easily converted into a situation or history
 term for the purposes of reasoning, and can easily be extended one action
 at a time.
\end_layout

\begin_layout Standard
Joint executions are also significantly more flexible than previous approaches.
 They allow independent actions to be performed without synchronization,
 in any order.
 The agents need never know precisely what actions have been executed, only
 those that enable them to perform their next action.
 Synchronization is automatically achieved when required by explicitly reasoning
 about what actions each agent can observe, rather than requiring that all
 actions be public.
\end_layout

\begin_layout Standard
The utility of these structures has been demonstrated by implementing a
 system that constructs a joint execution for a shared ConGolog program,
 distributing the planning workload between the agents in the team.
 Once a valid joint execution is found, the team is guaranteed to be able
 to execute it in the world without further deliberation and without explicit
 synchronization between the agents, in spite of asynchronicity and partial
 observability of actions.
\end_layout

\begin_layout Standard
Our approach thus facilitates the use of the situation calculus, and powerful
 non-deterministic programming techniques such as ConGolog, for multi-agent
 problem solving tasks in richer, more realistic domains.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "aaai"
bibfiles "/storage/uni/pgrad/library/references"

\end_inset


\end_layout

\end_body
\end_document
