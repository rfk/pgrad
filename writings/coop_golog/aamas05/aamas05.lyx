#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass sig-alternate
\language english
\inputencoding default
\fontscheme default
\graphics default
\float_placement hbt
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Standard


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
conferenceinfo{AAMAS'06,} {TODO: Date And Place Go Here}
\layout Standard

\backslash 
CopyrightYear{2005}
\layout Standard

\backslash 
crdata{1-59593-057-4/05/0004}
\layout Standard

\backslash 
title{High-Level Program Execution for Multi-Agent Teams}
\layout Standard

\backslash 
numberofauthors{1}
\layout Standard

\backslash 
author{  
\backslash 
alignauthor Ryan Kelly
\backslash 
titlenote{Currently a postgraduate student at the University of Melbourne} and Adrian Pearce
\backslash 

\backslash 
 
\backslash 
affaddr{Department of Computer Science and Software Engineering}
\backslash 

\backslash 
 
\backslash 
affaddr{The University of Melbourne}
\backslash 

\backslash 
 
\backslash 
affaddr{Parkville, Victoria, 3052, Australia}
\backslash 

\backslash 
 
\backslash 
email{
\backslash 
{rfk, pearce
\backslash 
}@cs.mu.oz.au} }
\layout Standard

\backslash 
maketitle
\layout Standard

\end_inset 


\layout Abstract

In this paper we robustly combine several extensions to the agent programming
 language Golog to represent programs for multiagent teams.
 These include combining true concurrency of actions with the interleaved
 concurrency of ConGolog, incorporating an explicit notion of time to give
 a richer world model and aid in coordination, and tightly integrating the
 concept of natural actions to predict the behavior of the environment.
 An implementation using the programming language Mozart is described, and
 we demonstrate its effectiveness as a centralised multiagent planner and
 a method for distributed execution.
 
\layout Abstract

The concept of high-level program execution, as embodied by Golog, has recently
 arisen as a practical alternative to traditional planning for single-agent
 systems.
 When a team of agents must cooperate closely in order to achieve some shared
 goal, they can often be conceptualised as a single agent with distributed
 sensing, reasoning and acting capabilities.
 Behaviors and goals are naturally ascribed to the team rather than to individua
l members.
 This suggests that high-level program execution can also provide an attractive
 alternative to team planning.
\layout Abstract


\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
category{I.2.11}{Artificial Intelligence}{Distributed Artificial Intelligence}[Multiagent systems] 
\backslash 
category{I.2.8}{Artificial Intelligence}{Problem Solving, Control Methods, and Search} 
\layout Standard

\backslash 
keywords{Agent programming languages, Cooperative distributed problem solving in agent systems, Multi-agent planning}
\layout Standard

\end_inset 


\layout Section

Introduction
\layout Standard

As described in 
\begin_inset LatexCommand \cite{lesperance2000_igl_ext,Levesque98beyondplanning}

\end_inset 

, 
\emph on 
high-level program execution
\emph default 
 is emerging as a practical alternative to traditional plan synthesis.
 By 
\begin_inset Quotes eld
\end_inset 

high-level program
\begin_inset Quotes erd
\end_inset 

 is meant a program whose primitive operations are domain-specific actions,
 and which may be incompletely specified due to nondeterministic constructs.
 Rather than a planner finding a sequence of actions leading from an initial
 state to a state in which some goals are achieved, the task is instead
 to find a sequence of actions which constitute an instance of this program.
\layout Standard

This task can range from executing a fully-specified program to synthesising
 an action sequence from a completely nondeterministic program.
 It thus subsumes both deterministic agent programming and traditional planning.
 The primary advantage of this approach is 
\emph on 
controlled nondeterminism
\emph default 
, allowing some aspects of the program to remain unspecified while avoiding
 an exponential increase in planning difficulty for large programs.
 This method of agent control is epitomised by the Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

 family of programming languages, which have provided the following benefits
 for single-agent programming:
\layout Itemize

Ability to control the amount of nondeterminism
\layout Itemize

Programs can incorporate sophisticated symbolic reasoning about the world
\layout Itemize

Formal verification of program properties, in some cases using automated
 tools
\layout Standard

Systems involving multiple autonomous agents can be classified into two
 subtypes
\begin_inset LatexCommand \cite{durfee05ma_plan_coordination}

\end_inset 

 - 
\begin_inset Quotes eld
\end_inset 

open multiagent systems
\begin_inset Quotes erd
\end_inset 

 in which agent behaviors are loosely coupled, and 
\begin_inset Quotes eld
\end_inset 

multiagent teams
\begin_inset Quotes erd
\end_inset 

 in which the agents depend intimately on one another for the accomplishment
 of a shared task.
 From a programming viewpoint, open multiagent systems are typically constructed
 by specifying the behavior and goals of individual agents and using communicati
on primitives to design interaction between agents.
 This approach can also be taken with multiagent teams.
\layout Standard

For tightly-coupled teams it may be more convenient to conceptualise the
 team as a single agent with distributed sensing, reasoning and acting abilities
, and ascribe behaviors and goals to the team as a whole.
 This suggests that high-level program execution may also provide an attractive
 alternative to team planning, providing the benefits described above to
 applications involving multiagent teams.
\layout Standard

Pursuant to this goal, we combine several existing extensions to the Golog
 language to make it suitable for representing multiagent teams.
 Key among these is the notion of true concurrency of actions, which we
 combine with the account of interleaved concurrency found in the language
 ConGolog
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 to give a flexible model for concurrent execution.
 An explicit notion of time is incorporated, both to allow this to be included
 in models of the world and to assist in coordination between agents.
 The well-known concept of natural actions is also tightly integrated into
 the semantics of the language, to allow agents to predict the behavior
 of their environment without additional burden for the programmer.
\layout Standard

Versions of this language have been implemented in CIAO Prolog 
\begin_inset LatexCommand \cite{ciao-reference-manual-tr}

\end_inset 

 and Mozart 
\begin_inset LatexCommand \cite{vanroy99mozart}

\end_inset 

 to facilitate our research.
 Using the distributed computing capabilities of Mozart, we show how the
 combined resources of all agents in the team may be utilised during the
 planning process.
\layout Standard

The contributions of this paper are thus: to motivate high-level program
 execution as a problem-solving paradigm for multiagent teams, to robustly
 combine several existing extensions to the Golog language into a semantics
 suitable for describing multiagent teams, to describe a concrete implementation
 of this language and to demonstrate its effectiveness both as a centralised
 multiagent planner and a method for distributed execution.
\layout Standard

The remainder of the paper is structured as follows.
 Section 
\begin_inset LatexCommand \ref{sec:Background}

\end_inset 

 describes the Golog family of languages and their underlying formalism
 the situation calculus, and introduces a running example to be used throughout
 the paper.
 In section 
\begin_inset LatexCommand \ref{sec:Language-Features}

\end_inset 

 we present and combine extensions to Golog which offer capabilities useful
 for describing multiagent teams, while section 
\begin_inset LatexCommand \ref{sec:Langauge-Semantics}

\end_inset 

 details the formal semantics and demonstrates that it has some important
 properties.
 Section 
\begin_inset LatexCommand \ref{sec:Language-Execution}

\end_inset 

 describes our implementation with examples of its operation.
 Finally, section 
\begin_inset LatexCommand \ref{sec:Other-Work}

\end_inset 

 places this work in the wider context of multiagent systems and existing
 Golog implementations (such as ConGolog and IndiGolog) while section 
\begin_inset LatexCommand \ref{sec:Conclusions-and-Future}

\end_inset 

 presents our conclusions and ideas for future research.
 
\layout Section

Background
\layout Standard


\begin_inset LatexCommand \label{sec:Background}

\end_inset 


\layout Subsection

Example: The Cooking Agents
\layout Standard

In order to explore this topic in a concrete way, a running example is introduce
d and investigated throughout the paper: the 
\begin_inset Quotes eld
\end_inset 

Cooking Agents
\begin_inset Quotes erd
\end_inset 

 domain.
 In this domain, several robotic chefs inhabit a kitchen which they share
 with inanimate objects such as various ingredients, appliances and utensils.
 The agents must cooperate to produce a meal consisting of several dishes.
\layout Standard

This example is particularly suitable because tightly-coupled cooperation
 will be of benefit, rather than assigning specific tasks to specific agents
 and potentially leaving some agents idle.
 It contains several challenges common to a wide variety of multiagent settings,
 such as contention for shared resources and scheduling timing and scheduling
 constraints.
 It also involves large amounts of procedural knowledge in the form of recipes,
 highlighting the benefits high-level program execution for specifying procedura
l knowledge.
\layout Standard

The domain also embodies several assumptions which reduce the complexity
 of this initial investigation.
 It may be idealised as being completely deterministic and fully observable.
 The agents are also in close proximity allowing complete and reliable communica
tion.
\layout Subsection

The Situation Calculus
\layout Standard

The situation calculus is a first order logic formalism for representing
 and reasoning about dynamic worlds.
 While its concepts remain largely unchanged since its inception, the accompanyi
ng notation has evolved somewhat.
 The notation presented here is that of 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

.
\layout Standard

A representation of a dynamic world in the situation calculus consists of
 first-order logic statements capturing the following:
\layout Itemize

Actions that can be performed in the world
\layout Itemize

Fluents that describe the state of the world
\layout Itemize

Action precondition axioms, one for each action
\layout Itemize

Successor state axioms, one for each fluent
\layout Itemize

Axioms describing the initial world situation
\layout Itemize

The foundational axioms of the situation calculus
\layout Standard

Only an overview of these concepts is presented here.
 A detailed treatment may be found in 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

.
\layout Standard


\emph on 
Actions
\emph default 
 are literals in the logic representing the ways in which the world can
 be changed, and are taken to be instantaneous.
 The 
\begin_inset Quotes eld
\end_inset 

state of the world
\begin_inset Quotes erd
\end_inset 

 is represented as a 
\emph on 
situation
\emph default 
, which is the history of actions that have been performed so far, with
 the initial situation represented by the term 
\begin_inset Formula $S_{0}$
\end_inset 

.
 Terms representing other situations are constructed using the function
 
\begin_inset Formula $do(a,s)$
\end_inset 

 which gives the situation resulting from performing action 
\begin_inset Formula $a$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

.
\layout Standard

In this paper, all actions have as their first argument the name of the
 agent performing them.
 For example, the agent 
\begin_inset Formula $Thomas$
\end_inset 

 may perform the action of placing an egg in a bowl, represented as
\begin_inset Foot
collapsed true

\layout Standard

We follow the convention that uppercase terms refer to ground instances,
 while lowercase terms are implicitly universally quantified.
 
\end_inset 

:
\layout Standard


\begin_inset Formula \[
place\_ in(Thomas,Egg,Bowl)\]

\end_inset 


\layout Standard

If this is the first action performed in the world, the new situation becomes:
\layout Standard


\begin_inset Formula \[
do(place\_ in(Thomas,Egg,Bowl),S_{0})\]

\end_inset 


\layout Standard

Properties of the world are described by 
\emph on 
fluents
\emph default 
, which are functions or predicates taking a situation as their final argument.
 For example, the fact that agent 
\begin_inset Formula $Richard$
\end_inset 

 has possession of a knife in some situation 
\begin_inset Formula $S$
\end_inset 

 might be represented as:
\layout Standard


\begin_inset Formula \[
has\_ object(Richard,Knife,S)\]

\end_inset 


\layout Standard

Action precondition axioms are given in terms of 
\emph on 
possibility predicates
\emph default 
, which specify when it is possible for a given action to be performed.
 To state that an agent may only place an object in a bowl when they have
 possession of that bowl, the following possibility fluent could be used:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
\forall agt,obj,s.\left[Poss(place\_ in(agt,obj,Bowl),s)\right.\\
\left.\leftrightarrow has\_ object(agt,Bowl,s)\right]\end{array}\]

\end_inset 


\layout Standard

The truth values of fluents are specified in two parts.
 First, one must define what is true of the initial situation, such as the
 following statement that no agents possess any objects initially:
\layout Standard


\begin_inset Formula \[
\forall agt.\left[\neg\exists obj.\left(has\_ object(agt,obj,S_{0})\right)\right]\]

\end_inset 


\layout Standard

The effects of various actions are collected into successor state axioms,
 which state that a fluent is true if something caused it to be true, or
 it was previously true and nothing caused it to be false.
 They have the general form:
\layout Standard


\begin_inset Formula \[
f(\overrightarrow{x},do(a,s))\leftrightarrow\Gamma^{+}(\overrightarrow{x},a)\vee f(\overrightarrow{x},s)\wedge\neg\Gamma^{-}(\overrightarrow{x},a)\]

\end_inset 


\layout Subsection

Golog
\layout Standard

Golog is a declarative agent programming language based on the situation
 calculus, developed by Levesque et.
 al 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset 

.
 Testimony to its success are its wide range of applications (see, for example,
 
\begin_inset LatexCommand \cite{Levesque98beyondplanning,Ferrein2005readylog}

\end_inset 

 ) and many extensions to provide additional functionality (such as ConGolog
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

, DTGolog
\begin_inset LatexCommand \cite{boutilier00dtgolog}

\end_inset 

, and IndiGolog
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset 

).
 In this paper we use the term 
\begin_inset Quotes eld
\end_inset 

Golog
\begin_inset Quotes erd
\end_inset 

 to refer to the family of languages based on this technique.
\layout Standard

To program an agent using Golog one specifies an axiomatisation of the agent's
 world in the situation calculus, and a program consisting of actions from
 the world connected using programming constructs such as if-then-else,
 while loops, and nondeterministic choice.
 Table 
\begin_inset LatexCommand \ref{tbl:Golog-Operators}

\end_inset 

 lists some of the operators available from various incarnations of the
 language.
\layout Standard


\begin_inset Float table
wide false
collapsed true

\layout Caption

Golog Operators
\begin_inset LatexCommand \label{tbl:Golog-Operators}

\end_inset 


\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="15" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard

Operator
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Meaning
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $nil$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Empty program
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $a$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Execute action 
\begin_inset Formula $a$
\end_inset 

 in the world
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\phi?$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Proceed only if condition 
\begin_inset Formula $\phi$
\end_inset 

 is true
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\delta_{1};\delta_{2}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Execute program 
\begin_inset Formula $\delta_{1}$
\end_inset 

followed by 
\begin_inset Formula $\delta_{2}$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\delta_{1}|\delta_{2}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Execute either 
\begin_inset Formula $\delta_{1}$
\end_inset 

 or 
\begin_inset Formula $\delta_{2}$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\pi(x)\delta(x)$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Nondet.
 select arguments for 
\begin_inset Formula $\delta$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\delta*$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Execute 
\begin_inset Formula $\delta$
\end_inset 

 zero or more times
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\mathbf{if}\phi\mathbf{then}\delta_{1}\mathbf{else}\delta_{2}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Exec.
 
\begin_inset Formula $\delta_{1}$
\end_inset 

 if 
\begin_inset Formula $\phi$
\end_inset 

 holds, 
\begin_inset Formula $\delta_{2}$
\end_inset 

 otherwise
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\mathbf{while}\phi\mathbf{do}\delta$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Execute 
\begin_inset Formula $\delta$
\end_inset 

 while 
\begin_inset Formula $\phi$
\end_inset 

 holds
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Concurrently execute 
\begin_inset Formula $\delta_{1}$
\end_inset 

and 
\begin_inset Formula $\delta_{2}$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\delta_{1}\gg\delta_{2}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Conc.
 exec.
 
\begin_inset Formula $\delta_{1}$
\end_inset 

 prioritised over 
\begin_inset Formula $\delta_{2}$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\delta^{||}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Conc.
 exec.
 
\begin_inset Formula $\delta$
\end_inset 

 zero or more times
\end_inset 
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\Sigma\delta$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Find and perform legal exec.
 of 
\begin_inset Formula $\delta$
\end_inset 


\end_inset 
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\begin_inset Formula $\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$
\end_inset 


\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Procedure definition
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_inset 


\layout Standard

In line with the idea of high-level program execution, the agent's control
 program is nondeterministic.
 It is the task of the agent to find a deterministic instantiation of the
 program, a sequence of actions that can be performed in the world.
 Such a sequence is called a 
\begin_inset Quotes eld
\end_inset 

legal execution
\begin_inset Quotes erd
\end_inset 

 of the Golog program.
\layout Standard

The original Golog was conceived as on offline planner - the agent would
 determine a complete execution of the program before any actions were performed
 in the world.
 While this guarantees that a legal execution will be found if present,
 it can be impractical for large programs and cannot account for unexpected
 occurrences or information obtained from run-time sensing.
 An alternative is online execution, where nondeterministic choices become
 arbitrary choices and are committed to immediately.
 This notion was formalised in the extension IndiGolog
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset 

, which introduced a search operator to allow offline planning to be conducted
 over specific parts of the program.
\layout Standard

The semantics of the Golog operators are typically defined recursively using
 logical formulae.
 The most flexible semantics have proven to be the transition semantics
 introduced with the extension ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 to allow concurrent execution of several programs.
 Two predicates 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

 are defined for each operator.
 Intuitively, 
\begin_inset Formula $Trans(\delta,s,\delta',s')$
\end_inset 

 is true precisely when executing a single step of program 
\begin_inset Formula $\delta$
\end_inset 

 can cause the world to move from situation 
\begin_inset Formula $s$
\end_inset 

 to situation 
\begin_inset Formula $s'$
\end_inset 

, after which 
\begin_inset Formula $\delta'$
\end_inset 

 remains to be executed.
 It thus specifies single steps of computation of the program 
\begin_inset Formula $\delta$
\end_inset 

.
 
\begin_inset Formula $Final(\delta,s)$
\end_inset 

 is true when program 
\begin_inset Formula $\delta$
\end_inset 

 may legally terminate its execution in situation 
\begin_inset Formula $s$
\end_inset 

.
 Finding a legal execution then consists of proving that 
\begin_inset Formula $\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]$
\end_inset 

, where 
\begin_inset Formula $Trans*$
\end_inset 

 is the reflexive transitive closure of 
\begin_inset Formula $Trans$
\end_inset 

.
\layout Section

Language Features
\layout Standard


\begin_inset LatexCommand \label{sec:Language-Features}

\end_inset 


\layout Standard

A multiagent setting poses several challenges for the situation calculus
 and Golog.
 It should allow the programmer to represent the following aspects of the
 system, each of which are described using examples from the Cooking Agents
 domain:
\layout Itemize


\series bold 
Time
\series default 
: Some tasks in the cooking domain may require an explicit notion of time.
 For example, a cake must be baked for 30 minutes before being removed from
 the oven.
 Explicit time also makes coordination between agents easier, as they may
 arrange to perform joint actions at a particular time.
\layout Itemize


\series bold 
Natural Actions
\series default 
: These are predictable actions which occur outside of the agent's control.
 If an agent sets a timer then it will ring at the appropriate time without
 intervention from any agent.
 Natural actions should incorporate easily into the program.
\layout Itemize


\series bold 
Concurrency
\series default 
: Several agents are capable of acting at the same time, meaning several
 primitive actions can occur simultaneously.
 They must also be able to perform tasks concurrently, such as preparing
 several parts of a meal at once.
\layout Itemize


\series bold 
Shared Resources
\series default 
: The agents will face contention for limited physical resources such as
 the oven, mixing bowls and chopping boards.
\layout Itemize


\series bold 
Continuous Processes
\series default 
: Agents are required to perform actions with some finite duration, such
 as mixing ingredients for a specified time.
\layout Standard

While other aspects may also be important for some domains, the above are
 sufficient for the scenarios considered here.
 Many of these concepts have been independently addressed in Golog and the
 situation calculus.
 They will be systematically examined and combined in the following sections.
\layout Subsection

Time
\layout Standard

There have been several efforts to incorporate a temporal component into
 the situation calculus.
 Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 introduced the functions 
\begin_inset Formula $start(s)$
\end_inset 

 and 
\begin_inset Formula $end(s,a)$
\end_inset 

 which range over the real numbers and give the starting and ending time
 of a situation respectively.
 Reiter 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 simplified this scheme by including within each action an explicit temporal
 argument indicating the time at which it was performed.
 While this is useful when specifying precise times for action occurrences,
 it adds complexity when actions are performed concurrently.
\layout Standard

In work on the related Fluent Calculus, Martin 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset 

 attaches the explicit occurrence time not to actions but to situations,
 an approach which was also adopted for this paper.
 The successor situation function 
\begin_inset Formula $do(a,s)$
\end_inset 

 becomes 
\begin_inset Formula $do(a,t,s)$
\end_inset 

, to indicate 
\begin_inset Quotes eld
\end_inset 

action 
\begin_inset Formula $a$
\end_inset 

 was performed at time 
\begin_inset Formula $t$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 


\begin_inset Quotes erd
\end_inset 

.
 Likewise, the possibility predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset 

 becomes 
\begin_inset Formula $Poss(a,t,s)$
\end_inset 

, meaning 
\begin_inset Quotes eld
\end_inset 

it is possible to perform action 
\begin_inset Formula $a$
\end_inset 

 at time 
\begin_inset Formula $t$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 


\begin_inset Quotes erd
\end_inset 

.
 The function 
\begin_inset Formula $start(s)$
\end_inset 

 is added which gives the starting time of a situation:
\layout Standard


\begin_inset Formula \[
start(do(a,t,s))=t\]

\end_inset 


\layout Standard

Note that the start time of the initial situation is arbitrary, and may
 be defined as required for specific application.
\layout Subsection

Natural Actions
\layout Standard

Natural actions are a special class of exogenous actions, those actions
 which occur outside of the agent's control.
 Introduced to the situation calculus by Pinto 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

 and expanded by Reiter 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

, they are classified according to the following requirement: natural actions
 are exogenous actions which must occur at their predicted times, provided
 no earlier actions prevent them from occurring.
 For example, the action of a ball bouncing when it reaches the ground is
 a natural action, which may be prevented by catching the ball.
\layout Standard

The methodology of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 is adopted, suitably modified for the additional extensions of this paper.
 Natural actions are indicated by the predicate 
\begin_inset Formula $natural(a)$
\end_inset 

, which is true precisely when 
\begin_inset Formula $a$
\end_inset 

 is a natural action.
 The times at which natural actions may occur are specified by the 
\begin_inset Formula $Poss$
\end_inset 

 predicate, as with agent-initiated actions.
 For example, suppose that the following fluent represents the fact that
 a timer identified by 
\begin_inset Formula $ID$
\end_inset 

 is set to ring in 10 minutes in the situation 
\begin_inset Formula $S$
\end_inset 

:
\layout Standard


\begin_inset Formula \[
timer\_ set(ID,10,S)\]

\end_inset 


\layout Standard

The possibility predicate for the 
\begin_inset Formula $ring\_ timer(ID)$
\end_inset 

 action could then be given as:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
Poss(ring\_ timer(ID),t,s)\leftrightarrow\\
\exists m.\left[timer\_ set(ID,m,s)\wedge t=start(s)+m\right]\end{array}\]

\end_inset 


\layout Standard

An important concept when dealing with natural actions it the least natural
 time point (LNTP) of a situation.
 This is defined as the earliest time at which a natural action may occur
 in a situation:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
lntp(s,t)\leftrightarrow\exists a\left[natural(a)\wedge Poss(a,t,s)\right]\wedge\\
\forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]\end{array}\]

\end_inset 


\layout Standard

Note that the LNTP need not exist for a given situation.
 To enforce the requirement that natural actions must occur provided nothing
 prevents them, a predicate 
\begin_inset Formula $legal(s)$
\end_inset 

 is introduced which is true only for situations which respect this requirement
 (assuming no precondition interaction among natural actions):
\layout Standard


\begin_inset Formula \[
legal(S_{0})\leftrightarrow True\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\begin{array}{cc}
legal(do(c,t,s))\leftrightarrow & legal(s)\wedge Poss(c,t,s)\wedge\\
 & start(s)\leq t\wedge\\
 & (\forall a,t_{a}).natural(a)\wedge Poss(a,t_{a},s)\rightarrow\\
 & \left[a\in c\vee t<t_{a}\right]\end{array}\]

\end_inset 


\layout Standard

When utilising natural actions within a Golog program, all legal program
 executions should result in situations for which the 
\begin_inset Formula $legal$
\end_inset 

 predicate is true.
 This can be enforced in the semantics of the language, avoiding the need
 to check it explicitly.
\layout Standard

A single action term represents a valid program, the possible transitions
 for which depend on whether the accompanying situation has a least natural
 time point.
 If not, it is legal to perform the action at any time greater than or equal
 to the start of the situation.
 If there is an LNTP, a legal situation can be produced in one of three
 ways: perform the action before the LNTP, perform it at the LNTP in conjunction
 with the natural actions, or perform the natural actions first.
 This is captured by the following transition rule:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
Trans(c,s,\delta',s')\leftarrow\\
\\\exists t_{n}.\left\{ lntp(s,t_{n})\wedge\right.\\
\left[\exists t.t\geq start(s)\wedge t<t_{n}\wedge Poss(c,t,s)\wedge\right.\\
\left.s'=do(c,t,s)\wedge\delta'=nil\right]\\
\vee\\
\exists cn.\left(\forall a.natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in cn\right)\wedge\\
\left[poss(c\cup cn,t_{n},s)\wedge s'=do(c\cup cn,t_{n},s)\wedge\delta'=nil\right.\\
\vee\\
\left.\left.s'=do(cn,t_{n},s)\wedge\delta'=c\right]\right\} \\
\vee\\
\neg\exists t_{n}.lntp(s,t_{n})\wedge\exists t.\left[Poss(c,t,s)\wedge\right.\\
\left.t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\end{array}\]

\end_inset 


\layout Standard

Using this formulation, natural actions will occur at their predicted times
 without the programmer needing to mention them explicitly.
 If natural actions are included in the program, they will performed only
 at their predicted time.
 A proof of this is offered in section 
\begin_inset LatexCommand \ref{sub:Properties-of-the-semantics}

\end_inset 

.
\layout Standard

While time and natural actions in Golog have previously been utilised as
 a planning tool 
\begin_inset LatexCommand \cite{pirri00planning_nat_acts}

\end_inset 

, the programmer was required to explicitly check for the possible occurance
 of natural actions and ensure that executions of the program resulted in
 legal situations.
 Out integration significantly lowers the burden on the programmer by providing
 the ability to predict the behavior of the environment, while guaranteeing
 that all program executions produce legal situations.
\layout Subsection

Concurrency
\layout Standard

Concurrency is one of the defining attributes of multiagent systems.
 In the context of the situation calculus and Golog, it refers to two distinct
 ideas - the possibility of having several primitive actions performed at
 the same instance, and the possibility of simultaneously executing several
 high-level programs.
\layout Standard

The notion of concurrently executing multiple high-level programs is given
 an in-depth treatment in 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset 

 with the development of ConGolog.
 We refer to this approach as 
\emph on 
interleaved concurrency
\emph default 
 as individual actions from each program are interleaved to provide concurrent
 execution.
\layout Standard

The work of 
\begin_inset LatexCommand \cite{lin92sc_conc,reiter96sc_nat_conc}

\end_inset 

 provides an extension to the situation calculus to allow several primitive
 actions to occur at the same time.
 We refer to this as 
\emph on 
true concurrency
\emph default 
 as many actions occur at the same instant.
 Primitive action terms are replaced with sets of actions to be performed
 concurrently.
 All functions and predicates that take an action are modified to accept
 sets of actions instead:
\layout Standard


\begin_inset Formula \[
do(\{ a_{1},a_{2},...\},t,s)\]

\end_inset 


\begin_inset Formula \[
Poss(\{ a_{1},a_{2},...\},t,s)\]

\end_inset 


\layout Standard

Throughout the remainder of the paper, the variables 
\begin_inset Formula $c$
\end_inset 

, 
\begin_inset Formula $c_{1}$
\end_inset 

, etc will be used to refer to sets of concurrently performed actions.
 
\layout Standard

The approach to time used in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset 

 requires a predicate 
\begin_inset Formula $coherent(c)$
\end_inset 

 to be defined, which is true when the concurrent action 
\begin_inset Formula $c$
\end_inset 

 contains at least one action and all actions occur at the same time.
 The approach to time used here ensures that this property is automatically
 satisfied.
 To ensure that program executions do not include empty sets of actions,
 one need only ensure that it is never possible to perform such an empty
 set:
\layout Standard


\begin_inset Formula \[
\forall s,t.\left[Poss(\{\},t,s)\equiv False\right]\]

\end_inset 


\layout Standard

These two concepts of concurrency were combined by Baier and Pinto 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset 

 by modifying ConGolog to incorporate sets of concurrent actions.
 We follow a similar approach below, but place additional restrictions on
 the semantics to ensure that programs are well-behaved.
\layout Standard

Recall that the semantics of a ConGolog program is a transition system based
 on the predicate 
\begin_inset Formula $Trans$
\end_inset 

.
 It is straightforward to modify the transition for primitive actions to
 handle sets of concurrent actions instead.
 However, the fact that several actions can occur simultaneously means that
 the definition of concurrent execution found in ConGolog can be extended.
\layout Standard

The concurrency operator 
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset 

 is intended to mean 
\begin_inset Quotes eld
\end_inset 

execute programs 
\begin_inset Formula $\delta_{1}$
\end_inset 

and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 concurrently
\begin_inset Quotes erd
\end_inset 

.
 In the original transition semantics, this is achieved by accepting a transitio
n from either of the two programs as a transition for the pair:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow\\
\exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s')\\
\vee\\
\exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\end{array}\]

\end_inset 


\layout Standard

In the presence of true concurrency, this is insufficient.
 It may be possible to simultaneously transition both 
\begin_inset Formula $\delta_{1}$
\end_inset 

 and 
\begin_inset Formula $\delta_{2}$
\end_inset 

 by executing actions concurrently, as suggested in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset 

:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow\,\,\,\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\\
Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\wedge\\
Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\\
\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\end{array}\]

\end_inset 


\layout Standard

This approach introduces several complications.
 The first is that the ability to perform actions concurrently leads to
 complications in the possibility axioms.
 While the actions 
\begin_inset Formula $acquire(Thomas,Bowl)$
\end_inset 

 and 
\begin_inset Formula $acquire(Richard,Bowl)$
\end_inset 

 may individual be possible, performing them concurrently clearly is not.
 This is known as the precondition interaction problem and is an area of
 ongoing research 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset 

.
\layout Standard

For the purposes of this domain, precondition interaction is addressed by
 introducing a predicate 
\begin_inset Formula $Conflicts(c,t,s)$
\end_inset 

 which is true when the concurrent actions in 
\begin_inset Formula $c$
\end_inset 

 are in conflict and cannot be performed together.
 The possibility axiom for concurrent actions is then:
\layout Standard


\begin_inset Formula \[
Poss(c,t,s)\leftrightarrow\forall a\left[a\in c\rightarrow Poss(a,t,s)\right]\wedge\neg Conflicts(c,t,s)\]

\end_inset 


\layout Standard

A typical use of this approach is to prevent each agent from performing
 more than one action at a time:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
\exists a_{1},a_{2}\left[a_{1}\in c\wedge a_{2}\in c\wedge actor(a_{1})=actor(a_{2})\right]\\
\rightarrow Conflicts(c,t,s)\end{array}\]

\end_inset 

Since the semantics of (TODO:ref eqn) do not check possibility of the concurrent
 actions, there is no guarantee that the resulting situation is reachable.
 Another issue arises when two programs can legitimately be single-stepped
 by execution of the same action.
 Consider the following programs which add ingredients to a bowl:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
\begin{array}{cc}
\delta_{1}= & place\_ in(Thomas,Flour,Bowl)\,;\\
 & place\_ in(Thomas,Sugar,Bowl)\\
\delta_{2}= & place\_ in(Thomas,Flour,Bowl)\,;\\
 & place\_ in(Thomas,Egg,Bowl)\end{array}\end{array}\]

\end_inset 


\layout Standard

Executing 
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset 

 should result in the bowl containing two units of flour, one unit of sugar
 and an egg.
 However, the semantics of (TODO:ref eqn) allow a transition with 
\begin_inset Formula $c_{1}=c_{2}=place\_ in(Thomas,Flour,Bowl)$
\end_inset 

, resulting in only one unit of flour being added.
 Alternately, consider two programs waiting for a timer to ring (a natural
 action):
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
\begin{array}{cc}
\delta_{1}= & ring\_ timer(OvenTimer)\,;\\
 & acquire(Thomas,Bowl)\\
\delta_{2}= & ring\_ timer(OvenTimer)\,;\\
 & acquire(Richard,Board)\end{array}\end{array}\]

\end_inset 


\layout Standard

Clearly both programs should be allowed to proceed with a single occurance
 of the 
\begin_inset Formula $ring\_ timer$
\end_inset 

 action.
 To enforce this intuitive notion of how programs should behave, concurrent
 execution must not be allowed to transition both programs through the occurance
 of the same agent-initiated action.
 An improved transition rule which takes these factors into account is:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\leftarrow\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\\
Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\wedge\\
Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\\
\forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow natural(a)\right]\wedge\\
Poss(c_{1}\cup c_{2},t,s)\wedge\\
\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\end{array}\]

\end_inset 


\layout Standard

This robust combination of true and interleaved concurrency will allow the
 language to more accurately reflect the concurrency present in multiagent
 teams.
\layout Subsection

Shared Resources
\layout Standard

Contention for shared resources can be addressed in the situation calculus
 by using a notion of resource acquisition and release.
 Before an agent can use a resource, it must acquire exclusive access to
 it.
 Other agents cannot use a resource that has been acquired until it is explicitl
y released.
 This requires no additions to the situation calculus, but is aided by a
 systematic approach.
\layout Standard

We propose a fluent 
\begin_inset Formula $has\_ object(agent,object,s)$
\end_inset 

 which is true when 
\begin_inset Formula $agent$
\end_inset 

 has exclusive use of resource 
\begin_inset Formula $object$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

.
 This is complemented by actions 
\begin_inset Formula $acquire(agent,object)$
\end_inset 

 and 
\begin_inset Formula $release(agent,object)$
\end_inset 

 for resource acquisition and release.
 The possibility predicates for these actions must ensure that previous
 acquisitions are respected:
\layout Standard


\begin_inset Formula \[
Poss(acquire(agt,obj),t,s)\rightarrow\neg\exists a_{2}\left[has\_ object(a_{2},obj,s)\right]\]

\end_inset 


\layout Standard


\begin_inset Formula \[
Poss(release(agt,obj),t,s)\rightarrow has\_ object(agt,obj,s)\]

\end_inset 


\layout Standard

The successor state axioms for 
\begin_inset Formula $has\_ object$
\end_inset 

 must reflect ownership accordingly:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
has\_ object(agt,obj,do(c,t,s))\leftrightarrow\\
acquire(agt,obj)\in c\vee\\
\left[has\_ object(agt,obj,s)\wedge\right.\\
\left.release(agt,obj)\notin c\right]\end{array}\]

\end_inset 


\layout Standard

Finally, the addition of true concurrency means that multiple agents must
 be prevented from acquiring control of a resource at the same time:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
acquire(a_{1},obj)\in c\wedge acquire(a_{2},obj)\in c\\
\wedge a_{1}\neq a_{2}\rightarrow Conflicts(c,t,s)\end{array}\]

\end_inset 


\layout Subsection

Continuous Processes
\layout Standard

Continuous processes can be represented in the situation calculus by associating
 them with a fluent which is true precisely when the process is being performed
 
\begin_inset LatexCommand \cite{pinto94temporal,reiter96sc_nat_conc}

\end_inset 

.
 This is accompanied by two actions, one indicating the start of the process
 and one indicating when it stops.
 For the cooking agents this can be achieved using a general fluent 
\begin_inset Formula $doing\_ task$
\end_inset 

 to indicate that 
\begin_inset Formula $agt$
\end_inset 

 is in the process of doing 
\begin_inset Formula $tsk$
\end_inset 

 in situation 
\begin_inset Formula $s$
\end_inset 

:
\layout Standard


\begin_inset Formula \[
doing\_ task(agt,tsk,s)\]

\end_inset 

 
\layout Standard

It is accompanied by two actions 
\begin_inset Formula $begin\_ task(agt,tsk)$
\end_inset 

 and 
\begin_inset Formula $end\_ task(agt,tsk)$
\end_inset 

:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
Poss(begin\_ task(agt,tsk),t,s)\rightarrow\\
\neg\exists tsk_{2}.doing\_ task(agt,tsk_{2},s)\end{array}\]

\end_inset 


\layout Standard


\begin_inset Formula \[
Poss(end\_ task(agt,tsk),t,s)\rightarrow doing\_ task(agt,tsk,s)\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\begin{array}{c}
doing\_ task(agt,tsk,do(c,t,s))\leftrightarrow\\
begin\_ task(agt,tsk)\in c\vee\\
\left[doing\_ task(agt,tsk,s)\wedge\right.\\
\left.end\_ task(agt,tsk)\notin c\right]\end{array}\]

\end_inset 


\layout Subsection

Example Programs
\layout Standard

Having developed the necessary extensions, we now give some examples of
 programs which could be used in the cooking agents domain.
 One powerful feature of our language is the ability to nondeterministically
 select an agent for a particular task.
 Consider the following procedure for making a simple cake mix in a specified
 container:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
\mathbf{proc}\, MakeCakeMix(dest)\\
\left[\pi(agt)(DoPlaceIn(agt,Egg,dest))\,||\right.\\
\pi(agt)(DoPlaceIn(agt,Flour,dest))\,||\\
\left.\pi(agt)(DoPlaceIn(agt,Sugar,dest))\right]\,;\\
\pi(agt)(acquire(agt,dest)\,;\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, begin\_ task(agt,mix(dest,5))\,;\\
\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, end\_ task(agt,mix(dest,5))\,;\\
\,\,\,\, release(agt,dest))\\
\mathbf{end}\end{array}\]

\end_inset 


\layout Standard

It first requires that each of three ingredients be added to the bowl.
 The concurrency operators allow the order in which they are added to be
 arbitrary, and the nondeterministic choice of argument operator 
\begin_inset Formula $\pi$
\end_inset 

 is used to allow any appriate agent to add each ingredient.
 After the ingredients have been added, they must be mixed for five minutes
 by some agent.
\layout Standard

This procedure can be utilised to define a procedure for actually making
 a cake:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
\mathbf{proc}\, MakeCake()\\
MakeCakeMix(Bowl)\,;\\
\pi(agt)\left[DoPlaceIn(agt,Bowl,Oven)\,;\right.\\
\,\,\,\,\,\,\,\,\,\,\,\left.set\_ timer(agt,OvenTimer,35)\right]\,;\\
\,\, ring\_ timer(OvenTimer)\,;\\
\pi(agt)(DoTransfer(agt,Oven,Bench))\\
\mathbf{end}\end{array}\]

\end_inset 


\layout Standard

This procedure incorporates the natural action 
\begin_inset Formula $ring\_ timer$
\end_inset 

, will block execution of the program until it is predicted to occur.
 Running additional programs concurrently would allow other work to be done
 while waiting for the timer to ring, for example:
\layout Standard


\begin_inset Formula \[
MakeEntree()\,||\, MakeMainMeal()\,||\, MakeCake()\]

\end_inset 


\layout Standard

TODO: show actions performed for a simple example, contrast with ConGolog
\layout Section

Language Semantics
\layout Standard


\begin_inset LatexCommand \label{sec:Langauge-Semantics}

\end_inset 


\layout Subsection

Transition Semantics
\layout Standard

This section shows the modifications that have been made to the semantics
 of IndiGolog to incorporate the extensions outlined above.
 Many operators are defined recursively using combinations of 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

 and thus did not need to be modified - for details on the operators not
 presented here, refer to 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset 

.
\layout Subsubsection

Concurrent Primitive Actions 
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
Trans(c,s,\delta',s')\equiv\\
\\\exists t_{n}.\left[lntp(s,t_{n})\wedge\right.\\
\exists t.t\geq start(s)\wedge t<t_{n}\wedge Poss(c,t,s)\wedge\\
s'=do(c,t,s)\wedge\delta'=nil\\
\vee\\
\exists cn.\left(\forall a.natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in cn\right)\wedge\\
\left[poss(c\cup cn,t_{n},s)\wedge s'=do(c\cup cn,t_{n},s)\wedge\delta'=nil\right.\vee\\
\left.\left.s'=do(cn,t_{n},s)\wedge\delta'=c\right]\right]\\
\vee\\
\neg\exists t_{n}.lntp(s,t_{n})\wedge\exists t.\left[Poss(c,t,s)\wedge\right.\\
\left.t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\end{array}\]

\end_inset 


\layout Subsubsection

Concurrent Execution:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\\
\\\exists\gamma.\delta'=(\gamma||\delta_{2})\wedge Trans(\delta_{1},s,\gamma,s')\\
\vee\\
\exists\gamma.\delta'=(\delta_{1}||\gamma)\wedge Trans(\delta_{2},s,\gamma,s')\\
\vee\\
\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t.Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\wedge\\
Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge\\
\forall a\left[a\in c_{1}\wedge a\in c_{2}\rightarrow natural(a)\right]\wedge\\
Poss(c_{1}\cup c_{2},t,s)\wedge s'=do(c_{1}\cup c_{2},t,s)\end{array}\]

\end_inset 


\layout Subsection

Properties of the Semantics
\begin_inset LatexCommand \label{sub:Properties-of-the-semantics}

\end_inset 


\layout Standard

From the formal semantics presented above, it is possible to prove useful
 properties of the proposed language.
 In particular, weprove that if a program starts in a legal situation, all
 executions of the program will produce legal situations.
\layout Standard

To show this, first notice that only two transition rules directly modify
 the situation term - execution of a primitive action, and concurrent execution.
 All other rules modify the situation term by further use of the 
\begin_inset Formula $Trans$
\end_inset 

 predicate.
 Thus, it suffices to show that these two rules will produce only legal
 situations.
 Recall the definition of 
\begin_inset Formula $legal(s)$
\end_inset 

:
\layout Standard


\begin_inset Formula \[
\begin{array}{cc}
legal(do(c,t,s))\leftrightarrow & legal(s)\wedge Poss(c,t,s)\wedge\\
 & start(s)\leq t\wedge\\
 & (\forall a,t_{a}).natural(a)\wedge Poss(a,t_{a},s)\rightarrow\\
 & \left[a\in c\vee t<t_{a}\right]\end{array}\]

\end_inset 


\layout Standard

Considering the 
\begin_inset Formula $Trans$
\end_inset 

 rule for primitive actions, each of four disjuncts may produce a new situation
 term.
 The first requires that:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
\exists t_{n}.\left[lntp(s,t_{n})\wedge\exists t.\left[t\geq start(s)\wedge t<t_{n}\right.\right.\\
\left.\left.\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=nil\right]\right]\end{array}\]

\end_inset 


\layout Standard

From from it is immediately clear that:
\layout Standard


\begin_inset Formula \[
start(s)\leq t\,\,\,\,\, Poss(c,t,s)\]

\end_inset 


\layout Standard

Using the definition of 
\begin_inset Formula $lntp(s,t_{n})$
\end_inset 

:
\layout Standard


\begin_inset Formula \[
\exists a\left[natural(a)\wedge Poss(a,t_{n},s)\right]\wedge\forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t_{n}\leq t_{a}\right]\]

\end_inset 


\layout Standard

Since 
\begin_inset Formula $t<t_{n}$
\end_inset 

, this gives:
\layout Standard


\begin_inset Formula \[
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow t\leq t_{a}\right]\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow a\in c\vee t\leq t_{a}\right]\]

\end_inset 


\layout Standard

Assuming 
\begin_inset Formula $legal(s)$
\end_inset 

, these conjuncts are sufficient to establish 
\begin_inset Formula $legal(do(c,t,s))$
\end_inset 

.
\layout Standard

The next disjunct requires that:
\layout Standard


\begin_inset Formula \[
\exists t_{n}.\left[lntp(s,t_{n})\wedge\exists cn.\left(\forall a.natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in cn\right)\wedge Poss(c\cup cn,t_{n},s)\wedge s'=do(c\cup cn,t_{n},s)\wedge\delta'=nil\right]\]

\end_inset 


\layout Standard

Using this along with the definition of LNTP, it is clear that:
\layout Standard


\begin_inset Formula \[
Poss(c\cup cn,t_{n},s)\]

\end_inset 


\layout Standard


\begin_inset Formula \[
start(s)\leq t_{n}\]

\end_inset 


\layout Standard


\begin_inset Formula \[
\forall a,t_{a}.\left[natural(a)\wedge Poss(a,t_{n},s)\rightarrow a\in cn\,\,\wedge\,\, natural(a)\wedge Poss(a,t_{a},s)\rightarrow t_{n}\leq t_{a}\right]\]

\end_inset 


\layout Standard

The last of which yields:
\layout Standard


\begin_inset Formula \[
\forall a,t_{a}\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow c\in c\cup cn\vee t_{n}\leq t_{a}\right]\]

\end_inset 


\layout Standard

Again, all conjuncts necessary to prove 
\begin_inset Formula $legal(do(c\cup cn,t_{n},s))$
\end_inset 

 are true.
\layout Standard

Consider then the case of 
\begin_inset Formula $Trans(\delta_{1}||\delta_{2},s,\delta',s')$
\end_inset 

.
 The only part of interest is the conjunction which directly produces a
 modified situation 
\begin_inset Formula $s'=do(c_{1}\cup c_{2},t,s)$
\end_inset 

.
 Assuming that 
\begin_inset Formula $s$
\end_inset 

 is a legal situation and that all other transition rules produce legal
 situations, 
\begin_inset Formula $Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))$
\end_inset 

 and 
\begin_inset Formula $Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))$
\end_inset 

 will produce legal situations 
\begin_inset Formula $do(c_{1},t,s)$
\end_inset 

 and 
\begin_inset Formula $do(c_{2},t,s)$
\end_inset 

.
\layout Standard

From 
\begin_inset Formula $legal(do(c_{1},t,s))$
\end_inset 

 it can be inferred that:
\layout Standard


\begin_inset Formula \[
\begin{array}{c}
legal(s)\,\,\,\,\,\,\,\,\,\, start(s)\leq t\\
(\forall a,t_{a}).\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c_{1}\vee t<t_{a}\right]\right]\end{array}\]

\end_inset 


\layout Standard

This implies that:
\layout Standard


\begin_inset Formula \[
(\forall a,t_{a}).\left[natural(a)\wedge Poss(a,t_{a},s)\rightarrow\left[a\in c_{1}\cup c_{2}\vee t<t_{a}\right]\right]\]

\end_inset 


\layout Standard

The definition of 
\begin_inset Formula $Trans$
\end_inset 

 further requires that:
\layout Standard


\begin_inset Formula \[
Poss(c_{1}\cup c_{2},t,s)\]

\end_inset 


\layout Standard

Thus all four conjuncts necessary prove 
\begin_inset Formula $legal(do(c_{1}\cup c_{2},t,s))$
\end_inset 

 are true, and this rule generates only legal situations.
\layout Standard

TODO: finish this proof and clean it up *a lot*
\layout Standard

TODO: control loop for offline/online execution
\layout Section

Language Execution
\layout Standard


\begin_inset LatexCommand \label{sec:Language-Execution}

\end_inset 


\layout Standard

As the existing languages based on Golog have demonstrated, an interpreter
 can be conviently constructed using a logic programming language such a
 Prolog.
 We have followed the style of 
\begin_inset LatexCommand \cite{giacomo00congolog,giacomo99indigolog}

\end_inset 

, to build interpreters for our language
\begin_inset Foot
collapsed true

\layout Standard

Availabe from the author's website at http://TODO
\end_inset 

 in Eclipse Prolog (TODO:ref), CIAO Prolog (TODO:ref) and Mozart
\begin_inset LatexCommand \cite{vanroy99mozart}

\end_inset 

.
 The Mozart implementation is highlighted in this paper as it provides strong
 support for distributed execution.
\layout Standard

Programs are encoded in Mozart as record terms, with the name of the record
 representing an operator and its fields (TODO: check terminology) the arguments.
 Actions are also encoded as records.
 In line with convention in both Prolog and Mozart, uppercase term now represent
 variables.
 For example, the program:
\layout Standard


\begin_inset Formula \[
\pi(agt)\left[acquire(agt,Bowl);acquire(agt,Knife)\right]\]

\end_inset 


\layout Standard

Is represented as follows:
\layout Standard


\begin_inset Include \verbatiminput{listings/goloz_ex_prog.oz}
preview false

\end_inset 


\layout Standard

The predicates 
\begin_inset Formula $Trans$
\end_inset 

 and 
\begin_inset Formula $Final$
\end_inset 

 have a straightforward encoding as Mozart procedures:
\layout Standard


\begin_inset Include \verbatiminput{listings/goloz_trans.oz}
preview false

\end_inset 


\layout Standard


\begin_inset Include \verbatiminput{listings/goloz_final.oz}
preview false

\end_inset 


\layout Standard

By defining a procedure 
\begin_inset Formula $Do(\delta,s,s')\leftrightarrow Trans*(\delta,s,\delta',s')\wedge Final(\delta',s')$
\end_inset 

 it is possible to use the inbuilt depth-firt search procedure to find a
 legal execution for a given program:
\layout Standard


\begin_inset Include \verbatiminput{listings/goloz_do.oz}
preview false

\end_inset 


\layout Standard

TODO.
 If each set of actions were sent to the appropriate agents for execution,
 this system would form a centralised multiagent planner.
\layout Standard

TODO: listing of centralised output
\layout Standard

TODO: discuss how this output is better than that produced by IndiGolog
\layout Standard

Of course, a centralised planner fails to utilise all the resources available
 to a multiagent team.
 While a legal execution is being found, other agents are idle.
 An important aspect of the Mozart system is that it provides a parallel
 search procedure that can take advantage of networked machines to speed
 up the search 
\begin_inset LatexCommand \cite{schulte00oz_parallel}

\end_inset 

.
 Utilising this, our implementation can be used to form a distributed multiagent
 planner.
\layout Standard

TODO: actually get this working
\layout Standard

TODO: discuss the coordination algorithm
\layout Standard

TODO: give a listing of actions performed by each agent
\layout Section

Related and Future Work
\layout Standard


\begin_inset LatexCommand \label{sec:Other-Work}

\end_inset 


\layout Standard

One important aspect of multiagent teams that was not approached in this
 paper is the fact that different agents may have differing and even conflicting
 beliefs about the state of the world.
 There has been significant research into representing knowledge and belief
 in Golog, which we hope to incorporate into the framework presented here.
\layout Itemize

alternate prediction schemes e.g.
 extra Golog programs (in readylog?)
\layout Itemize

treatmetn of exog actions in ConGolog is compatiable with this work
\layout Section

Conclusions
\layout Standard


\begin_inset LatexCommand \label{sec:Conclusions-and-Future}

\end_inset 


\layout Standard

In this paper, we have constructed a combination of several important extensions
 to the situation calculus and Golog that provides a language suitable for
 expressing high-level programs for multiagent teams.
 A implementation of this language using Mozart has proven capable of both
 centralised and distributed execution of these programs.
\layout Standard

TODO: good concluding line!
\layout Standard


\begin_inset LatexCommand \BibTeX[abbrv]{/storage/uni/pgrad/library/references}

\end_inset 


\the_end
