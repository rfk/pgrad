#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass llncs
\begin_preamble

\usepackage{verbatim}
\end_preamble
\language english
\inputencoding latin1
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize a4paper
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Title
MIndiGolog: Golog for Multi-Agent Teams
\end_layout

\begin_layout Author
Ryan F.
 Kelly and Adrian R.
 Pearce
\end_layout

\begin_layout Institute
NICTA Victoria Laboratory
\newline
Department of Computer Science and Software Engineering
\newline

The University of Melbourne
\newline
Victoria, 3010, Australia
\newline
{rfk,adrian}@csse.unimelb.edu.a
u
\end_layout

\begin_layout Abstract
We present MIndiGolog, a new variant of the Golog programming language specifica
lly designed for multi-agent teams.
 While Golog has proven a practical technique for single-agent systems,
 several challenges are encountered when moving to a multi-agent setting.
 We develop a robust integration of the following enhancements to better
 represent the dynamics of multi-agent teams: a combination of true concurrency
 of actions with the interleaved concurrency of ConGolog; an explicit notion
 of time to enrich the world model and assist coordination; and strong semantic
 support for predictable exogenous actions (also called 
\begin_inset Quotes eld
\end_inset

natural actions
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
When a team of agents must cooperate closely in order to achieve a shared
 goal, they can often be conceptualized as a single agent with distributed
 sensing, reasoning and acting capabilities.
 This insight leads to a two-stage technique for programming such teams:
 adapt a formalism from single-agent programming to specify the tasks to
 be performed, then provide a coordination strategy allowing the team to
 execute it cooperatively.
 This approach has been successfully employed by platforms such as STEAM
 
\begin_inset LatexCommand \cite{tambe97flexible_teamwork}

\end_inset

, SharedPlans 
\begin_inset LatexCommand \cite{grosz99planning_together}

\end_inset

, and TAEMS 
\begin_inset LatexCommand \cite{decker95designing_coordination}

\end_inset

, which specify tasks using the Hierarchical Task Networks (HTN) formalism.
\end_layout

\begin_layout Standard
While HTN is a powerful approach, other task-representation formalisms are
 also popular for single-agent programming.
 In this paper we adapt the 
\emph on
high-level program execution
\emph default
 approach 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

 to the needs of multi-agent teams.
 By 
\begin_inset Quotes eld
\end_inset

high-level program
\begin_inset Quotes erd
\end_inset

 is meant a program whose primitive operations are domain-specific actions,
 composed using familiar programming operators, and which may contain nondetermi
nistic constructs.
 An agent must find and perform a sequence of actions which constitute an
 execution of this program.
 Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

 is a language built on the situation calculus that implements the high-level
 program execution idea.
\end_layout

\begin_layout Standard
The primary advantage of this approach is 
\emph on
controlled nondeterminism
\emph default
, allowing some parts of the program to be fully specified while others
 may involve arbitrary amounts of nondeterminism, even open-ended planning.
 Golog has the following additional advantages over HTN: it provides a more
 natural representation of many tasks thanks to common programming constructs;
 and it is based on a more sophisticated logic of action 
\begin_inset LatexCommand \cite{son00htn_golog}

\end_inset

.
 Motivated by such advantages, our research program aims to build a Golog-based
 system for programming the behavior of multi-agent teams.
\end_layout

\begin_layout Standard
This paper represents a first step towards that goal.
 We combine several existing extensions to the Golog language to make it
 more suitable for representing the dynamics of a multi-agent team.
 Key among these is true concurrency of actions, which we combine with the
 interleaved concurrency of ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset

 to give a flexible account of concurrent execution.
 An explicit notion of time is incorporated to enrich the world model and
 to assist in coordination between agents.
 The concept of natural actions is also tightly integrated into the language,
 to allow agents to predict the behavior of their teammates and environment.
 We name the resulting language 
\begin_inset Quotes eld
\end_inset

MIndiGolog
\begin_inset Quotes erd
\end_inset

 for 
\begin_inset Quotes eld
\end_inset

Multi-Agent IndiGolog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The paper proceeds as follows: section 
\begin_inset LatexCommand \ref{sec:Background}

\end_inset

 gives some background on the situation calculus and Golog, and describes
 extensions to these formalisms that we will integrate in our work; section
 
\begin_inset LatexCommand \ref{sec:MIndiGolog}

\end_inset

 gives the semantics of MIndiGolog and demonstrates their utility; and section
 
\begin_inset LatexCommand \ref{sec:Conclusions}

\end_inset

 concludes with a summary of our results and ongoing research.
 The work is motivated and illustrated throughout by examples from a simple
 multi-agent domain, in which a team of robotic chefs must be programmed
 to cooperatively prepare a meal.
 
\end_layout

\begin_layout Section
Background
\begin_inset LatexCommand \label{sec:Background}

\end_inset


\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Standard
The situation calculus is a many-sorted language of first-order logic augmented
 with a second-order induction axiom.
 It has the following sorts: 
\emph on
Action
\emph default
 terms are functions denoting individual instantaneous events that can cause
 the state of the world to change; 
\emph on
Situation
\emph default
 terms are histories of the actions that have occurred in the world, with
 the initial situation represented by 
\begin_inset Formula $S_{0}$
\end_inset

 and successive situations built up using the function 
\begin_inset Formula $do\,:\, Action\times Situation\rightarrow Situation$
\end_inset

; 
\emph on
Object
\emph default
 terms represent any other object in the domain.
 It further distinguishes 
\emph on
Fluents
\emph default
 as predicates or functions representing properties of the world that may
 change from one situation to another.
 The special fluent 
\begin_inset Formula $Poss(a,s)$
\end_inset

 indicates when it is possible to perform an action in a situation.
 For a detailed description see 
\begin_inset LatexCommand \cite{pirri99contributions_sitcalc}

\end_inset

.
 
\end_layout

\begin_layout Standard
A collection of situation calculus statements 
\begin_inset Formula $\mathcal{D}$
\end_inset

 describing a dynamic world is referred to as a 
\emph on
theory of action
\emph default
, and queries about the behavior or evolution of the world are posed as
 logical entailment queries relative to this theory.
\end_layout

\begin_layout Subsubsection
Concurrency.
\end_layout

\begin_layout Standard
In the basic situation calculus only a single action can occur at any instant.
 While suitable for most single-agent domains, this limitation is emphatically
 not suitable for multi-agent systems - several actions can easily occur
 simultaneously if performed by different agents.
 Modeling this 
\emph on
true concurrency
\emph default
 is necessary to avoid problems with conflicting or incompatible actions.
 There is also the potential to utilize concurrency to execute tasks more
 efficiently.
 Clearly a solid account of concurrency is required for programming multi-agent
 systems.
\end_layout

\begin_layout Standard
The work of 
\begin_inset LatexCommand \cite{lin92sc_conc,reiter96sc_nat_conc}

\end_inset

 adds true concurrency to the situation calculus by replacing action terms
 with sets of actions that are performed simultaneously.
 All functions and predicates that take an action are modified to take sets
 of actions instead.
 For example, 
\begin_inset Formula $do(a,s)$
\end_inset

 becomes 
\begin_inset Formula $do(\{ a_{1},a_{2},...\},s)$
\end_inset

.
\end_layout

\begin_layout Standard
This seemingly simple modification introduces a complication - a combination
 of actions is not guaranteed to be possible even if the individual actions
 are.
 For example, two agents may not be able to acquire the same resource at
 the same time.
 This is known as the precondition interaction problem 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and is an area of ongoing research.
 For our purposes it is addressed by introducing a predicate 
\begin_inset Formula $Conflicts(c,s)$
\end_inset

 which is true when the actions in 
\begin_inset Formula $c$
\end_inset

 are in conflict and cannot be performed together.
 The possibility axiom for concurrent actions is then:
\begin_inset Foot
status collapsed

\begin_layout Standard
Throughout the paper, lower-case free variables are implicitly universally
 quantified
\end_layout

\end_inset


\begin_inset Formula \begin{equation}
Poss(c,s)\equiv\forall a.\left[a\in c\rightarrow Poss(a,s)\right]\wedge\neg Conflicts(c,s)\label{eqn:poss_conc_acts}\end{equation}

\end_inset


\end_layout

\begin_layout Subsubsection
Time.
\end_layout

\begin_layout Standard
An explicit notion of time can make coordination between agents easier,
 as joint actions may be performed at a particular time.
 It also allows a richer description of the world, for example when stating
 the baking time of a cake.
\end_layout

\begin_layout Standard
A temporal component was incorporated into the situation calculus by 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and simplified by 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

.
 Each action gains an extra argument indicating the time at which is was
 performed.
 Time itself can be represented by any appropriately-behaved sequence, such
 as integers or reals, whose axiomatisation must be included in the theory
 of action.
 The functions 
\begin_inset Formula $time$
\end_inset

 and 
\begin_inset Formula $start$
\end_inset

 are introduced to give the performance time of an action and the starting
 time of a situation respectively.
 The start time of the initial situation may be defined arbitrarily.
\end_layout

\begin_layout Standard
All members in a set of concurrent actions are clearly required to be performed
 at the same time.
 An additional predicate 
\begin_inset Formula $Coherent$
\end_inset

 ensures this:
\begin_inset Formula \begin{equation}
Coherent(c)\equiv\exists t.\forall a.\left[a\in c\rightarrow time(a)=t\right]\label{eq:coherent_def}\end{equation}

\end_inset

These authors also utilize a standard approach to actions with a finite
 duration - they are decomposed into instantaneous 
\begin_inset Formula $start$
\end_inset

 and 
\begin_inset Formula $end$
\end_inset

 actions and a fluent indicating that the action is in progress.
 For example, a long-running task may be represented by the actions 
\begin_inset Formula $beginTask$
\end_inset

 and 
\begin_inset Formula $endTask$
\end_inset

 and a fluent 
\begin_inset Formula $doingTask$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Natural Actions.
\end_layout

\begin_layout Standard
These are a special class of exogenous actions, those actions which occur
 outside of an agent's control.
 Introduced to the situation calculus by 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 and expanded by 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

, they are classified according to the following requirement: natural actions
 must occur at their predicted times, provided no earlier actions prevent
 them from occurring.
 For example, a timer will ring at the time it was set for, unless it is
 switched off.
 The action 
\begin_inset Formula $endTask$
\end_inset

 from above is another example - it must occur whenever it is possible.
 In domains where many agents may be simultaneously engaged in many long-running
 tasks, strong semantic support for such natural actions will therefore
 be of significant benefit.
\end_layout

\begin_layout Standard
Natural actions are indicated by the truth of the predicate 
\begin_inset Formula $Natural(a)$
\end_inset

.
 As usual, the times at which natural actions may occur are specified by
 the 
\begin_inset Formula $Poss$
\end_inset

 predicate.
 For example, suppose that the fluent 
\begin_inset Formula $TimerSet(m,s)$
\end_inset

 represents the fact that a timer is set to ring in 
\begin_inset Formula $m$
\end_inset

 minutes in situation 
\begin_inset Formula $s$
\end_inset

.
 The possibility predicate for the 
\begin_inset Formula $ringTimer(t)$
\end_inset

 action would be:
\begin_inset Formula \begin{equation}
Poss(ringTimer(t),s)\equiv\exists m.\left[TimerSet(m,s)\wedge t=start(s)+m\right]\label{eqn:poss_ring_timer}\end{equation}

\end_inset

The timer may thus ring only at its predicted time.
 To enforce the requirement that natural actions 
\emph on
must
\emph default
 occur whenever possible, a predicate 
\begin_inset Formula $Legal(s)$
\end_inset

 is introduced which is true only for situations which respect this requirement.
 Legal situations are the only situations that could be brought about in
 the real world:
\begin_inset Formula \begin{multline}
Legal(S_{0})\equiv True\label{eqn:legal_def}\\
\shoveleft{Legal(do(c,s))\equiv Legal(s)\wedge Poss(c,s)\wedge Coherent(c)\wedge start(s)\leq time(c)}\\
\wedge\,\forall a.\left[Natural(a)\wedge Poss(a,s)\rightarrow\left[a\in c\vee t<time(a)\right]\right]\end{multline}

\end_inset

An important concept when dealing with natural actions it the least natural
 time point (LNTP) of a situation, defined as the earliest time at which
 a natural action may occur.
 We assume that the theory of action avoids certain pathological cases,
 so that absence of an LNTP implies that no natural actions are possible.
\begin_inset Formula \begin{align}
Lntp(s,t)\equiv\,\, & \exists a.\left[Natural(a)\wedge Poss(a,s)\wedge time(a)=t\right]\wedge\nonumber \\
 & \forall a.\left[Natural(a)\wedge Poss(a,s)\rightarrow t\leq time(a)\right]\label{eqn:lntp_def}\end{align}

\end_inset


\end_layout

\begin_layout Subsection
Golog
\end_layout

\begin_layout Standard
Golog 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

 is a declarative agent programming language based on the situation calculus.
 Testimony to its success are its wide range of applications and many extensions
 to provide additional functionality (
\begin_inset LatexCommand \cite{giacomo00congolog,giacomo99indigolog,Ferrein2005readylog}

\end_inset

).
 We use the term 
\begin_inset Quotes eld
\end_inset

Golog
\begin_inset Quotes erd
\end_inset

 to refer to the family of languages based on this technique.
\end_layout

\begin_layout Standard
To program an agent using Golog one specifies a situation calculus theory
 of action, and a program consisting of actions connected by programming
 constructs such as if-then-else, while loops, and nondeterministic choice.
 Table 
\begin_inset LatexCommand \ref{tbl:Golog-Operators}

\end_inset

 lists some of the operators available in various incarnations of the language.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Operator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Meaning
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\phi?$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Proceed only if condition 
\begin_inset Formula $\phi$
\end_inset

 is true
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1};\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute program 
\begin_inset Formula $\delta_{1}$
\end_inset

followed by 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}|\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute either 
\begin_inset Formula $\delta_{1}$
\end_inset

 or 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\pi(x)\delta(x)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Nondet.
 select arguments for 
\begin_inset Formula $\delta$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 zero or more times
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{if}\,\phi\,\mathbf{then}\,\delta_{1}\,\mathbf{else}\,\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Exec.
 
\begin_inset Formula $\delta_{1}$
\end_inset

 if 
\begin_inset Formula $\phi$
\end_inset

 holds, 
\begin_inset Formula $\delta_{2}$
\end_inset

 otherwise
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{while\,}\phi\mathbf{\, do}\,\delta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Execute 
\begin_inset Formula $\delta$
\end_inset

 while 
\begin_inset Formula $\phi$
\end_inset

 holds
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Concurrently execute 
\begin_inset Formula $\delta_{1}$
\end_inset

and 
\begin_inset Formula $\delta_{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $\mathbf{proc}P(\overrightarrow{x})\delta(\overrightarrow{x})\mathbf{end}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Procedure definition
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Caption
Some Golog Operators
\begin_inset LatexCommand \label{tbl:Golog-Operators}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In line with the idea of high-level program execution, the agent's control
 program may be nondeterministic.
 It is the task of the agent to plan a deterministic instantiation of the
 program, a sequence of actions that can legally be performed in the world.
 Such a sequence is called a 
\emph on
legal execution
\emph default
 of the Golog program.
\end_layout

\begin_layout Standard
Two predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 define the semantics for each operator.
 
\begin_inset Formula $Trans(\delta,s,\delta',s')$
\end_inset

 holds when executing a single step of program 
\begin_inset Formula $\delta$
\end_inset

 can cause the world to move from situation 
\begin_inset Formula $s$
\end_inset

 to situation 
\begin_inset Formula $s'$
\end_inset

, after which 
\begin_inset Formula $\delta'$
\end_inset

 remains to be executed.
 It thus characterizes single steps of computation.
 
\begin_inset Formula $Final(\delta,s)$
\end_inset

 holds when program 
\begin_inset Formula $\delta$
\end_inset

 may legally terminate its execution in situation 
\begin_inset Formula $s$
\end_inset

.
 We base our work on the semantics of IndiGolog 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

, which builds on ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog}

\end_inset

 and is the most feature-full of the standard Golog variants.
 The full semantics are available in the references, but as an example consider
 equation (
\begin_inset LatexCommand \ref{eqn:trans_conc_orig}

\end_inset

), which specifies the concurrency operator as an 
\emph on
interleaving
\emph default
 of computation steps.
 It states that it is possible to single-step the concurrent execution of
 
\begin_inset Formula $\delta_{1}$
\end_inset

 and 
\begin_inset Formula $\delta_{2}$
\end_inset

 by performing either a step from 
\begin_inset Formula $\delta_{1}$
\end_inset

 or a step from 
\begin_inset Formula $\delta_{2}$
\end_inset

, with the remainder 
\begin_inset Formula $\gamma$
\end_inset

 left to execute concurrently with the other program:
\begin_inset Formula \begin{align}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv & \,\,\,\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})\nonumber \\
 & \vee\,\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\label{eqn:trans_conc_orig}\end{align}

\end_inset

If the theory of action 
\begin_inset Formula $\mathcal{D}$
\end_inset

 is enriched with 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

, executing a Golog program 
\begin_inset Formula $\delta$
\end_inset

 is basically a theorem proving task as shown in equation (
\begin_inset LatexCommand \ref{eqn:golog_execution}

\end_inset

).
 Here 
\begin_inset Formula $Trans*$
\end_inset

 indicates reflexive transitive closure.
 The situation 
\begin_inset Formula $s$
\end_inset

 gives a sequence of actions forming a legal execution of the program.
\begin_inset Formula \begin{equation}
\mathcal{D}\models\exists s.\left[Trans*(\delta,S_{0},\delta',s)\wedge Final(\delta',s)\right]\label{eqn:golog_execution}\end{equation}

\end_inset

As an example of a multi-agent task specification in Golog, consider a program
 
\begin_inset Formula $MakeSalad$
\end_inset

 that instructs a team of agents to prepare a simple salad:
\begin_inset Formula \begin{multline}
\mathbf{proc}\, MakeSalad(dest)\label{eqn:MakeSalad}\\
\left[\pi(agt)(ChopTypeInto(agt,Lettuce,dest))\,||\right.\\
\pi(agt)(ChopTypeInto(agt,Carrot,dest))\,||\\
\left.\pi(agt)(ChopTypeInto(agt,Tomato,dest))\right]\,;\\
\pi(agt)\left[acquire(agt,dest)\,;\, beginTask(agt,mix(dest,1))\,;\right.\\
\left.endTask(agt,mix(dest,1))\,;\, release(agt,dest)\right]\,\,\mathbf{end}\end{multline}

\end_inset

The sub-procedure 
\begin_inset Formula $ChopTypeInto$
\end_inset

 (not shown) picks an object of the given type and an available chopping
 board, chops the object using the board, then transfers it into the destination
 container.
 
\begin_inset Formula $MakeSalad$
\end_inset

 tells the agents to do this for a lettuce, a carrot and a tomato, then
 mix the ingredients together for 1 minute.
 The agent assigned to handling each ingredient is not specified (
\begin_inset Formula $\pi$
\end_inset

 construct), nor is the order in which they should be added (
\begin_inset Formula $||$
\end_inset

 construct).
\end_layout

\begin_layout Standard
While this program could be executed using the existing semantics of IndiGolog,
 the result would be suboptimal.
 As this languages lack true concurrency, only a single agent could act
 at each step.
 There is also no guarantee that the special requirements of natural actions
 such as 
\begin_inset Formula $endTask$
\end_inset

 would be respected.
 Our new variant MIndiGolog is designed to produce executions of such programs
 that overcome these limitations, and so are more suitable for multi-agent
 teams.
\end_layout

\begin_layout Subsection
Related Work
\end_layout

\begin_layout Standard
That Golog shows promise for multi-agent teams is evidenced by the success
 of 
\begin_inset LatexCommand \cite{Ferrein2005readylog}

\end_inset

 with a RoboCup soccer team executing a shared Golog program.
 However, the semantics of their Golog variant 
\begin_inset Quotes eld
\end_inset

ReadyLog
\begin_inset Quotes erd
\end_inset

 remain largely single-agent and do not address concerns such as: the possibilit
y of performing actions concurrently and the coordination of concurrent
 actions; differing knowledge or beliefs between team members; sharing the
 computational workload of planning; and predicting the behavior of teams
 members and the environment in the face of many concurrently-executing
 tasks.
 MIndiGolog overcomes some of these limitations, while our ongoing work
 on cooperative execution will address the others.
\end_layout

\begin_layout Standard
Note that this paper focuses on task specification using Golog and does
 not deal with coordination between team members.
 We are currently developing techniques for cooperative execution of MIndiGolog
 programs, based on successful approaches to executing HTN task specifications
 such as 
\begin_inset LatexCommand \cite{tambe97flexible_teamwork,grosz99planning_together,decker95designing_coordination}

\end_inset

.
\end_layout

\begin_layout Standard
A key aspect of our work is the integration of two distinct notions of concurren
cy: the possibility of performing several actions at the same instant (
\emph on
true concurrency
\emph default
), and the possibility of interleaving the execution of several programs
 (
\emph on
interleaved concurrency
\emph default
).
 These two notions of concurrency were combined in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

 by modifying Golog to incorporate sets of concurrent actions.
 However, as we shall see below, their semantics may call for actions to
 be performed that are not possible and may also result in unintuitive program
 behavior.
 We develop a more robust integration of these notions of concurrency.
\end_layout

\begin_layout Section
MIndiGolog
\begin_inset LatexCommand \label{sec:MIndiGolog}

\end_inset


\end_layout

\begin_layout Standard
We have integrated three extensions to the situation calculus with the semantics
 of IndiGolog to better model the dynamics of a multi-agent setting.
 These extensions allow agents to represent time, concurrently-occurring
 actions, and natural actions in a robust way.
\end_layout

\begin_layout Subsubsection
Time.
\end_layout

\begin_layout Standard
It is clear from the background section that the approach of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 to modeling time is complicated by the presence of concurrent actions.
 To avoid the need for the 
\begin_inset Formula $Coherent$
\end_inset

 predicate, we attach the temporal argument to each situation rather than
 to each action.
 The successor situation function 
\begin_inset Formula $do(a,s)$
\end_inset

 becomes 
\begin_inset Formula $do(a,t,s)$
\end_inset

, to indicate 
\begin_inset Quotes eld
\end_inset

action 
\begin_inset Formula $a$
\end_inset

 was performed at time 
\begin_inset Formula $t$
\end_inset

 in situation 
\begin_inset Formula $s$
\end_inset


\begin_inset Quotes erd
\end_inset

.
 The possibility predicate 
\begin_inset Formula $Poss(a,s)$
\end_inset

 likewise becomes 
\begin_inset Formula $Poss(a,t,s)$
\end_inset

.
 The semantics of IndiGolog are trivially modified to accommodate this change.
 
\begin_inset Formula $Coherent$
\end_inset

 and 
\begin_inset Formula $time$
\end_inset

 are no longer needed, and the definition of 
\begin_inset Formula $start$
\end_inset

 becomes simply:
\begin_inset Formula \[
start(do(a,t,s))=t\]

\end_inset


\end_layout

\begin_layout Subsubsection
Concurrency.
\end_layout

\begin_layout Standard
While it is straightforward to modify the IndiGolog 
\begin_inset Formula $Trans$
\end_inset

 rule for primitive actions to accept sets of concurrent actions, there
 are deeper implications for the concurrency operator.
 This is implemented by accepting a transition from either of the two programs
 as a transition for the pair.
 In the presence of true concurrency, this is insufficient.
 Suppose program 
\begin_inset Formula $\delta_{1}$
\end_inset

 may be transitioned by performing actions 
\begin_inset Formula $c_{1}$
\end_inset

, and 
\begin_inset Formula $\delta_{2}$
\end_inset

 may be transitioned by performing actions 
\begin_inset Formula $c_{2}$
\end_inset

.
 As noted in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

, it should be possible to exploit true concurrency by performing both simultane
ously, i.e.
 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
However, this introduces several complications not addressed in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

.
 First, precondition interaction means that 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 may not be possible even if the individual actions are.
 The transition clause must ensure that the combination of the two sets
 of actions is actually possible.
 Another issue arises when two programs can legitimately be transitioned
 by executing the same action.
 Consider the following programs which add ingredients to a bowl:
\begin_inset Formula \begin{gather*}
\delta_{1}=placeIn(Thomas,Flour,Bowl)\,;\, placeIn(Thomas,Sugar,Bowl)\\
\delta_{2}=placeIn(Thomas,Flour,Bowl)\,;\, placeIn(Thomas,Egg,Bowl)\end{gather*}

\end_inset

Executing 
\begin_inset Formula $\delta_{1}||\delta_{2}$
\end_inset

 should result in the bowl containing two units of flour, one unit of sugar
 and an egg.
 However, an individual transition for both programs is 
\begin_inset Formula $c_{1}=c_{2}=placeIn(Thomas,Flour,Bowl)$
\end_inset

.
 Naively executing 
\begin_inset Formula $c_{1}\cup c_{2}$
\end_inset

 to transition both programs would add only one unit of flour.
 Alternately, consider two programs waiting for a timer to ring:
\begin_inset Formula \begin{gather*}
\delta_{1}=ringTimer(OvenTimer)\,;\, acquire(Thomas,Bowl)\\
\delta_{2}=ringTimer(OvenTimer)\,;\, acquire(Richard,Board)\end{gather*}

\end_inset

Both programs should be allowed to proceed with a single occurrence of the
 
\begin_inset Formula $ringTimer$
\end_inset

 action, because it is an aspect of the environment.
 To avoid unintuitive (and potentially dangerous) behavior, concurrent execution
 must not be allowed to transition both programs using the same 
\emph on
agent-initiated
\emph default
 action.
 If an agent-initiated action may be safely skipped, it should be enclosed
 in an appropriate if-then-else or choice construct.
\end_layout

\begin_layout Standard
Taking these factors into account, we develop the improved transition rule
 for concurrency in equation (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

).
 The first two lines are the original interleaved concurrency clause from
 ConGolog, while the remainder characterizes the above considerations for
 true concurrency.
 This robust combination allows the language to more accurately reflect
 the concurrency present in multi-agent teams.
 As with ConGolog and IndiGolog, our semantics make no attempt to maximize
 concurrency or otherwise differentiate between potential executions, they
 only state what transitions are legal.
 
\begin_inset Formula \begin{multline}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\exists\gamma.Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})\label{eqn:trans_conc_new}\\
\vee\exists\gamma.Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)\\
\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\\
\shoveright{\wedge Poss(c_{1}\cup c_{2},t,s)\wedge\forall a.\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Natural(a)\right]}\\
\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)\end{multline}

\end_inset


\end_layout

\begin_layout Subsubsection
Natural Actions.
\end_layout

\begin_layout Standard
The formalism of 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 is adopted, suitably modified for our handling of time.
 While planning with natural actions has previously been done in Golog 
\begin_inset LatexCommand \cite{pirri00planning_nat_acts}

\end_inset

, the programmer was required to explicitly check for any possible natural
 actions and ensure that they appear in the execution.
 We significantly lower the burden on the programmer by guaranteeing that
 all program executions produce legal situations.
 MIndiGolog agents will plan for the occurrence of natural actions without
 having them explicitly mentioned in the program.
 They may optionally be included in the program, instructing the agents
 to wait for the action to occur before proceeding.
\end_layout

\begin_layout Standard
This is achieved using a new 
\begin_inset Formula $Trans$
\end_inset

 clause for the case of a single action 
\begin_inset Formula $c$
\end_inset

, as shown in equation (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

).
 If 
\begin_inset Formula $s$
\end_inset

 has an LNTP 
\begin_inset Formula $t_{n}$
\end_inset

 and corresponding set of natural actions 
\begin_inset Formula $c_{n}$
\end_inset

, a transition can be made in three ways: perform 
\begin_inset Formula $c$
\end_inset

 at a time before 
\begin_inset Formula $t_{n}$
\end_inset

 (third line), perform it along with the natural actions at 
\begin_inset Formula $t_{n}$
\end_inset

 (fourth line), or wait for the natural actions to occur (fifth line).
 If there is no LNTP, then 
\begin_inset Formula $c$
\end_inset

 may be performed at any time greater than 
\begin_inset Formula $start(s)$
\end_inset

.
\begin_inset Formula \begin{multline}
Trans(c,s,\delta',s')\equiv\,\,\,\exists t,t_{n},c_{n}.Lntp(s,t_{n})\wedge t\geq start(s)\wedge\label{eqn:trans_prim_new}\\
\forall a.\left[Natural(a)\wedge Poss(a,t_{n},s)\equiv c\in c_{n}\right]\wedge\\
\left[t<t_{n}\wedge Poss(c,t,s)\wedge s'=do(c,t,s)\wedge\delta'=Nil\right.\\
\vee Poss(c\cup c_{n},t_{n},s)\wedge s'=do(c\cup c_{n},t,s)\wedge\delta'=Nil\\
\vee\left.s'=do(c_{n},t_{n},s)\wedge\delta'=c\right]\\
\vee\,\neg\exists t_{n}.Lntp(s,t_{n})\wedge\exists t.Poss(c,t,s)\wedge\\
t\geq start(s)\wedge s'=do(c,t,s)\wedge\delta'=Nil\end{multline}

\end_inset


\end_layout

\begin_layout Standard
Let a 
\emph on
MIndiGolog Theory of Action
\emph default
 be a theory of action in the situation calculus enhanced with time, true
 concurrency and natural actions, augmented with the predicates 
\begin_inset Formula $Trans$
\end_inset

 and 
\begin_inset Formula $Final$
\end_inset

 from IndiGolog, modified according to equations (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

).
 All legal executions of a MIndiGolog program derived from such a theory
 of action produce legal situations.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $\mathcal{D}$
\end_inset

 be a MIndiGolog theory of action.
 Then:
\begin_inset LatexCommand \label{thm:trans_legal}

\end_inset


\begin_inset Formula \[
\mathcal{D}\models\forall s,s',\delta,\delta'\,.\, Legal(s)\wedge Trans(\delta,s,\delta',s')\rightarrow Legal(s')\]

\end_inset


\end_layout

\begin_layout Proof
By induction on the structure of 
\begin_inset Formula $\delta$
\end_inset

.
 That the theorem holds for the modified 
\begin_inset Formula $Trans$
\end_inset

 clauses of equations (
\begin_inset LatexCommand \ref{eqn:trans_conc_new}

\end_inset

) and (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

) is straightforward, and no other clause constructs new situation terms.
 
\begin_inset Note Note
status collapsed

\begin_layout Standard
Consider first the base case of a single concurrent action 
\begin_inset Formula $\delta=c$
\end_inset

.
 This 
\begin_inset Formula $Trans$
\end_inset

 clause (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

) has four disjuncts.
 We treat here only the case where actions are performed before the LNTP,
 other cases employ similar reasoning.
 Assuming this case, (
\begin_inset LatexCommand \ref{eqn:trans_prim_new}

\end_inset

) reduces to:
\begin_inset Formula \begin{multline*}
Trans(c,s,Nil,do(c,t,s))\equiv\\
\exists t_{n}.Lntp(s,t_{n})\wedge t<t_{n}\wedge ti\geq start(s)\wedge Poss(c,t,s)\end{multline*}

\end_inset

By the definition of 
\begin_inset Formula $Lntp$
\end_inset

 (
\begin_inset LatexCommand \ref{eqn:lntp_def}

\end_inset

) and given 
\begin_inset Formula $t<t_{n}$
\end_inset

, no natural actions can be possible before or at time 
\begin_inset Formula $t$
\end_inset

, allowing us to add:
\begin_inset Formula \begin{multline*}
Trans(c,s,Nil,do(c,t,s))\equiv\\
\exists t_{n}.Lntp(s,t_{n})\wedge t<t_{n}\wedge t\geq start(s)\wedge Poss(c,t,s)\wedge\\
\forall a,t_{a}\left[Natural(a)\wedge Poss(a,t_{a},s)\rightarrow t<t_{a}\right]\end{multline*}

\end_inset

 Given 
\begin_inset Formula $Legal(s)$
\end_inset

 and equation (
\begin_inset LatexCommand \ref{eqn:legal_def}

\end_inset

), it is then clear that for this case:
\begin_inset Formula \[
\mathcal{D}\models Legal(s)\wedge Trans(c,s,Nil,do(c,t,s))\rightarrow Legal(do(c,t,s))\]

\end_inset

Of the remaining clauses for 
\begin_inset Formula $Trans$
\end_inset

, only that for the concurrency operator explicitly builds a new situation
 term.
 Establishing the theorem for this construction is straightforward and is
 not detailed here.
\end_layout

\end_inset


\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $\mathcal{D}$
\end_inset

 be a MIndiGolog theory of action.
 Then: 
\begin_inset Formula \[
\mathcal{D}\models\forall s',\delta,\delta'\,.\, Trans*(\delta,S_{0},\delta',s')\rightarrow Legal(s')\]

\end_inset

 Thus, all legal executions of a MIndiGolog program produce legal situations.
 
\end_layout

\begin_layout Proof
From lemma 
\begin_inset LatexCommand \ref{thm:trans_legal}

\end_inset

, the legality of 
\begin_inset Formula $S_{0}$
\end_inset

, and the properties of transitive closure.
 
\end_layout

\begin_layout Standard
This means that MIndiGolog, like standard IndiGolog, will only call for
 actions to be executed if they are possible in the world.
 Moreover, the execution will contain all natural actions that will occur,
 regardless of whether they were considered explicitly by the programmer.
\end_layout

\begin_layout Standard
The effect of our enhancements can be seen in Figure 
\begin_inset LatexCommand \ref{cap:example_trace}

\end_inset

, which shows one possible legal execution of the 
\begin_inset Formula $MakeSalad$
\end_inset

 program
\begin_inset Foot
status collapsed

\begin_layout Standard
A Prolog implementation of the MIndiGolog semantics, from which this trace
 was obtained, is available at http://www.csse.unimelb.edu.au/~rfk/golog/
\end_layout

\end_inset

.
 Note the occurrence of several actions within each 
\series bold
do
\series default
 statement, demonstrating the integration of true concurrency into the language.
 Note also the explicit occurrence time for each step, allowing the agents
 to properly synchronize their actions.
 This time is not fixed, but constrained according to the occurrence times
 of the natural actions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 0
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "100in"
height_special "depth"
status open

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
scriptsize 
\backslash
verbatiminput{listings/output_makeSalad_1.txt}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Standard


\backslash
scriptsize 
\backslash
verbatiminput{listings/output_makeSalad_2.txt}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Caption
One possible execution of the 
\begin_inset Formula $MakeSalad$
\end_inset

 program with three agents.
 Variables 
\begin_inset Formula $\_U$
\end_inset

, 
\begin_inset Formula $\_T$
\end_inset

, etc give the occurrence times of each action, constrained to ensure all
 situations are legal.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \label{cap:example_trace}

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusions and Future Work
\begin_inset LatexCommand \label{sec:Conclusions}

\end_inset


\end_layout

\begin_layout Standard
Our work integrates several important extensions to the situation calculus
 and Golog to better model the dynamics of multi-agent teams.
 Specifically, MIndiGolog combines true and interleaved concurrency, an
 explicit account of time, and seamless integration of natural actions.
\end_layout

\begin_layout Standard
Since the semantics of MIndiGolog are based on first-order logic, existing
 techniques for distributed logic programming can be used to share the execution
-planning workload between agents.
 We are currently developing a coordination strategy to augment these techniques
 and allow cooperative execution of the program.
 Our ultimate goal is the distributed execution of programs such as 
\begin_inset Formula $MakeSalad$
\end_inset

 by a team of autonomous agents.
\end_layout

\begin_layout Standard
This paper thus represents a first step toward providing the advantages
 of Golog (such as controlled nondeterminism, powerful programming constructs,
 and a rich logic of action) for task specification for multi-agent teams.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[splncs]{/storage/uni/pgrad/library/references}

\end_inset

 
\end_layout

\end_body
\end_document
