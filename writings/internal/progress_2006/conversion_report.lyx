#LyX 1.4.1 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{a4wide}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes true
\end_header

\begin_body

\begin_layout Title
A Programming Language for Multi-Agent Teams
\end_layout

\begin_layout Author
PhD Conversion Report
\newline

\newline
Ryan Kelly
\newline
Department of Computer Science and Software
 Engineering
\newline
The University of Melbourne
\newline
Parkville, Australia
\newline
rfk@csse.unimelb.edu.au
\newline

\newline
S
upervisor: Dr.
 Adrian Pearce
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
When a team of agents must cooperate closely in order to achieve some shared
 goal, they may be usefully conceptualized as a single agent with distributed
 sensing, reasoning and acting capabilities.
 Behaviors and goals are more naturally ascribed to the team rather than
 to individual members.
 This viewpoint suggests that techniques for programming in single-agent
 systems may be may be useful when programming the behavior of multi-agent
 teams: rather than specifying the behavior of each team member, write a
 single program that determines the behavior of the entire team.
\end_layout

\begin_layout Standard
In my thesis I adapt the idea of
\emph on
 
\emph default
High-Level Program
\emph on
 
\emph default
Execution for use in such a manner.
 A single program is written describing the desired behavior of the team.
 The individual team members then cooperate amongst themselves to find and
 perform a legal execution of this program.
 Specifically, I extend the Situation Calculus and the Golog family of programmi
ng languages for this purpose.
 The result is a new programming language named 
\begin_inset Quotes eld
\end_inset

MIndiGolog
\begin_inset Quotes erd
\end_inset

 suitable for specifying the behavior of multi-agent teams.
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
This project focuses on programming the behavior of teams of autonomous
 agents who are required to cooperate closely to perform some shared task.
 Such teams can be found in many different settings - for example, a team
 of robots assembling a complicated artifact or playing a game of soccer,
 or a group of computers performing a distributed calculation.
 A robust formalism for programming such teams would find a wide variety
 of applications.
\end_layout

\begin_layout Standard
As will be discussed below, there are two main approaches to specifying
 the behavior of a team of agents.
 In the Multi-Agent Systems approach, each agent acts according to its own
 individual program, with individual goals and desires, and the behavior
 of the team emerges from the interactions between such agents.
 In the Distributed Problem Solving approach, a single task is posed to
 the team as a whole, who cooperate to execute it.
 For teams which must cooperate closely, the later approach offers some
 distinct advantages:
\end_layout

\begin_layout Itemize
It is easier to validate and predict the behavior of the team, as it does
 not rely on emergent interactions
\end_layout

\begin_layout Itemize
The same task specification may be given to any team of agents, facilitating
 re-usability and flexibility
\end_layout

\begin_layout Itemize
The programmer need not specify unimportant details such as precisely which
 agents perform which aspects of the task, again facilitating re-usability
 and flexibility
\end_layout

\begin_layout Itemize
The agents are better able to anticipate (and thus coordinate and assist
 with) the actions of other agents, increasing overall team performance
\end_layout

\begin_layout Standard
While this approach has met some success in programming the behavior of
 teams, the tasks to be carried out are typically specified using fairly
 limiting formalisms, such as decomposing tasks into simple combinations
 of sub-tasks.
 High-Level Program Execution, a technique from single-agent programming
 actualized in the programming language Golog, has several advantages over
 existing formalisms for specifying the tasks to be performed by the team:
\end_layout

\begin_layout Itemize
It provides a greater level of control over the amount of reasoning the
 agents are required to perform, even allowing purely goal-driven planning
 when required
\end_layout

\begin_layout Itemize
It is more natural for the programmer, giving easy access to common programming
 constructs such as loops and if-then-else
\end_layout

\begin_layout Itemize
It is based on a more sophisticated logic of actions
\end_layout

\begin_layout Standard
Unfortunately, the existing semantics of languages such as Golog are not
 rich enough to robustly capture the behavior of multi-agent teams.
 They require enhancement to incorporate features such as true concurrency,
 time, and knowledge in a partially-observable multi-agent environment.
\end_layout

\begin_layout Standard
Distributed Problem Solving and High-Level Program Execution are both compelling
 approaches in their respective fields.
 By extending Golog to allow it to properly represent multi-agent teams,
 and by defining an appropriate strategy for coordinating planning and execution
, I will develop the union of these technologies into a powerful formalism
 for programming multi-agent teams.
\end_layout

\begin_layout Subsection
Research Objectives
\end_layout

\begin_layout Standard
The major objectives of my research program are thus:
\end_layout

\begin_layout Itemize
Develop an appropriate formalism for programming multi-agent teams at the
 level of the team.
 Specifically:
\end_layout

\begin_deeper
\begin_layout Itemize
Enhance the semantics of Golog to effectively model the dynamics of multi-agent
 teams in partially-observable environments
\end_layout

\begin_layout Itemize
Develop a coordination strategy allowing the agents to execute a shared
 Golog program, while making efficient use of distributed computing resources
\end_layout

\end_deeper
\begin_layout Itemize
Develop an implementation of the formalism that can be used to program real-worl
d teams
\end_layout

\begin_layout Itemize
Demonstrate the effectiveness of the approach using a small example implemented
 on a set of networked computers
\end_layout

\begin_layout Section
Background and Related Work
\begin_inset LatexCommand \label{sec:Background-and-Related}

\end_inset


\end_layout

\begin_layout Subsection
Multi-Agent Systems
\end_layout

\begin_layout Subsubsection
Overview and Terminology
\end_layout

\begin_layout Standard
Multi-agent systems research is a large and diverse field, with a correspondingl
y vast literature base.
 While an overview of the entire field is beyond the scope of this report
 (such an overview may be found in 
\begin_inset LatexCommand \cite{nwana95software_agents,mataric95issues_designing_agents}

\end_inset

), it is necessary to situate this work within the broader field by describing
 the types of multi-agent applications that it targets.
\end_layout

\begin_layout Standard
Although often implicit in the literature, there is a clear distinction
 between two types of systems involving multiple agents: 
\emph on
Multi-Agent Systems
\emph default
 (MAS) and 
\emph on
Distributed Problem Solving
\emph default
 (DPS) 
\begin_inset LatexCommand \cite{nwana95software_agents,mataric95issues_designing_agents}

\end_inset

.
 MAS applications involve autonomous agents that act independently, and
 may cooperate or compete depending on their individual goals and desires.
 By contrast, DPS applications involve a team of agents cooperating to solve
 a joint problem or perform a joint task.
 A detailed discussion of the DPS field can be found in 
\begin_inset LatexCommand \cite{Durfee91dps}

\end_inset

.
\end_layout

\begin_layout Standard
This research project aims to develop a programming language with which
 one can specify the tasks to be performed by a DPS system, along with a
 coordination strategy that will enable a team of agents to execute such
 programs.
 That is, I focus on specifying the behavior of a team of agents who must
 cooperate closely to achieve some shared goal, and who are under the control
 of a central designer.
 While specifying and coordinating teamwork in open MAS applications is
 a fascinating and challenging topic, it is outside the scope of this project.
\end_layout

\begin_layout Subsubsection
Task Representation
\end_layout

\begin_layout Standard
For a team of agents to form a DPS system, they require some shared notion
 of the task to be carried out.
 Formalisms from traditional single-agent planning are frequently used for
 this purpose, based on a representation of actions and their effects developed
 with the STRIPS 
\begin_inset LatexCommand \cite{fikes71strips}

\end_inset

 planning system.
 A popular choice is the 
\emph on
Hierarchical Task Networks
\emph default
 (HTN) formalism 
\begin_inset LatexCommand \cite{obst05htn_teams}

\end_inset

.
 In this approach, the tasks to be carried out are represented as sequences
 (or more generally, partial orders) of sub-tasks.
 By replacing tasks with their constituent sub-tasks until only primitive
 actions remain, a complete plan for achieving the task can be developed.
 Formalisms such as STEAM 
\begin_inset LatexCommand \cite{tambe97flexible_teamwork}

\end_inset

, SharedPlans 
\begin_inset LatexCommand \cite{grosz99planning_together}

\end_inset

 and STAPLE 
\begin_inset LatexCommand \cite{kumar04staple}

\end_inset

 combine such accounts of action with theories of mental states such as
 belief and intention to provide rigorous models of teamwork.
\end_layout

\begin_layout Standard
Another example of this style of task specification is the TAEMS framework
 
\begin_inset LatexCommand \cite{decker95designing_coordination}

\end_inset

.
 It is specifically designed for DPS applications, and enriches the HTN
 formalism with information such as time constraints and facilitates/inhibits
 relationships between tasks.
 Combined with a coordination system called Generalized Partial Global Planning,
 it has been successfully applied in wide range of domains 
\begin_inset LatexCommand \cite{Lesser04gpgp_taems}

\end_inset

.
\end_layout

\begin_layout Standard
While the HTN approach to task representation and planning is quite useful,
 it is certainly not the only approach.
 An emerging alternative for single-agent systems is 
\emph on
High-level Program Execution
\emph default
, exemplified by the Golog programming language.
 This approach and its advantages are described in detail in section 
\begin_inset LatexCommand \ref{sub:Golog}

\end_inset

.
\end_layout

\begin_layout Standard
Considering its potential advantages, we aim to use the High-Level Program
 Execution paradigm for specifying the tasks to be performed by a multi-agent
 DPS team.
 That this is a promising approach is highlighted in 
\begin_inset LatexCommand \cite{Ferrein2005readylog}

\end_inset

, where a Golog variant is used to specify the behavior of a robotic soccer
 team.
 My work will formalize and extend the approach to a broader range of multi-agen
t systems.
\end_layout

\begin_layout Subsubsection
Coordination
\end_layout

\begin_layout Standard
Along with their description of the tasks to be performed, a multi-agent
 team must have some strategy to coordinate their shared execution of those
 tasks.
 A comprehensive overview of coordination techniques is given in 
\begin_inset LatexCommand \cite{jennings96coordination}

\end_inset

.
 Again, although there is a large body of literature on coordination in
 multi-agent systems, much of it is well beyond the scope of this project.
 As noted in 
\begin_inset LatexCommand \cite{durfee05ma_plan_coordination}

\end_inset

, the coordination needs of loosely-coupled multi-agent systems differ markedly
 from multi-agent teams involved in distributed problem solving.
\end_layout

\begin_layout Standard
Coordination strategies can be broadly categorised as either implicit or
 explicit.
 Implicit coordination takes the form of pre-existing agreements that limit
 when or how actions can be performed - for example, the agreement that
 everyone drive on the left-hand side of the road.
 Explicit coordination requires communication between agents to resolve
 possible conflicts in their plans, for example as described in 
\begin_inset LatexCommand \cite{durfee05ma_plan_coordination}

\end_inset


\end_layout

\begin_layout Standard
Since DPS teams frequently have a good idea of what actions other team-members
 will be performing, implicit coordination can achieve more than may be
 immediately obvious.
 As has been shown with both a HTN approach 
\begin_inset LatexCommand \cite{obst05htn_teams}

\end_inset

 and with Golog 
\begin_inset LatexCommand \cite{Ferrein2005readylog}

\end_inset

, when the world is fully observable and the agents know the entirety of
 the joint task specification, coordination can be achieved without any
 communication at all.
 This is possible by having each agent independently plan a full execution
 of the task, including the actions to be performed by other agents.
 As long as they are all using the same planning procedure they will all
 arrive at the same plan, removing the need to communicate.
\end_layout

\begin_layout Standard
Clearly there are disadvantages to this approach.
 There is significant duplication of effort as each agent plans an identical
 execution.
 It is also only applicable when full knowledge of the world is available,
 so that agents are planning from the same information.
 I will adopt ideas from this approach, but enable sharing the planning
 workload and the ability to communicate to determine the state of the world.
 
\end_layout

\begin_layout Standard
Many of the formalisms mentioned earlier provide a strategy for explicit
 coordination among agents, including GPGP 
\begin_inset LatexCommand \cite{decker95designing_coordination,Lesser04gpgp_taems}

\end_inset

, STEAM 
\begin_inset LatexCommand \cite{tambe97flexible_teamwork}

\end_inset

 and SharedPlans 
\begin_inset LatexCommand \cite{grosz99planning_together}

\end_inset

.
 It has not yet been determined what aspects of these approaches can be
 utilized to coordinate the execution of a shared Golog program.
\end_layout

\begin_layout Subsection
The Situation Calculus
\end_layout

\begin_layout Standard
The formal underpinnings of the most popular implementation of the High-Level
 Program Execution paradigm are a first-order theory of action known as
 the 
\emph on
Situation Calculus
\emph default
.
 This section describes the situation calculus and a variety of extensions
 that are necessary to properly represent multi-agent domains.
 
\end_layout

\begin_layout Subsubsection
The Basic Situation Calculus
\end_layout

\begin_layout Standard
The situation calculus is a (mostly) first-order logic formalism for describing
 and reasoning about dynamic worlds.
 It was introduced by McCarthy and Hayes in 
\begin_inset LatexCommand \cite{McCHay69sitcalc}

\end_inset

, and has since been significantly expanded and formalized 
\begin_inset LatexCommand \cite{reiter91frameprob,pirri99contributions_sitcalc,levesque98sc_foundations}

\end_inset

.
 The key elements of the situation calculus are:
\end_layout

\begin_layout Itemize

\series bold
Actions:
\series default
 function terms in the language denoting ways in which the state of the
 world can change.
\end_layout

\begin_layout Itemize

\series bold
Situations:
\series default
 histories of the actions that have occurred in the world
\end_layout

\begin_layout Itemize

\series bold
Fluents:
\series default
 functions or predicates taking a situation as their final argument, indicating
 properties of the world that may change from one situation to another.
\end_layout

\begin_layout Standard
Using these building blocks, along with some foundational axioms, it is
 possible to construct a 
\emph on
theory of action
\emph default
 
\begin_inset Formula $\Sigma$
\end_inset

, a collection of first-order logic sentences (along with a second-order
 induction axiom) that describes the behavior of a dynamic world.
 Queries about the state or behavior of the world can then be posed as entailmen
t queries in first-order logic.
\end_layout

\begin_layout Standard
One of the most attractive aspects of the situation calculus is that it
 permits an elegant monotonic solution to the infamous frame problem - the
 problem of specifying which properties of the world do not change between
 situations.
 Reiter 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

 describes how to construct 
\emph on
successor state axioms
\emph default
 which completely capture the change and non-change of a fluent with respect
 to various actions.
\end_layout

\begin_layout Subsubsection
Continuous and Concurrent Actions
\end_layout

\begin_layout Standard
Actions in the basic situation calculus are taken to be instantaneous, and
 can only happen in strict sequence.
 For multi-agent domains such limitations are unacceptable.
 Different agents may take different amount of time to perform the same
 action, making it necessary to represent continuous actions.
 There is also the possibility of several agents performing different actions
 at the same instant, necessitating an account of concurrency.
\end_layout

\begin_layout Standard
Fortunately, such issues have a long history in the situation calculus and
 mature formalisms exist for representing both.
 Concurrent actions are introduced in 
\begin_inset LatexCommand \cite{lin92sc_conc}

\end_inset

 and 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

 by using sets of actions to represent all the actions that occur at a given
 instant.
 Reiter simplifies this somewhat in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 by appealing to the standard axiomatisation of sets rather than defining
 a new set-like operator to combine action terms.
\end_layout

\begin_layout Standard
These papers, particularly 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

, also introduce a standard mechanism for dealing with actions that have
 finite duration.
 They are split into instantaneous 
\begin_inset Formula $begin$
\end_inset

 and 
\begin_inset Formula $end$
\end_inset

 actions and an accompanying fluent that indicates that the action is in
 progress.
\end_layout

\begin_layout Subsubsection
Explicit Time and Natural Actions
\end_layout

\begin_layout Standard
An explicit notion of time is introduced to the situation calculus in 
\begin_inset LatexCommand \cite{pinto94temporal}

\end_inset

, where the functions 
\begin_inset Formula $start(s)$
\end_inset

 and 
\begin_inset Formula $end(s)$
\end_inset

 denote the starting/ending time of a given situation.
 This was simplified somewhat by Reiter in 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

.
 The key to this representation is that each action has, as its final argument,
 the time at which it was performed.
 Since situations are just sequences of actions, this allows the timing
 of situations to be determined.
\end_layout

\begin_layout Standard
This mechanism interacts with the set-based representation of concurrent
 actions, as all actions that are performed concurrently are required to
 have the same occurrence time.
 In 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 a predicate 
\begin_inset Formula $coherent(c)$
\end_inset

 is introduced to enforce this requirement.
 An alternate approach is demonstrated for the related fluent calculus in
 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset

 where the occurrence time is attached directly to situations rather than
 actions.
 I will follow this modified approach.
\end_layout

\begin_layout Standard
Closely related to the temporal situation calculus is the notion of natural
 actions 
\begin_inset LatexCommand \cite{pinto94temporal,reiter96sc_nat_conc}

\end_inset

, those actions which must occur whenever it is possible for them to occur.
 These are typically used to represent predictable effects of nature, such
 as a dropped ball bouncing when it hits the ground.
 An additional predicate 
\begin_inset Formula $legal(s)$
\end_inset

 is introduced, which is true of precisely those situations that respect
 the occurance of natural actions.
\end_layout

\begin_layout Subsubsection
Knowledge
\end_layout

\begin_layout Standard
A robust account of knowledge is important when implementing distributed
 systems where cooperation is required, as the agents need to reason about
 the knowledge possessed by other agents.
 Knowledge can be added to the situation calculus by following the traditional
 
\begin_inset Quotes eld
\end_inset

possible worlds
\begin_inset Quotes erd
\end_inset

 semantics, as demonstrated in 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

.
 An extension of this account to handle time and concurrent actions is given
 in 
\begin_inset LatexCommand \cite{scherl03conc_knowledge}

\end_inset

, and the application of this approach in a multi-agent setting is described
 in 
\begin_inset LatexCommand \cite{Lesperance01epi_feas_casl}

\end_inset

.
\end_layout

\begin_layout Standard
There are, however, some limitations to the existing account.
 It is typically assumed that all agents are aware of all actions that occur,
 as this allows the successor-state-axiom approach of 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

 to be employed.
 When this assumption is not made, the other extreme is posited - that agents
 are only aware of actions that they themselves perform.
 Clearly many multi-agent domains fall somewhere between these extremes.
 A key contribution of my research is to produce an improved account of
 knowledge that lifts these assumptions while allowing reasoning about knowledge
 to remain tractable.
\end_layout

\begin_layout Subsubsection
Reasoning
\end_layout

\begin_layout Standard
One important aspect of the situation calculus is the tractability of reasoning
 within it.
 The key idea here is 
\emph on
regression
\emph default
, a technique for reducing reasoning about arbitrary future situations to
 reasoning solely about the initial situation.
 Introduced by Reiter to accompany his solution to the frame problem in
 
\begin_inset LatexCommand \cite{reiter91frameprob}

\end_inset

, the technique has been expanded to accommodate the various extensions
 outlined above - most importantly, to accommodate regressing formulae about
 knowledge 
\begin_inset LatexCommand \cite{scherl03sc_knowledge,scherl03conc_knowledge}

\end_inset

.
 Lin and Reiter demonstrate in 
\begin_inset LatexCommand \cite{Lin94-StateConstraints}

\end_inset

 how these techniques can also accommodate declarative state constraints,
 by compiling them into the direct effects of actions.
\end_layout

\begin_layout Standard
Unfortunately, quantification over situations typically requires the use
 of a second-order induction axiom 
\begin_inset LatexCommand \cite{Reiter93proving}

\end_inset

.
 While this is useful for proving properties of domain specifications manually,
 it has proved problematic for automated reasoning.
 I have developed a procedure for performing limited forms of quantification
 over situations that relies solely on first-order reasoning, allowing the
 regression idea to be used with a richer account of knowledge.
\end_layout

\begin_layout Subsubsection
Related Approaches
\end_layout

\begin_layout Standard
The situation calculus is one of a family of approaches to modeling dynamic
 worlds in first-order logic.
 Other approaches include the Event Calculus 
\begin_inset LatexCommand \cite{kowalski86event_calculus}

\end_inset

 and Fluent Calculus 
\begin_inset LatexCommand \cite{thielscher99fluentcalc,theilscher02flux}

\end_inset

.
 These formalisms all share the same basic concepts for describing the world,
 such as fluents and actions.
 Because of this, many techniques developed in one formalism can be imported
 to others without difficulty - for example, see the similarities between
 concurrency, time and natural actions in the situation calculus 
\begin_inset LatexCommand \cite{reiter96sc_nat_conc}

\end_inset

 and fluent calculus 
\begin_inset LatexCommand \cite{martin03conc_flux}

\end_inset

.
 I have chosen the situation calculus because it is the oldest and most
 widely understood of such formalisms, and with the understanding that my
 results will likely be applicable to other formalisms.
\end_layout

\begin_layout Standard
There is also a growing interest in using techniques from modal logic for
 such applications, particularly the combination of knowledge and action
 represented by epistemic dynamic logic 
\begin_inset LatexCommand \cite{herzig00edl_partial_obs}

\end_inset

.
 There have even been re-formulations of the situation calculus in modal
 logic 
\begin_inset LatexCommand \cite{Lakemeyer2005Semantic}

\end_inset

 and hybrid logic 
\begin_inset LatexCommand \cite{blackburn01hybrid_sitcalc}

\end_inset

.
 I have chosen to remain in first-order logic largely due to the availability
 of mature programming tools and systems such as Prolog.
 I also believe my ideas to be general enough that they could be imported
 to a modal formalism without difficulty.
\end_layout

\begin_layout Subsection
Golog
\begin_inset LatexCommand \label{sub:Golog}

\end_inset


\end_layout

\begin_layout Subsubsection
High-Level Program Execution and Golog
\end_layout

\begin_layout Standard
The programming language Golog builds on the situation calculus to provide
 a means for building 
\begin_inset Quotes eld
\end_inset

complex actions
\begin_inset Quotes erd
\end_inset

 from primitive actions using operators such as sequence, iteration and
 if-then-else.
 It is formally introduced in 
\begin_inset LatexCommand \cite{levesque97golog}

\end_inset

, but is based on ideas dating back much earlier.
 
\end_layout

\begin_layout Standard
Golog is an implementation of the more general paradigm of 
\emph on
High-Level Program Execution
\emph default
.
 As explained in 
\begin_inset LatexCommand \cite{Levesque98beyondplanning}

\end_inset

, high-level program execution is a tractable alternative to traditional
 goal-based planning for single-agent systems.
 Rather than simply specifying some goal state that is to be achieved, the
 programmer specifies a program that the agent should follow that will achieve
 the desired state.
 Crucially, this program may contain non-deterministic constructs where
 the agent is required to determine its sequence of actions at run-time,
 based on its knowledge of how the world behaves.
 Such programs can thus range from fully deterministic programming to full
 planning, depending on how much of the agent's plan the designer wishes
 to prescribe ahead of time.
\end_layout

\begin_layout Standard
The primary advantage of this approach is 
\emph on
controlled nondeterminism.
 
\emph default
The programmer can require the agent to perform as little or as much reasoning
 as the application warrants.
 At the same time, the programs can include very sophisticated symbolic
 reasoning about the world - it is straightforward to implement a purely
 goal-based planner in Golog.
 For a more detailed discussion of the advantages and applications of this
 approach, see 
\begin_inset LatexCommand \cite{Lesperance99sitcalc_approach,reiter01kia}

\end_inset

.
\end_layout

\begin_layout Standard
The Golog approach is contrasted with HTN in 
\begin_inset LatexCommand \cite{son00htn_golog}

\end_inset

, where the following advantages are highlighted:
\end_layout

\begin_layout Itemize
Provides a more natural representation of common constructs such as loops
 and if-then-else than HTN
\end_layout

\begin_layout Itemize
Uses a more sophisticated logic of actions than HTN
\end_layout

\begin_layout Standard
That Golog is a viable alternative for specifying and implementing agent
 behavior is highlighted by the many successful applications of the technique
 in different planning tasks, such as 
\begin_inset LatexCommand \cite{Finzi00open_world_sitcalc}

\end_inset

, 
\begin_inset LatexCommand \cite{pirri00planning_nat_acts}

\end_inset

, and 
\begin_inset LatexCommand \cite{baier03golog_planning}

\end_inset

.
\end_layout

\begin_layout Subsubsection
ConGolog
\end_layout

\begin_layout Standard
ConGolog 
\begin_inset LatexCommand \cite{giacomo00congolog,lesperance99modeling}

\end_inset

 is an extension to Golog that adds concurrency by means of interleaving
 - two programs can be run in parallel with steps of their execution interleaved
 together.
 This operator adds a great deal of flexibility to ConGolog programs - for
 example, they can simulate 
\begin_inset Quotes eld
\end_inset

interrupts
\begin_inset Quotes erd
\end_inset

 that are executed immediately when some condition becomes true in the environme
nt.
\end_layout

\begin_layout Standard
ConGolog was initially designed to operate only using basic situation calculus
 theories of action.
 The extension TConGolog is proposed in 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset

 to integrate interleaved concurrency with the true concurrency of actions
 mentioned above.
 However, the approach taken does not fully consider the implications of
 this integration and may, in certain circumstances, call for actions to
 be executed that cannot be performed in the world.
 A key aspect of my work is improving this integration to be more robust,
 and further integrating other extensions to the situation calculus.
\end_layout

\begin_layout Subsubsection
IndiGolog
\end_layout

\begin_layout Standard
Both Golog and ConGolog require the agent to construct a complete execution
 of the program before any actions are carried out in the world, as this
 is the only way it can be sure that the program will eventually run to
 completion.
 For large programs or those involving a lot of nondeterminism, this could
 be intractable.
 The language extension IndiGolog 
\begin_inset LatexCommand \cite{giacomo99indigolog}

\end_inset

 was introduced to allow planning to be interleaved with action.
 This is accomplished by adding a 
\begin_inset Quotes eld
\end_inset

search
\begin_inset Quotes erd
\end_inset

 operator.
 While programs within the scope of a search operator have a full execution
 planned as before, programs outside the search operator are executed with
 only a single step of look-ahead.
\end_layout

\begin_layout Standard
The original semantics of the search operator committed the agent to its
 initial choice of execution.
 Further enhancements 
\begin_inset LatexCommand \cite{Lesperance00improved_indigolog,giacomo04sem_delib_indigolog}

\end_inset

 commit the agent only to those actions it has already performed, allowing
 re-planning if the environment has changed.
\end_layout

\begin_layout Subsubsection
DTGolog
\end_layout

\begin_layout Standard
The situation calculus typically requires the world to be deterministic
 - actions always have the same, predictable effects.
 In many situations it is more realistic to assign probabilities to the
 effects of an action, indicating various ways in which it might fail or
 have unintended consequences.
 The branch of AI that deals with acting under such probabilistic models
 is known as Decision Theory.
 DTGolog 
\begin_inset LatexCommand \cite{boutilier00dtgolog}

\end_inset

 is an extension of the Golog semantics of include decision-theoretic concepts,
 such as determining the execution of a program with the highest expected
 utility.
 These techniques have been extended further by GTGolog 
\begin_inset LatexCommand \cite{finzi03gtgolog,finzi05pogtgolog}

\end_inset

, which introduces concepts from Game Theory.
\end_layout

\begin_layout Standard
While these extensions are certainly very powerful and allow Golog to be
 applied to a wider range of domains, they will not be included in my research
 program in order to keep the problem manageable within the time-frame of
 a PhD thesis.
 I anticipate that these techniques could be combined with my research output
 without significant difficulty.
\end_layout

\begin_layout Subsubsection
CASL 
\end_layout

\begin_layout Standard
The Cognitive Agent Specification Language
\begin_inset LatexCommand \cite{shapiro02casl,lesperance05ecasl}

\end_inset

 is an attempt to build a complete specification and simulation environment
 for multi-agent systems, using the situation calculus and ConGolog to provide
 a formal underpinning.
 While similar to this project in that it seeks to use Golog in a multi-agent
 context, it is focused more on the specification of open multi-agent systems
 rather than distributed problem solving with multi-agent teams.
 Consequently, each agent has its own individual control program written
 in ConGolog.
\end_layout

\begin_layout Standard
Despite this differing focus, many results from the CASL effort are applicable
 to my thesis - in particular, the account of knowledge for multi-agent
 systems documented in 
\begin_inset LatexCommand \cite{Lesperance01epi_feas_casl}

\end_inset

.
\end_layout

\begin_layout Subsubsection
ReadyLog
\end_layout

\begin_layout Standard
Closer in spirit to my research objectives is the work on Ferrein et.
 al.
 on applying the Golog variant ReadyLog to the control of a robotic soccer
 team 
\begin_inset LatexCommand \cite{Ferrein2003icpgolog_multi,Ferrein2005readylog}

\end_inset

.
 In their approach, the team of agents share a common ReadyLog program describin
g the actions to be performed.
 Each agent reasons individually to determine the best legal execution of
 the program, which they then carry out.
 Because the robotic soccer domain is completely observable, this allows
 the agents to coordinate their actions without the need to communicate.
\end_layout

\begin_layout Standard
I aim to support scenarios such as this, but also a broader range of application
s that:
\end_layout

\begin_layout Itemize
Take advantage of multiple agents to perform actions concurrently
\end_layout

\begin_layout Itemize
Take advantage of multiple agents to share the planning workload
\end_layout

\begin_layout Itemize
Allow communication and the ability to deal with partially observable domains
\end_layout

\begin_layout Subsubsection
Other Extensions
\end_layout

\begin_layout Standard
There have been numerous other extensions to the Golog paradigm to adapt
 it to different domains.
 Because its operators are defined declaratively and recursively, new operators
 or changed semantics can be incorporated in a straightforward manner without
 affecting the rest of the language.
 Examples include modifications for highly-dynamic domains 
\begin_inset LatexCommand \cite{grosskreutz00ccgolog}

\end_inset

, planning with explicit time 
\begin_inset LatexCommand \cite{Reiter98seq_temp_golog}

\end_inset

, and the integration of HTN techniques 
\begin_inset LatexCommand \cite{son00htn_golog,Son04golog+htn+time}

\end_inset

.
 As with DTGolog and its relatives, I do not consider these extensions in
 my research program but am confident that they will be compatible with
 my research.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Progress to Date
\end_layout

\begin_layout Standard
Through the course of my research so far, I have produced three manuscripts
 detailing extensions to the Situation Calculus and Golog, along with two
 software programs implementing these ideas.
 I have presented my work at three seminars within the department.
\end_layout

\begin_layout Subsection
Manuscripts
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

High-Level Program Execution for Multi-Agent Teams
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This paper describes a series of extensions to the semantics of IndiGolog
 that allow it to better represent multi-agent domains, and take advantage
 of the inherent parallelism they offer.
 It is an integration and extension of several existing techniques.
 In particular, the language offers:
\end_layout

\begin_layout Itemize
A combined account of true and interleaved concurrency, that is more robust
 than the work of 
\begin_inset LatexCommand \cite{pinto99tcongolog}

\end_inset


\end_layout

\begin_layout Itemize
An explicit notion of time, similar to that of 
\begin_inset LatexCommand \cite{Reiter98seq_temp_golog,reiter96sc_nat_conc}

\end_inset

 but avoiding the need to check coherency of concurrent actions
\end_layout

\begin_layout Itemize
The tight integration of natural actions, with all legal executions guaranteed
 to produce legal situations
\end_layout

\begin_layout Standard
The paper was submitted to the AAMAS'06 and AAAI'06 conferences, but has
 not yet been accepted for publication.
 Further submission is planned to IAT'06, incorporating feedback from previous
 conference reviewers.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

Property Persistence in the Situation Calculus
\begin_inset Quotes erd
\end_inset


\begin_inset LatexCommand \label{sub:Property-Persistence}

\end_inset


\end_layout

\begin_layout Standard
Currently in first draft stage, this paper describes a procedure for reasoning
 about the persistence of properties in a situation calculus theory of action.
 The type of reasoning it allows is as follows: given that a property 
\begin_inset Formula $\phi$
\end_inset

 is true in a situation 
\begin_inset Formula $s$
\end_inset

, under what circumstances will it remain true in all situations in the
 future of 
\begin_inset Formula $s$
\end_inset

? Such reasoning is required for my improved account of knowledge, where
 the agents must consider possible any arbitrary sequence of actions that
 they would not have observed.
 It is also useful for more general reasoning, such as verifying that state
 constraints are always satisfied.
\end_layout

\begin_layout Standard
The second-order induction that is typically required for such reasoning
 is replaced by iterated first-order reasoning, by defining an operator
 
\begin_inset Formula $\mathcal{P}^{1}[\phi]$
\end_inset

 that gives the conditions under which 
\begin_inset Formula $\phi$
\end_inset

 will remain true in immediate successor situations.
 By iteratively seeking a fixed-point for this operator, the conditions
 under which 
\begin_inset Formula $\phi$
\end_inset

 remains true in all future situations can be determined.
\end_layout

\begin_layout Standard
Submission is planned to the IJCAI'07 and AI'06 conferences.
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

Multi-Agent Knowledge in the Situation Calculus with Partial Awareness of
 Actions
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Currently in second draft stage, this paper extends existing accounts of
 knowledge in the multi-agent situation calculus 
\begin_inset LatexCommand \cite{scherl03conc_knowledge,Lesperance01epi_feas_casl}

\end_inset

.
 Such approaches typically assume that all agents are aware of all actions
 that occur.
 I relax this assumption by allowing the conditions under which each agent
 will be aware of the occurrence of an action to be explicitly axiomatised.
 Agents then consider possible all legal situations that could have come
 about without them being aware.
 I extend the regression operator of 
\begin_inset LatexCommand \cite{scherl03sc_knowledge}

\end_inset

 to this new account, which requires reasoning about the persistence of
 properties as detailed in section 
\begin_inset LatexCommand \ref{sub:Property-Persistence}

\end_inset

.
\end_layout

\begin_layout Standard
Submission is planned to the IJCAI'07 and AI'06 conferences.
\end_layout

\begin_layout Subsection
Software
\end_layout

\begin_layout Subsubsection
An implementation of MIndiGolog using the CIAO Prolog system
\end_layout

\begin_layout Standard
This system is similar to previous implementations of the Golog language,
 but using the modified semantics of MIndiGolog.
 It performs the functions of a centralized multi-agent planner: given a
 team program, it finds a complete legal execution that specifies the actions
 of all agents.
 These actions could then be communicated to each agent for execution.
\end_layout

\begin_layout Subsubsection
An implementation of MIndiGolog using the Mozart programming system
\end_layout

\begin_layout Standard
This system utilizes the distributed logic programming capabilities of Mozart
 to allow a team of agents to share the workload of planning a legal execution.
 Control is still centralized as in the Prolog-based system - a master agent
 must coordinate and distribute the reasoning tasks to the other agents,
 then collate and distribute the final solution.
 It represents a first step towards truly distributed execution of MIndiGolog
 programs.
\end_layout

\begin_layout Subsection
Presentations
\end_layout

\begin_layout Subsubsection
15/11/05: Agentlab Seminar on Golog
\end_layout

\begin_layout Standard
On the 15th of November 2005, I presented a 1-hour seminar to the departmental
 Agentlab group giving a summary of the Golog family of programming languages,
 their advantages and applications.
\end_layout

\begin_layout Subsubsection
29/11/05: Agentlab Seminar on MIndiGolog
\end_layout

\begin_layout Standard
On the 29th of November 2005, I presented a 1-hour seminar to the departmental
 Agentlab group.
 I described my research aims and presented my initial extensions to the
 IndiGolog programming language to allow it to better represent the behavior
 of multi-agent teams.
\end_layout

\begin_layout Subsubsection
07/04/06: CSSE Postgraduate Seminar
\end_layout

\begin_layout Standard
On the 7th of April 2006, I presented a 1-hour seminar as part of the department
's postgraduate seminar series.
 The seminar provided a description of my research objectives, a summary
 of the work to date, and a brief discussion of ideas for future work.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
In addition to completing the in-progress manuscripts described above, I
 anticipate producing two additional major works during the progression
 of my research - a manuscript describing a distributed execution algorithm,
 and a software system implementing these ideas.
 These four manuscripts, together with a description and evaluation of the
 implemented software systems, will be merged to form the body of my final
 thesis.
\end_layout

\begin_layout Subsection
Manuscripts
\end_layout

\begin_layout Subsubsection
\begin_inset Quotes eld
\end_inset

Distributed Execution of MIndiGolog Programs
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
This paper will describe a coordination strategy allowing a team of agents
 to execute a shared MIndiGolog program without the need for centralized
 control, with incomplete knowledge in partially observable environments.
 The techniques used will be based on standard techniques for coordination
 in DPS, adapted to the Golog paradigm.
 I am currently aiming for submission to the AAMAS'07 conference.
\end_layout

\begin_layout Subsection
Software
\end_layout

\begin_layout Subsubsection
An implementation of MIndiGolog with Distributed Execution
\end_layout

\begin_layout Standard
This system will implement the strategy described in the above paper, providing
 a practical demonstration of the utility of the techniques developed in
 my thesis.
 While an initial implementation will be completed using CIAO Prolog, implementa
tions in Mozart and/or Mercury will be considered to increase the efficiency
 of the system.
\end_layout

\begin_layout Subsection
Research Timeline
\end_layout

\begin_layout Standard
The following is the proposed timeline for completion of my thesis:
\end_layout

\begin_layout Itemize

\series bold
Now - June 2006:
\series default
 Finalize existing papers for submission to IAT'06, IJCAI'07 and AI'06 conferenc
es.
 Preliminary development of distributed execution strategy.
\end_layout

\begin_layout Itemize

\series bold
July - October 2006:
\series default
 Finalize distributed execution strategy.
 Prepare manuscript for submission to AAMAS'07.
\end_layout

\begin_layout Itemize

\series bold
Nov 2006 - June 2007:
\series default
 Begin composing manuscripts into final thesis.
 First implementation of final system in Prolog.
 First draft of thesis.
\end_layout

\begin_layout Itemize

\series bold
July - Nov 2007:
\series default
 Finalize implementation.
 Perform testing using networked departmental machines as agents.
 Second draft of thesis.
\end_layout

\begin_layout Itemize

\series bold
Nov 2007 - Apr 2008:
\series default
 Finalization of thesis.
 Thesis submission.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{/storage/uni/pgrad/library/references}

\end_inset


\end_layout

\end_body
\end_document
