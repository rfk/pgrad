\documentclass{beamer}

\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}
\newcommand{\Dt}{\mathcal{D}}
\newcommand{\Reg}{\mathcal{R}}
\newcommand{\Pst}{\mathcal{P}}
\newcommand{\Trn}{\mathcal{T}}
\newcommand{\Kln}{\mathcal{K}}
\newcommand{\TrnA}{\Trn_{a}}
\newcommand{\EKnows}{\mathbf{EKnows}}
\newcommand{\Knows}{\mathbf{Knows}}
\newcommand{\CKnows}{\mathbf{CKnows}}
\newcommand{\KnowsZ}{\mathbf{Knows_{0}}}
\newcommand{\PKnowsZ}{\mathbf{PKnows_{0}}}
\newcommand{\PKnows}{\mathbf{PKnows}}
\newcommand{\KTrans}{\mathbf{KDo}}
\newcommand{\KDo}{\mathbf{KDo}}
\newcommand{\EDo}{\mathbf{EDo}}
\newcommand{\vars}[1]{\bar{#1}}
\newcommand{\PbU}{PbU}

\mode<presentation>{\usetheme{Dresden}}

\usepackage{fancyvrb}

\title{Asynchronous Multi-Agent Domains\\ in the Situation Calculus}
\author[Ryan Kelly]{Ryan Kelly\\ Supervisor: Adrian Pearce}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Contributions}
  Powerful extensions to the Situation Calculus for representing and reasoning
  about rich, asynchronous multi-agent domains:
  \ \\
  \ \\
  \begin{itemize}
  \item Multi-agent Golog with distributed execution planning
  \item Techniques for effective inductive reasoning
  \item Reasoning about knowledge with hidden actions
  \item Reasoning about group-level knowledge modalities
  \item Planning joint executions with partial observability
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

\section{Situation Calculus}

\begin{frame}
\frametitle{The Situation Calculus}
\emph{Actions} are instantaneous events causing the world to change
\begin{itemize}
  \item $pickup(Thomas,Bowl)$, $beginTask(Richard,mix(Bowl,1))$
\end{itemize}
\emph{Situations} are histories of actions that have been performed
\begin{itemize}
  \item $S_0$, $do(pickup(Harriet,Knife),S_0)$
\end{itemize}
\emph{Fluents} are situation-dependent properties of the world
\begin{itemize}
  \item $Poss(a,s)$, $Holding(Harriet,Knife,s)$
\end{itemize}
\emph{Successor State Axioms} define what holds after an action in terms of what held before the action
\begin{itemize}
  \item $Holding(agt,obj,do(a,s)) \equiv a = pickup(agt,obj)$ \\
        $\,\,\,\,\,\,\,\,\,\,\,\,\,\vee Holding(agt,obj,s) \wedge \neg\left(a = drop(agt,obj)\right)$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The Situation Calculus}
From these components we can built a first-order \emph{Theory of Action}
$\Dt$, with which agents can:
\begin{itemize}
  \item Reason about when actions are possible
  \item Reason about the effects of actions
  \item Represent sequences of actions as situations:\[
\left[a_1, a_2, a_3, a_4\right] \rightarrow do(a_4,do(a_3,do(a_2,do(a_1,S_0))))
\]
\end{itemize}
\pause
But, what about more complex actions and procedures?
\begin{itemize}
  \item $\mathbf{if}\ available(Item)\ \mathbf{then}\ pickup(Item)\ \mathbf{else}\ beSad$
  \item $\mathbf{while}\ (\exists block)\ ontable(block)\ \mathbf{do}\ remove(block)\ \mathbf{endWhile}$
  \item $\mathbf{proc}\ remove(block)\ [pickup(block);putaway(block)]\ \mathbf{endProc}$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Golog}
Golog introduces programs to the SitCalc via "complex actions".
Primitive actions are composed using operators such as:

\begin{itemize}
  \item $\delta_1;\delta_2$ - Perform two programs in sequence
  \item $\phi?$ - Assert that a condition holds
  \item $\delta_1|\delta_2$ - Choose between programs to execute
  \item $\pi(x,\ \delta(x))$ - Choose suitable bindings for variables
  \item $\delta^*$ - Execute a program zero or more times
  \item $\delta_1 || \delta_2$ - Execute programs concurrently
\end{itemize}
\ \\
\ \\
\pause
Key Point:  programs can include \alert{nondeterminism}
\end{frame}

\begin{frame}
\frametitle{A Quick Example}
Consider a Golog program for getting to uni of a morning:\[
\begin{array}{c}
ringAlarm;(hitSnooze; ringAlarm)^*;turnOffAlarm;\\
\pi(food,\ edible(food)?;eat(food)); haveShower; brushTeeth\\
(driveToUni\ |\ trainToUni); (time<9:00)?
\end{array}\]

There are potentially many ways to execute this progream, depending on which 
actions are possible in the world.
\pause
\ \\
\ \\
Use theory of action to plan a \emph{Legal Execution}:\[
\mathbf{D} \models \exists s,\delta' . Trans*(\delta,S_0,\delta',s) \wedge Final(\delta',s)\]

\end{frame}

\begin{frame}
\frametitle{Why the Situation Calculus?}
\begin{itemize}
\item Elegant, monotonic solution to frame problem
\item Effective reasoning techniques based on Regression
\item Straightforward implementation as a logic program
\item Powerful nondeterminism control for programming/planning
\item Large body of existing work and results
\item Many useful extensions for rich domain features...
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Extending the Situation Calculus}
\begin{itemize}
\pause
\item Concurrent Actions:\ \ \ $do(\{a_1,a_2\},s)$
\pause
\item Continuous time:\ \ \ $do(c,t,s)$
\pause
\item Long-running tasks:\ \ \ $begin(t)$, $doing(t,s)$, $end(t)$
\pause
\item Natural processes:\ \ \ $Legal(a,s)\rightarrow\neg\exists n: nat(n) \wedge Poss(n,s)$
\pause
\item Incomplete knowledge:\ \ \ $\Knows(\phi,s)$
\pause
\item Asynchronous multi-agent domains:\ \ \ ???
\end{itemize}
\ \\
\ \\
\pause
Our work continues this proud tradition.
\end{frame}

\section{MIndiGolog}

\begin{frame}
\frametitle{MIndiGolog}
Vision:
\begin{itemize}
\item Agents cooperate to plan and perform the execution of a shared Golog program
\end{itemize}
\ \\
\ \\
Contributions
\begin{itemize}
\item Merge concurrent actions with concurrent program execution
\item Integrate time and natural actions for coordination
\item Share planning workload using distributed logic programming
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Motivating Example: The Cooking Agents}
Several robotic chefs inhabit a kitchen, along with various ingredients,
appliances and utensils.  They must cooperate to produce a meal consisting
of several dishes.\\
\ \\
\pause
Challenges:
\begin{itemize}
  \item Encoding procedural knowledge
  \item Concurrent execution of tasks
  \item Conflict over shared resources
  \item Coordination of shared actions
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Example Programs}

Consider some programs we might write for this domain:

\begin{columns}
  \begin{column}{0.5\textwidth}
\[
\pause
\begin{array}{c}
\mathbf{proc}\ ChopTypeInto(type,dest)\\
\pi((agt,obj), \ \ \ \ \ \ \ \\
IsType(obj,type)?\ ;\\
Chop(agt,obj)\ ;\\
PlaceIn(agt,obj,dest))\\
\mathbf{end}\end{array}\]
  \end{column}
  \begin{column}{0.5\textwidth}
\[
\pause
\begin{array}{c}
\mathbf{proc}\ MakeSalad(bowl)\\
(ChopTypeInto(Lettuce,bowl)\ ||\\
ChopTypeInto(Carrot,bowl)\ ||\\
ChopTypeInto(Tomato,bowl)\ )\ ;\\
\pi(agt, Mix(agt,dest,1))\\
\mathbf{end}\end{array}\]
  \end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{MIndiGolog Semantics}
Single-steps of computation are specified by  $Trans(\delta,s,\delta',s')$.
\begin{itemize}
  \item $Trans(a,s,nil,s')\ \equiv\ Poss(a,s)\wedge s'=do(a,s)$
  \item $Trans(\delta_1|\delta_2,s,\delta',s')\ \equiv\ Trans(\delta_1,s,\delta',s')\vee Trans(\delta_2,s,\delta',s')$
  \item $Trans(\delta_1||\delta_2,s,\delta',s')\ \equiv\ \exists\gamma:Trans(\delta_1,s,\gamma,s')\wedge\delta'=(\gamma||\delta_2)$\\
        $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vee\ \exists\gamma:Trans(\delta_2,s,\gamma,s')\wedge\delta'=(\delta_1||\gamma)$
  \item $\dots$
\end{itemize}
\ \\
\pause
Termination is indicated by $Final(\delta,s)$
\begin{itemize}
  \item $Final(nil,s) \equiv true$
  \item $Final(\delta_1|\delta_2,s) \equiv Final(\delta_1,s)\vee Final(\delta_2,s)$
  \item $\dots$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{MIndiGolog Semantics}
Agents should take advantage of true concurrency. Basic idea:
\begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\exists\gamma\,.\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})\\
\shoveright{\vee\exists\gamma\,.\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\wedge}\\ 
Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)
\end{multline*}
\end{frame}

\begin{frame}
\frametitle{Example Output}
\begin{columns}
  \begin{column}{0.5\textwidth}
    \VerbatimInput[fontsize=\tiny]{output_makeSalad_1.txt}
  \end{column}
  \begin{column}{0.5\textwidth}
    \VerbatimInput[fontsize=\tiny]{output_makeSalad_2.txt}
  \end{column}
\end{columns}
\ \\
\ \\
\pause
Can give idle agents other work using:\[
MakeSalad(Bowl1)\ ||\ MakeCake(Bowl2)\ ||\ \dots\]
\end{frame}

\section{Asynchronicity}

\begin{frame}
\end{frame}

\section{Knowledge}

\begin{frame}
\end{frame}

\section{Group Knowledge}

\begin{frame}
\end{frame}

\section{Joint Execution}

\begin{frame}
\end{frame}

\section{Conclusions}

\begin{frame}
\end{frame}

\end{document}
