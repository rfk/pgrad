\documentclass{beamer}

\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}
\newcommand{\Dt}{\mathcal{D}}
\newcommand{\Reg}{\mathcal{R}}
\newcommand{\Pst}{\mathcal{P}}
\newcommand{\Trn}{\mathcal{T}}
\newcommand{\Kln}{\mathcal{K}}
\newcommand{\TrnA}{\Trn_{a}}
\newcommand{\EKnows}{\mathbf{EKnows}}
\newcommand{\Knows}{\mathbf{Knows}}
\newcommand{\CKnows}{\mathbf{CKnows}}
\newcommand{\KnowsZ}{\mathbf{Knows_{0}}}
\newcommand{\PKnowsZ}{\mathbf{PKnows_{0}}}
\newcommand{\PKnows}{\mathbf{PKnows}}
\newcommand{\KTrans}{\mathbf{KDo}}
\newcommand{\KDo}{\mathbf{KDo}}
\newcommand{\EDo}{\mathbf{EDo}}
\newcommand{\vars}[1]{\bar{#1}}
\newcommand{\PbU}{PbU}

\mode<presentation>{\usetheme{Dresden}}

\usepackage{fancyvrb}
\usepackage{bibentry}
\usepackage[numbers]{natbib}

\title{Asynchronous Multi-Agent Domains\\ in the Situation Calculus}
\author[Ryan Kelly]{Ryan Kelly\\ Supervisor: Adrian Pearce}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Contributions}
  Powerful extensions to the Situation Calculus for representing and reasoning
  about rich, asynchronous multi-agent domains:
  \ \\
  \ \\
  \begin{itemize}
  \item Multi-agent Golog with distributed execution planning
  \item Reasoning about knowledge with hidden actions
  \item Techniques for effective inductive reasoning
  \item Reasoning about group-level knowledge modalities
  \item Planning joint executions with partial observability
  \end{itemize}
\end{frame}

\section{Situation Calculus}

\begin{frame}
\frametitle{The Situation Calculus}
A formalism for reasoning about dynamic worlds.
\ \\
\ \\
\emph{Actions} are instantaneous events causing the world to change
\begin{itemize}
  \item $pickup(Thomas,Bowl)$, $beginTask(Richard,mix(Bowl,1))$
\end{itemize}
\ \\
\ \\
\emph{Situations} are histories of actions that have been performed
\begin{itemize}
  \item $S_0$, $do(pickup(Harriet,Knife),S_0)$
\end{itemize}
\ \\
\ \\
\emph{Fluents} are situation-dependent properties of the world
\begin{itemize}
  \item $Poss(a,s)$, $Holding(Harriet,Knife,s)$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The Situation Calculus}
\emph{Successor State Axioms} define what holds after an action in terms of what held before the action
\begin{itemize}
  \item $Holding(agt,obj,do(a,s)) \equiv a = pickup(agt,obj)$ \\
        $\,\,\,\,\,\,\,\,\,\,\,\,\,\vee Holding(agt,obj,s) \wedge \neg\left(a = drop(agt,obj)\right)$
\end{itemize}
\ \\
\ \\
\pause
From these components we can built a first-order \emph{Theory of Action}
with which agents can:
\begin{itemize}
  \item Reason about when actions are possible
  \item Reason about the effects of actions
  \item Represent sequences of actions as situations:\[
\left[a_1, a_2, a_3, a_4\right] \rightarrow do(a_4,do(a_3,do(a_2,do(a_1,S_0))))
\]
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Golog}
Golog introduces programming to the situation calculus.\\
Primitive actions are composed using operators such as:

\begin{itemize}
  \item $a$ - Perform a primitive action
  \item $\delta_1;\delta_2$ - Perform two programs in sequence
  \item $\phi?$ - Assert that a condition holds
  \item $\delta_1|\delta_2$ - Choose between programs to execute
  \item $\pi(x,\ \delta(x))$ - Choose suitable bindings for variables
  \item $\delta^*$ - Execute a program zero or more times
  \item $\delta_1 || \delta_2$ - Execute programs concurrently
\end{itemize}
\ \\
\ \\
\pause
Key Point:  programs can include \alert{nondeterminism}
\end{frame}

\begin{frame}
\frametitle{A Quick Example}
Consider a Golog program for getting to uni of a morning:\[
\begin{array}{c}
ringAlarm;(hitSnooze; ringAlarm)^*;turnOffAlarm;\\
\pi(food,\ edible(food)?;eat(food)); haveShower; brushTeeth\\
(driveToUni\ |\ trainToUni); (time<9:00)?
\end{array}\]

There are potentially many ways to execute this program, depending on which 
actions are possible in the world.
\pause
\ \\
\ \\
Use theory of action to plan a \emph{Legal Execution}:\[
\Dt \models \exists s,\delta': Trans^{*}(\delta,S_0,\delta',s) \wedge Final(\delta',s)\]

\end{frame}

\begin{frame}
\frametitle{Why the Situation Calculus?}
\begin{itemize}
\item Elegant, monotonic solution to frame problem
\item Effective reasoning techniques based on Regression
\item Straightforward implementation as a logic program
\item Powerful nondeterminism control for programming/planning
\item Large body of existing work and results
\item Many useful extensions for rich domain features...
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Extending the Situation Calculus}
\begin{itemize}
\pause
\item Concurrent Actions:\ \ \ $do(\{a_1,a_2\},s)$
\pause
\item Continuous time:\ \ \ $do(c,t,s)$
\pause
\item Long-running tasks:\ \ \ $begin(t)$, $doing(t,s)$, $end(t)$
\pause
\item Natural processes:\ \ \ $Legal(a,s)\rightarrow\neg\exists n: nat(n) \wedge Poss(n,s)$
\pause
\item Incomplete knowledge:\ \ \ $\Knows(\phi,s)$
\pause
\item Asynchronous multi-agent domains:\ \ \ ???
\end{itemize}
\ \\
\ \\
\pause
Our work continues this proud tradition.
\end{frame}

\section{MIndiGolog}

\begin{frame}
\frametitle{Motivating Example: The Cooking Agents}
Several robotic chefs inhabit a kitchen, along with various ingredients,
appliances and utensils.  They must cooperate to produce a meal consisting
of several dishes.\\
\ \\
\pause
Challenges:
\begin{itemize}
  \item Encoding procedural knowledge
  \item Concurrent execution of tasks
  \item Conflict over shared resources
  \item Coordination of shared actions
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{MIndiGolog}
Vision:
\begin{itemize}
\item Agents cooperate to plan and perform the execution of a shared Golog program
\end{itemize}
\ \\
\ \\
Contributions
\begin{itemize}
\item Merge concurrent actions with concurrent program execution
\item Integrate time and natural actions for coordination
\item Share planning workload using distributed logic programming
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Example Programs}

Consider some programs we might write for this domain:

\begin{columns}
  \begin{column}{0.5\textwidth}
\[
\pause
\begin{array}{c}
\mathbf{proc}\ MakeSalad(bowl)\\
(ChopTypeInto(Lettuce,bowl)\ ||\\
ChopTypeInto(Carrot,bowl)\ ||\\
ChopTypeInto(Tomato,bowl)\ )\ ;\\
\pi(agt, Mix(agt,dest,1))\\
\mathbf{end}\end{array}\]
  \end{column}
  \begin{column}{0.5\textwidth}
\[
\pause
\begin{array}{c}
\mathbf{proc}\ ChopTypeInto(type,dest)\\
\pi((agt,obj), \ \ \ \ \ \ \ \\
IsType(obj,type)?\ ;\\
Chop(agt,obj)\ ;\\
PlaceIn(agt,obj,dest))\\
\mathbf{end}\end{array}\]
  \end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{MIndiGolog Semantics}
Agents should take advantage of true concurrency. Basic idea:
\begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\exists\gamma\,.\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})\\
\shoveright{\vee\exists\gamma\,.\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\end{multline*}
\end{frame}

\begin{frame}
\frametitle{MIndiGolog Semantics}
Agents should take advantage of true concurrency. Basic idea:
\begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\exists\gamma\,.\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})\\
\shoveright{\vee\exists\gamma\,.\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))\wedge}\\ 
Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\delta'=(\gamma_{1}||\gamma_{2})\wedge s'=do(c_{1}\cup c_{2},t,s)
\end{multline*}
\end{frame}

\begin{frame}
\frametitle{MIndiGolog Semantics}
The combination of actions $(c_1\cup c_2)$ may not be possible.
\begin{itemize}
  \item Must check this explicitly
\end{itemize}
\ \\
\ \\
The same \emph{agent-initiated} action mustn't $Trans$ both programs.
\begin{itemize}
  \item otherwise dangerous 'skipping' of actions can occur
  \item if two concurrent programs both call for $pay(Ryan,\$100)$ to be performed, it had better be performed twice!
  \item Natural actions can transition both programs
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{MIndiGolog Semantics}
\begin{multline*}
Trans(\delta_{1}||\delta_{2},s,\delta',s')\equiv\exists\gamma\,.\, Trans(\delta_{1},s,\gamma,s')\wedge\delta'=(\gamma||\delta_{2})\\
\shoveright{\vee\exists\gamma\,.\, Trans(\delta_{2},s,\gamma,s')\wedge\delta'=(\delta_{1}||\gamma)}\\
\shoveright{\vee\exists c_{1},c_{2},\gamma_{1},\gamma_{2},t\,.\, Trans(\delta_{1},s,\gamma_{1},do(c_{1},t,s))}\\
\shoveright{\wedge Trans(\delta_{2},s,\gamma_{2},do(c_{2},t,s))\wedge\delta'=(\gamma_1||\gamma_2)\wedge s'=do(c_1\cup c_2,t,s)}\\
\wedge Poss(c_1\cup c_2,t,s)\wedge\forall a.\left[a\in c_{1}\wedge a\in c_{2}\rightarrow Natural(a)\right]
\end{multline*}
\end{frame}

\begin{frame}
\frametitle{MIndiGolog Semantics}
Previous work required the programmer to explicitly predict natural actions
and include them in the program.
\ \\
\ \\
We modify $Trans$ to predict the occurrence of natural actions automatically.
\begin{itemize}
  \item The programmer can completely ignore natural actions
  \item Relevant ones can be included directly in the program, to mean "wait for this natural action to occur"
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{MIndiGolog Execution}
\begin{itemize}
 \item Agents can each plan a legal execution individually
 \item Identical search strategy produces identical results
 \item Coordination without communication!
\end{itemize}
\ \\
\ \\
But, we can also take advantage of communication to share the planning
workload between agents.
\end{frame}

\begin{frame}
\frametitle{MIndiGolog Execution}
The semantics of Golog can be neatly encoded as a logic program.
Prolog is traditionally used.
We use Oz for its strong distributed programming support.

\VerbatimInput[fontsize=\scriptsize,frame=lines]{goloz_trans.oz}

\end{frame}

\begin{frame}
\frametitle{MIndiGolog Execution}
Using the builtin ParallelSearch object, the agents can transparently
share the planning workload:

\VerbatimInput[fontsize=\scriptsize,frame=lines]{goloz_do_parallel.oz}

\end{frame}

\begin{frame}
\frametitle{Example Output}
\begin{columns}
  \begin{column}{0.5\textwidth}
    \VerbatimInput[fontsize=\tiny]{output_makeSalad_1.txt}
  \end{column}
  \begin{column}{0.5\textwidth}
    \VerbatimInput[fontsize=\tiny]{output_makeSalad_2.txt}
  \end{column}
\end{columns}
\ \\
\ \\
\pause
Can give idle agents other work using:\[
MakeSalad(Bowl1)\ ||\ MakeCake(Bowl2)\ ||\ \dots\]
\end{frame}

\begin{frame}
\frametitle{Limitations}
This works well, but it depends on two assumptions:
\ \\
\ \\
\pause
Complete knowledge:
\begin{itemize}
\item linear plan
\item no sensing required
\end{itemize}
\ \\
\ \\
\pause
Synchronous domain:
\begin{itemize}
\item agents proceed in lock-step
\end{itemize}
\end{frame}

\section{Asynchronicity}

\begin{frame}
\frametitle{Synchronicity}
Synchronous domains:
\begin{itemize}
\item when an action occurs, everyone knows an action has occurred
\end{itemize}
\ \\
\ \\
Nearly universal in the literature: "assume all actions are public".
\ \\
\ \\
\pause
\alert{Challenge:}  Regression depends intimately on synchronicity

\end{frame}

\begin{frame}
\frametitle{Regression}
Regression operates by unwinding actions one at a time:
\ \\
\ \\
$\Reg(Holding(agt,obj,do(c,s))) \Rightarrow$\\
$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,pickup(agt,obj) \in c$ \\
$\,\,\,\,\,\,\,\,\,\,\,\,\,\vee Holding(agt,obj,s) \wedge \neg\left(drop(agt,obj) \in c\right)$
\ \\
\ \\
\pause
By repeatedly applying it, we get a query about $S_0$:
\[
\Dt\models\phi[do(c_1,do(c_2,\dots,S_0))]\,\,\,\,\mathrm{iff}\,\,\,\,\Dt\models\Reg^{*}(\phi)[S_0]
\]
\ \\
\ \\
\pause
If you don't know the current situation, you cannot reason using regression.
\end{frame}

\begin{frame}
\frametitle{Observations}
First, we must represent asynchronicity.\\
We reify the \emph{observations} made by each agent:
\ \\
\ \\
\small
$Obs(agt,c,s) = o$
\ \\
\ \\
$View(agt,S_0) = \epsilon$\\
$Obs(agt,c,s) = \{\} \rightarrow View(agt,do(c,s)) = View(agt,s)$\\
$Obs(agt,c,s) \neq \{\} \rightarrow View(agt,do(c,s)) = Obs(agt,c,s) \cdot View(agt,s)$
\normalsize
\ \\
\ \\
If $Obs(agt,c,s)=\{\}$ then the actions are completely hidden.
\end{frame}

\begin{frame}
\frametitle{Observations}
Action:  global event changing the state of the world\\
Observation:  local event changing an agent's knowledge
\ \\
\ \\
Situation:  global history of actions giving current world state\\
View:  local history of observations giving current knowledge
\ \\
\ \\
\pause
How can we let agents reason using only their local view?
\end{frame}

\section{Knowledge}

\begin{frame}
\frametitle{Knowledge}
If an agent is unsure about the state of the world, there must be several
different states of the world that it considers possible.

\begin{center}
  \includegraphics[scale=0.4]{poss_worlds.png}
\end{center}

The agent \emph{knows} $\phi$ iff $\phi$ is true in all possible worlds.
\end{frame}

\begin{frame}
\frametitle{Knowledge}
Introduce a possible-worlds fluent $K(agt,s',s)$:

\begin{center}
  \includegraphics[scale=0.5]{k_relation.png}
\end{center}

We can then define knowledge as a simple macro:
\[ \mathbf{Knows}(agt,\phi,s)\ \isdef\ \forall s'\left[K(agt,s',s)\rightarrow \phi(s')\right] \]
\end{frame}

\begin{frame}
\frametitle{Knowledge: The Synchronous Case}
In the syncrhonous case, $K$ has a simple successor state axiom:
\ \\
\ \\
\begin{multline*}
 K_0(agt,s'',do(c,s)) \equiv \exists s',c':\ s''=do(c',s') \wedge K_0(agt,s',s)\\
  \wedge Poss(c',s') \wedge Obs(agt,c,s) = Obs(agt,c',s')
\end{multline*}
\ \\
\ \\
And a correspondingly simple regression rule:
\ \\
\ \\
\begin{multline*}
 \Reg(\KnowsZ(agt,\phi,do(c,s))\ \isdef\ \exists o: Obs(agt,c,s)=o\\
  \wedge \forall c': \KnowsZ(agt,Poss(c')\wedge Obs(agt,c')=o \rightarrow \Reg(\phi,c'))
  \wedge Poss(c',s') \wedge Obs(agt,c,s) = Obs(agt,c',s')
\end{multline*}

\end{frame}


\section{Group Knowledge}

\begin{frame}
\end{frame}

\section{Joint Execution}

\begin{frame}
\end{frame}

\section{Conclusions}

\begin{frame}
  \frametitle{Contributions}
  Powerful extensions to the Situation Calculus for representing and reasoning
  about rich, asynchronous multi-agent domains:
  \ \\
  \ \\
  \begin{itemize}
  \item Multi-agent Golog with distributed execution planning
  \item Techniques for effective inductive reasoning
  \item Reasoning about knowledge with hidden actions
  \item Reasoning about group-level knowledge modalities
  \item Planning joint executions with partial observability
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Publications}
\begin{itemize}
\item \bibentry{kelly06hlp_dps}
\item \bibentry{kelly07sc_persistence}
\item \bibentry{kelly07sc_know_obs}
\item \bibentry{kelly08complex_epistemic_modalities}
\end{itemize}

\end{frame}

\end{document}
