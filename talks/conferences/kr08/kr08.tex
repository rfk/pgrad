\documentclass[compress]{beamer}

\mode<presentation>
{
  \usetheme{Dresden}
%  \setbeamercovered{transparent}
}

\usepackage[english]{babel}

\usepackage[latin1]{inputenc}

\usepackage{amsmath}
\usepackage[all]{xy}

\usepackage{times}
\usepackage[T1]{fontenc}

\usepackage{algorithm}
\usepackage{algorithmic}

\newcommand{\isdef}{\hbox{$\stackrel{\mbox{\tiny def}}{=}$}}
\newcommand{\Dt}{\mathcal{D}}
\newcommand{\Reg}{\mathcal{R}}
\newcommand{\Pst}{\mathcal{P}}
\newcommand{\Trn}{\mathcal{T}}
\newcommand{\Kln}{\mathcal{K}}
\newcommand{\TrnA}{\Trn_{a}}
\newcommand{\EKnows}{\mathbf{EKnows}}
\newcommand{\Knows}{\mathbf{Knows}}
\newcommand{\CKnows}{\mathbf{CKnows}}
\newcommand{\KnowsZ}{\mathbf{Knows_{0}}}
\newcommand{\PKnowsZ}{\mathbf{PKnows_{0}}}
\newcommand{\PKnows}{\mathbf{PKnows}}
\newcommand{\KTrans}{\mathbf{KDo}}
\newcommand{\KDo}{\mathbf{KDo}}
\newcommand{\EDo}{\mathbf{EDo}}
\newcommand{\vars}[1]{\bar{#1}}
\newcommand{\PbU}{PbU}


\title
{Complex Epistemic Modalities \\in the Situation Calculus}

\author
{Ryan F. Kelly\\
and Adrian R. Pearce}

\institute[The University of Melbourne]
{
  Department of Computer Science and Software Engineering\\
  The University of Melbourne\\
  Victoria, 3010, Australia\\
  \{rfk,adrian\}@csse.unimelb.edu.au
}

\date[The University of Melbourne]
{19th September 2007}

\pgfdeclareimage[height=1.2cm]{university-logo}{MINSilvr}
\logo{\pgfuseimage{university-logo}}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Motivation}

\begin{frame}
\frametitle{Motivation}
We want:
\begin{itemize}
\item A rich theory of knowledge and action; with
\item Group-level knowledge operators; and
\item An effective reasoning procedure
\end{itemize}
\ \\
\ \\
\pause
We obtain:
\begin{itemize}
\item The Situation Calculus; with
\item Common Knowledge; and
\item A Regression Rule
\end{itemize}
\end{frame}

\section{Background}

\begin{frame}
\frametitle{The Situation Calculus}
\emph{Actions} are instantaneous events causing the world to change
\begin{itemize}
  \item $open(Bob,Letter)$, $read(Ann,Letter)$
\end{itemize}
\ \\
\ \\
\emph{Situations} are histories of actions that have been performed
\begin{itemize}
  \item $S_0$,\ \ \ $do(\{read(Ann,Letter)\},S_0)$
\end{itemize}
\ \\
\ \\
\emph{Fluents} are situation-dependent properties of the world
\begin{itemize}
  \item $Poss(c,s)$, $Sealed(obj,s)$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The Situation Calculus}
\emph{Successor State Axioms} for the frame problem:
\begin{multline*}
Sealed(obj,do(c,s)) \equiv seal(agt,obj) \in c \\
  \vee Sealed(obj,s) \wedge \neg\left(open(agt,obj) \in c\right)
\end{multline*}
\ \\
\ \\
\emph{Regression} provides an effective reasoning procedure:
\begin{multline*}
\Reg(Sealed(obj,do(c,s))) \Rightarrow \\
  seal(agt,obj) \in c \\
 \vee Sealed(obj,s) \wedge \neg\left(open(agt,obj) \in c\right)
\end{multline*}
\end{frame}

\begin{frame}
\frametitle{Knowledge in the Situation Calculus}
Reify possible worlds using "possible situations":
\begin{equation*}
 K(agt,s',s)
\end{equation*}
\ \\
\ \\
And define knowledge using a simple macro:
\begin{equation*}
\Knows(agt,\phi,s)\,\,\isdef\,\,\forall s': \left[ K(agt,s',s) \rightarrow \phi[s']\right]
\end{equation*}
\end{frame}

\begin{frame}
\frametitle{Knowledge in the Situation Calculus}
Sensing etc axiomatised by \emph{observations}:
\begin{gather*}
Obs(Ann,\{read(Ann,Letter)\},s) = \{read(Ann,Letter)\#loc(s)\}\\
Obs(Bob,\{read(Ann,Letter)\},s) = \{read(Ann,Letter)\}
\end{gather*}
Successor state axiom for $K$:
\begin{multline*}
K(agt,s'',do(c,s)) \equiv \exists c',s': s'' = do(c',s') \wedge K(agt,s',s)\\
  Poss(c',s') \wedge Obs(agt,c',s') = Obs(agt,c,s)
\end{multline*}
\end{frame}

\begin{frame}
\frametitle{Reasoning about Knowledge}
Regression rule for knowledge:
\begin{multline*}
\Reg(\Knows(agt,\phi,do(c,s)))\,\,\isdef\,\,\exists o: o = Obs(agt,c,s)\,\wedge \\
  \Knows(agt,\forall c': Poss(c')\wedge Obs(agt,c')=o \rightarrow \Reg(\phi,c'),s)
\end{multline*}
\ \\
\ \\
We can reduce a query about future knowledge to a query about initial knowledge.
\end{frame}

\section{Group Knowledge}

\begin{frame}
\frametitle{Group-Level Knowledge}
Simple group-level modalities like "everyone knows" can be expanded down to individual-level knowledge:
\begin{gather*}
\EKnows(G,\phi,s)\,\,\isdef\,\,\bigwedge_{agt \in G} \Knows(agt,\phi,s)\\
\EKnows^{n}(G,\phi,s)\,\,\isdef\,\,\EKnows(G,\EKnows^{n-1}(G,\phi),s)
\end{gather*}
\ \\
\ \\
\pause
But common knowledge is infinitary:
\begin{equation*}
\CKnows(G,\phi,s)\,\,\,\isdef\,\,\,\EKnows^{\infty}(G,\phi,s)\,\,\,\isdef\,\,\,???
\end{equation*}
\end{frame}

\begin{frame}
\frametitle{Common Knowledge}
Usually introduce $\CKnows$ using a second-order axiom.

This precludes using regression for common knowledge.
\ \\
\ \\
\pause
But maybe we can formulate a special-case rule?
\begin{multline*}
\Reg(\CKnows(G,\phi,do(c,s)))\,\,\isdef\,\,\exists o: o = \mathbf{CObs}(G,c,s)\,\wedge \\
  \CKnows(G,\forall c': Poss(c')\wedge \mathbf{CObs}(agt,c')=o \rightarrow \Reg(\phi,c'),s)
\end{multline*}
\pause
This is \alert{impossible} even in very restricted domains.
\end{frame}

\begin{frame}
\frametitle{Common Knowledge}
Diagram explaining why this is not possible.
\end{frame}

\section{Epistemic Paths}

\begin{frame}
\frametitle{Dynamic Logic}
Dynamic logic typically thought of as a logic of action.

More generally, it is a language for exploring Kripke structures.
\end{frame}

\begin{frame}
\frametitle{Epistemic Path Language}
van Bentham, van Eijck \& Kooi,\\
"Logics of Communication and Change":
\ \\
\ \\
\begin{centering}
What if we interpret dynamic logic epistemically?
\end{centering}
\ \\
\ \\
We lift this idea to the situation calculus:
\begin{itemize}
\item first-order preconditions and effects
\item de-dicto/de-re
\item sets of concurrent actions
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Knowledge using Epistemic Path}
We introduce a new macro $\PKnows$ subsuming all group-level knowledge modalities:
\begin{alignat*}
\Knows(Ann,\phi) & \,\,\Rightarrow\,\,\PKnows(Ann,\phi) \\
\Knows(Ann,\Knows(Bob,\phi)) & \,\,\Rightarrow\,\,\PKnows(Ann ; Bob,\phi) \\
\EKnows(\{Ann,Bob\},\phi) & \,\,\Rightarrow\,\,\PKnows(Ann \cup Bob,\phi) \\
\CKnows(\{Ann,Bob\},\phi) & \,\,\Rightarrow\,\,\PKnows((Ann \cup Bob)^*,\phi)
\end{alignat*}
\end{frame}


\begin{frame}
\centering \large Thank You\\
\end{frame}

\end{document}
